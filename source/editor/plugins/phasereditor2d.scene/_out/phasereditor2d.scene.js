var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        function PhaserHelp(key) {
            if (key === undefined) {
                return undefined;
            }
            const prefix = "phaser:";
            if (key.startsWith(prefix)) {
                return scene.ScenePlugin.getInstance().getPhaserDocs().getDoc(key.substring(prefix.length));
            }
            return key;
        }
        scene.PhaserHelp = PhaserHelp;
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_1) {
        var ide = colibri.ui.ide;
        var controls = colibri.ui.controls;
        scene_1.SCENE_OBJECT_IMAGE_CATEGORY = "Texture";
        scene_1.SCENE_OBJECT_TEXT_CATEGORY = "String";
        scene_1.SCENE_OBJECT_GROUPING_CATEGORY = "Grouping";
        scene_1.SCENE_OBJECT_SHAPE_CATEGORY = "Shape";
        scene_1.SCENE_OBJECT_TILEMAP_CATEGORY = "Tile Map";
        scene_1.SCENE_OBJECT_ARCADE_CATEGORY = "Arcade";
        scene_1.SCENE_OBJECT_INPUT_CATEGORY = "Input";
        scene_1.SCENE_OBJECT_SCRIPT_CATEGORY = "Script";
        scene_1.SCENE_OBJECT_FX_CATEGORY = "FX";
        scene_1.SCENE_OBJECT_SPINE_CATEGORY = "Spine";
        scene_1.SCENE_OBJECT_CATEGORIES = [
            scene_1.SCENE_OBJECT_IMAGE_CATEGORY,
            scene_1.SCENE_OBJECT_GROUPING_CATEGORY,
            scene_1.SCENE_OBJECT_TEXT_CATEGORY,
            scene_1.SCENE_OBJECT_ARCADE_CATEGORY,
            scene_1.SCENE_OBJECT_SHAPE_CATEGORY,
            scene_1.SCENE_OBJECT_TILEMAP_CATEGORY,
            scene_1.SCENE_OBJECT_INPUT_CATEGORY,
            scene_1.SCENE_OBJECT_SPINE_CATEGORY,
            scene_1.SCENE_OBJECT_SCRIPT_CATEGORY
        ];
        scene_1.SCENE_OBJECT_CATEGORY_SET = new Set(scene_1.SCENE_OBJECT_CATEGORIES);
        class ScenePlugin extends colibri.Plugin {
            static _instance = new ScenePlugin();
            static DEFAULT_CANVAS_CONTEXT = Phaser.WEBGL;
            static DEFAULT_EDITOR_CANVAS_CONTEXT = Phaser.WEBGL;
            static DEFAULT_PIXEL_ART = true;
            static DEFAULT_EDITOR_PIXEL_ART = true;
            _sceneFinder;
            _docs;
            _eventsDocs;
            _spineThumbnailCache;
            _canvasManager;
            static getInstance() {
                return this._instance;
            }
            constructor() {
                super("phasereditor2d.scene");
            }
            getCanvasManager() {
                return this._canvasManager;
            }
            async starting() {
                const type = window.localStorage.getItem("phasereditor2d.scene.RENDER_TYPE");
                console.log("ScenePlugin: default render type: " + (type === "canvas" ? "Phaser.CANVAS" : "Phaser.WEBGL"));
                this.setDefaultRenderType(type);
                const pixelArt = window.localStorage.getItem("phasereditor2d.scene.PIXEL_ART") !== "0";
                this.setDefaultRenderPixelArt(pixelArt);
                console.log("ScenePlugin: default pixelArt: " + pixelArt);
                this._canvasManager = new scene_1.ui.CanvasManager();
            }
            setDefaultRenderType(type) {
                window.localStorage.setItem("phasereditor2d.scene.RENDER_TYPE", type);
                ScenePlugin.DEFAULT_CANVAS_CONTEXT = type === "canvas" ? Phaser.CANVAS : Phaser.WEBGL;
                ScenePlugin.DEFAULT_EDITOR_CANVAS_CONTEXT = ScenePlugin.DEFAULT_CANVAS_CONTEXT;
            }
            setDefaultRenderPixelArt(pixelArt) {
                window.localStorage.setItem("phasereditor2d.scene.PIXEL_ART", pixelArt ? "1" : "0");
                ScenePlugin.DEFAULT_PIXEL_ART = pixelArt;
                ScenePlugin.DEFAULT_EDITOR_PIXEL_ART = pixelArt;
            }
            getPhaserEventsDocs() {
                if (!this._eventsDocs) {
                    this._eventsDocs = new phasereditor2d.ide.core.PhaserDocs(phasereditor2d.resources.ResourcesPlugin.getInstance(), "phasereditor2d.scene/docs/events.json");
                }
                return this._eventsDocs;
            }
            getPhaserDocs() {
                if (!this._docs) {
                    this._docs = new phasereditor2d.ide.core.PhaserDocs(phasereditor2d.resources.ResourcesPlugin.getInstance(), "phasereditor2d.scene/docs/phaser.json");
                }
                return this._docs;
            }
            async started() {
                this._sceneFinder.registerStorageListener();
            }
            registerExtensions(reg) {
                this._sceneFinder = new scene_1.core.json.SceneFinder();
                this.registerAnimationsPreviewDialogInAssetPack();
                // migrations
                reg.addExtension(new scene_1.core.migrations.OriginMigration_v2_to_v3());
                reg.addExtension(new scene_1.core.migrations.UnlockPositionMigration_v1_to_v2());
                reg.addExtension(new scene_1.core.migrations.TextAlignMigration());
                scene_1.ui.sceneobjects.ScriptNodeCodeResources.getInstance().registerCommands("phasereditor.scene.ScriptNodeCategory", "ScriptNode", reg);
                // preload project
                reg.addExtension(this._sceneFinder.getProjectPreloader());
                // content type resolvers
                reg.addExtension(new colibri.core.ContentTypeExtension([new scene_1.core.SceneContentTypeResolver()], 5));
                reg.addExtension(new colibri.core.ContentTypeExtension([new colibri.core.ContentTypeResolverByExtension(scene_1.core.CONTENT_TYPE_USER_COMPONENTS + "Resolver", [
                        ["components", scene_1.core.CONTENT_TYPE_USER_COMPONENTS]
                    ])
                ]));
                // content type renderer
                reg.addExtension(new phasereditor2d.files.ui.viewers.SimpleContentTypeCellRendererExtension(scene_1.core.CONTENT_TYPE_SCENE, new scene_1.ui.viewers.SceneFileCellRenderer()));
                reg.addExtension(colibri.ui.ide.ContentTypeIconExtension.withPluginIcons(phasereditor2d.resources.ResourcesPlugin.getInstance(), [
                    {
                        iconName: phasereditor2d.resources.ICON_USER_COMPONENT,
                        contentType: scene_1.core.CONTENT_TYPE_USER_COMPONENTS
                    }
                ]));
                // loader updates
                reg.addExtension(new scene_1.ui.sceneobjects.ImageLoaderExtension(), new scene_1.ui.sceneobjects.BitmapFontLoaderUpdater(), new scene_1.ui.sceneobjects.TilemapLoaderUpdater(), new scene_1.ui.sceneobjects.SpineLoaderUpdater());
                // outline extensions
                reg.addExtension(new scene_1.ui.sceneobjects.TilemapOutlineExtension());
                // commands
                reg.addExtension(new ide.commands.CommandExtension(m => scene_1.ui.editor.commands.SceneEditorCommands.registerCommands(m)));
                reg.addExtension(new ide.commands.CommandExtension(m => scene_1.ui.editor.usercomponent.UserComponentsEditor.registerCommands(m)));
                // compile project
                reg.addExtension(new scene_1.ui.editor.usercomponent.UserComponentCompileAllExtension(), new scene_1.core.code.SceneCompileAllExtension());
                // editors
                reg.addExtension(new ide.EditorExtension([
                    scene_1.ui.editor.SceneEditor.getFactory(),
                    scene_1.ui.editor.usercomponent.UserComponentsEditor.getFactory()
                ]));
                // new file wizards
                reg.addExtension(new scene_1.ui.dialogs.NewSceneFileDialogExtension(), new scene_1.ui.dialogs.NewPrefabFileDialogExtension(), new scene_1.ui.dialogs.NewUserComponentsFileDialogExtension());
                // file properties
                reg.addExtension(new phasereditor2d.files.ui.views.FilePropertySectionExtension(page => new scene_1.ui.SceneFileSection(page), page => new scene_1.ui.ManySceneFileSection(page)));
                // scene game object extensions
                reg.addExtension(scene_1.ui.sceneobjects.ImageExtension.getInstance(), scene_1.ui.sceneobjects.SpriteExtension.getInstance(), scene_1.ui.sceneobjects.TileSpriteExtension.getInstance(), scene_1.ui.sceneobjects.NineSliceExtension.getInstance(), scene_1.ui.sceneobjects.ThreeSliceExtension.getInstance(), scene_1.ui.sceneobjects.TextExtension.getInstance(), scene_1.ui.sceneobjects.BitmapTextExtension.getInstance(), scene_1.ui.sceneobjects.ContainerExtension.getInstance(), scene_1.ui.sceneobjects.LayerExtension.getInstance(), scene_1.ui.sceneobjects.TilemapLayerExtension.getInstance(), scene_1.ui.sceneobjects.RectangleExtension.getInstance(), scene_1.ui.sceneobjects.EllipseExtension.getInstance(), scene_1.ui.sceneobjects.TriangleExtension.getInstance(), scene_1.ui.sceneobjects.PolygonExtension.getInstance(), scene_1.ui.sceneobjects.ArcadeImageExtension.getInstance(), scene_1.ui.sceneobjects.ArcadeSpriteExtension.getInstance(), scene_1.ui.sceneobjects.ColliderExtension.getInstance(), scene_1.ui.sceneobjects.KeyboardKeyExtension.getInstance(), scene_1.ui.sceneobjects.ScriptNodeExtension.getInstance(), scene_1.ui.sceneobjects.SpineExtension.getInstance(), scene_1.ui.sceneobjects.FXGlowExtension.getInstance(), scene_1.ui.sceneobjects.FXShadowExtension.getInstance());
                // scene plain object extensions
                reg.addExtension(scene_1.ui.sceneobjects.TilemapExtension.getInstance());
                reg.addExtension(new scene_1.ui.codesnippets.CreateFromAsepriteCodeSnippetExtension());
                // align extensions
                reg.addExtension(...scene_1.ui.editor.layout.DefaultLayoutExtensions.ALL);
                // property sections
                reg.addExtension(new scene_1.ui.editor.properties.SceneEditorPropertySectionExtension(page => new scene_1.ui.sceneobjects.GameObjectVariableSection(page), page => new scene_1.ui.sceneobjects.PrefabObjectVariableSection(page), page => new scene_1.ui.sceneobjects.NestedPrefabObjectVariableSection(page)));
                // dynamic component sections
                reg.addExtension(new scene_1.ui.editor.properties.DynamicUserSectionExtension());
                // more property sections
                reg.addExtension(new scene_1.ui.editor.properties.SceneEditorPropertySectionExtension(page => new scene_1.ui.sceneobjects.ListVariableSection(page), page => new scene_1.ui.sceneobjects.GameObjectListSection(page), page => new scene_1.ui.sceneobjects.ChildrenSection(page), page => new scene_1.ui.sceneobjects.TransformSection(page), page => new scene_1.ui.sceneobjects.OriginSection(page), page => new scene_1.ui.sceneobjects.FlipSection(page), page => new scene_1.ui.sceneobjects.VisibleSection(page), page => new scene_1.ui.sceneobjects.AlphaSection(page), page => new scene_1.ui.sceneobjects.AlphaSingleSection(page), page => new scene_1.ui.sceneobjects.TintSection(page), page => new scene_1.ui.sceneobjects.TintSingleSection(page), page => new scene_1.ui.sceneobjects.SizeSection(page), page => new scene_1.ui.sceneobjects.ShadersSection(page), page => new scene_1.ui.sceneobjects.TileSpriteSection(page), page => new scene_1.ui.sceneobjects.NineSliceSection(page), page => new scene_1.ui.sceneobjects.ThreeSliceSection(page), page => new scene_1.ui.sceneobjects.HitAreaSection(page), page => new scene_1.ui.sceneobjects.RectangleHitAreaSection(page), page => new scene_1.ui.sceneobjects.CircleHitAreaSection(page), page => new scene_1.ui.sceneobjects.EllipseHitAreaSection(page), page => new scene_1.ui.sceneobjects.PolygonHitAreaSection(page), page => new scene_1.ui.sceneobjects.PixelPerfectHitAreaSection(page), page => new scene_1.ui.sceneobjects.ArcadeBodySection(page), page => new scene_1.ui.sceneobjects.ArcadeGeometrySection(page), page => new scene_1.ui.sceneobjects.ArcadeBodyMovementSection(page), page => new scene_1.ui.sceneobjects.ArcadeBodyCollisionSection(page), page => new scene_1.ui.sceneobjects.SpriteAnimationSection(page), page => new scene_1.ui.sceneobjects.SpriteAnimationConfigSection(page), page => new scene_1.ui.sceneobjects.TextContentSection(page), page => new scene_1.ui.sceneobjects.TextSection(page), page => new scene_1.ui.sceneobjects.BitmapTextSection(page), page => new scene_1.ui.sceneobjects.ObjectListItemSection(page), page => new scene_1.ui.sceneobjects.ScenePlainObjectVariableSection(page), page => new scene_1.ui.sceneobjects.TilemapSection(page), page => new scene_1.ui.sceneobjects.TilesetSection(page), page => new scene_1.ui.sceneobjects.TilesetPreviewSection(page), page => new scene_1.ui.sceneobjects.TilemapLayerSection(page), page => new scene_1.ui.sceneobjects.ShapeSection(page), page => new scene_1.ui.sceneobjects.EllipseSection(page), page => new scene_1.ui.sceneobjects.TriangleSection(page), page => new scene_1.ui.sceneobjects.PolygonSection(page), page => new scene_1.ui.sceneobjects.ColliderSection(page), page => new scene_1.ui.sceneobjects.KeyboardKeySection(page), page => new scene_1.ui.sceneobjects.TextureSection(page), page => new scene_1.ui.sceneobjects.FXObjectSection(page), page => new scene_1.ui.sceneobjects.FXGlowSection(page), page => new scene_1.ui.sceneobjects.FXShadowSection(page), page => new scene_1.ui.sceneobjects.SpineSection(page), page => new scene_1.ui.sceneobjects.SpineBoundsProviderSection(page), page => new scene_1.ui.sceneobjects.SpineAnimationSection(page), page => new scene_1.ui.codesnippets.CreateFromAsepriteCodeSnippetSection(page)));
                // scene tools
                reg.addExtension(new scene_1.ui.editor.tools.SceneToolExtension(new scene_1.ui.sceneobjects.TranslateTool(), new scene_1.ui.sceneobjects.RotateTool(), new scene_1.ui.sceneobjects.ScaleTool(), new scene_1.ui.sceneobjects.OriginTool(), new scene_1.ui.sceneobjects.SizeTool(), new scene_1.ui.sceneobjects.EditHitAreaTool(), new scene_1.ui.sceneobjects.ArcadeBodyTool(), new scene_1.ui.sceneobjects.SliceTool(), new scene_1.ui.sceneobjects.PolygonTool(), new scene_1.ui.sceneobjects.SelectionRegionTool(), new scene_1.ui.sceneobjects.PanTool()));
                // files view sections
                reg.addExtension(new phasereditor2d.files.ui.views.ContentTypeSectionExtension({
                    section: phasereditor2d.files.ui.views.TAB_SECTION_DESIGN,
                    contentType: scene_1.core.CONTENT_TYPE_SCENE
                }, {
                    section: phasereditor2d.files.ui.views.TAB_SECTION_DESIGN,
                    contentType: scene_1.core.CONTENT_TYPE_USER_COMPONENTS
                }));
                // asset pack renderer extension
                reg.addExtension(new scene_1.ui.sceneobjects.SpineAssetPackCellRendererExtension());
                // asset pack preview extension
                reg.addExtension(new phasereditor2d.pack.ui.AssetPackPreviewPropertyProviderExtension(page => new scene_1.ui.sceneobjects.SpineSkeletonDataSection(page), page => new scene_1.ui.sceneobjects.SpineSkinItemPreviewSection(page), page => new scene_1.ui.sceneobjects.SpineAssetPreviewSection(page)));
            }
            registerAnimationsPreviewDialogInAssetPack() {
                phasereditor2d.pack.ui.properties.AnimationsPreviewSection.openPreviewDialog = elem => {
                    const dlg = new scene_1.ui.sceneobjects.AnimationPreviewDialog(elem.getParent(), {
                        key: elem.getKey()
                    });
                    dlg.create();
                };
            }
            async openAnimationInEditor(anim) {
                // nothing, it is injected in the AnimationsPlugin.
            }
            getTools() {
                return colibri.Platform.getExtensions(scene_1.ui.editor.tools.SceneToolExtension.POINT_ID)
                    .flatMap(ext => ext.getTools());
            }
            getTool(toolId) {
                return this.getTools().find(tool => tool.getId() === toolId);
            }
            getDefaultSceneSettings() {
                const settings = new scene_1.core.json.SceneSettings();
                try {
                    const finder = ScenePlugin.getInstance().getSceneFinder();
                    const files = [...finder.getSceneFiles()];
                    files.sort((a, b) => b.getModTime() - a.getModTime());
                    if (files.length > 0) {
                        const file = files[0];
                        settings.readJSON(finder.getSceneData(file).settings);
                    }
                }
                catch (e) {
                    console.error(e);
                }
                return settings;
            }
            getUserPropertyTypes() {
                // TODO: we should do this via extension
                return [
                    new scene_1.ui.sceneobjects.NumberPropertyType(),
                    new scene_1.ui.sceneobjects.StringPropertyType(),
                    new scene_1.ui.sceneobjects.BooleanPropertyType(),
                    new scene_1.ui.sceneobjects.ColorPropertyType(),
                    new scene_1.ui.sceneobjects.KeyCodePropertyType(),
                    new scene_1.ui.sceneobjects.ExpressionPropertyType(),
                    new scene_1.ui.sceneobjects.OptionPropertyType(),
                    new scene_1.ui.sceneobjects.ObjectVarPropertyType(),
                    new scene_1.ui.sceneobjects.ObjectConstructorPropertyType(),
                    new scene_1.ui.sceneobjects.EventPropertyType(),
                    new scene_1.ui.sceneobjects.TextureConfigPropertyType(),
                    new scene_1.ui.sceneobjects.AnimationKeyPropertyType(),
                    new scene_1.ui.sceneobjects.AudioKeyPropertyType(),
                    new scene_1.ui.sceneobjects.AssetKeyPropertyType(),
                    new scene_1.ui.sceneobjects.SceneKeyPropertyType(),
                    new scene_1.ui.sceneobjects.SpineSkinNamePropertyType(),
                    new scene_1.ui.sceneobjects.SpineAnimationNamePropertyType()
                ];
            }
            getUserPropertyType(typeId) {
                return this.getUserPropertyTypes().find(t => t.getId() === typeId);
            }
            getScriptsLibraryColor() {
                return colibri.ui.controls.Controls.getTheme().dark ? "lightBlue" : "blue";
            }
            getPrefabColor() {
                return colibri.ui.controls.Controls.getTheme().dark ? "lightGreen" : "darkGreen";
            }
            getNestedPrefabColor() {
                return "olive";
            }
            getSceneFinder() {
                return this._sceneFinder;
            }
            isSceneContentType(file) {
                return !file.isFolder() && colibri.Platform.getWorkbench().getContentTypeRegistry().getCachedContentType(file) === scene_1.core.CONTENT_TYPE_SCENE;
            }
            getCodeSnippetExtensions() {
                return colibri.Platform
                    .getExtensions(scene_1.ui.codesnippets.CodeSnippetExtension.POINT_ID);
            }
            getCodeSnippetExtensionByType(type) {
                return this.getCodeSnippetExtensions().find(e => e.getType() === type);
            }
            getPlainObjectExtensions() {
                return colibri.Platform
                    .getExtensions(scene_1.ui.sceneobjects.ScenePlainObjectExtension.POINT_ID);
            }
            getPlainObjectCategories() {
                return this.getPlainObjectExtensions().map(e => e.getCategory());
            }
            getPlainObjectExtensionByObjectType(type) {
                return this.getPlainObjectExtensions().find(ext => ext.getTypeName() === type);
            }
            getGameObjectExtensions() {
                return colibri.Platform
                    .getExtensions(scene_1.ui.sceneobjects.SceneGameObjectExtension.POINT_ID);
            }
            getGameObjectExtensionByObjectType(type) {
                return this.getGameObjectExtensions().find(ext => {
                    if (ext.getTypeName() === type) {
                        return ext;
                    }
                    if (ext.getTypeNameAlias().indexOf(type) >= 0) {
                        return ext;
                    }
                });
            }
            getSceneEditorOutlineExtensions() {
                return colibri.Platform
                    .getExtensions(scene_1.ui.editor.outline.SceneEditorOutlineExtension.POINT_ID);
            }
            _fxExtensions;
            _fxTypes;
            isFXType(type) {
                this.getFXExtensions();
                return this._fxTypes.has(type);
            }
            getFXExtensions() {
                if (this._fxExtensions) {
                    return this._fxExtensions;
                }
                this._fxExtensions = colibri.Platform
                    .getExtensions(scene_1.ui.sceneobjects.SceneGameObjectExtension.POINT_ID)
                    .filter(e => e instanceof scene_1.ui.sceneobjects.FXObjectExtension);
                this._fxTypes = new Set(this._fxExtensions.map(e => e.getTypeName()));
                return this._fxExtensions;
            }
            getLayoutExtensions() {
                return colibri.Platform
                    .getExtensions(scene_1.ui.editor.layout.LayoutExtension.POINT_ID);
            }
            getLayoutExtensionsByGroup() {
                const allExtensions = ScenePlugin.getInstance().getLayoutExtensions();
                const groups = [];
                for (const ext of allExtensions) {
                    if (groups.indexOf(ext.getConfig().group) < 0) {
                        groups.push(ext.getConfig().group);
                    }
                }
                const result = [];
                for (const group of groups) {
                    const extensions = allExtensions.filter(e => e.getConfig().group === group);
                    result.push({ group, extensions });
                }
                return result;
            }
            getLoaderUpdaterForAsset(asset) {
                const exts = colibri.Platform
                    .getExtensions(scene_1.ui.sceneobjects.LoaderUpdaterExtension.POINT_ID);
                for (const ext of exts) {
                    if (ext.acceptAsset(asset)) {
                        return ext;
                    }
                }
                return null;
            }
            getLoaderUpdaters() {
                const exts = colibri.Platform
                    .getExtensions(scene_1.ui.sceneobjects.LoaderUpdaterExtension.POINT_ID);
                return exts;
            }
            async compileAll() {
                const files = this._sceneFinder.getSceneFiles();
                const dlg = new controls.dialogs.ProgressDialog();
                dlg.create();
                dlg.setTitle("Compiling Scene Files");
                const monitor = new controls.dialogs.ProgressDialogMonitor(dlg);
                monitor.addTotal(files.length);
                for (const file of files) {
                    const data = this.getSceneFinder().getSceneData(file);
                    const scene = await scene_1.ui.OfflineScene.createScene(data);
                    const compiler = new scene_1.core.code.SceneCompiler(scene, file);
                    await compiler.compile();
                    scene.destroyGame();
                    monitor.step();
                }
                dlg.close();
            }
            _showIncompatibilityMessage = true;
            runSceneDataMigrations(sceneData) {
                // check scene data min supported version
                if (this._showIncompatibilityMessage) {
                    const version = sceneData.meta.version;
                    if (version) {
                        if (version > scene_1.ui.Scene.CURRENT_VERSION) {
                            alert(`
                        The project contains scene files created by newer versions of the editor.
                        You should update the editor.
                        `);
                        }
                    }
                    this._showIncompatibilityMessage = false;
                }
                // check migrations
                const migrations = colibri.Platform.getExtensionRegistry()
                    .getExtensions(scene_1.ui.SceneDataMigrationExtension.POINT_ID);
                for (const migration of migrations) {
                    try {
                        migration.migrate(sceneData);
                    }
                    catch (e) {
                        console.error(e);
                    }
                }
            }
            getSpineThumbnailCache() {
                if (!this._spineThumbnailCache) {
                    this._spineThumbnailCache = new scene_1.ui.SpineThumbnailCache();
                }
                return this._spineThumbnailCache;
            }
            buildSpineSkinThumbnailImage(skinItem) {
                const { spineAsset, spineAtlasAsset, skinName } = skinItem;
                const data = {
                    "id": "ad829e9b-d82c-466a-a31c-a2789656ef84",
                    "sceneType": scene_1.core.json.SceneType.SCENE,
                    "settings": {},
                    "displayList": [
                        {
                            "type": "SpineGameObject",
                            "id": "spine-thumbnail-id",
                            "label": "spine",
                            "dataKey": spineAsset.getKey(),
                            "atlasKey": spineAtlasAsset.getKey(),
                            "skinName": skinName,
                            "bpType": scene_1.ui.sceneobjects.BoundsProviderType.SKINS_AND_ANIMATION_TYPE,
                            "bpSkin": scene_1.ui.sceneobjects.BoundsProviderSkin.CURRENT_SKIN,
                            "x": 0,
                            "y": 0
                        }
                    ],
                    "plainObjects": [],
                    "meta": {
                        "version": 4
                    }
                };
                return new scene_1.ui.SceneThumbnailImage(data);
            }
        }
        scene_1.ScenePlugin = ScenePlugin;
        colibri.Platform.addPlugin(ScenePlugin.getInstance());
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/* tslint:disable */
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core_1) {
            var core = colibri.core;
            core_1.CONTENT_TYPE_SCENE = "phasereditor2d.core.scene.SceneContentType";
            core_1.CONTENT_TYPE_USER_COMPONENTS = "phasereditor2d.core.scene.UserComponents";
            class SceneContentTypeResolver extends core.ContentTypeResolver {
                constructor() {
                    super("phasereditor2d.scene.core.SceneContentTypeResolver");
                }
                async computeContentType(file) {
                    if (file.getExtension() === "scene") {
                        const content = await colibri.ui.ide.FileUtils.preloadAndGetFileString(file);
                        if (content !== null) {
                            try {
                                const data = JSON.parse(content);
                                if (data.meta.contentType === core_1.CONTENT_TYPE_SCENE) {
                                    return core_1.CONTENT_TYPE_SCENE;
                                }
                            }
                            catch (e) {
                                // nothing
                            }
                        }
                    }
                    return core.CONTENT_TYPE_ANY;
                }
            }
            core_1.SceneContentTypeResolver = SceneContentTypeResolver;
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code_1) {
                class CodeDOM {
                    _offset;
                    getOffset() {
                        return this._offset;
                    }
                    setOffset(offset) {
                        this._offset = offset;
                    }
                    static isBlankLine(codeDom) {
                        if (codeDom instanceof code_1.RawCodeDOM) {
                            const code = codeDom.getCode();
                            return code === "";
                        }
                        return false;
                    }
                    static removeBlankLines(list) {
                        const list2 = [];
                        let lastIsBlankLine = false;
                        for (const item of list) {
                            if (this.isBlankLine(item)) {
                                if (lastIsBlankLine) {
                                    continue;
                                }
                                lastIsBlankLine = true;
                            }
                            else {
                                lastIsBlankLine = false;
                            }
                            list2.push(item);
                        }
                        return list2;
                    }
                    static toHex(n) {
                        const hex = n.toString(16);
                        if (hex.length < 2) {
                            return "0" + hex;
                        }
                        return hex;
                    }
                    static quote(s) {
                        if (s === null || s === undefined || s.length === 0) {
                            return '""';
                        }
                        let b;
                        let c;
                        let i;
                        const len = s.length;
                        let result = '"';
                        for (i = 0; i < len; i += 1) {
                            b = c;
                            c = s.charAt(i);
                            switch (c) {
                                case "\\":
                                case '"':
                                    result += "\\";
                                    result += c;
                                    break;
                                case "/":
                                    if (b === "<") {
                                        result += "\\";
                                    }
                                    result += c;
                                    break;
                                case "\b":
                                    result += "\\b";
                                    break;
                                case "\t":
                                    result += "\\t";
                                    break;
                                case "\n":
                                    result += "\\n";
                                    break;
                                case "\f":
                                    result += "\\f";
                                    break;
                                case "\r":
                                    result += "\\r";
                                    break;
                                default:
                                    result += c;
                            }
                        }
                        result += '"';
                        return result;
                    }
                }
                code_1.CodeDOM = CodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./CodeDOM.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class AssignPropertyCodeDOM extends code.CodeDOM {
                    _propertyName;
                    _propertyValueExpr;
                    _contextExpr;
                    _propertyType;
                    _optionalContext;
                    constructor(propertyName, context) {
                        super();
                        this._propertyName = propertyName;
                        this._contextExpr = context;
                        this._optionalContext = false;
                    }
                    setOptionalContext(optionalContext) {
                        this._optionalContext = optionalContext;
                    }
                    isOptionalContext() {
                        return this._optionalContext;
                    }
                    value(expr) {
                        this._propertyValueExpr = expr;
                    }
                    valueLiteral(expr) {
                        this._propertyValueExpr = code.CodeDOM.quote(expr);
                    }
                    valueFloat(n) {
                        // tslint:disable-next-line:no-construct
                        this._propertyValueExpr = new Number(n).toString();
                    }
                    valueInt(n) {
                        // tslint:disable-next-line:no-construct
                        this._propertyValueExpr = new Number(Math.floor(n)).toString();
                    }
                    valueBool(b) {
                        // tslint:disable-next-line:no-construct
                        this._propertyValueExpr = new Boolean(b).toString();
                    }
                    getPropertyName() {
                        return this._propertyName;
                    }
                    getContextExpr() {
                        return this._contextExpr;
                    }
                    setContextExpr(contextExpr) {
                        this._contextExpr = contextExpr;
                    }
                    getPropertyValueExpr() {
                        return this._propertyValueExpr;
                    }
                    getPropertyType() {
                        return this._propertyType;
                    }
                    setPropertyType(propertyType) {
                        this._propertyType = propertyType;
                    }
                }
                code.AssignPropertyCodeDOM = AssignPropertyCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./CodeDOM.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class MemberDeclCodeDOM extends code.CodeDOM {
                    _name;
                    constructor(name) {
                        super();
                        this._name = name;
                    }
                    getName() {
                        return this._name;
                    }
                }
                code.MemberDeclCodeDOM = MemberDeclCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./MemberDeclCodeDOM.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class ClassDeclCodeDOM extends code.MemberDeclCodeDOM {
                    _exportClass;
                    _body;
                    _constructor;
                    _superClass;
                    constructor(name) {
                        super(name);
                        this._body = [];
                        this._exportClass = false;
                    }
                    isExportClass() {
                        return this._exportClass;
                    }
                    setExportClass(exportClass) {
                        this._exportClass = exportClass;
                    }
                    getConstructor() {
                        return this._constructor;
                    }
                    setConstructor(constructor) {
                        this._constructor = constructor;
                    }
                    getSuperClass() {
                        return this._superClass;
                    }
                    setSuperClass(superClass) {
                        this._superClass = superClass;
                    }
                    getBody() {
                        return this._body;
                    }
                }
                code.ClassDeclCodeDOM = ClassDeclCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                var controls = colibri.ui.controls;
                const SPEC_EXT = {
                    "js": "js",
                    "js-module": "js",
                    "ts": "ts",
                    "ts-module": "ts"
                };
                class CodeResources {
                    _plugin;
                    _resources;
                    _resDataMap;
                    constructor(plugin) {
                        this._plugin = plugin;
                        this._resources = [];
                        this._resDataMap = new Map();
                    }
                    addResource(id, path) {
                        this._resources.push({ id, path });
                    }
                    addCodeResource(fileName) {
                        for (const spec of ["js", "ts", "js-module", "ts-module"]) {
                            const ext = SPEC_EXT[spec];
                            this.addResource(`${spec}/${fileName}`, `code-resources/${spec}/${fileName}.${ext}`);
                        }
                    }
                    addCodeDefsResource(fileName) {
                        this.addResource(`defs/${fileName}`, `code-resources/defs/${fileName}.d.ts`);
                    }
                    async preload() {
                        for (const res of this._resources) {
                            const data = await this._plugin.getString(res.path);
                            this._resDataMap.set(res.id, data);
                        }
                    }
                    async createFile(resId, parent, name) {
                        const data = this._resDataMap.get(resId);
                        return await colibri.ui.ide.FileUtils.createFile_async(parent, name, data);
                    }
                    async createCodeFiles(spec, dlgTitle) {
                        try {
                            const filesView = colibri.Platform.getWorkbench().getActiveWindow()
                                .getView(phasereditor2d.files.ui.views.FilesView.ID);
                            const sel = filesView.getSelection();
                            let folder;
                            if (sel.length > 0) {
                                const file = sel[0];
                                if (file.isFolder()) {
                                    folder = file;
                                }
                                else {
                                    folder = file.getParent();
                                }
                            }
                            else {
                                alert("Please, select a folder in the Files view.");
                                return;
                            }
                            const dlg = new controls.dialogs.ProgressDialog();
                            dlg.create();
                            dlg.setTitle(dlgTitle);
                            const monitor = new controls.dialogs.ProgressDialogMonitor(dlg);
                            const newFiles = [];
                            const resources = this._resources.filter(r => r.id.startsWith(`${spec}/`));
                            const defsRes = this._resources.find(r => r.id.startsWith("defs"));
                            if (defsRes) {
                                resources.push(defsRes);
                            }
                            monitor.addTotal(resources.length + 1);
                            await this.preload();
                            monitor.step();
                            console.log(resources);
                            for (const resource of resources) {
                                const fileName = resource.path.split("/").pop();
                                newFiles.push(await this.createFile(resource.id, folder, fileName));
                                monitor.step();
                            }
                            dlg.close();
                            const viewer = filesView.getViewer();
                            viewer.setExpanded(folder, true);
                            await viewer.repaint();
                            viewer.setSelection(newFiles);
                        }
                        catch (e) {
                            console.log(e);
                            alert("Error: " + e.message);
                        }
                    }
                    registerCommands(categoryId, categoryName, reg) {
                        reg.addExtension(new colibri.ui.ide.commands.CommandExtension(manager => {
                            manager.addCategory({
                                id: categoryId,
                                name: categoryName,
                            });
                            for (const spec of ["js", "js-module", "ts", "ts-module"]) {
                                manager.add({
                                    command: {
                                        id: categoryId + "." + spec,
                                        category: categoryId,
                                        name: `Create User Files (${spec})`,
                                        tooltip: `Create the user files with the ${categoryName} API.`
                                    },
                                    handler: {
                                        executeFunc: args => {
                                            this.createCodeFiles(spec, `Creating ${categoryName} files`);
                                        }
                                    }
                                });
                            }
                        }));
                    }
                }
                code.CodeResources = CodeResources;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                var controls = colibri.ui.controls;
                class CodeResources2 {
                    _resKey;
                    _resources;
                    constructor(resKey) {
                        this._resKey = resKey;
                        this._resources = [];
                    }
                    addResource(id) {
                        this._resources.push({ id });
                    }
                    addCodeResource(fileName) {
                        for (const spec of ["js", "ts", "js-module", "ts-module"]) {
                            const ext = spec.replace("-module", "");
                            this.addResource(`${spec}/${fileName}.${ext}`);
                        }
                    }
                    addCodeDefsResource(fileName) {
                        this.addResource(`defs/${fileName}`);
                    }
                    async createFile(resId, parent, name) {
                        const key = this._resKey + "/" + resId;
                        const data = phasereditor2d.resources.getResString(key);
                        console.log("creating resource", resId, "data", data);
                        return await colibri.ui.ide.FileUtils.createFile_async(parent, name, data);
                    }
                    async createCodeFiles(spec, dlgTitle) {
                        try {
                            const filesView = colibri.Platform.getWorkbench().getActiveWindow()
                                .getView(phasereditor2d.files.ui.views.FilesView.ID);
                            const sel = filesView.getSelection();
                            let folder;
                            if (sel.length > 0) {
                                const file = sel[0];
                                if (file.isFolder()) {
                                    folder = file;
                                }
                                else {
                                    folder = file.getParent();
                                }
                            }
                            else {
                                alert("Please, select a folder in the Files view.");
                                return;
                            }
                            const dlg = new controls.dialogs.ProgressDialog();
                            dlg.create();
                            dlg.setTitle(dlgTitle);
                            const monitor = new controls.dialogs.ProgressDialogMonitor(dlg);
                            const newFiles = [];
                            const resourceList = this._resources.filter(r => r.id.startsWith(`${spec}/`));
                            const defsRes = this._resources.find(r => r.id.startsWith("defs"));
                            if (defsRes) {
                                resourceList.push(defsRes);
                            }
                            monitor.addTotal(resourceList.length + 1);
                            monitor.step();
                            for (const resource of resourceList) {
                                const fileName = resource.id.split("/").pop();
                                newFiles.push(await this.createFile(resource.id, folder, fileName));
                                monitor.step();
                            }
                            dlg.close();
                            const viewer = filesView.getViewer();
                            viewer.setExpanded(folder, true);
                            await viewer.repaint();
                            viewer.setSelection(newFiles);
                        }
                        catch (e) {
                            console.log(e);
                            alert("Error: " + e.message);
                        }
                    }
                    registerCommands(categoryId, categoryName, reg) {
                        reg.addExtension(new colibri.ui.ide.commands.CommandExtension(manager => {
                            manager.addCategory({
                                id: categoryId,
                                name: categoryName,
                            });
                            for (const spec of ["js", "js-module", "ts", "ts-module"]) {
                                manager.add({
                                    command: {
                                        id: categoryId + "." + spec,
                                        category: categoryId,
                                        name: `Create User Files (${spec})`,
                                        tooltip: `Create the user files with the ${categoryName} API.`
                                    },
                                    handler: {
                                        executeFunc: args => {
                                            this.createCodeFiles(spec, `Creating ${categoryName} files`);
                                        }
                                    }
                                });
                            }
                        }));
                    }
                }
                code.CodeResources2 = CodeResources2;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                code.getImportPath = phasereditor2d.ide.core.code.getImportPath;
                code.formatToValidVarName = phasereditor2d.ide.core.code.formatToValidVarName;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class FieldDeclCodeDOM extends code.MemberDeclCodeDOM {
                    _type;
                    _publicScope;
                    _initialValueExpr;
                    _allowUndefined;
                    _interfaceMember;
                    constructor(name, type, publicScope = false) {
                        super(name);
                        this._type = type;
                        this._publicScope = publicScope;
                        this._initialValueExpr = null;
                        this._allowUndefined = false;
                        this._interfaceMember = false;
                    }
                    isInterfaceMember() {
                        return this._interfaceMember;
                    }
                    setInterfaceMember(interfaceMember) {
                        this._interfaceMember = interfaceMember;
                    }
                    isAllowUndefined() {
                        return this._allowUndefined;
                    }
                    setAllowUndefined(allowUndefined) {
                        this._allowUndefined = allowUndefined;
                    }
                    isInitialized() {
                        return this._initialValueExpr !== null && this._initialValueExpr !== undefined && this._initialValueExpr.length > 0;
                    }
                    getInitialValueExpr() {
                        return this._initialValueExpr;
                    }
                    setInitialValueExpr(expr) {
                        this._initialValueExpr = expr;
                    }
                    isPublic() {
                        return this._publicScope;
                    }
                    setPublic(publicScope) {
                        this._publicScope = publicScope;
                    }
                    getType() {
                        return this._type;
                    }
                    setType(type) {
                        this._type = type;
                    }
                    getStrictType() {
                        if (this.isAllowUndefined()) {
                            return this._type + " | undefined";
                        }
                        return this._type;
                    }
                }
                code.FieldDeclCodeDOM = FieldDeclCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class ImportCodeDOM extends code.CodeDOM {
                    _elementName;
                    _filePath;
                    _asDefault;
                    constructor(elementName, filePath, asDefault) {
                        super();
                        this._elementName = elementName;
                        this._filePath = filePath;
                        this._asDefault = asDefault;
                    }
                    getElementName() {
                        return this._elementName;
                    }
                    getFilePath() {
                        return this._filePath;
                    }
                    isAsDefault() {
                        return this._asDefault;
                    }
                }
                code.ImportCodeDOM = ImportCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./MemberDeclCodeDOM.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class InterfaceDeclCodeDOM extends code.MemberDeclCodeDOM {
                    _exportInterface;
                    _body;
                    constructor(name) {
                        super(name);
                        this._body = [];
                        this._exportInterface = false;
                    }
                    isExportInterface() {
                        return this._exportInterface;
                    }
                    setExportInterface(exportClass) {
                        this._exportInterface = exportClass;
                    }
                    getBody() {
                        return this._body;
                    }
                }
                code.InterfaceDeclCodeDOM = InterfaceDeclCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code_2) {
                var BaseCodeGenerator = phasereditor2d.ide.core.code.BaseCodeGenerator;
                class JavaScriptUnitCodeGenerator extends BaseCodeGenerator {
                    _unit;
                    _initFieldsInConstructor;
                    _generateImports;
                    constructor(unit) {
                        super();
                        this._unit = unit;
                        this._generateImports = true;
                    }
                    isTypeScript() {
                        return false;
                    }
                    getUnit() {
                        return this._unit;
                    }
                    setInitFieldInConstructor(initFieldInConstructor) {
                        this._initFieldsInConstructor = initFieldInConstructor;
                    }
                    isInitFieldInConstructor() {
                        return this._initFieldsInConstructor;
                    }
                    setGenerateImports(generateImports) {
                        this._generateImports = generateImports;
                    }
                    isGenerateImports() {
                        return this._generateImports;
                    }
                    internalGenerate() {
                        this.sectionStart("/* START OF COMPILED CODE */", "\n// You can write more code here\n\n");
                        this.line();
                        this.line();
                        const body = code_2.CodeDOM.removeBlankLines(this._unit.getBody());
                        if (this._generateImports) {
                            this.generateImports();
                        }
                        this.generateExtraUnitCode();
                        for (const elem of body) {
                            this.generateUnitElement(elem);
                        }
                        this.sectionEnd("/* END OF COMPILED CODE */", "\n\n// You can write more code here\n");
                    }
                    generateUnitElement(elem) {
                        if (elem instanceof code_2.InterfaceDeclCodeDOM) {
                            this.generateInterface(elem);
                        }
                        else if (elem instanceof code_2.ClassDeclCodeDOM) {
                            this.generateClass(elem);
                        }
                        else if (elem instanceof code_2.MethodDeclCodeDOM) {
                            this.line();
                            this.generateMethodDecl(null, elem, true);
                            this.line();
                        }
                        else if (elem instanceof code_2.RawCodeDOM) {
                            this.line();
                            this.line(elem.getCode());
                            this.line();
                        }
                    }
                    generateInterface(interfaceDecl) {
                        // nothing, it is for the TypeScript generator
                    }
                    generateExtraUnitCode() {
                        // nothing, used by the TypeScript generator
                    }
                    generateImports() {
                        const imports = this._unit.getImports();
                        for (const importDom of imports) {
                            let name = importDom.getElementName();
                            if (!importDom.isAsDefault()) {
                                name = `{ ${name} }`;
                            }
                            this.line(`import ${name} from "${importDom.getFilePath()}";`);
                        }
                        this.section("/* START-USER-IMPORTS */", "/* END-USER-IMPORTS */", "\n");
                        this.line();
                        this.line();
                    }
                    generateClass(clsDecl) {
                        if (clsDecl.isExportClass()) {
                            this.append("export default ");
                        }
                        this.append("class " + clsDecl.getName() + " ");
                        if (clsDecl.getSuperClass() && clsDecl.getSuperClass().trim().length > 0) {
                            this.append("extends " + clsDecl.getSuperClass() + " ");
                        }
                        this.openIndent("{");
                        this.line();
                        const body = code_2.CodeDOM.removeBlankLines(clsDecl.getBody());
                        // methods
                        for (const memberDecl of body) {
                            if (memberDecl instanceof code_2.MethodDeclCodeDOM) {
                                this.generateMethodDecl(clsDecl, memberDecl, false);
                                this.line();
                            }
                        }
                        // fields
                        for (const memberDecl of body) {
                            if (memberDecl instanceof code_2.FieldDeclCodeDOM) {
                                this.generateFieldDecl(memberDecl);
                            }
                        }
                        if (body.find(m => m instanceof code_2.FieldDeclCodeDOM)) {
                            this.line();
                        }
                        // user section
                        for (const memberDecl of body) {
                            if (memberDecl instanceof code_2.UserSectionCodeDOM) {
                                this.generateSection(memberDecl);
                            }
                        }
                        // close body
                        this.closeIndent("}");
                        this.line();
                    }
                    generateFieldDecl(fieldDecl) {
                        if (this._initFieldsInConstructor) {
                            return;
                        }
                        this.line(`/** @type {${fieldDecl.getType()}} */`);
                        if (fieldDecl.isInitialized()) {
                            this.line(fieldDecl.getName() + " = " + fieldDecl.getInitialValueExpr() + ";");
                        }
                        else {
                            this.line(fieldDecl.getName() + ";");
                        }
                    }
                    generateMethodDecl(classDecl, methodDecl, isFunction) {
                        if (methodDecl.getReturnType()) {
                            this.generateMethodReturnTypeJSDoc(methodDecl);
                        }
                        for (const modifier of methodDecl.getModifiers()) {
                            this.append(modifier + " ");
                        }
                        if (isFunction) {
                            this.append("function ");
                        }
                        this.append(methodDecl.getName() + "(");
                        this.generateMethodDeclArgs(methodDecl);
                        const methodReturnDeclText = this.getMethodReturnDeclText(methodDecl);
                        this.openIndent(")" + methodReturnDeclText + "{");
                        let body = code_2.CodeDOM.removeBlankLines(methodDecl.getBody());
                        if (this._initFieldsInConstructor && methodDecl.getName() === "constructor") {
                            const superCall = body.find(instr => instr instanceof code_2.MethodCallCodeDOM && instr.getMethodName() === "super");
                            if (superCall) {
                                this.generateMethodCall(superCall);
                                body = body.filter(instr => instr !== superCall);
                            }
                            this.generateFieldInitInConstructor(classDecl, methodDecl);
                        }
                        // never add a blank line at the end of a method body
                        if (body.length > 0) {
                            const last = body.pop();
                            if (last instanceof code_2.RawCodeDOM) {
                                if (!code_2.CodeDOM.isBlankLine(last)) {
                                    body.push(last);
                                }
                            }
                            else {
                                body.push(last);
                            }
                            for (const instr of body) {
                                this.generateInstr(instr);
                            }
                        }
                        this.closeIndent("}");
                    }
                    generateMethodReturnTypeJSDoc(methodDecl) {
                        this.line(`/** @returns {${methodDecl.getReturnType()}} */`);
                    }
                    getMethodReturnDeclText(methodDecl) {
                        return " ";
                    }
                    generateFieldInitInConstructor(classDecl, ctrDecl) {
                        const fields = classDecl.getBody()
                            .filter(obj => obj instanceof code_2.FieldDeclCodeDOM);
                        if (fields.length > 0) {
                            this.line();
                            for (const field of fields) {
                                const assign = new code_2.AssignPropertyCodeDOM(field.getName(), "this");
                                assign.setPropertyType(field.getType());
                                assign.value(field.getInitialValueExpr());
                                this.generateAssignProperty(assign);
                            }
                            this.line();
                        }
                    }
                    generateMethodDeclArgs(methodDecl) {
                        this.append(methodDecl.getArgs()
                            .map(arg => arg.name)
                            .join(", "));
                    }
                    generateInstr(instr) {
                        instr.setOffset(this.getOffset());
                        if (instr instanceof code_2.RawCodeDOM) {
                            this.generateRawCode(instr);
                        }
                        else if (instr instanceof code_2.MethodCallCodeDOM) {
                            this.generateMethodCall(instr);
                        }
                        else if (instr instanceof code_2.AssignPropertyCodeDOM) {
                            this.generateAssignProperty(instr);
                        }
                        else if (instr instanceof code_2.UserSectionCodeDOM) {
                            this.generateSection(instr);
                        }
                    }
                    generateSection(section) {
                        this.section(section.getOpenTag(), section.getCloseTag(), section.getDefaultContent());
                    }
                    generateAssignProperty(assign) {
                        this.generateTypeAnnotation(assign);
                        if (assign.getContextExpr()) {
                            this.append(assign.getContextExpr());
                            if (this.isTypeScript() && assign.isOptionalContext()) {
                                this.append("!");
                            }
                            this.append(".");
                        }
                        this.append(assign.getPropertyName());
                        if (assign.getPropertyValueExpr()) {
                            this.append(" = ");
                            this.append(assign.getPropertyValueExpr());
                        }
                        this.append(";");
                        this.line();
                    }
                    generateTypeAnnotation(assign) {
                        const type = assign.getPropertyType();
                        if (type != null) {
                            this.line("/** @type {" + type + "} */");
                        }
                    }
                    generateMethodCall(call) {
                        if (call.getReturnToVar()) {
                            if (call.isDeclareReturnToVar()) {
                                if (!this.isTypeScript() && call.getExplicitType()) {
                                    this.line(`/** @type {${call.getExplicitType()}} */`);
                                }
                                this.append("const ");
                            }
                            this.append(call.getReturnToVar());
                            this.append(" = ");
                        }
                        if (call.isConstructor()) {
                            this.append("new ");
                        }
                        if (call.getContextExpr() && call.getContextExpr().length > 0) {
                            this.append(call.getContextExpr());
                            if (this.isTypeScript() && call.isOptionalContext()) {
                                this.append("!");
                            }
                            this.append(".");
                        }
                        this.append(call.getMethodName());
                        this.append("(");
                        const args = [...call.getArgs()];
                        while (args.length > 0 && args[args.length - 1] === "undefined") {
                            args.pop();
                        }
                        this.join(args);
                        if (this.isTypeScript()
                            && (call.getExplicitType() || call.isNonNullAssertion())
                            && call.isDeclareReturnToVar()
                            && call.getReturnToVar()) {
                            let line = ")";
                            if (call.isNonNullAssertion()) {
                                line += "!";
                            }
                            if (call.getExplicitType()) {
                                line += ` as ${call.getExplicitType()}`;
                            }
                            line += ";";
                            this.line(line);
                        }
                        else {
                            this.line(");");
                        }
                    }
                    generateRawCode(raw) {
                        const code = raw.getCode();
                        const lines = code.split("\\R");
                        for (const line of lines) {
                            this.line(line);
                        }
                    }
                }
                code_2.JavaScriptUnitCodeGenerator = JavaScriptUnitCodeGenerator;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class MethodCallCodeDOM extends code.CodeDOM {
                    _methodName;
                    _contextExpr;
                    _args;
                    _returnToVar;
                    _declareReturnToVar;
                    _isConstructor;
                    _explicitType;
                    _optionalContext;
                    _nonNullAssertion;
                    constructor(methodName, contextExpr = "") {
                        super();
                        this._methodName = methodName;
                        this._contextExpr = contextExpr;
                        this._args = [];
                        this._declareReturnToVar = false;
                        this._isConstructor = false;
                        this._nonNullAssertion = false;
                    }
                    setNonNullAssertion(nonNullAssertion) {
                        this._nonNullAssertion = nonNullAssertion;
                    }
                    isNonNullAssertion() {
                        return this._nonNullAssertion;
                    }
                    setOptionalContext(optionalContext) {
                        this._optionalContext = optionalContext;
                    }
                    isOptionalContext() {
                        return this._optionalContext;
                    }
                    isConstructor() {
                        return this._isConstructor;
                    }
                    setConstructor(isConstructor) {
                        this._isConstructor = isConstructor;
                    }
                    getReturnToVar() {
                        return this._returnToVar;
                    }
                    setReturnToVar(returnToVar) {
                        this._returnToVar = returnToVar;
                    }
                    setDeclareReturnToVar(declareReturnToVar) {
                        this._declareReturnToVar = declareReturnToVar;
                    }
                    isDeclareReturnToVar() {
                        return this._declareReturnToVar;
                    }
                    setExplicitType(explicitType) {
                        this._explicitType = explicitType;
                    }
                    getExplicitType() {
                        return this._explicitType;
                    }
                    arg(expr) {
                        this._args.push(expr);
                    }
                    argUndefined() {
                        this.arg("undefined");
                    }
                    argStringOrFloat(expr) {
                        switch (typeof expr) {
                            case "string":
                                this.argLiteral(expr);
                                break;
                            case "number":
                                this.argFloat(expr);
                                break;
                        }
                    }
                    argStringOrInt(expr) {
                        switch (typeof expr) {
                            case "string":
                                this.argLiteral(expr);
                                break;
                            case "number":
                                this.argInt(expr);
                                break;
                            case "undefined":
                                this.arg("undefined");
                                break;
                        }
                    }
                    argLiteral(expr) {
                        this._args.push(code.CodeDOM.quote(expr));
                    }
                    argFloat(n) {
                        this._args.push(n + "");
                    }
                    argInt(n) {
                        this._args.push(Math.floor(n) + "");
                    }
                    argBool(b) {
                        this.arg(b ? "true" : "false");
                    }
                    getMethodName() {
                        return this._methodName;
                    }
                    setMethodName(methodName) {
                        this._methodName = methodName;
                    }
                    getContextExpr() {
                        return this._contextExpr;
                    }
                    getArgs() {
                        return this._args;
                    }
                }
                code.MethodCallCodeDOM = MethodCallCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class MethodDeclCodeDOM extends code.MemberDeclCodeDOM {
                    _modifiers;
                    _body;
                    _args;
                    _returnType;
                    constructor(name) {
                        super(name);
                        this._modifiers = [];
                        this._args = [];
                        this._body = [];
                    }
                    getReturnType() {
                        return this._returnType;
                    }
                    setReturnType(returnType) {
                        this._returnType = returnType;
                    }
                    getModifiers() {
                        return this._modifiers;
                    }
                    arg(name, type, optional = false) {
                        this._args.push({
                            name, type, optional
                        });
                    }
                    getArgs() {
                        return this._args;
                    }
                    getBody() {
                        return this._body;
                    }
                    setBody(body) {
                        this._body = body;
                    }
                }
                code.MethodDeclCodeDOM = MethodDeclCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code_3) {
                class RawCodeDOM extends code_3.CodeDOM {
                    _code;
                    static many(...codes) {
                        return codes.map(code => new RawCodeDOM(code));
                    }
                    constructor(code = "") {
                        super();
                        this._code = code;
                    }
                    getCode() {
                        return this._code;
                    }
                }
                code_3.RawCodeDOM = RawCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_2) {
        var core;
        (function (core) {
            var code;
            (function (code_4) {
                class SceneCodeDOMBuilder {
                    _scene;
                    _isPrefabScene;
                    _sceneFile;
                    _unit;
                    _fileNameMap;
                    _requireDeclareVarSet;
                    _objectsToFieldList;
                    constructor(scene, file) {
                        this._scene = scene;
                        this._sceneFile = file;
                        this._isPrefabScene = this._scene.isPrefabSceneType();
                        this._fileNameMap = new Map();
                        this._requireDeclareVarSet = new Set();
                        this._objectsToFieldList = [];
                    }
                    getCompletePhaserType(obj) {
                        const objES = obj.getEditorSupport();
                        const objExt = objES.getExtension();
                        const typeName = objExt.getPhaserTypeName();
                        if (objExt.isThirdPartyLib()) {
                            if (this._scene.isESModule()) {
                                this._unit.addImport(`${typeName}`, objExt.getPhaserTypeThirdPartyLibModule(), false);
                                return typeName;
                            }
                            return objExt.getPhaserTypeThirdPartyLib() + "." + typeName;
                        }
                        return typeName;
                    }
                    async build() {
                        colibri.ui.ide.Workbench.getWorkbench().getFileStorage().getRoot().visit(file => {
                            if (file.isFile()) {
                                this._fileNameMap.set(file.getNameWithoutExtension(), file);
                            }
                        });
                        const settings = this._scene.getSettings();
                        const methods = [];
                        const unit = new code_4.UnitCodeDOM([]);
                        this._unit = unit;
                        if (settings.onlyGenerateMethods) {
                            const createMethodDecl = this.buildCreateMethod();
                            await this.buildPreloadMethod(unit.getBody());
                            unit.getBody().push(createMethodDecl);
                        }
                        else {
                            const clsName = this.getClassName();
                            const clsDecl = new code_4.ClassDeclCodeDOM(clsName);
                            clsDecl.setExportClass(settings.exportClass);
                            let superCls;
                            if (this._isPrefabScene) {
                                const obj = this._scene.getPrefabObject();
                                if (!obj) {
                                    return null;
                                }
                                const objES = obj.getEditorSupport();
                                if (obj.getEditorSupport().isPrefabInstance()) {
                                    superCls = objES.getPrefabName();
                                }
                                else {
                                    superCls = this.getCompletePhaserType(obj);
                                }
                                superCls = settings.superClassName.trim().length === 0 ?
                                    superCls : settings.superClassName;
                            }
                            else {
                                superCls = settings.superClassName.trim().length === 0 ?
                                    "Phaser.Scene" : settings.superClassName;
                            }
                            clsDecl.setSuperClass(superCls);
                            if (superCls.startsWith("Phaser.")) {
                                unit.addImport("Phaser", "phaser", true);
                            }
                            else {
                                const superClsFile = this._fileNameMap.get(superCls);
                                if (superClsFile) {
                                    const { importPath, asDefault } = code.getImportPath(this._sceneFile, superClsFile);
                                    unit.addImport(superCls, importPath, asDefault);
                                }
                            }
                            if (this._isPrefabScene) {
                                // prefab constructor
                                const ctrMethod = this.buildPrefabConstructorMethod();
                                methods.push(ctrMethod);
                            }
                            else {
                                // scene constructor
                                const key = settings.sceneKey;
                                if (key.trim().length > 0) {
                                    const ctrMethod = this.buildSceneConstructorMethod(key);
                                    methods.push(ctrMethod);
                                }
                                // scene preload method
                                await this.buildPreloadMethod(methods);
                                // scene create method
                                const createMethodDecl = this.buildCreateMethod();
                                methods.push(createMethodDecl);
                            }
                            const fields = [];
                            this.buildObjectClassFields(fields, this._scene.getGameObjects());
                            this.buildPlainObjectsClassFields(fields);
                            this.buildListClassFields(fields);
                            if (this._isPrefabScene) {
                                this.buildPrefabPropertiesFields(fields);
                            }
                            clsDecl.getBody().push(...methods);
                            clsDecl.getBody().push(...fields);
                            if (this._isPrefabScene) {
                                clsDecl.getBody().push(new code_4.UserSectionCodeDOM("/* START-USER-CODE */", "/* END-USER-CODE */", "\n\n\t// Write your code here.\n\n\t"));
                            }
                            else {
                                const defaultContent = [
                                    "",
                                    "",
                                    "// Write your code here",
                                    "",
                                    "create() {",
                                    "",
                                    "\tthis.editorCreate();",
                                    "}",
                                    "",
                                    ""
                                ].join("\n\t");
                                clsDecl.getBody().push(new code_4.UserSectionCodeDOM("/* START-USER-CODE */", "/* END-USER-CODE */", defaultContent));
                            }
                            unit.getBody().push(clsDecl);
                        }
                        return unit;
                    }
                    addImportForType(type) {
                        if (!this._scene.getSettings().autoImport) {
                            return;
                        }
                        if (type) {
                            if (type.startsWith("Phaser.")) {
                                this._unit.addImport("Phaser", "phaser", true);
                            }
                            else if (this._fileNameMap.has(type)) {
                                const importFile = this._fileNameMap.get(type);
                                const { importPath, asDefault } = code.getImportPath(this._sceneFile, importFile);
                                this._unit.addImport(type, importPath, asDefault);
                            }
                        }
                    }
                    getClassName() {
                        return this._sceneFile.getNameWithoutExtension();
                    }
                    buildPrefabPropertiesFields(fields) {
                        const decls = this._scene.getPrefabUserProperties()
                            .getProperties()
                            .filter(prop => !prop.isCustomDefinition())
                            .flatMap(prop => prop.buildFieldDeclarationCode());
                        fields.push(...decls);
                    }
                    buildPlainObjectsClassFields(fields) {
                        for (const obj of this._scene.getPlainObjects()) {
                            const objES = obj.getEditorSupport();
                            if (objES.isClassOrPublicScope()) {
                                const objType = objES.getPhaserType();
                                const dom = new code_4.FieldDeclCodeDOM(code_4.formatToValidVarName(objES.getLabel()), objType, objES.isPublicScope());
                                dom.setAllowUndefined(!this._scene.isPrefabSceneType());
                                fields.push(dom);
                            }
                        }
                    }
                    buildListClassFields(fields) {
                        const objMap = this._scene.buildObjectIdMap();
                        for (const list of this._scene.getObjectLists().getLists()) {
                            if (scene_2.ui.sceneobjects.isClassOrPublicScope(list.getScope())) {
                                const listType = list.inferType(objMap);
                                const dom = new code_4.FieldDeclCodeDOM(code_4.formatToValidVarName(list.getLabel()), listType, scene_2.ui.sceneobjects.isPublicScope(list.getScope()));
                                dom.setAllowUndefined(!this._scene.isPrefabSceneType());
                                fields.push(dom);
                            }
                        }
                    }
                    buildObjectClassFields(fields, children) {
                        for (const obj of this._objectsToFieldList) {
                            const objES = obj.getEditorSupport();
                            const isPrefabObj = this._scene.isPrefabSceneType() && this._scene.getPrefabObject() === obj;
                            const isPrefabScene = this._scene.isPrefabSceneType();
                            if (!isPrefabObj) {
                                const varName = code.formatToValidVarName(objES.getLabel());
                                let phaserType = this.getCompletePhaserType(obj);
                                const explicitType = this.getExplicitType(obj, phaserType);
                                if (explicitType) {
                                    phaserType = explicitType;
                                }
                                const type = objES.isPrefabInstance()
                                    ? objES.getPrefabName()
                                    : phaserType;
                                const isPublic = objES.isPublicScope();
                                const field = new code_4.FieldDeclCodeDOM(varName, type, isPublic);
                                // Allow undefined if the object is part of a scene.
                                // In a prefab, the objects are created in the constructor
                                field.setAllowUndefined(!isPrefabScene);
                                fields.push(field);
                            }
                        }
                    }
                    buildPrefabConstructorMethod() {
                        const ctrDecl = new code.MethodDeclCodeDOM("constructor");
                        const body = ctrDecl.getBody();
                        const prefabObj = this._scene.getPrefabObject();
                        if (!prefabObj) {
                            throw new Error("Invalid prefab scene state: missing object.");
                        }
                        const type = prefabObj.getEditorSupport().getObjectType();
                        const ext = scene_2.ScenePlugin.getInstance().getGameObjectExtensionByObjectType(type);
                        const objBuilder = ext.getCodeDOMBuilder();
                        this.buildPrefabTypeScriptDefinitionsCodeDOM(prefabObj, objBuilder);
                        ctrDecl.arg("scene", "Phaser.Scene");
                        const args = {
                            ctrDeclCodeDOM: ctrDecl,
                            prefabObj,
                            importTypes: [],
                            unit: this._unit,
                            isESModule: this._scene.isESModule()
                        };
                        objBuilder.buildPrefabConstructorDeclarationCodeDOM(args);
                        for (const type of args.importTypes) {
                            this.addImportForType(type);
                        }
                        {
                            const superCall = new code_4.MethodCallCodeDOM("super");
                            superCall.arg("scene");
                            objBuilder.buildPrefabConstructorDeclarationSupperCallCodeDOM({
                                superMethodCallCodeDOM: superCall,
                                prefabObj: prefabObj,
                                unit: this._unit
                            });
                            body.push(superCall);
                            body.push(new code_4.RawCodeDOM(""));
                        }
                        const lazyStatements = [];
                        const result = this.buildSetObjectProperties({
                            obj: prefabObj,
                            varname: "this"
                        });
                        this.buildCodeSnippets(result.statements);
                        lazyStatements.push(...result.lazyStatements);
                        body.push(...result.statements);
                        this.addChildrenObjects({
                            createMethodDecl: ctrDecl,
                            obj: prefabObj,
                            lazyStatements
                        });
                        this.addCreateAllPlainObjectCode(ctrDecl.getBody(), lazyStatements);
                        this.addCreateListsCode(body);
                        body.push(...lazyStatements);
                        this.addFieldInitCode(body);
                        {
                            // prefab awake handler
                            const settings = this._scene.getSettings();
                            if (settings.generateAwakeHandler) {
                                body.push(new code_4.RawCodeDOM("// awake handler"));
                                body.push(new code_4.RawCodeDOM("this.scene.events.once(\"scene-awake\", () => this.awake());"));
                                body.push(new code_4.RawCodeDOM(""));
                            }
                        }
                        body.push(new code_4.RawCodeDOM(""));
                        body.push(new code_4.UserSectionCodeDOM("/* START-USER-CTR-CODE */", "/* END-USER-CTR-CODE */", "\n\t\t// Write your code here.\n\t\t"));
                        this.buildCustomPropertiesInit(body);
                        return ctrDecl;
                    }
                    buildCodeSnippets(statements) {
                        const snippets = this._scene.getCodeSnippets().getSnippets();
                        if (snippets.length > 0) {
                            statements.push(new code.RawCodeDOM(""));
                            statements.push(new code.RawCodeDOM("// snippets"));
                            for (const codeSnippet of snippets) {
                                const code = codeSnippet.buildCodeDOM();
                                statements.push(...code);
                            }
                        }
                    }
                    buildPrefabTypeScriptDefinitionsCodeDOM(prefabObj, objBuilder) {
                        for (const comp of prefabObj.getEditorSupport().getActiveComponents()) {
                            comp.buildPrefabTypeScriptDefinitionsCodeDOM({
                                unit: this._unit,
                                prefabObj,
                                clsName: this.getClassName()
                            });
                        }
                        const settings = this._scene.getSettings();
                        for (const iface of this._unit.getTypeScriptInterfaces()) {
                            iface.setExportInterface(settings.exportClass);
                        }
                    }
                    buildCustomPropertiesInit(body) {
                        const userProps = this._scene.getPrefabUserProperties();
                        const assignDomList = userProps.getProperties()
                            .filter(prop => prop.isCustomDefinition())
                            .map(prop => {
                            const fieldDecl = prop.buildFieldDeclarationCode();
                            const assignDom = new code.AssignPropertyCodeDOM(fieldDecl.getName(), "this");
                            assignDom.value(fieldDecl.getInitialValueExpr());
                            return assignDom;
                        });
                        if (assignDomList.length > 0) {
                            body.push(new code.RawCodeDOM("\n"));
                            body.push(new code.RawCodeDOM("// custom definition props"));
                        }
                        body.push(...assignDomList);
                    }
                    buildCreateMethod() {
                        const settings = this._scene.getSettings();
                        const createMethodDecl = new code_4.MethodDeclCodeDOM(settings.createMethodName);
                        createMethodDecl.setReturnType("void");
                        if (settings.onlyGenerateMethods && this._scene.isPrefabSceneType()) {
                            createMethodDecl.arg("scene", "Phaser.Scene");
                        }
                        const body = createMethodDecl.getBody();
                        const lazyStatements = [];
                        this.buildCodeSnippets(body);
                        this.addCreateAllPlainObjectCode(body, lazyStatements);
                        for (const obj of this._scene.getGameObjects()) {
                            if (obj.getEditorSupport().isMutableNestedPrefabInstance()) {
                                // this.addCreateObjectCodeOfNestedPrefab(obj, createMethodDecl, lazyStatements);
                                throw new Error("Assert: this code should not be reached.");
                            }
                            else {
                                body.push(new code_4.RawCodeDOM(""));
                                body.push(new code_4.RawCodeDOM("// " + obj.getEditorSupport().getLabel()));
                                this.addCreateObjectCode(obj, createMethodDecl, lazyStatements);
                            }
                        }
                        this.addCreateListsCode(body);
                        body.push(...lazyStatements);
                        this.addFieldInitCode(body);
                        body.push(new code_4.RawCodeDOM(""));
                        body.push(new code_4.RawCodeDOM(`this.events.emit("scene-awake");`));
                        return createMethodDecl;
                    }
                    addCreateAllPlainObjectCode(firstStatements, lazyStatements) {
                        for (const obj of this._scene.getPlainObjects()) {
                            this.addCreatePlainObjectCode(obj, firstStatements, lazyStatements);
                        }
                    }
                    addCreatePlainObjectCode(obj, firstStatements, lazyStatements) {
                        const objES = obj.getEditorSupport();
                        const varname = code_4.formatToValidVarName(objES.getLabel());
                        const result = objES.getExtension().buildCreateObjectWithFactoryCodeDOM({
                            gameObjectFactoryExpr: this._scene.isPrefabSceneType() ? "scene" : "this",
                            obj: obj,
                            varname
                        });
                        const comments = [
                            new code_4.RawCodeDOM(""),
                            new code_4.RawCodeDOM("// " + obj.getEditorSupport().getLabel())
                        ];
                        if (result.firstStatements) {
                            firstStatements.push(...comments);
                            firstStatements.push(...result.firstStatements);
                        }
                        if (result.lazyStatements) {
                            lazyStatements.push(...comments);
                            lazyStatements.push(...result.lazyStatements);
                        }
                        const objectFactoryMethodCall = result.objectFactoryMethodCall;
                        if (objES.isClassOrPublicScope() || objES.isMethodScope()) {
                            objectFactoryMethodCall.setDeclareReturnToVar(true);
                        }
                        if (objectFactoryMethodCall.isDeclareReturnToVar()) {
                            objectFactoryMethodCall.setReturnToVar(varname);
                        }
                    }
                    addCreateListsCode(body) {
                        const lists = this._scene.getObjectLists().getLists();
                        if (lists.length > 0) {
                            body.push(new code_4.RawCodeDOM(""), new code_4.RawCodeDOM("// lists"));
                        }
                        for (const list of lists) {
                            const map = this._scene.buildObjectIdMap();
                            const objectVarnames = [];
                            for (const objId of list.getObjectIds()) {
                                const obj = map.get(objId);
                                if (obj) {
                                    objectVarnames.push(code_4.formatToValidVarName(obj.getEditorSupport().getLabel()));
                                }
                            }
                            const varname = code_4.formatToValidVarName(list.getLabel());
                            let dom;
                            const isTsOutput = this._scene.getSettings().compilerOutputLanguage === "TYPE_SCRIPT";
                            if (isTsOutput && objectVarnames.length === 0) {
                                dom = new code_4.RawCodeDOM(`const ${varname}: Array<any> = [${objectVarnames.join(", ")}];`);
                            }
                            else {
                                dom = new code_4.RawCodeDOM(`const ${varname} = [${objectVarnames.join(", ")}];`);
                            }
                            body.push(dom);
                        }
                    }
                    addFieldInitCode_GameObjects(fields, prefabObj, children) {
                        for (const obj of this._objectsToFieldList) {
                            const objES = obj.getEditorSupport();
                            if (prefabObj !== obj) {
                                const varname = code_4.formatToValidVarName(objES.getLabel());
                                const dom = new code_4.AssignPropertyCodeDOM(varname, "this");
                                dom.value(varname);
                                fields.push(dom);
                            }
                        }
                    }
                    addFieldInitCode(body) {
                        const fields = [];
                        const prefabObj = this._scene.isPrefabSceneType() ? this._scene.getPrefabObject() : null;
                        this.addFieldInitCode_GameObjects(fields, prefabObj, this._scene.getGameObjects());
                        for (const obj of this._scene.getPlainObjects()) {
                            const objES = obj.getEditorSupport();
                            if (objES.isClassOrPublicScope()) {
                                const varname = code_4.formatToValidVarName(objES.getLabel());
                                const dom = new code_4.AssignPropertyCodeDOM(varname, "this");
                                dom.value(varname);
                                fields.push(dom);
                            }
                        }
                        for (const list of this._scene.getObjectLists().getLists()) {
                            if (scene_2.ui.sceneobjects.isClassOrPublicScope(list.getScope())) {
                                const varname = code_4.formatToValidVarName(list.getLabel());
                                const dom = new code_4.AssignPropertyCodeDOM(varname, "this");
                                dom.value(varname);
                                fields.push(dom);
                            }
                        }
                        if (fields.length > 0) {
                            body.push(new code_4.RawCodeDOM(""));
                            body.push(...fields);
                        }
                    }
                    addCreateObjectCodeOfNestedPrefab(obj, createMethodDecl, lazyStatements) {
                        const varname = SceneCodeDOMBuilder.getPrefabInstanceVarName(obj);
                        const result = this.buildSetObjectProperties({
                            obj,
                            varname
                        });
                        lazyStatements.push(...result.lazyStatements);
                        if (result.statements.length + result.lazyStatements.length > 0) {
                            this.addVarNameToRequiredDeclareVarSet(varname);
                        }
                        createMethodDecl.getBody().push(...result.statements);
                        this.addChildrenObjects({
                            createMethodDecl,
                            obj,
                            lazyStatements
                        });
                    }
                    addVarNameToRequiredDeclareVarSet(varName) {
                        const split = varName.split(".");
                        if (split.length > 1) {
                            this._requireDeclareVarSet.add(split[0]);
                        }
                    }
                    addCreateObjectCode(obj, createMethodDecl, lazyStatements) {
                        const objES = obj.getEditorSupport();
                        let createObjectMethodCall;
                        const objParent = objES.getObjectParent();
                        let parentVarName;
                        if (objParent) {
                            const parentIsPrefabObject = this._scene.isPrefabSceneType()
                                && objParent === this._scene.getPrefabObject();
                            parentVarName = parentIsPrefabObject ? "this"
                                : SceneCodeDOMBuilder.getPrefabInstanceVarName(objParent);
                        }
                        // the script nodes require using the varname of the parents
                        // so we need to generate a var for it. This covers the cases of
                        // nested prefabs which are parents of new nodes
                        if (obj instanceof scene_2.ui.sceneobjects.ScriptNode && parentVarName) {
                            this.addVarNameToRequiredDeclareVarSet(parentVarName);
                        }
                        if (objES.isPrefabInstance()) {
                            const clsName = objES.getPrefabName();
                            const type = objES.getObjectType();
                            const ext = scene_2.ScenePlugin.getInstance().getGameObjectExtensionByObjectType(type);
                            createObjectMethodCall = new code.MethodCallCodeDOM(clsName);
                            createObjectMethodCall.setConstructor(true);
                            const prefabSerializer = objES.getPrefabSerializer();
                            if (prefabSerializer) {
                                const builder = ext.getCodeDOMBuilder();
                                builder.buildCreatePrefabInstanceCodeDOM({
                                    obj,
                                    methodCallDOM: createObjectMethodCall,
                                    unit: this._unit,
                                    sceneExpr: this._isPrefabScene ? "scene" : "this",
                                    parentVarName,
                                    prefabSerializer
                                });
                                const { importPath, asDefault } = code.getImportPath(this._sceneFile, objES.getPrefabFile());
                                this._unit.addImport(clsName, importPath, asDefault);
                            }
                            else {
                                throw new Error(`Cannot find prefab with id ${objES.getPrefabId()}.`);
                            }
                        }
                        else {
                            const builder = objES.getExtension().getCodeDOMBuilder();
                            const factoryVarName = builder.getChainToFactory();
                            const sceneVarName = this._scene.isPrefabSceneType() ? `scene` : `this`;
                            createObjectMethodCall = builder.buildCreateObjectWithFactoryCodeDOM({
                                gameObjectFactoryExpr: `${sceneVarName}.${factoryVarName}`,
                                sceneExpr: sceneVarName,
                                parentVarName,
                                obj: obj,
                                unit: this._unit
                            });
                            // for example, in case it is adding a ScriptNode to a scene
                            if (createObjectMethodCall.isConstructor()) {
                                const clsName = createObjectMethodCall.getMethodName();
                                const clsFile = this._fileNameMap.get(clsName);
                                if (clsFile) {
                                    const { importPath, asDefault } = code.getImportPath(this._sceneFile, clsFile);
                                    this._unit.addImport(clsName, importPath, asDefault);
                                }
                            }
                            const forcingType = this.getExplicitType(obj, this.getCompletePhaserType(obj));
                            createObjectMethodCall.setExplicitType(forcingType);
                        }
                        const varname = code_4.formatToValidVarName(objES.getLabel());
                        createMethodDecl.getBody().push(createObjectMethodCall);
                        // script nodes are not added to the scene this way
                        if (objES.isPrefabInstance() && objES.isDisplayObject()) {
                            createObjectMethodCall.setDeclareReturnToVar(true);
                            if (!objParent) {
                                const addToScene = new code_4.MethodCallCodeDOM("existing", "this.add");
                                addToScene.arg(varname);
                                createMethodDecl.getBody().push(addToScene);
                            }
                        }
                        const result = this.buildSetObjectProperties({
                            obj,
                            varname
                        });
                        if (result.statements.length + result.lazyStatements.length > 0) {
                            createObjectMethodCall.setDeclareReturnToVar(true);
                        }
                        if (objES.isMethodScope()) {
                            // it is method scope... the user wants a variable!
                            createObjectMethodCall.setDeclareReturnToVar(true);
                        }
                        lazyStatements.push(...result.lazyStatements);
                        createMethodDecl.getBody().push(...result.statements);
                        // the script nodes are not added to the parent this way
                        if (objParent && objES.isDisplayObject()) {
                            createObjectMethodCall.setDeclareReturnToVar(true);
                            const addToParentCall = new code_4.MethodCallCodeDOM("add", parentVarName);
                            addToParentCall.arg(varname);
                            createMethodDecl.getBody().push(addToParentCall);
                        }
                        // generate children
                        {
                            let declareVar;
                            if (objES.isPrefabInstance()) {
                                declareVar = objES.getAppendedChildren().length > 0;
                            }
                            else {
                                declareVar = objES.getObjectChildren().length > 0;
                            }
                            this.addChildrenObjects({
                                createMethodDecl,
                                obj,
                                lazyStatements
                            });
                            if (this._requireDeclareVarSet.has(varname)) {
                                declareVar = true;
                            }
                            if (declareVar) {
                                createObjectMethodCall.setDeclareReturnToVar(true);
                            }
                        }
                        // generate lists
                        {
                            const lists = objES.getScene().getObjectLists().getListsByObjectId(objES.getId());
                            if (lists.length > 0) {
                                createObjectMethodCall.setDeclareReturnToVar(true);
                            }
                        }
                        // set var flags
                        if (objES.isClassOrPublicScope()) {
                            createObjectMethodCall.setDeclareReturnToVar(true);
                            this._objectsToFieldList.push(obj);
                        }
                        if (createObjectMethodCall.isDeclareReturnToVar()) {
                            createObjectMethodCall.setReturnToVar(varname);
                        }
                    }
                    getExplicitType(obj, baseType) {
                        const objES = obj.getEditorSupport();
                        return objES.getActiveComponents()
                            .map(comp => comp.getExplicitTypesForMethodFactory(baseType))
                            .filter(type => type !== undefined)
                            .join(" & ");
                    }
                    static getPrefabInstanceVarName(obj) {
                        const objES = obj.getEditorSupport();
                        if (objES.isScenePrefabObject()) {
                            return "this";
                        }
                        const varName = code_4.formatToValidVarName(objES.getLabel());
                        if (objES.isNestedPrefabInstance()) {
                            const parent = this.findPrefabInstanceWhereTheGivenObjectIsDefined(obj);
                            const parentVarName = this.getPrefabInstanceVarName(parent);
                            return parentVarName + "." + varName;
                        }
                        return varName;
                    }
                    static findPrefabInstanceWhereTheGivenObjectIsDefined(obj) {
                        const objES = obj.getEditorSupport();
                        // get the prefab file of the object...
                        const objPrefabFile = objES.getPrefabFile();
                        // ...so find the parent that is an instance of this file
                        const parent = objES.getObjectParent();
                        return this.findPrefabInstanceOfFile(parent, objPrefabFile);
                    }
                    static findPrefabInstanceOfFile(obj, targetPrefaFile) {
                        const finder = scene_2.ScenePlugin.getInstance().getSceneFinder();
                        const objES = obj.getEditorSupport();
                        // it is posible the object is a nested prefab,
                        // but what we need is the original prefab file or a variant of it.
                        const firstNonNestedPrefabId = finder.getFirstNonNestedPrefabId(objES.getPrefabId());
                        // maybe it is a nested prefab of a built-in type,
                        // in that case, the prefabId is undefined, and it should
                        // keep searching in the parent
                        if (firstNonNestedPrefabId) {
                            // the original prefab file (or a variant of it)
                            // this could be 'undefined' if the obj is a nested prefab
                            // of a primitive type.
                            const prefabFile = finder.getPrefabFile(firstNonNestedPrefabId);
                            // ok, if both file are the same, I found it!
                            if (prefabFile === targetPrefaFile) {
                                return obj;
                            }
                            // no, wait, it is a variant! That's ok too.
                            if (finder.isPrefabVariant(prefabFile, targetPrefaFile)) {
                                return obj;
                            }
                        }
                        // not found? keep searching with the parent...
                        return this.findPrefabInstanceOfFile(objES.getObjectParent(), targetPrefaFile);
                    }
                    buildSetObjectProperties(args) {
                        const obj = args.obj;
                        const support = obj.getEditorSupport();
                        const varname = args.varname;
                        let prefabSerializer = null;
                        if (support.isPrefabInstance()) {
                            prefabSerializer = support.getPrefabSerializer();
                        }
                        const statements = [];
                        const lazyStatements = [];
                        for (const comp of support.getActiveComponents()) {
                            comp.buildSetObjectPropertiesCodeDOM({
                                statements,
                                lazyStatements,
                                objectVarName: varname,
                                prefabSerializer: prefabSerializer,
                                unit: this._unit,
                                sceneFile: this._sceneFile,
                                obj
                            });
                        }
                        return { statements, lazyStatements };
                    }
                    addChildrenObjects(args) {
                        const objES = args.obj.getEditorSupport();
                        const body = args.createMethodDecl.getBody();
                        const parentIsPrefab = objES.isPrefabInstance();
                        for (const child of objES.getObjectChildren()) {
                            const childES = child.getEditorSupport();
                            if (childES.isMutableNestedPrefabInstance()) {
                                this.addCreateObjectCodeOfNestedPrefab(child, args.createMethodDecl, args.lazyStatements);
                            }
                            else if (!parentIsPrefab || childES.isPrefeabInstanceAppendedChild()) {
                                body.push(new code_4.RawCodeDOM(""));
                                body.push(new code_4.RawCodeDOM("// " + childES.getLabel()));
                                this.addCreateObjectCode(child, args.createMethodDecl, args.lazyStatements);
                            }
                        }
                    }
                    buildSceneConstructorMethod(sceneKey) {
                        const methodDecl = new code_4.MethodDeclCodeDOM("constructor");
                        const superCall = new code_4.MethodCallCodeDOM("super", null);
                        superCall.argLiteral(sceneKey);
                        const body = methodDecl.getBody();
                        body.push(superCall);
                        body.push(new code_4.RawCodeDOM(""));
                        body.push(new code_4.UserSectionCodeDOM("/* START-USER-CTR-CODE */", "/* END-USER-CTR-CODE */", "\n\t\t// Write your code here.\n\t\t"));
                        return methodDecl;
                    }
                    async buildPreloadMethod(methods) {
                        const settings = this._scene.getSettings();
                        if (settings.preloadPackFiles.length === 0) {
                            return;
                        }
                        const preloadDom = new code_4.MethodDeclCodeDOM(settings.preloadMethodName);
                        preloadDom.setReturnType("void");
                        preloadDom.getBody().push(new code_4.RawCodeDOM(""));
                        const ctx = (this._isPrefabScene ? "scene" : "this");
                        for (const fileName of settings.preloadPackFiles) {
                            const call = new code_4.MethodCallCodeDOM("pack", ctx + ".load");
                            const parts = fileName.split("/");
                            const namePart = parts[parts.length - 1];
                            const key = namePart.substring(0, namePart.length - 5);
                            const file = colibri.ui.ide.FileUtils.getFileFromPath(fileName);
                            let fileUrl = parts.slice(1).join("/");
                            if (file) {
                                fileUrl = phasereditor2d.pack.core.AssetPackUtils.getUrlFromAssetFile(file.getParent(), file);
                            }
                            call.argLiteral(key);
                            call.argLiteral(fileUrl);
                            preloadDom.getBody().push(call);
                        }
                        methods.push(preloadDom);
                    }
                }
                code_4.SceneCodeDOMBuilder = SceneCodeDOMBuilder;
            })(code = core.code || (core.code = {}));
        })(core = scene_2.core || (scene_2.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_3) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class SceneCompileAllExtension extends phasereditor2d.ide.core.CompileProjectExtension {
                    getFiles() {
                        const finder = scene_3.ScenePlugin.getInstance().getSceneFinder();
                        return finder.getSceneFiles(false);
                    }
                    getTotal() {
                        return this.getFiles().length;
                    }
                    static async compileSceneFile(file) {
                        const finder = scene_3.ScenePlugin.getInstance().getSceneFinder();
                        const data = finder.getSceneData(file);
                        const scene = await scene_3.ui.OfflineScene.createScene(data);
                        const compiler = new core.code.SceneCompiler(scene, file);
                        await compiler.compile();
                        scene.destroyGame();
                    }
                    async compile(monitor) {
                        const files = this.getFiles();
                        monitor.addTotal(files.length);
                        for (const file of files) {
                            await SceneCompileAllExtension.compileSceneFile(file);
                            monitor.step();
                        }
                    }
                }
                code.SceneCompileAllExtension = SceneCompileAllExtension;
            })(code = core.code || (core.code = {}));
        })(core = scene_3.core || (scene_3.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_4) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                var ide = colibri.ui.ide;
                class SceneCompiler {
                    _scene;
                    _sceneFile;
                    constructor(scene, sceneFile) {
                        this._scene = scene;
                        this._sceneFile = sceneFile;
                    }
                    getOutputFile() {
                        const settings = this._scene.getSettings();
                        const compileToJS = settings.compilerOutputLanguage === phasereditor2d.ide.core.code.SourceLang.JAVA_SCRIPT;
                        const fileExt = compileToJS ? "js" : "ts";
                        const fileName = this._sceneFile.getNameWithoutExtension() + "." + fileExt;
                        const outputFile = this._sceneFile.getSibling(fileName);
                        return outputFile;
                    }
                    async compile() {
                        console.log(`Compiling ${this._sceneFile.getName()}`);
                        const settings = this._scene.getSettings();
                        if (!settings.compilerEnabled) {
                            return;
                        }
                        const compileToJS = settings.compilerOutputLanguage === phasereditor2d.ide.core.code.SourceLang.JAVA_SCRIPT;
                        const builder = new core.code.SceneCodeDOMBuilder(this._scene, this._sceneFile);
                        const unit = await builder.build();
                        if (!unit) {
                            return;
                        }
                        const generator = compileToJS ?
                            new core.code.JavaScriptUnitCodeGenerator(unit)
                            : new core.code.TypeScriptUnitCodeGenerator(unit);
                        if (compileToJS) {
                            generator.setInitFieldInConstructor(settings.javaScriptInitFieldsInConstructor);
                        }
                        generator.setGenerateImports(settings.autoImport);
                        const fileExt = compileToJS ? "js" : "ts";
                        const fileName = this._sceneFile.getNameWithoutExtension() + "." + fileExt;
                        let replaceContent = "";
                        {
                            const outputFile = this._sceneFile.getSibling(fileName);
                            if (outputFile) {
                                replaceContent = await ide.FileUtils.getFileStorage().getFileString(outputFile);
                            }
                        }
                        let output = generator.generate(replaceContent);
                        if (settings.compilerInsertSpaces) {
                            const tabs = " ".repeat(Math.max(1, settings.compilerTabSize));
                            output = output.replace(/\t/g, tabs);
                        }
                        await ide.FileUtils.createFile_async(this._sceneFile.getParent(), fileName, output);
                    }
                }
                code.SceneCompiler = SceneCompiler;
            })(code = core.code || (core.code = {}));
        })(core = scene_4.core || (scene_4.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class TypeScriptUnitCodeGenerator extends code.JavaScriptUnitCodeGenerator {
                    constructor(unit) {
                        super(unit);
                    }
                    isTypeScript() {
                        return true;
                    }
                    generateExtraUnitCode() {
                        for (const codeDom of this.getUnit().getTypeScriptInterfaces()) {
                            this.generateUnitElement(codeDom);
                        }
                    }
                    generateInterface(ifaceDecl) {
                        if (ifaceDecl.isExportInterface()) {
                            this.append("export default ");
                        }
                        this.append("interface " + ifaceDecl.getName());
                        this.openIndent(" {");
                        this.line();
                        const body = code.CodeDOM.removeBlankLines(ifaceDecl.getBody());
                        for (const fieldDecl of body) {
                            this.generateFieldDecl(fieldDecl);
                        }
                        this.closeIndent("}");
                        this.line();
                    }
                    generateMethodReturnTypeJSDoc(methodDecl) {
                        // nothing, it is made in signature
                    }
                    generateFieldDecl(fieldDecl) {
                        let mod;
                        if (fieldDecl.isInterfaceMember()) {
                            mod = "";
                        }
                        else {
                            mod = fieldDecl.isPublic() ? "public" : "private";
                        }
                        if (fieldDecl.isInitialized()) {
                            this.line(`${mod} ${fieldDecl.getName()}: ${fieldDecl.getType()} = ${fieldDecl.getInitialValueExpr()};`);
                        }
                        else if (fieldDecl.isAllowUndefined()) {
                            this.line(`${mod} ${fieldDecl.getName()}!: ${fieldDecl.getType()};`);
                        }
                        else {
                            this.line(`${mod} ${fieldDecl.getName()}: ${fieldDecl.getType()};`);
                        }
                    }
                    getMethodReturnDeclText(methodDecl) {
                        if (methodDecl.getReturnType()) {
                            return ": " + methodDecl.getReturnType() + " ";
                        }
                        return " ";
                    }
                    // generateFieldInitInConstructor(classDecl: ClassDeclCodeDOM) {
                    //     // nothing, in TypeScript fields are initialized in the declaration
                    // }
                    generateTypeAnnotation(assign) {
                        // do nothing, in TypeScript uses the var declaration syntax
                    }
                    generateMethodDeclArgs(methodDecl) {
                        this.append(methodDecl.getArgs()
                            .map(arg => `${arg.name}${arg.optional ? "?" : ""}: ${arg.type}`)
                            .join(", "));
                    }
                }
                code.TypeScriptUnitCodeGenerator = TypeScriptUnitCodeGenerator;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class UnitCodeDOM {
                    _body;
                    _typeScriptInterfaces;
                    _imports;
                    _used;
                    constructor(elements) {
                        this._body = elements;
                        this._typeScriptInterfaces = [];
                        this._imports = [];
                        this._used = new Set();
                    }
                    getTypeScriptInterfaces() {
                        return this._typeScriptInterfaces;
                    }
                    getImports() {
                        return this._imports;
                    }
                    addImport(elementName, filePath, asDefault) {
                        const key = (asDefault ? elementName : `{ ${elementName} }`) + " form " + filePath;
                        if (this._used.has(key)) {
                            return;
                        }
                        this._used.add(key);
                        this._imports.push(new code.ImportCodeDOM(elementName, filePath, asDefault));
                    }
                    getBody() {
                        return this._body;
                    }
                    setBody(body) {
                        this._body = body;
                    }
                }
                code.UnitCodeDOM = UnitCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var code;
            (function (code) {
                class UserSectionCodeDOM extends code.CodeDOM {
                    _openTag;
                    _closeTag;
                    _defaultContent;
                    constructor(openTag, closeTag, userContent) {
                        super();
                        this._openTag = openTag;
                        this._closeTag = closeTag;
                        this._defaultContent = userContent;
                    }
                    getOpenTag() {
                        return this._openTag;
                    }
                    getCloseTag() {
                        return this._closeTag;
                    }
                    getDefaultContent() {
                        return this._defaultContent;
                    }
                }
                code.UserSectionCodeDOM = UserSectionCodeDOM;
            })(code = core.code || (core.code = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var json;
            (function (json) {
                let SceneType;
                (function (SceneType) {
                    SceneType["SCENE"] = "SCENE";
                    SceneType["PREFAB"] = "PREFAB";
                })(SceneType = json.SceneType || (json.SceneType = {}));
            })(json = core.json || (core.json = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    var read = colibri.core.json.read;
                    class UserComponent {
                        _name;
                        _displayName;
                        _objectDisplayFormat;
                        _baseClass;
                        _gameObjectType;
                        _properties;
                        constructor(name) {
                            this._name = name;
                            this._baseClass = "";
                            this._displayName = "";
                            this._objectDisplayFormat = "";
                            this._gameObjectType = "Phaser.GameObjects.Image";
                            this._properties = new usercomponent.UserComponentProperties(this);
                        }
                        toJSON() {
                            const propsData = [];
                            this._properties.writeJSON(propsData);
                            const data = {
                                name: this._name,
                                displayName: this._displayName,
                                objectDisplayFormat: this._objectDisplayFormat,
                                baseClass: this._baseClass,
                                gameObjectType: this._gameObjectType,
                                properties: propsData
                            };
                            return data;
                        }
                        readJSON(data) {
                            this._name = data.name;
                            this._displayName = read(data, "displayName", "");
                            this._objectDisplayFormat = read(data, "objectDisplayFormat", "");
                            this._baseClass = read(data, "baseClass", "");
                            this._gameObjectType = read(data, "gameObjectType", "Phaser.GameObjects.Image");
                            this._properties.readJSON(data.properties);
                        }
                        getName() {
                            return this._name;
                        }
                        setName(name) {
                            this._name = name;
                        }
                        getObjectDisplayFormat() {
                            return this._objectDisplayFormat;
                        }
                        setObjectDisplayFormat(objectDisplayFormat) {
                            this._objectDisplayFormat = objectDisplayFormat;
                        }
                        getDisplayName() {
                            return this._displayName;
                        }
                        setDisplayName(displayName) {
                            this._displayName = displayName;
                        }
                        getDisplayNameOrName() {
                            if (this._displayName && this._displayName.trim().length > 0) {
                                return this._displayName;
                            }
                            return this._name;
                        }
                        getBaseClass() {
                            return this._baseClass;
                        }
                        setBaseClass(baseClass) {
                            this._baseClass = baseClass;
                        }
                        getGameObjectType() {
                            return this._gameObjectType;
                        }
                        setGameObjectType(gameObjectType) {
                            this._gameObjectType = gameObjectType;
                        }
                        getUserProperties() {
                            return this._properties;
                        }
                    }
                    usercomponent.UserComponent = UserComponent;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../ui/editor/usercomponent/UserComponent.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var json;
            (function (json) {
                var FileUtils = colibri.ui.ide.FileUtils;
                var controls = colibri.ui.controls;
                var usercomponent = scene.ui.editor.usercomponent;
                class SceneFinderPreloader extends colibri.ui.ide.PreloadProjectResourcesExtension {
                    _finder;
                    constructor(finder) {
                        super();
                        this._finder = finder;
                    }
                    async computeTotal() {
                        return 0;
                    }
                    async preload(monitor) {
                        await this._finder.preload(monitor);
                    }
                }
                class SceneFinder {
                    _prefabObjectId_ObjectData_Map;
                    _sceneFilename_Data_Map;
                    _sceneFilename_Settings_Map;
                    _prefabId_File_Map;
                    _sceneFiles;
                    _prefabFiles;
                    _compFiles;
                    _compFilename_Data_Map;
                    _compModelsInfo;
                    _enabled;
                    _nestedPrefabIds;
                    _storageChangeListener;
                    constructor() {
                        this._prefabObjectId_ObjectData_Map = new Map();
                        this._nestedPrefabIds = new Set();
                        this._sceneFilename_Data_Map = new Map();
                        this._sceneFilename_Settings_Map = new Map();
                        this._prefabId_File_Map = new Map();
                        this._sceneFiles = [];
                        this._prefabFiles = [];
                        this._compFiles = [];
                        this._compFilename_Data_Map = new Map();
                        this._compModelsInfo = [];
                        this._enabled = true;
                    }
                    registerStorageListener() {
                        this._storageChangeListener = async (e) => {
                            await this.handleStorageChange(e);
                        };
                        colibri.ui.ide.FileUtils.getFileStorage().addChangeListener(this._storageChangeListener);
                    }
                    async handleStorageChange(change) {
                        const test = (names) => {
                            for (const name of names) {
                                if (name.endsWith(".scene") || name.endsWith(".components")) {
                                    return true;
                                }
                            }
                            return false;
                        };
                        if (test(change.getAddRecords())
                            || test(change.getModifiedRecords())
                            || test(change.getDeleteRecords())
                            || test(change.getRenameFromRecords())
                            || test(change.getRenameToRecords())) {
                            await this.preload(controls.EMPTY_PROGRESS_MONITOR);
                        }
                    }
                    getProjectPreloader() {
                        return new SceneFinderPreloader(this);
                    }
                    async preload(monitor) {
                        if (!this.isEnabled()) {
                            return;
                        }
                        const total = (await FileUtils.getFilesWithContentType(core.CONTENT_TYPE_SCENE)).length
                            + (await FileUtils.getFilesWithContentType(core.CONTENT_TYPE_USER_COMPONENTS)).length
                            + 1;
                        monitor.addTotal(total);
                        await this.preloadSceneFiles(monitor);
                        await this.preloadComponentsFiles(monitor);
                        monitor.step();
                    }
                    async preloadComponentsFiles(monitor) {
                        const compFiles = [];
                        const compFilename_Data_Map = new Map();
                        const compModels = [];
                        const files = await FileUtils.getFilesWithContentType(core.CONTENT_TYPE_USER_COMPONENTS);
                        for (const file of files) {
                            const content = await FileUtils.preloadAndGetFileString(file);
                            try {
                                const data = JSON.parse(content);
                                const model = new usercomponent.UserComponentsModel();
                                model.readJSON(data);
                                compModels.push({ file, model });
                                compFilename_Data_Map.set(file.getFullName(), model);
                                compFiles.push(file);
                            }
                            catch (e) {
                                console.error(`SceneDataTable: parsing file ${file.getFullName()}. Error: ${e.message}`);
                            }
                            monitor.step();
                        }
                        this._compFiles = compFiles;
                        this._compFilename_Data_Map = compFilename_Data_Map;
                        this._compModelsInfo = compModels;
                    }
                    setEnabled(enabled) {
                        this._enabled = enabled;
                    }
                    isEnabled() {
                        return this._enabled;
                    }
                    async preloadSceneFiles(monitor) {
                        const sceneIdSet = new Set();
                        const prefabObjectId_ObjectData_Map = new Map();
                        const nestedPrefabIds = new Set();
                        const sceneFilename_Data_Map = new Map();
                        const sceneFilename_Settings_Map = new Map();
                        const prefabId_File_Map = new Map();
                        const sceneFiles = [];
                        const prefabFiles = [];
                        const files = await FileUtils.getFilesWithContentType(core.CONTENT_TYPE_SCENE);
                        files.sort((a, b) => b.getModTime() - a.getModTime());
                        for (const file of files) {
                            const content = await FileUtils.preloadAndGetFileString(file);
                            try {
                                const data = JSON.parse(content);
                                scene.ScenePlugin.getInstance().runSceneDataMigrations(data);
                                sceneFilename_Data_Map.set(file.getFullName(), data);
                                {
                                    const settings = new json.SceneSettings();
                                    settings.readJSON(data.settings);
                                    sceneFilename_Settings_Map.set(file.getFullName(), settings);
                                }
                                if (data.id) {
                                    if (sceneIdSet.has(data.id)) {
                                        const mappedFile = prefabId_File_Map.get(data.id);
                                        alert(`ERROR! File ${mappedFile.getFullName()} has a duplicated ID ${data.id}. Run the command Fix Duplicated Scenes ID.`);
                                    }
                                    else {
                                        sceneIdSet.add(data.id);
                                    }
                                    if (data.displayList.length > 0) {
                                        const objData = data.displayList[data.displayList.length - 1];
                                        prefabObjectId_ObjectData_Map.set(data.id, objData);
                                        prefabId_File_Map.set(data.id, file);
                                        this.mapNestedPrefabData(prefabObjectId_ObjectData_Map, prefabId_File_Map, nestedPrefabIds, file, objData);
                                    }
                                    if (data.sceneType === json.SceneType.PREFAB) {
                                        prefabFiles.push(file);
                                    }
                                }
                                sceneFiles.push(file);
                            }
                            catch (e) {
                                console.error(`SceneDataTable: parsing file ${file.getFullName()}. Error: ${e.message}`);
                            }
                            monitor.step();
                        }
                        this._prefabObjectId_ObjectData_Map = prefabObjectId_ObjectData_Map;
                        this._nestedPrefabIds = nestedPrefabIds;
                        this._sceneFilename_Data_Map = sceneFilename_Data_Map;
                        this._sceneFilename_Settings_Map = sceneFilename_Settings_Map;
                        this._prefabId_File_Map = prefabId_File_Map;
                        this._sceneFiles = sceneFiles;
                        this._prefabFiles = prefabFiles;
                    }
                    mapNestedPrefabData(prefabObjectId_ObjectData_Map, prefabId_File_Map, nestedPrefabIds, file, objData) {
                        if (objData.list) {
                            for (const c of objData.list) {
                                if (c.private_np || scene.ui.sceneobjects.isNestedPrefabScope(c.scope)) {
                                    prefabObjectId_ObjectData_Map.set(c.id, c);
                                    prefabId_File_Map.set(c.id, file);
                                    nestedPrefabIds.add(c.id);
                                    this.mapNestedPrefabData(prefabObjectId_ObjectData_Map, prefabId_File_Map, nestedPrefabIds, file, c);
                                }
                            }
                        }
                        if (objData.nestedPrefabs) {
                            for (const c of objData.nestedPrefabs) {
                                prefabObjectId_ObjectData_Map.set(c.id, c);
                                prefabId_File_Map.set(c.id, file);
                                nestedPrefabIds.add(c.id);
                                this.mapNestedPrefabData(prefabObjectId_ObjectData_Map, prefabId_File_Map, nestedPrefabIds, file, c);
                            }
                        }
                    }
                    getUserComponentsFiles() {
                        return this._compFiles;
                    }
                    getUserComponentsByFile(file) {
                        return this._compFilename_Data_Map.get(file.getFullName());
                    }
                    getUserComponentsModels(includeLibraryFiles = true) {
                        if (!includeLibraryFiles) {
                            return this._compModelsInfo
                                .filter(info => !phasereditor2d.ide.core.code.isNodeLibraryFile(info.file)
                                && !phasereditor2d.ide.core.code.isCopiedLibraryFile(info.file));
                        }
                        return this._compModelsInfo;
                    }
                    getUserComponentByName(name) {
                        for (const info of this._compModelsInfo) {
                            for (const comp of info.model.getComponents()) {
                                if (comp.getName() === name) {
                                    return {
                                        file: info.file,
                                        model: info.model,
                                        component: comp
                                    };
                                }
                            }
                        }
                        return undefined;
                    }
                    getPrefabId(file) {
                        const data = this.getSceneData(file);
                        if (data) {
                            if (data.sceneType === json.SceneType.PREFAB) {
                                return data.id;
                            }
                        }
                        return null;
                    }
                    getSceneFiles(includeLibraryFiles = true) {
                        if (!includeLibraryFiles) {
                            return this._sceneFiles
                                .filter(f => !phasereditor2d.ide.core.code.isNodeLibraryFile(f)
                                && !phasereditor2d.ide.core.code.isCopiedLibraryFile(f));
                        }
                        return this._sceneFiles;
                    }
                    getPrefabFiles() {
                        return this._prefabFiles;
                    }
                    getScriptPrefabFiles() {
                        return this._prefabFiles.filter(file => this.isScriptPrefabFile(file));
                    }
                    isScriptPrefabFile(file) {
                        let prefabId = this.getPrefabId(file);
                        if (prefabId) {
                            prefabId = this.getOriginalPrefabId(prefabId);
                            const data = this.getPrefabData(prefabId);
                            if (data && data.type === scene.ui.sceneobjects.ScriptNodeExtension
                                .getInstance().getTypeName()) {
                                return true;
                            }
                        }
                        return false;
                    }
                    getFirstNonNestedPrefabId(prefabId) {
                        if (this.isNestedPrefab(prefabId)) {
                            const data = this.getPrefabData(prefabId);
                            if (data.prefabId) {
                                return this.getFirstNonNestedPrefabId(data.prefabId);
                            }
                            return undefined;
                        }
                        return prefabId;
                    }
                    getOriginalPrefabId(prefabId) {
                        const objData = this.getPrefabData(prefabId);
                        if (!objData) {
                            return undefined;
                        }
                        if (objData.prefabId) {
                            return this.getOriginalPrefabId(objData.prefabId);
                        }
                        return prefabId;
                    }
                    isNestedPrefab(prefabId) {
                        return this._nestedPrefabIds.has(prefabId);
                    }
                    existsPrefab(prefabId) {
                        return this._prefabObjectId_ObjectData_Map.has(prefabId);
                    }
                    getPrefabData(prefabId) {
                        return this._prefabObjectId_ObjectData_Map.get(prefabId);
                    }
                    getPrefabFile(prefabId) {
                        return this._prefabId_File_Map.get(prefabId);
                    }
                    getPrefabHierarchy(prefabId) {
                        return this.getPrefabHierarchy2(prefabId, []);
                    }
                    isPrefabVariant(basePrefabFile, superPrefabFile) {
                        const basePrefabId = this.getPrefabId(basePrefabFile);
                        const result = this.getPrefabHierarchy(basePrefabId);
                        if (result.indexOf(superPrefabFile) >= 0) {
                            return true;
                        }
                        return false;
                    }
                    getPrefabHierarchy2(prefabId, result) {
                        const file = this.getPrefabFile(prefabId);
                        if (file) {
                            if (!this.isNestedPrefab(prefabId)) {
                                result.push(file);
                            }
                            const objData = this.getPrefabData(prefabId);
                            if (objData && objData.prefabId) {
                                this.getPrefabHierarchy2(objData.prefabId, result);
                            }
                        }
                        return result;
                    }
                    isPrefabFile(file) {
                        const data = this.getSceneData(file);
                        return data && data.sceneType === json.SceneType.PREFAB;
                    }
                    getSceneData(file) {
                        return this._sceneFilename_Data_Map.get(file.getFullName());
                    }
                    getSceneSettings(file) {
                        return this._sceneFilename_Settings_Map.get(file.getFullName());
                    }
                    getScenePhaserType(file) {
                        const data = this.getSceneData(file);
                        if (data.sceneType === core.json.SceneType.SCENE) {
                            return "Phaser.Scene";
                        }
                        const prefabId = this.getPrefabId(file);
                        if (prefabId) {
                            const prefabData = this.getPrefabData(prefabId);
                            if (prefabData) {
                                const serializer = new core.json.Serializer(prefabData);
                                const type = serializer.getPhaserType();
                                return type;
                            }
                        }
                        return undefined;
                    }
                    getAllSceneData() {
                        return this.getSceneFiles().map(file => this.getSceneData(file));
                    }
                    printDebugInfo() {
                        console.log("Scene Finder debug:");
                        for (const prefab of this._prefabFiles) {
                            console.log("Prefab file '" + prefab.getFullName() + "'");
                        }
                        for (const id of this._prefabObjectId_ObjectData_Map.keys()) {
                            console.log("Prefab data " + id + ":");
                            console.log(this._prefabObjectId_ObjectData_Map.get(id));
                        }
                    }
                    async findUserEvents() {
                        const result = [];
                        for (const file of colibri.ui.ide.FileUtils.getAllFiles()) {
                            if (file.getName() === "events.txt") {
                                const content = await colibri.ui.ide.FileUtils.preloadAndGetFileString(file);
                                const lines = content.split("\n");
                                for (let line of lines) {
                                    line = line.trim();
                                    if (line.length === 0 || line.startsWith("#")) {
                                        continue;
                                    }
                                    let name = line;
                                    let help = "";
                                    const i = line.indexOf(" ");
                                    if (i > 0) {
                                        name = line.substring(0, i);
                                        help = line.substring(i + 1);
                                    }
                                    result.push({ name, help, file });
                                }
                            }
                        }
                        return result;
                    }
                }
                json.SceneFinder = SceneFinder;
            })(json = core.json || (core.json = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var json;
            (function (json) {
                var read = colibri.core.json.read;
                var write = colibri.core.json.write;
                class SceneSettings {
                    compilerEnabled;
                    compilerInsertSpaces;
                    compilerTabSize;
                    snapEnabled;
                    snapWidth;
                    snapHeight;
                    onlyGenerateMethods;
                    prefabObjDisplayFmt;
                    displayName;
                    superClassName;
                    preloadMethodName;
                    preloadPackFiles;
                    createMethodName;
                    javaScriptInitFieldsInConstructor;
                    sceneKey;
                    exportClass;
                    autoImport;
                    generateAwakeHandler;
                    compilerOutputLanguage;
                    scopeBlocksToFolder;
                    borderX;
                    borderY;
                    borderWidth;
                    borderHeight;
                    constructor(compilerEnabled = true, compilerInsertSpaces = false, compilerTabSize = 4, snapEnabled = false, snapWidth = 16, snapHeight = 16, onlyGenerateMethods = false, prefabObjDisplayFmt = undefined, displayName = undefined, superClassName = "", preloadMethodName = "preload", preloadPackFiles = [], createMethodName = "create", javaScriptInitFieldsInConstructor = false, sceneKey = "", exportClass = false, autoImport = false, generateAwakeHandler = false, compilerOutputLanguage = phasereditor2d.ide.core.code.SourceLang.JAVA_SCRIPT, scopeBlocksToFolder = false, borderX = 0, borderY = 0, borderWidth = 800, borderHeight = 600) {
                        this.compilerEnabled = compilerEnabled;
                        this.compilerInsertSpaces = compilerInsertSpaces;
                        this.compilerTabSize = compilerTabSize;
                        this.snapEnabled = snapEnabled;
                        this.snapWidth = snapWidth;
                        this.snapHeight = snapHeight;
                        this.onlyGenerateMethods = onlyGenerateMethods;
                        this.prefabObjDisplayFmt = prefabObjDisplayFmt;
                        this.displayName = displayName;
                        this.superClassName = superClassName;
                        this.preloadMethodName = preloadMethodName;
                        this.preloadPackFiles = preloadPackFiles;
                        this.createMethodName = createMethodName;
                        this.javaScriptInitFieldsInConstructor = javaScriptInitFieldsInConstructor;
                        this.sceneKey = sceneKey;
                        this.exportClass = exportClass;
                        this.autoImport = autoImport;
                        this.generateAwakeHandler = generateAwakeHandler;
                        this.compilerOutputLanguage = compilerOutputLanguage;
                        this.scopeBlocksToFolder = scopeBlocksToFolder;
                        this.borderX = borderX;
                        this.borderY = borderY;
                        this.borderWidth = borderWidth;
                        this.borderHeight = borderHeight;
                    }
                    toJSON() {
                        const data = {};
                        write(data, "compilerEnabled", this.compilerEnabled, true);
                        write(data, "compilerInsertSpaces", this.compilerInsertSpaces, false);
                        write(data, "compilerTabSize", this.compilerTabSize, 4);
                        write(data, "snapEnabled", this.snapEnabled, false);
                        write(data, "snapWidth", this.snapWidth, 16);
                        write(data, "snapHeight", this.snapHeight, 16);
                        write(data, "onlyGenerateMethods", this.onlyGenerateMethods, false);
                        write(data, "javaScriptInitFieldsInConstructor", this.javaScriptInitFieldsInConstructor, false);
                        write(data, "exportClass", this.exportClass, false);
                        write(data, "autoImport", this.autoImport, false);
                        write(data, "generateAwakeHandler", this.generateAwakeHandler, false);
                        write(data, "prefabObjDisplayFmt", this.prefabObjDisplayFmt, undefined);
                        write(data, "displayName", this.displayName, undefined);
                        write(data, "superClassName", this.superClassName, "");
                        write(data, "preloadMethodName", this.preloadMethodName, "preload");
                        write(data, "preloadPackFiles", this.preloadPackFiles, []);
                        write(data, "createMethodName", this.createMethodName, "create");
                        write(data, "sceneKey", this.sceneKey, "");
                        write(data, "compilerOutputLanguage", this.compilerOutputLanguage, phasereditor2d.ide.core.code.SourceLang.JAVA_SCRIPT);
                        write(data, "scopeBlocksToFolder", this.scopeBlocksToFolder, false);
                        write(data, "borderX", this.borderX, 0);
                        write(data, "borderY", this.borderY, 0);
                        write(data, "borderWidth", this.borderWidth, 800);
                        write(data, "borderHeight", this.borderHeight, 600);
                        return data;
                    }
                    readJSON(data) {
                        this.compilerEnabled = read(data, "compilerEnabled", true);
                        this.compilerInsertSpaces = read(data, "compilerInsertSpaces", false);
                        this.compilerTabSize = read(data, "compilerTabSize", 4);
                        this.snapEnabled = read(data, "snapEnabled", false);
                        this.snapWidth = read(data, "snapWidth", 16);
                        this.snapHeight = read(data, "snapHeight", 16);
                        this.onlyGenerateMethods = read(data, "onlyGenerateMethods", false);
                        this.javaScriptInitFieldsInConstructor = read(data, "javaScriptInitFieldsInConstructor", false);
                        this.exportClass = read(data, "exportClass", false);
                        this.autoImport = read(data, "autoImport", false);
                        this.generateAwakeHandler = read(data, "generateAwakeHandler", false);
                        this.prefabObjDisplayFmt = read(data, "prefabObjDisplayFmt", undefined);
                        this.displayName = read(data, "displayName", undefined);
                        this.superClassName = read(data, "superClassName", "");
                        this.preloadMethodName = read(data, "preloadMethodName", "preload");
                        this.preloadPackFiles = read(data, "preloadPackFiles", []);
                        this.createMethodName = read(data, "createMethodName", "create");
                        this.sceneKey = read(data, "sceneKey", "");
                        this.compilerOutputLanguage = read(data, "compilerOutputLanguage", phasereditor2d.ide.core.code.SourceLang.JAVA_SCRIPT);
                        this.scopeBlocksToFolder = read(data, "scopeBlocksToFolder", false);
                        this.borderX = read(data, "borderX", 0);
                        this.borderY = read(data, "borderY", 0);
                        this.borderWidth = read(data, "borderWidth", 800);
                        this.borderHeight = read(data, "borderHeight", 600);
                    }
                }
                json.SceneSettings = SceneSettings;
            })(json = core.json || (core.json = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_5) {
        var core;
        (function (core) {
            var json;
            (function (json_1) {
                class SceneWriter {
                    _scene;
                    constructor(scene) {
                        this._scene = scene;
                    }
                    toJSON() {
                        const sceneData = {
                            id: this._scene.getId(),
                            sceneType: this._scene.getSceneType(),
                            settings: this._scene.getSettings().toJSON(),
                            displayList: [],
                            plainObjects: [],
                            meta: {
                                app: "Phaser Editor 2D - Scene Editor",
                                url: "https://phasereditor2d.com",
                                contentType: core.CONTENT_TYPE_SCENE,
                                version: scene_5.ui.Scene.CURRENT_VERSION
                            }
                        };
                        // object lists
                        this._scene.getObjectLists().writeJSON(sceneData);
                        // plain objects
                        for (const obj of this._scene.getPlainObjects()) {
                            const objData = {};
                            obj.getEditorSupport().writeJSON(objData);
                            sceneData.plainObjects.push(objData);
                        }
                        // display list
                        for (const obj of this._scene.getGameObjects()) {
                            this.computeDataField_private_np(obj);
                        }
                        for (const obj of this._scene.getGameObjects()) {
                            const objData = {};
                            const objES = obj.getEditorSupport();
                            // write the `private_np` field
                            const private_np = objES._private_np;
                            if (private_np) {
                                objData.private_np = true;
                            }
                            // serialize all the other obj data
                            objES.writeJSON(objData);
                            // add the data to the list
                            sceneData.displayList.push(objData);
                        }
                        // prefab properties
                        const prefabProperties = [];
                        this._scene.getPrefabUserProperties().writeJSON(prefabProperties);
                        if (prefabProperties.length > 0) {
                            sceneData.prefabProperties = prefabProperties;
                        }
                        // code snippets
                        const codeSnippets = this._scene.getCodeSnippets();
                        if (codeSnippets.getSnippets().length > 0) {
                            sceneData.codeSnippets = codeSnippets.toJSON();
                        }
                        return sceneData;
                    }
                    computeDataField_private_np(obj) {
                        const objES = obj.getEditorSupport();
                        for (const child of objES.getObjectChildren()) {
                            this.computeDataField_private_np(child);
                        }
                        if (!objES.isPrefabInstancePart()
                            && !objES.isNestedPrefabScope()
                            && !objES.isScenePrefabObject()) {
                            // ok, it is an object in the scene which
                            // I don't know if it is a private nested prefab (`private_np`)
                            // let's investigate with the kids
                            for (const child of objES.getObjectChildren()) {
                                const childES = child.getEditorSupport();
                                if (
                                // the child is flagged as private_np
                                childES._private_np
                                    // or the child is is a common object with a NESTED_PREFAB scope
                                    || (childES.isNestedPrefabScope() && !childES.isPrefabInstancePart())) {
                                    // flag the object and stop the search
                                    objES._private_np = true;
                                    break;
                                }
                            }
                        }
                    }
                    toString() {
                        const json = this.toJSON();
                        return JSON.stringify(json);
                    }
                }
                json_1.SceneWriter = SceneWriter;
            })(json = core.json || (core.json = {}));
        })(core = scene_5.core || (scene_5.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var json;
            (function (json) {
                class Serializer {
                    _data;
                    _prefabSer;
                    constructor(data) {
                        this._data = data;
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        if (this._data.prefabId) {
                            const prefabData = finder.getPrefabData(this._data.prefabId);
                            if (prefabData) {
                                this._prefabSer = new Serializer(prefabData);
                            }
                            else {
                                finder.printDebugInfo();
                                throw new Error(`[${this._data.label}] Cannot find scene prefab with id "${this._data.prefabId}".`);
                            }
                        }
                    }
                    getSerializer(data) {
                        return new Serializer(data);
                    }
                    getData() {
                        return this._data;
                    }
                    getType() {
                        if (this._prefabSer) {
                            return this._prefabSer.getType();
                        }
                        return this._data.type;
                    }
                    getPhaserType() {
                        if (this._prefabSer) {
                            return this._prefabSer.getPhaserType();
                        }
                        const ext = scene.ScenePlugin.getInstance().getGameObjectExtensionByObjectType(this._data.type);
                        if (!ext) {
                            const msg = `Cannot find extension for ObjectType '${this._data.type}'`;
                            alert(msg);
                            throw new Error(msg);
                        }
                        return ext.getPhaserTypeName();
                    }
                    getPrefabSerializer() {
                        return this._prefabSer;
                    }
                    getDefaultValue(name, defaultValue) {
                        if (this.isPrefabInstance()) {
                            if (!this.isUnlocked(name)) {
                                const defaultPrefabValue = this._prefabSer.getDefaultValue(name, defaultValue);
                                if (defaultPrefabValue !== undefined) {
                                    return defaultPrefabValue;
                                }
                                return defaultValue;
                            }
                        }
                        const localValue = this._data[name];
                        if (localValue === undefined) {
                            return defaultValue;
                        }
                        return localValue;
                    }
                    isUnlocked(name) {
                        if (this.isPrefabInstance()) {
                            // check if it is a local component property
                            if (this._data.components) {
                                for (const compName of this._data.components) {
                                    if (name.startsWith(compName + ".")) {
                                        return true;
                                    }
                                }
                            }
                            if (this._data.unlock) {
                                const i = this._data.unlock.indexOf(name);
                                return i >= 0;
                            }
                            return false;
                        }
                        return true;
                    }
                    setUnlocked(name, unlocked) {
                        if (this.isPrefabInstance()) {
                            const dataUnlock = this._data.unlock ?? [];
                            const set = new Set(dataUnlock);
                            if (unlocked) {
                                set.add(name);
                            }
                            else {
                                set.delete(name);
                            }
                            this._data.unlock = [...set];
                        }
                    }
                    isPrefabInstance() {
                        return typeof this._data.prefabId === "string";
                    }
                    write(name, value, defValue) {
                        if (this.isPrefabInstance()) {
                            if (this.isUnlocked(name)) {
                                // const defValue2 = this.getDefaultValue(name, defValue);
                                // colibri.core.json.write(this._data, name, value, defValue2);
                                this._data[name] = value;
                            }
                        }
                        else {
                            colibri.core.json.write(this._data, name, value, defValue);
                        }
                    }
                    read(name, defValue) {
                        // const defValue2 = this.getDefaultValue(name, defValue);
                        // const value = colibri.core.json.read(this._data, name, defValue2);
                        // return value;
                        if (this.isPrefabInstance()) {
                            const prefabValue = this.getDefaultValue(name, defValue);
                            if (this.isUnlocked(name)) {
                                return colibri.core.json.read(this._data, name, prefabValue);
                            }
                            return prefabValue;
                        }
                        return colibri.core.json.read(this._data, name, defValue);
                    }
                }
                json.Serializer = Serializer;
            })(json = core.json || (core.json = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            class SceneDataMigrationExtension extends colibri.Extension {
                static POINT_ID = "phasereditor2d.scene.ui.SceneDataMigrationExtension";
                constructor(priority) {
                    super(SceneDataMigrationExtension.POINT_ID, priority);
                }
            }
            ui.SceneDataMigrationExtension = SceneDataMigrationExtension;
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
///<reference path="../../ui/SceneDataMigrationExtension.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var migrations;
            (function (migrations) {
                class OriginMigration_v2_to_v3 extends scene.ui.SceneDataMigrationExtension {
                    migrate(data) {
                        const version = data.meta.version ?? 1;
                        if (version < 3) {
                            console.log("Migrating: unlock position by default");
                            this.migrateList(data.displayList);
                        }
                    }
                    migrateList(list) {
                        for (const obj of list) {
                            const serializer = new core.json.Serializer(obj);
                            const type = serializer.getType();
                            if (type === "Text" || type === "BitmapText") {
                                const origin = {
                                    originX: serializer.read("originX", 0.5),
                                    originY: serializer.read("originY", 0.5),
                                };
                                Object.assign(obj, origin);
                            }
                            if (obj.list) {
                                this.migrateList(obj.list);
                            }
                            if (obj.nestedPrefabs) {
                                this.migrateList(obj.nestedPrefabs);
                            }
                        }
                    }
                }
                migrations.OriginMigration_v2_to_v3 = OriginMigration_v2_to_v3;
            })(migrations = core.migrations || (core.migrations = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
///<reference path="../../ui/SceneDataMigrationExtension.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var migrations;
            (function (migrations) {
                class TextAlignMigration extends scene.ui.SceneDataMigrationExtension {
                    migrate(data) {
                        this.migrateList(data.displayList);
                    }
                    migrateList(list) {
                        for (const obj of list) {
                            if (obj.type === "Text") {
                                const objData = obj;
                                if (typeof objData.align === "number") {
                                    const alignProp = scene.ui.sceneobjects.TextComponent.align;
                                    objData.align = alignProp.values[objData.align] ?? alignProp.defValue;
                                    console.log(`Migrate Text align to ${objData.align} [${objData.id}]`);
                                }
                            }
                            if (obj.list) {
                                this.migrateList(obj.list);
                            }
                            if (obj.nestedPrefabs) {
                                this.migrateList(obj.nestedPrefabs);
                            }
                        }
                    }
                }
                migrations.TextAlignMigration = TextAlignMigration;
            })(migrations = core.migrations || (core.migrations = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
///<reference path="../../ui/SceneDataMigrationExtension.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var core;
        (function (core) {
            var migrations;
            (function (migrations) {
                class UnlockPositionMigration_v1_to_v2 extends scene.ui.SceneDataMigrationExtension {
                    migrate(data) {
                        const version = data.meta.version ?? 1;
                        if (version === 1) {
                            console.log("Migrating: unlock position by default");
                            this.migrateList(data.displayList);
                        }
                    }
                    migrateList(list) {
                        for (const obj of list) {
                            if (obj.prefabId) {
                                obj.unlock = obj.unlock ?? [];
                                obj.unlock.push("x", "y");
                            }
                            if (obj.list) {
                                this.migrateList(obj.list);
                            }
                        }
                    }
                }
                migrations.UnlockPositionMigration_v1_to_v2 = UnlockPositionMigration_v1_to_v2;
            })(migrations = core.migrations || (core.migrations = {}));
        })(core = scene.core || (scene.core = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            class BaseScene extends Phaser.Scene {
                _packCache;
                _maker;
                constructor(key) {
                    super(key);
                    this._packCache = new phasereditor2d.pack.core.parsers.AssetPackCache();
                    this._maker = this.createSceneMaker();
                }
                getPackCache() {
                    return this._packCache;
                }
                getMaker() {
                    return this._maker;
                }
                getCamera() {
                    return this.cameras.main;
                }
                destroyGame() {
                    if (this.game) {
                        // we need to start the loop so the game could be destroyed
                        // for checking if the game is destroyed, you can listen to Phaser.Core.Events.DESTROY.
                        this.game.loop.start(this.game.loop.callback);
                        this.game.destroy(true, false);
                    }
                }
            }
            ui.BaseScene = BaseScene;
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_6) {
        var ui;
        (function (ui) {
            class BaseSceneMaker {
                _packFinder;
                _scene;
                constructor(scene) {
                    this._packFinder = new phasereditor2d.pack.core.PackFinder();
                    this._scene = scene;
                }
                getPackFinder() {
                    return this._packFinder;
                }
                getScene() {
                    return this._scene;
                }
                async preload() {
                    await this.getPackFinder().preload();
                    const updaters = scene_6.ScenePlugin.getInstance().getLoaderUpdaters();
                    for (const updater of updaters) {
                        updater.clearCache(this._scene);
                    }
                }
            }
            ui.BaseSceneMaker = BaseSceneMaker;
        })(ui = scene_6.ui || (scene_6.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            Phaser.Cameras.Scene2D.Camera.prototype.getScreenPoint = function (worldX, worldY) {
                const x = (worldX - this.scrollX) * this.zoom;
                const y = (worldY - this.scrollY) * this.zoom;
                return new Phaser.Math.Vector2(x, y);
            };
            Phaser.Cameras.Scene2D.Camera.prototype.getWorldPoint2 = function (screenX, screenY) {
                const x = screenX / this.zoom + this.scrollX;
                const y = screenY / this.zoom + this.scrollY;
                return new Phaser.Math.Vector2(x, y);
            };
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            class CanvasManager {
                _freeCanvases;
                _count;
                constructor() {
                    this._freeCanvases = [];
                    this._count = 0;
                }
                takeCanvas() {
                    if (this._freeCanvases.length === 0) {
                        this._count++;
                        console.log("CanvasManager: create new canvas. Count new: " + this._count);
                        const canvas = document.createElement("canvas");
                        return canvas;
                    }
                    else {
                        console.log("CanvasManager: reuse canvas. Total available: " + (this._freeCanvases.length - 1));
                        return this._freeCanvases.pop();
                    }
                }
                releaseCanvas(canvas) {
                    if (this._freeCanvases.indexOf(canvas) < 0) {
                        console.log("CanvasManager: release canvas. Total available: " + (this._freeCanvases.length + 1));
                        this._freeCanvases.push(canvas);
                    }
                    else {
                        console.log("CanvasManager: Hey, releasing a released canvas?");
                    }
                }
            }
            ui.CanvasManager = CanvasManager;
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var controls = colibri.ui.controls;
            var io = colibri.core.io;
            class ManySceneFileSection extends controls.properties.PropertySection {
                constructor(page) {
                    super(page, "phasereditor2d.scene.ui.ManySceneFileSection", "Scene", true, false);
                }
                createForm(parent) {
                    const viewer = new phasereditor2d.files.ui.views.GridImageFileViewer();
                    const filteredViewer = new colibri.ui.ide.properties.FilteredViewerInPropertySection(this.getPage(), viewer, true);
                    parent.appendChild(filteredViewer.getElement());
                    this.addUpdater(() => {
                        viewer.setInput([]);
                        viewer.repaint();
                        viewer.setInput(this.getSelection());
                        filteredViewer.resizeTo();
                    });
                }
                canEdit(obj, n) {
                    return obj instanceof io.FilePath
                        && colibri.Platform.getWorkbench().getContentTypeRegistry()
                            .getCachedContentType(obj) === scene.core.CONTENT_TYPE_SCENE;
                }
                canEditNumber(n) {
                    return n > 1;
                }
            }
            ui.ManySceneFileSection = ManySceneFileSection;
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseScene.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_7) {
        var ui;
        (function (ui) {
            class Scene extends ui.BaseScene {
                static CURRENT_VERSION = 5;
                _id;
                _sceneType;
                _editor;
                _settings;
                _prefabProperties;
                _objectLists;
                _plainObjects;
                _codeSnippets;
                _version;
                constructor(editor) {
                    super("ObjectScene");
                    this._id = Phaser.Utils.String.UUID();
                    this._editor = editor;
                    this._settings = new scene_7.core.json.SceneSettings();
                    this._objectLists = new ui.sceneobjects.ObjectLists();
                    this._plainObjects = [];
                    this._codeSnippets = new ui.codesnippets.CodeSnippets();
                    this._prefabProperties = new ui.sceneobjects.PrefabUserProperties();
                    this._version = Scene.CURRENT_VERSION;
                }
                getVersion() {
                    return this._version;
                }
                setVersion(version) {
                    this._version = version;
                }
                sortObjectsByIndex(objects) {
                    const map = new Map();
                    this.buildSortingMap(map, this.getGameObjects(), 0);
                    objects.sort((a, b) => {
                        const aa = map.get(a);
                        const bb = map.get(b);
                        return aa - bb;
                    });
                }
                buildSortingMap(map, list, index) {
                    for (const obj of list) {
                        index++;
                        map.set(obj, index);
                        const objES = obj.getEditorSupport();
                        if (!objES.isPrefabInstance()) {
                            const children = objES.getObjectChildren();
                            index = this.buildSortingMap(map, children, index);
                        }
                    }
                    return index;
                }
                readPlainObjects(list) {
                    this._plainObjects = [];
                    for (const objData of list) {
                        this.readPlainObject(objData);
                    }
                }
                readPlainObject(objData) {
                    const ext = scene_7.ScenePlugin.getInstance().getPlainObjectExtensionByObjectType(objData.type);
                    if (ext) {
                        const plainObject = ext.createPlainObjectWithData({
                            scene: this,
                            data: objData
                        });
                        plainObject.getEditorSupport().readJSON(objData);
                        this.addPlainObject(plainObject);
                        return plainObject;
                    }
                    return undefined;
                }
                removePlainObjects(objects) {
                    const set = new Set(objects);
                    this._plainObjects = this._plainObjects.filter(obj => !set.has(obj));
                    for (const obj of set) {
                        obj.getEditorSupport().destroy();
                    }
                }
                getGameObjectIndex(obj) {
                    return this.children.getIndex(obj);
                }
                removeGameObject(obj) {
                    this.children.remove(obj);
                    if (obj instanceof ui.sceneobjects.ScriptNode) {
                        obj.setParent(undefined);
                    }
                }
                addGameObject(obj, skipCallback = false) {
                    this.children.add(obj, skipCallback);
                }
                addGameObjectAt(obj, index, skipCallback = false) {
                    this.children.addAt(obj, index, skipCallback);
                }
                getCodeSnippets() {
                    return this._codeSnippets;
                }
                addCodeSnippet(codeSnippet) {
                    this._codeSnippets.add(codeSnippet);
                }
                addPlainObject(obj) {
                    this._plainObjects.push(obj);
                }
                getPlainObjectById(id) {
                    return this.getPlainObjects().find(o => o.getEditorSupport().getId() === id);
                }
                getPlainObjects() {
                    return this._plainObjects;
                }
                getPlainObjectsByCategory(category) {
                    return this._plainObjects.filter(obj => obj.getEditorSupport()
                        .getExtension().getCategory() === category);
                }
                createSceneMaker() {
                    return new ui.SceneMaker(this);
                }
                getEditor() {
                    return this._editor;
                }
                registerDestroyListener(name) {
                    // console.log(name + ": register destroy listener.");
                    // this.game.events.on(Phaser.Core.Events.DESTROY, e => {
                    //     console.log(name + ": destroyed.");
                    // });
                }
                removeAll() {
                    this.sys.updateList.removeAll();
                    this.sys.displayList.removeAll();
                    // a hack to clean the whole scene
                    this.input["_list"].length = 0;
                    this.input["_pendingInsertion"].length = 0;
                    this.input["_pendingRemoval"].length = 0;
                    for (const obj of this.getGameObjects()) {
                        obj.getEditorSupport().destroy();
                    }
                }
                isScriptNodePrefabScene() {
                    if (this.isPrefabSceneType()) {
                        const obj = this.getPrefabObject();
                        if (obj) {
                            return obj instanceof ui.sceneobjects.ScriptNode;
                        }
                    }
                    return false;
                }
                getPrefabObject() {
                    if (this.sys.displayList) {
                        const list = this.getGameObjects();
                        return list[list.length - 1];
                    }
                    return undefined;
                }
                isNonTopPrefabObject(obj) {
                    const objES = ui.sceneobjects.GameObjectEditorSupport.getEditorSupport(obj);
                    if (objES) {
                        const scene = objES.getScene();
                        if (scene.isPrefabSceneType()) {
                            if (scene.getPrefabObject() !== obj) {
                                const parent = objES.getObjectParent();
                                if (parent) {
                                    return this.isNonTopPrefabObject(parent);
                                }
                                return true;
                            }
                        }
                    }
                    return false;
                }
                getObjectLists() {
                    return this._objectLists;
                }
                getSettings() {
                    return this._settings;
                }
                getPrefabUserProperties() {
                    return this._prefabProperties;
                }
                getId() {
                    return this._id;
                }
                setId(id) {
                    this._id = id;
                }
                getSceneType() {
                    return this._sceneType;
                }
                isPrefabSceneType() {
                    return this.getSceneType() === scene_7.core.json.SceneType.PREFAB;
                }
                setSceneType(sceneType) {
                    this._sceneType = sceneType;
                }
                isESModule() {
                    return this._settings.autoImport || this._settings.exportClass;
                }
                isTypeScriptOutput() {
                    return this._settings.compilerOutputLanguage === phasereditor2d.ide.core.code.SourceLang.TYPE_SCRIPT;
                }
                getMaker() {
                    return super.getMaker();
                }
                sortGameObjects() {
                    ui.sceneobjects.sortObjectsAlgorithm(this.getGameObjects(), 0);
                }
                getGameObjects() {
                    return this.sys.displayList.getChildren();
                }
                getInputSortedObjects() {
                    return this.getInputSortedObjects2([], this.getGameObjects());
                }
                getInputSortedObjects2(result, list) {
                    for (const obj of list) {
                        if (obj instanceof ui.sceneobjects.Container || obj instanceof ui.sceneobjects.Layer) {
                            if (obj.visible && obj.alpha > 0) {
                                this.getInputSortedObjects2(result, obj.getEditorSupport().getObjectChildren());
                            }
                        }
                        else {
                            result.push(obj);
                        }
                    }
                    return result;
                }
                visitAll(visitor) {
                    this.visit(visitor, this.getGameObjects());
                }
                visit(visitor, children) {
                    for (const obj of children) {
                        visitor(obj);
                        this.visit(visitor, obj.getEditorSupport().getObjectChildren());
                    }
                }
                visitAllAskChildren(visitor) {
                    this.visitAskChildren(visitor, this.getGameObjects());
                }
                visitAskChildren(visitor, children) {
                    for (const obj of children) {
                        const visitChildren = visitor(obj);
                        if (visitChildren) {
                            this.visitAskChildren(visitor, obj.getEditorSupport().getObjectChildren());
                        }
                    }
                }
                makeNewName(baseName) {
                    const nameMaker = this.createNameMaker();
                    return nameMaker.makeName(baseName);
                }
                createNameMaker() {
                    const nameMaker = new colibri.ui.ide.utils.NameMaker((obj) => {
                        const objES = ui.sceneobjects.EditorSupport.getEditorSupport(obj);
                        if (objES) {
                            return objES.getLabel();
                        }
                        return obj.getLabel();
                    });
                    this.visitAllAskChildren(obj => {
                        nameMaker.update([obj]);
                        const objES = obj.getEditorSupport();
                        return !objES.isPrefabInstance() || objES.isMutableNestedPrefabInstance()
                            || objES.isPrefeabInstanceAppendedChild;
                        ;
                    });
                    nameMaker.update(this._plainObjects);
                    for (const list of this._objectLists.getLists()) {
                        nameMaker.update([list]);
                    }
                    return nameMaker;
                }
                /**
                 * Map an object with its pre-order index. This can be used to sort objects.
                 */
                buildObjectSortingMap() {
                    const map = new Map();
                    this.buildObjectSortingMap2(map, this.getGameObjects());
                    return map;
                }
                sortObjectsByRenderingOrder(list) {
                    const map = this.buildObjectSortingMap();
                    list.sort((a, b) => {
                        const aa = map.get(a);
                        const bb = map.get(b);
                        return aa - bb;
                    });
                }
                buildObjectSortingMap2(map, list) {
                    let i = 0;
                    for (const obj of list) {
                        map.set(obj, i);
                        if (obj instanceof ui.sceneobjects.Container || obj instanceof ui.sceneobjects.Layer) {
                            i += this.buildObjectSortingMap2(map, obj.getEditorSupport().getObjectChildren());
                        }
                        i++;
                    }
                    return i;
                }
                buildObjectIdMap() {
                    const map = new Map();
                    this.visitAll(obj => {
                        map.set(obj.getEditorSupport().getId(), obj);
                    });
                    return map;
                }
                buildUserComponentIdMap() {
                    const map = new Map();
                    this.visitAll(obj => {
                        for (const node of obj.getEditorSupport().getUserComponentsComponent().getUserComponentNodes()) {
                            map.set(node.getId(), node);
                        }
                    });
                    return map;
                }
                snapPoint(x, y) {
                    if (this._settings.snapEnabled) {
                        return {
                            x: Math.round(x / this._settings.snapWidth) * this._settings.snapWidth,
                            y: Math.round(y / this._settings.snapHeight) * this._settings.snapHeight
                        };
                    }
                    return { x, y };
                }
                snapVector(vector) {
                    const result = this.snapPoint(vector.x, vector.y);
                    vector.set(result.x, result.y);
                }
                getByEditorId(id) {
                    const obj = Scene.findByEditorId(this.getGameObjects(), id);
                    return obj;
                }
                findByEditorLabel(label) {
                    const found = { obj: undefined };
                    this.visitAll(obj => {
                        const support = ui.sceneobjects.EditorSupport.getEditorSupport(obj);
                        if (support) {
                            if (support.getLabel() === label) {
                                found.obj = obj;
                            }
                        }
                    });
                    if (found.obj) {
                        return found.obj;
                    }
                    for (const objList of this.getObjectLists().getLists()) {
                        if (objList.getLabel() === label) {
                            return objList;
                        }
                    }
                    return undefined;
                }
                debugFindDuplicatedEditorId(list, set) {
                    set = set ?? new Set();
                    for (const obj of (list ?? this.getGameObjects())) {
                        const id = obj.getEditorSupport().getId();
                        if (set.has(id)) {
                            console.error("Duplicated " + obj.getEditorSupport().getLabel() + " id " + id);
                        }
                        else {
                            console.log("New " + obj.getEditorSupport().getLabel() + " id " + id);
                            set.add(id);
                        }
                        if (obj instanceof ui.sceneobjects.Container || obj instanceof ui.sceneobjects.Layer) {
                            this.debugFindDuplicatedEditorId(obj.list, set);
                        }
                    }
                }
                static findByEditorId(list, id) {
                    for (const obj of list) {
                        if (obj.getEditorSupport().getId() === id) {
                            return obj;
                        }
                        const result = this.findByEditorId(obj.getEditorSupport().getObjectChildren(), id);
                        if (result) {
                            return result;
                        }
                    }
                    return null;
                }
                create() {
                    this.registerDestroyListener("Scene");
                    if (this._editor) {
                        const camera = this.getCamera();
                        camera.setOrigin(0, 0);
                    }
                }
            }
            ui.Scene = Scene;
        })(ui = scene_7.ui || (scene_7.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./Scene.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_8) {
        var ui;
        (function (ui) {
            class OfflineScene extends ui.Scene {
                static async createScene(data) {
                    const promise = new Promise((resolve, reject) => {
                        const scene = new OfflineScene(data);
                        const canvasManager = scene_8.ScenePlugin.getInstance().getCanvasManager();
                        const canvas = canvasManager.takeCanvas();
                        scene.setCallback(() => {
                            resolve(scene);
                            canvasManager.releaseCanvas(canvas);
                        });
                        const game = new Phaser.Game({
                            type: Phaser.WEBGL,
                            canvas,
                            width: 1,
                            height: 1,
                            audio: {
                                noAudio: true,
                            },
                            physics: {
                                default: "arcade"
                            },
                            plugins: {
                                scene: [
                                    { key: "spine.SpinePlugin", plugin: spine.SpinePlugin, mapping: "spine" }
                                ]
                            },
                            scene: scene,
                        });
                    });
                    return promise;
                }
                _data;
                _callback;
                constructor(data) {
                    super();
                    this._data = data;
                }
                setCallback(callback) {
                    this._callback = callback;
                }
                async create() {
                    scene_8.ScenePlugin.getInstance().runSceneDataMigrations(this._data);
                    this.registerDestroyListener("OfflineScene");
                    const maker = this.getMaker();
                    await maker.preload();
                    await maker.updateSceneLoader(this._data);
                    maker.createScene(this._data);
                    this._callback();
                }
            }
            ui.OfflineScene = OfflineScene;
        })(ui = scene_8.ui || (scene_8.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var controls = colibri.ui.controls;
            var io = colibri.core.io;
            class SceneFileSection extends controls.properties.PropertySection {
                constructor(page) {
                    super(page, "phasereditor2d.scene.ui.SceneFileSection", "Scene", true, false);
                }
                createForm(parent) {
                    const imgControl = new controls.ImageControl();
                    this.getPage().eventControlLayout.addListener(() => {
                        imgControl.resizeTo();
                    });
                    parent.appendChild(imgControl.getElement());
                    this.addUpdater(async () => {
                        const file = this.getSelectionFirstElement();
                        const cache = ui.SceneThumbnailCache.getInstance();
                        await cache.preload(file);
                        const image = ui.SceneThumbnailCache.getInstance().getContent(file);
                        imgControl.setImage(image);
                        setTimeout(() => imgControl.resizeTo(), 1);
                    });
                }
                canEdit(obj, n) {
                    return obj instanceof io.FilePath
                        && colibri.Platform.getWorkbench().getContentTypeRegistry()
                            .getCachedContentType(obj) === scene.core.CONTENT_TYPE_SCENE;
                }
                canEditNumber(n) {
                    return n === 1;
                }
            }
            ui.SceneFileSection = SceneFileSection;
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseSceneMaker.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_9) {
        var ui;
        (function (ui) {
            var json = scene_9.core.json;
            var FileUtils = colibri.ui.ide.FileUtils;
            class SceneMaker extends ui.BaseSceneMaker {
                _editorScene;
                constructor(scene) {
                    super(scene);
                    this._editorScene = scene;
                }
                findDropScriptTargetParent(obj) {
                    // if (obj instanceof sceneobjects.ScriptNode) {
                    //     return obj;
                    // }
                    // const parent = obj.getEditorSupport().getObjectParent();
                    // const objES = obj.getEditorSupport();
                    // if (objES.isPrefabInstanceElement() && !objES.isMutableNestedPrefabInstance()) {
                    //     if (parent) {
                    //         return this.findDropTargetParent(parent);
                    //     }
                    //     return undefined;
                    // }
                    return obj;
                }
                findDropTargetParent(obj) {
                    const parent = obj.getEditorSupport().getObjectParent();
                    if (obj instanceof ui.sceneobjects.Container || obj instanceof ui.sceneobjects.Layer) {
                        const objES = obj.getEditorSupport();
                        if (objES.isPrefabInstanceElement() || objES.isPrefabInstance()) {
                            if (!objES.isAllowAppendChildren() || objES.isPrefabInstanceElement() && !objES.isMutableNestedPrefabInstance()) {
                                if (parent) {
                                    return this.findDropTargetParent(parent);
                                }
                                return undefined;
                            }
                        }
                        return obj;
                    }
                    if (parent) {
                        return this.findDropTargetParent(parent);
                    }
                    return undefined;
                }
                afterDropObjects(prefabObj, dropObjects, alternativeSelection) {
                    let dropInContainer;
                    let dropInObj;
                    const selection = alternativeSelection
                        || this._editorScene.getEditor().getSelectedGameObjects();
                    const areDroppingScriptNodes = dropObjects.filter(obj => obj instanceof ui.sceneobjects.ScriptNode).length === dropObjects.length;
                    for (const sprite of selection) {
                        const dropTarget = areDroppingScriptNodes ? this.findDropScriptTargetParent(sprite) : this.findDropTargetParent(sprite);
                        if (dropTarget) {
                            if (areDroppingScriptNodes) {
                                dropInObj = dropTarget;
                            }
                            else if (dropTarget instanceof ui.sceneobjects.Container) {
                                dropInContainer = dropTarget;
                            }
                            else if (dropTarget instanceof ui.sceneobjects.Layer) {
                                dropInObj = dropTarget;
                            }
                            else if (dropTarget.displayList instanceof ui.sceneobjects.Layer) {
                                dropInObj = dropTarget.displayList;
                            }
                        }
                    }
                    if (dropInContainer) {
                        for (const dropObj of dropObjects) {
                            if (dropObj instanceof ui.sceneobjects.Layer) {
                                continue;
                            }
                            if (dropObj.getEditorSupport().isDisplayObject()) {
                                const sprite = dropObj;
                                const p = new Phaser.Math.Vector2();
                                sprite.getWorldTransformMatrix().transformPoint(0, 0, p);
                                this._editorScene.removeGameObject(sprite);
                                dropInContainer.getEditorSupport().addObjectChild(sprite);
                                dropInContainer.getWorldTransformMatrix().applyInverse(p.x, p.y, p);
                                sprite.x = p.x;
                                sprite.y = p.y;
                            }
                            else {
                                dropInContainer.getEditorSupport().addObjectChild(dropObj);
                            }
                        }
                    }
                    else if (dropInObj) {
                        for (const obj of dropObjects) {
                            dropInObj.getEditorSupport().addObjectChild(obj);
                        }
                    }
                    else {
                        this.afterDropObjectsInPrefabScene(prefabObj, dropObjects);
                    }
                }
                afterDropObjectsInPrefabScene(prefabObj, sprites) {
                    if (!prefabObj) {
                        return;
                    }
                    const scene = prefabObj.getEditorSupport().getScene();
                    if (!scene.isPrefabSceneType()) {
                        return;
                    }
                    const dropOnlyScripts = sprites
                        .filter(obj => obj instanceof ui.sceneobjects.ScriptNode).length === sprites.length;
                    let parent;
                    if (scene.isPrefabSceneType()) {
                        if (sprites.length > 0) {
                            const prefabObjES = prefabObj.getEditorSupport();
                            if ((!prefabObjES.isPrefabInstance() || prefabObjES.isAllowAppendChildren())
                                && (prefabObj instanceof ui.sceneobjects.Container
                                    || prefabObj instanceof ui.sceneobjects.Layer
                                    || (dropOnlyScripts && prefabObj instanceof ui.sceneobjects.ScriptNode))) {
                                parent = prefabObj;
                            }
                            else {
                                [parent] = ui.sceneobjects.ContainerExtension.getInstance().createDefaultSceneObject({
                                    scene: scene,
                                    x: 0,
                                    y: 0
                                });
                                parent.getEditorSupport().setLabel(scene.makeNewName("container"));
                                scene.removeGameObject(prefabObj);
                                parent.getEditorSupport().addObjectChild(prefabObj);
                            }
                            if (parent) {
                                for (const sprite of sprites) {
                                    if (parent instanceof ui.sceneobjects.Container) {
                                        if (sprite.getEditorSupport().hasComponent(ui.sceneobjects.TransformComponent)) {
                                            sprite.x -= parent.x;
                                            sprite.y -= parent.y;
                                        }
                                    }
                                    scene.removeGameObject(sprite);
                                    const parentES = parent.getEditorSupport();
                                    parentES.addObjectChild(sprite);
                                }
                                if (parent !== prefabObj && parent instanceof ui.sceneobjects.Container) {
                                    parent.getEditorSupport().trim();
                                }
                            }
                        }
                    }
                }
                static acceptDropFile(dropFile, editorFile) {
                    if (dropFile.getFullName() === editorFile.getFullName()) {
                        return false;
                    }
                    const sceneFinder = scene_9.ScenePlugin.getInstance().getSceneFinder();
                    const sceneData = sceneFinder.getSceneData(dropFile);
                    if (sceneData) {
                        if (sceneData.sceneType !== scene_9.core.json.SceneType.PREFAB) {
                            return false;
                        }
                        if (sceneData.displayList.length === 0) {
                            return false;
                        }
                        const objData = sceneData.displayList[sceneData.displayList.length - 1];
                        if (objData.prefabId) {
                            const prefabFile = sceneFinder.getPrefabFile(objData.prefabId);
                            if (prefabFile) {
                                return this.acceptDropFile(prefabFile, editorFile);
                            }
                        }
                        return true;
                    }
                    return false;
                }
                static isValidSceneDataFormat(data) {
                    return "displayList" in data && Array.isArray(data.displayList);
                }
                async buildDependenciesHash() {
                    const builder = new phasereditor2d.ide.core.MultiHashBuilder();
                    for (const obj of this._editorScene.getGameObjects()) {
                        await obj.getEditorSupport().buildDependencyHash({ builder });
                    }
                    this._editorScene.getPackCache().buildAssetsDependenciesHash(builder);
                    const hash = builder.build();
                    return hash;
                }
                isPrefabFile(file) {
                    const ct = colibri.Platform.getWorkbench().getContentTypeRegistry().getCachedContentType(file);
                    if (ct === scene_9.core.CONTENT_TYPE_SCENE) {
                        const finder = scene_9.ScenePlugin.getInstance().getSceneFinder();
                        const data = finder.getSceneData(file);
                        return data && data.sceneType === json.SceneType.PREFAB;
                    }
                    return false;
                }
                async createPrefabInstanceWithFile(file) {
                    const content = await FileUtils.preloadAndGetFileString(file);
                    if (!content) {
                        return null;
                    }
                    try {
                        const prefabData = JSON.parse(content);
                        const obj = this.createObject({
                            id: Phaser.Utils.String.UUID(),
                            prefabId: prefabData.id,
                            label: "temporal"
                        });
                        const objES = obj.getEditorSupport();
                        if (objES.isUnlockedProperty(ui.sceneobjects.TransformComponent.x)) {
                            const { x, y } = this.getCanvasCenterPoint();
                            const sprite = obj;
                            sprite.x = x;
                            sprite.y = y;
                        }
                        return obj;
                    }
                    catch (e) {
                        console.error(e);
                        return null;
                    }
                }
                getSerializer(data) {
                    return new json.Serializer(data);
                }
                createScene(sceneData, errors) {
                    const version = sceneData.meta.version ?? 1;
                    this._editorScene.setVersion(version);
                    // if (version === 1) {
                    //     // old version, perform unlock x & y migration
                    //     new json.Version1ToVersion2Migration().migrate(sceneData);
                    // }
                    if (sceneData.settings) {
                        this._editorScene.getSettings().readJSON(sceneData.settings);
                    }
                    if (sceneData.lists) {
                        this._editorScene.getObjectLists().readJSON(sceneData);
                    }
                    if (sceneData.plainObjects) {
                        this._editorScene.readPlainObjects(sceneData.plainObjects);
                    }
                    if (sceneData.prefabProperties) {
                        this._editorScene.getPrefabUserProperties().readJSON(sceneData.prefabProperties);
                    }
                    if (sceneData.codeSnippets) {
                        this._editorScene.getCodeSnippets().readJSON(sceneData.codeSnippets);
                    }
                    this._editorScene.setSceneType(sceneData.sceneType || scene_9.core.json.SceneType.SCENE);
                    // removes this condition, it is used temporal for compatibility
                    this._editorScene.setId(sceneData.id);
                    for (const objData of sceneData.displayList) {
                        this.createObject(objData, errors);
                    }
                }
                async updateSceneLoader(sceneData, monitor) {
                    await this.updateLoaderWithData(sceneData.plainObjects, sceneData.displayList, monitor);
                }
                async updateLoaderWithData(plainObjects, displayObjects, monitor) {
                    const finder = new phasereditor2d.pack.core.PackFinder();
                    await finder.preload();
                    await this.updateSceneLoaderWithGameObjectDataList(finder, displayObjects, monitor);
                    await this.updateSceneLoaderWithPlainObjDataList(finder, plainObjects, monitor);
                }
                async updateSceneLoaderWithPlainObjDataList(finder, list, monitor) {
                    if (!list) {
                        return;
                    }
                    const assets = [];
                    for (const data of list) {
                        try {
                            const type = data.type;
                            const ext = scene_9.ScenePlugin.getInstance().getPlainObjectExtensionByObjectType(type);
                            if (ext) {
                                const result = await ext.getAssetsFromObjectData({
                                    scene: this._editorScene,
                                    finder,
                                    data
                                });
                                assets.push(...result);
                            }
                        }
                        catch (e) {
                            console.error(e);
                        }
                    }
                    await this.updateSceneLoaderWithAssets(assets, monitor);
                }
                async updateSceneLoaderWithGameObjectDataList(finder, list, monitor) {
                    const assets = [];
                    for (const objData of list) {
                        try {
                            const ser = this.getSerializer(objData);
                            const type = ser.getType();
                            const ext = scene_9.ScenePlugin.getInstance().getGameObjectExtensionByObjectType(type);
                            if (ext) {
                                const objAssets = await ext.getAssetsFromObjectData({
                                    serializer: ser,
                                    finder: finder,
                                    scene: this._editorScene
                                });
                                assets.push(...objAssets);
                            }
                        }
                        catch (e) {
                            console.error(e);
                        }
                    }
                    await this.updateSceneLoaderWithAssets(assets, monitor);
                }
                async updateSceneLoaderWithAssets(assets, monitor) {
                    if (monitor) {
                        monitor.addTotal(assets.length);
                    }
                    for (const asset of assets) {
                        const updater = scene_9.ScenePlugin.getInstance().getLoaderUpdaterForAsset(asset);
                        if (updater) {
                            await updater.updateLoader(this._editorScene, asset);
                            if (monitor) {
                                monitor.step();
                            }
                        }
                    }
                }
                getCanvasCenterPoint() {
                    const canvas = this._editorScene.game.canvas;
                    let x = canvas.width / 2;
                    let y = canvas.height / 2;
                    const worldPoint = this._editorScene.getCamera().getWorldPoint(x, y);
                    x = Math.floor(worldPoint.x);
                    y = Math.floor(worldPoint.y);
                    return { x, y };
                }
                createDefaultObject(ext, extraData, x, y) {
                    if (x === undefined) {
                        const point = this.getCanvasCenterPoint();
                        x = point.x;
                        y = point.y;
                    }
                    const newObjects = ext.createDefaultSceneObject({
                        scene: this._editorScene,
                        x,
                        y,
                        extraData
                    });
                    const nameMaker = this._editorScene.createNameMaker();
                    for (const newObject of newObjects) {
                        const oldLabel = newObject.getEditorSupport().getLabel();
                        const newLabel = nameMaker.makeName(oldLabel);
                        newObject.getEditorSupport().setLabel(newLabel);
                    }
                    return newObjects;
                }
                createObject(data, errors, parent) {
                    try {
                        const ser = this.getSerializer(data);
                        const type = ser.getType();
                        const ext = scene_9.ScenePlugin.getInstance().getGameObjectExtensionByObjectType(type);
                        if (ext) {
                            const sprite = ext.createGameObjectWithData({
                                data: data,
                                parent,
                                scene: this._editorScene
                            });
                            return sprite;
                        }
                        else {
                            const msg = `SceneMaker: no extension is registered for type "${type}".`;
                            if (errors) {
                                errors.push(msg);
                            }
                            console.error(msg);
                        }
                        return null;
                    }
                    catch (e) {
                        const msg = e.message;
                        if (errors) {
                            errors.push(msg);
                        }
                        console.error(e);
                        return null;
                    }
                }
            }
            ui.SceneMaker = SceneMaker;
        })(ui = scene_9.ui || (scene_9.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var controls = colibri.ui.controls;
            var core = colibri.core;
            const localForage = window["localforage"];
            class ThumbnailCache extends core.io.ContentCache {
                _database;
                async clearCache() {
                    await this._database?.clear();
                }
                constructor(dbName) {
                    super(async (file, force) => {
                        this._database = localForage.createInstance({
                            name: dbName,
                            driver: localForage.INDEXEDDB
                        });
                        const db = this._database;
                        const objKey = this.computeObjectKey(file);
                        const imageKey = objKey + "@image";
                        const hashKey = objKey + "@modTime";
                        const currentHash = this.computeObjectHash(file);
                        if (!force) {
                            try {
                                const blob = await db.getItem(imageKey);
                                const savedFileTime = await db.getItem(hashKey);
                                if (blob) {
                                    if (currentHash === savedFileTime) {
                                        const imgElement = controls.Controls.createImageFromBlob(blob);
                                        await new Promise((resolver, reject) => {
                                            imgElement.addEventListener("load", () => resolver(undefined));
                                        });
                                        return new controls.ImageWrapper(imgElement);
                                    }
                                }
                            }
                            catch (error) {
                                console.log(error);
                            }
                        }
                        const image = this.createObjectImage(file);
                        await image.preload();
                        const element = image.getImageElement();
                        if (element) {
                            const newBlob = await controls.Controls.createBlobFromImage(element);
                            db.setItem(imageKey, newBlob);
                            db.setItem(hashKey, currentHash);
                        }
                        return Promise.resolve(image);
                    });
                }
            }
            ui.ThumbnailCache = ThumbnailCache;
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./ThumbnailCache.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            const localForage = window["localforage"];
            class SceneThumbnailCache extends ui.ThumbnailCache {
                static _instance;
                static getInstance() {
                    if (!this._instance) {
                        this._instance = new SceneThumbnailCache();
                    }
                    return this._instance;
                }
                constructor() {
                    super("phasereditor2d.scene.ui.SceneThumbnailCache");
                }
                createObjectImage(obj) {
                    return new ui.SceneThumbnailImage(obj);
                }
                computeObjectHash(obj) {
                    return obj.getModTime().toString();
                }
                computeObjectKey(obj) {
                    return obj.getFullName();
                }
            }
            ui.SceneThumbnailCache = SceneThumbnailCache;
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_10) {
        var ui;
        (function (ui) {
            var controls = colibri.ui.controls;
            var ide = colibri.ui.ide;
            var io = colibri.core.io;
            class ThumbnailScene extends ui.Scene {
                _data;
                _callback;
                constructor(data, callback) {
                    super();
                    if (data.sceneType === scene_10.core.json.SceneType.PREFAB) {
                        if (data.displayList.length > 1) {
                            data.displayList.splice(0, data.displayList.length - 1);
                        }
                    }
                    this._data = data;
                    this._callback = callback;
                }
                async create() {
                    this.registerDestroyListener("ThumbnailScene");
                    const maker = this.getMaker();
                    await maker.preload();
                    await maker.updateSceneLoader(this._data);
                    maker.createScene(this._data);
                    const children = this.getGameObjects();
                    let singleObject;
                    const s = this.getSettings();
                    if (this.isPrefabSceneType()) {
                        singleObject = this.getPrefabObject();
                    }
                    else if (children.length === 1) {
                        singleObject = children[0];
                    }
                    if (singleObject) {
                        if (singleObject instanceof ui.sceneobjects.Container || singleObject instanceof ui.sceneobjects.Layer) {
                            const container = singleObject;
                            this.breakContainers([container]);
                        }
                        else if (singleObject.getEditorSupport().hasComponent(ui.sceneobjects.OriginComponent)) {
                            const sprite = singleObject;
                            sprite.setOrigin(0.5, 0.5);
                            sprite.setPosition(s.borderX + s.borderWidth / 2, s.borderY + s.borderHeight / 2);
                        }
                        else {
                            const sprite = singleObject;
                            const displayOriginX = sprite.displayWidth * sprite.originX;
                            const displayOriginY = sprite.displayHeight * sprite.originY;
                            const spriteCX = sprite.displayWidth / 2;
                            const spriteCY = sprite.displayHeight / 2;
                            const dx = spriteCX - displayOriginX;
                            const dy = spriteCY - displayOriginY;
                            const cx = s.borderX + s.borderWidth / 2 + dx;
                            const cy = s.borderY + s.borderHeight / 2 + dy;
                            if (sprite.setPosition) {
                                sprite.setPosition(cx, cy);
                            }
                        }
                    }
                    else {
                        this.breakContainers(children);
                    }
                    let bounds = this.computeSceneBounds();
                    if (!singleObject && (bounds.width > s.borderWidth || bounds.height > s.borderHeight)) {
                        bounds = {
                            x: s.borderX,
                            y: s.borderY,
                            width: s.borderWidth,
                            height: s.borderHeight
                        };
                    }
                    else {
                        for (const child of children) {
                            const obj = child;
                            if ("x" in obj) {
                                if (bounds.x < 0) {
                                    obj.x += Math.abs(bounds.x);
                                }
                                if (bounds.y < 0) {
                                    obj.y += Math.abs(bounds.y);
                                }
                            }
                        }
                        if (bounds.x < 0) {
                            bounds.x = 0;
                        }
                        if (bounds.y < 0) {
                            bounds.y = 0;
                        }
                        if (bounds.width <= 0) {
                            bounds.width = 800;
                        }
                        if (bounds.height <= 0) {
                            bounds.height = 600;
                        }
                    }
                    this.sys.renderer.snapshotArea(bounds.x, bounds.y, bounds.width, bounds.height, (img) => {
                        this._callback(img);
                        this.destroyGame();
                    });
                }
                breakContainers(list) {
                    for (const obj of list) {
                        if (obj instanceof ui.sceneobjects.Container || obj instanceof ui.sceneobjects.Layer) {
                            if (!obj.visible || obj.alpha === 0) {
                                obj.destroy();
                                continue;
                            }
                        }
                        if (obj instanceof ui.sceneobjects.Container) {
                            ui.sceneobjects.BreakParentOperation.breakParent(this, [obj]);
                            this.breakContainers(obj.list);
                        }
                    }
                }
                computeSceneBounds() {
                    const children = this.getGameObjects().filter(obj => obj.getEditorSupport().isDisplayObject());
                    if (children.length === 0) {
                        return { x: 0, y: 0, width: 10, height: 10 };
                    }
                    const camera = this.getCamera();
                    let minX = Number.MAX_SAFE_INTEGER;
                    let minY = Number.MAX_SAFE_INTEGER;
                    let maxX = Number.MIN_SAFE_INTEGER;
                    let maxY = Number.MIN_SAFE_INTEGER;
                    for (const obj of children) {
                        const points = obj.getEditorSupport().getScreenBounds(camera);
                        for (const point of points) {
                            minX = Math.min(minX, point.x);
                            minY = Math.min(minY, point.y);
                            maxX = Math.max(maxX, point.x);
                            maxY = Math.max(maxY, point.y);
                        }
                    }
                    return {
                        x: Math.floor(minX),
                        y: Math.floor(minY),
                        width: Math.floor(maxX - minX),
                        height: Math.floor(maxY - minY)
                    };
                }
            }
            class SceneThumbnailImage {
                _file;
                _data;
                _image;
                _promise;
                constructor(file) {
                    if (file instanceof io.FilePath) {
                        this._file = file;
                    }
                    else {
                        this._data = file;
                    }
                    this._image = null;
                }
                paint(context, x, y, w, h, center) {
                    if (this._image) {
                        this._image.paint(context, x, y, w, h, center);
                    }
                }
                paintFrame(context, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH) {
                    if (this._image) {
                        this._image.paintFrame(context, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);
                    }
                }
                getWidth() {
                    return this._image ? this._image.getWidth() : 16;
                }
                getHeight() {
                    return this._image ? this._image.getHeight() : 16;
                }
                preloadSize() {
                    return this.preload();
                }
                async preload() {
                    if (this._image == null) {
                        if (this._promise) {
                            return this._promise;
                        }
                        this._promise = this.preloadData()
                            .then(() => this.createImageElement())
                            .then(imageElement => {
                            this._image = new controls.ImageWrapper(imageElement);
                            this._promise = null;
                            return controls.PreloadResult.RESOURCES_LOADED;
                        });
                        return this._promise;
                    }
                    return controls.Controls.resolveNothingLoaded();
                }
                async preloadData() {
                    if (this._file) {
                        return ide.FileUtils.preloadFileString(this._file);
                    }
                    return controls.Controls.resolveResourceLoaded();
                }
                getImageElement() {
                    if (this._image) {
                        return this._image.getImageElement();
                    }
                    return null;
                }
                static _canvas;
                createImageElement() {
                    return new Promise((resolve, reject) => {
                        let data;
                        if (this._file) {
                            const content = ide.FileUtils.getFileString(this._file);
                            data = JSON.parse(content);
                        }
                        else {
                            data = this._data;
                        }
                        scene_10.ScenePlugin.getInstance().runSceneDataMigrations(data);
                        // const width = data.settings.borderWidth || 800;
                        // const height = data.settings.borderHeight || 600;
                        const width = 1920;
                        const height = 1080;
                        let canvas;
                        if (SceneThumbnailImage._canvas) {
                            canvas = SceneThumbnailImage._canvas;
                        }
                        else {
                            canvas = document.createElement("canvas");
                            canvas.style.width = (canvas.width = width) + "px";
                            canvas.style.height = (canvas.height = height) + "px";
                            SceneThumbnailImage._canvas = canvas;
                            const parent = document.createElement("div");
                            parent.style.position = "fixed";
                            parent.style.left = -width - 10 + "px";
                            parent.appendChild(canvas);
                            document.body.appendChild(parent);
                        }
                        const game = new Phaser.Game({
                            type: scene_10.ScenePlugin.DEFAULT_CANVAS_CONTEXT,
                            canvas: canvas,
                            parent: null,
                            width: width,
                            height: height,
                            scale: {
                                mode: Phaser.Scale.NONE
                            },
                            render: {
                                pixelArt: scene_10.ScenePlugin.DEFAULT_PIXEL_ART,
                                transparent: true
                            },
                            audio: {
                                noAudio: true
                            },
                            physics: {
                                default: "arcade"
                            },
                            plugins: {
                                scene: [
                                    { key: "spine.SpinePlugin", plugin: spine.SpinePlugin, mapping: "spine" }
                                ]
                            },
                        });
                        const scene = new ThumbnailScene(data, image => {
                            resolve(image);
                            scene.destroyGame();
                        });
                        game.scene.add("scene", scene, true);
                    });
                }
            }
            ui.SceneThumbnailImage = SceneThumbnailImage;
        })(ui = scene_10.ui || (scene_10.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            class SpineThumbnailCache extends ui.ThumbnailCache {
                constructor() {
                    super("phasereditor2d.scene.ui.SpineThumbnailCache");
                }
                createObjectImage(obj) {
                    return scene.ScenePlugin.getInstance().buildSpineSkinThumbnailImage(obj);
                }
                computeObjectHash(obj) {
                    return obj.computeHash();
                }
                computeObjectKey(obj) {
                    const { spineAsset, spineAtlasAsset, skinName } = obj;
                    return spineAsset.getPack().getFile().getFullName()
                        + "+" + spineAsset.getKey()
                        + "+" + spineAtlasAsset.getKey()
                        + "+" + skinName;
                }
            }
            ui.SpineThumbnailCache = SpineThumbnailCache;
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var blocks;
            (function (blocks) {
                var controls = colibri.ui.controls;
                class SceneEditorBlocksCellRendererProvider extends phasereditor2d.pack.ui.viewers.AssetPackCellRendererProvider {
                    constructor() {
                        super("grid");
                    }
                    getCellRenderer(element) {
                        if (scene.SCENE_OBJECT_CATEGORY_SET.has(element)) {
                            return new controls.viewers.IconImageCellRenderer(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                        }
                        if (element instanceof colibri.core.io.FilePath && scene.ScenePlugin.getInstance().isSceneContentType(element)) {
                            if (scene.ScenePlugin.getInstance().getSceneFinder().isScriptPrefabFile(element)) {
                                return new colibri.ui.controls.viewers.IconGridCellRenderer(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_BUILD));
                            }
                            return new ui.viewers.SceneFileCellRenderer();
                        }
                        else if (element instanceof ui.sceneobjects.SceneObjectExtension) {
                            return new ui.viewers.ObjectExtensionCellRendererProvider().getCellRenderer(element);
                        }
                        else if (element === ui.sceneobjects.ObjectList) {
                            return new controls.viewers.IconImageCellRenderer(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_LIST));
                        }
                        else if (typeof (element) === "string" && blocks.BLOCKS_SECTIONS.indexOf(element) >= 0) {
                            return new controls.viewers.IconImageCellRenderer(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                        }
                        else if (element instanceof ui.viewers.PhaserTypeSymbol) {
                            return new controls.viewers.IconImageCellRenderer(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                        }
                        else if (element instanceof phasereditor2d.pack.core.AnimationConfigInPackItem) {
                            return new phasereditor2d.pack.ui.viewers.AnimationConfigCellRenderer("square");
                        }
                        return super.getCellRenderer(element);
                    }
                }
                blocks.SceneEditorBlocksCellRendererProvider = SceneEditorBlocksCellRendererProvider;
            })(blocks = ui.blocks || (ui.blocks = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var blocks;
            (function (blocks) {
                var io = colibri.core.io;
                const SCENE_EDITOR_BLOCKS_PACK_ITEM_TYPES = new Set([
                    phasereditor2d.pack.core.IMAGE_TYPE,
                    phasereditor2d.pack.core.SVG_TYPE,
                    phasereditor2d.pack.core.ATLAS_TYPE,
                    phasereditor2d.pack.core.ATLAS_XML_TYPE,
                    phasereditor2d.pack.core.MULTI_ATLAS_TYPE,
                    phasereditor2d.pack.core.UNITY_ATLAS_TYPE,
                    phasereditor2d.pack.core.SPRITESHEET_TYPE,
                    phasereditor2d.pack.core.ANIMATION_TYPE,
                    phasereditor2d.pack.core.ASEPRITE_TYPE,
                    phasereditor2d.pack.core.BITMAP_FONT_TYPE,
                    phasereditor2d.pack.core.SPINE_JSON_TYPE,
                    phasereditor2d.pack.core.SPINE_BINARY_TYPE,
                ]);
                const grouping = phasereditor2d.pack.ui.viewers.AssetPackGrouping;
                class SceneEditorBlocksContentProvider extends phasereditor2d.pack.ui.viewers.AssetPackContentProvider {
                    _getPacks;
                    _blocksProvider;
                    _editor;
                    _scriptsContentProvider;
                    constructor(editor, getPacks) {
                        super();
                        this._blocksProvider = editor.getBlocksProvider();
                        this._getPacks = getPacks;
                        this._editor = this._blocksProvider.getEditor();
                        this._scriptsContentProvider = new ui.sceneobjects.ScriptsContentProvider();
                    }
                    getPackItems() {
                        return this._getPacks()
                            .flatMap(pack => pack.getItems())
                            .filter(item => SCENE_EDITOR_BLOCKS_PACK_ITEM_TYPES.has(item.getType()));
                    }
                    isScriptNodePrefabScene() {
                        return this._editor.getScene().isScriptNodePrefabScene();
                    }
                    getRoots(input) {
                        if (this.isScriptNodePrefabScene()) {
                            return this._scriptsContentProvider.getRoots(input);
                        }
                        const groupingType = grouping.getGroupingPreference();
                        const section = this._blocksProvider.getSelectedTabSection();
                        switch (section) {
                            case blocks.TAB_SECTION_BUILT_IN:
                                return scene.SCENE_OBJECT_CATEGORIES;
                            case blocks.TAB_SECTION_PREFABS:
                                if (groupingType === grouping.GROUP_ASSETS_BY_LOCATION) {
                                    const files = colibri.ui.ide.FileUtils.distinct(this.getPrefabFiles("prefabs").map(f => f.getParent()));
                                    return files;
                                }
                                return ui.viewers.PhaserTypeSymbol.getSymbols();
                        }
                        switch (groupingType) {
                            case grouping.GROUP_ASSETS_BY_TYPE:
                                if (section === blocks.TAB_SECTION_ASSETS) {
                                    return blocks.BLOCKS_ASSET_SECTIONS;
                                }
                                return blocks.BLOCKS_SECTIONS;
                            case grouping.GROUP_ASSETS_BY_PACK:
                                if (section === blocks.TAB_SECTION_ASSETS) {
                                    return this._getPacks();
                                }
                                return [
                                    blocks.BUILTIN_SECTION,
                                    blocks.PREFAB_SECTION,
                                    ...this._getPacks()
                                ];
                            case grouping.GROUP_ASSETS_BY_LOCATION:
                                const packFolders = grouping.getAssetsFolders(this._getPacks());
                                if (section === blocks.TAB_SECTION_ASSETS) {
                                    return packFolders;
                                }
                                return [
                                    blocks.BUILTIN_SECTION,
                                    ...colibri.ui.ide.FileUtils.distinct([
                                        ...this.getPrefabFiles().map(f => f.getParent()),
                                        ...packFolders
                                    ])
                                ];
                        }
                        return [];
                    }
                    getPrefabFiles(sceneType = "prefabs") {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        let files = [];
                        switch (sceneType) {
                            case "prefabs":
                                files = finder.getPrefabFiles().filter(f => !finder.isScriptPrefabFile(f));
                                break;
                            case "scripts":
                                files = finder.getPrefabFiles().filter(f => finder.isScriptPrefabFile(f));
                                break;
                        }
                        files = files.filter(file => ui.SceneMaker.acceptDropFile(file, this._editor.getInput()));
                        return files;
                    }
                    getChildren(parent) {
                        if (this.isScriptNodePrefabScene()) {
                            return this._scriptsContentProvider.getChildren(parent);
                        }
                        if (parent instanceof ui.viewers.PhaserTypeSymbol) {
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            return this.getPrefabFiles().filter(file => finder.getScenePhaserType(file) === parent.getPhaserType());
                        }
                        if (parent instanceof phasereditor2d.pack.core.AssetPack) {
                            return parent.getItems().filter(i => SCENE_EDITOR_BLOCKS_PACK_ITEM_TYPES.has(i.getType()));
                        }
                        if (parent instanceof phasereditor2d.pack.core.BaseAnimationsAssetPackItem) {
                            return parent.getAnimations();
                        }
                        if (typeof (parent) === "string") {
                            if (scene.SCENE_OBJECT_CATEGORY_SET.has(parent)) {
                                const isPrefabScene = this._editor.getScene() && this._editor.getScene().isPrefabSceneType();
                                const exts = [
                                    ...scene.ScenePlugin.getInstance().getGameObjectExtensions(),
                                    ...scene.ScenePlugin.getInstance().getPlainObjectExtensions()
                                ]
                                    .filter(ext => !isPrefabScene || ext.isAvailableAsPrefabElement())
                                    .filter(ext => ext.getCategory() === parent);
                                return [
                                    ...exts,
                                    ...(parent === scene.SCENE_OBJECT_GROUPING_CATEGORY ? [ui.sceneobjects.ObjectList] : [])
                                ];
                            }
                            switch (parent) {
                                case phasereditor2d.pack.core.ATLAS_TYPE:
                                    return this.getPackItems()
                                        .filter(item => item instanceof phasereditor2d.pack.core.BaseAtlasAssetPackItem);
                                case phasereditor2d.pack.core.BITMAP_FONT_TYPE:
                                    return this.getPackItems()
                                        .filter(item => item instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem);
                                case phasereditor2d.pack.core.ANIMATION_TYPE:
                                    return this.getPackItems()
                                        .filter(item => item instanceof phasereditor2d.pack.core.BaseAnimationsAssetPackItem);
                                case blocks.BUILTIN_SECTION:
                                    return scene.SCENE_OBJECT_CATEGORIES;
                                case blocks.PREFAB_SECTION:
                                    const files = this.getPrefabFiles();
                                    return files;
                            }
                            return this.getPackItems()
                                .filter(item => item.getType() === parent);
                        }
                        if (parent instanceof io.FilePath && parent.isFolder()) {
                            const tabSection = this._editor.getBlocksProvider().getSelectedTabSection();
                            if (tabSection === blocks.TAB_SECTION_PREFABS) {
                                return this.getPrefabFiles("prefabs").filter(f => f.getParent() === parent);
                            }
                            const scenes = this.getPrefabFiles().filter(f => f.getParent() === parent);
                            const items = this.getPackItems().filter(item => grouping.getItemFolder(item) === parent);
                            return [...scenes, ...items];
                        }
                        if (parent instanceof phasereditor2d.pack.core.SpineAssetPackItem) {
                            return parent.getGuessSkinItems();
                        }
                        return super.getChildren(parent);
                    }
                }
                blocks.SceneEditorBlocksContentProvider = SceneEditorBlocksContentProvider;
            })(blocks = ui.blocks || (ui.blocks = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var blocks;
            (function (blocks) {
                var core = colibri.core;
                var code = phasereditor2d.ide.core.code;
                class SceneEditorBlocksLabelProvider extends phasereditor2d.pack.ui.viewers.AssetPackLabelProvider {
                    getLabel(obj) {
                        if (obj instanceof core.io.FilePath) {
                            if (obj.isFolder() && code.isNodeLibraryFile(obj)) {
                                return code.findNodeModuleName(obj);
                            }
                            return ui.sceneobjects.getSceneDisplayName(obj);
                        }
                        else if (obj instanceof ui.sceneobjects.SceneObjectExtension) {
                            return obj.getTypeName();
                        }
                        else if (obj === ui.sceneobjects.ObjectList) {
                            return "List";
                        }
                        else if (obj instanceof ui.viewers.PhaserTypeSymbol) {
                            return obj.getDisplayName();
                        }
                        return super.getLabel(obj);
                    }
                }
                blocks.SceneEditorBlocksLabelProvider = SceneEditorBlocksLabelProvider;
            })(blocks = ui.blocks || (ui.blocks = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var blocks;
            (function (blocks) {
                class SceneEditorBlocksPropertyProvider extends phasereditor2d.pack.ui.properties.AssetPackPreviewPropertyProvider {
                    addSections(page, sections) {
                        super.addSections(page, sections);
                        sections.push(new ui.sceneobjects.ObjectTypeDocSection(page), new ui.sceneobjects.ObjectListDocSection(page));
                    }
                }
                blocks.SceneEditorBlocksPropertyProvider = SceneEditorBlocksPropertyProvider;
            })(blocks = ui.blocks || (ui.blocks = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var blocks;
            (function (blocks) {
                var ide = colibri.ui.ide;
                blocks.TAB_SECTION_BUILT_IN = "Built-In";
                blocks.TAB_SECTION_PREFABS = "Prefabs";
                blocks.TAB_SECTION_ASSETS = "Assets";
                blocks.TAB_SECTIONS = [
                    blocks.TAB_SECTION_BUILT_IN,
                    blocks.TAB_SECTION_PREFABS,
                    blocks.TAB_SECTION_ASSETS,
                ];
                class SceneEditorBlocksProvider extends ide.EditorViewerProvider {
                    _editor;
                    _packs;
                    constructor(editor) {
                        super();
                        this._editor = editor;
                        this._packs = [];
                    }
                    getEditor() {
                        return this._editor;
                    }
                    allowsTabSections() {
                        return true;
                    }
                    getTabSections() {
                        return blocks.TAB_SECTIONS;
                    }
                    fillContextMenu(menu) {
                        phasereditor2d.pack.ui.viewers.AssetPackGrouping.fillMenu(menu, () => this.repaint(true));
                    }
                    async preload(complete) {
                        let finder;
                        if (this._editor.getScene() && !complete) {
                            finder = this._editor.getSceneMaker().getPackFinder();
                        }
                        else {
                            finder = new phasereditor2d.pack.core.PackFinder();
                            await finder.preload();
                        }
                        this._packs = finder.getPacks();
                    }
                    prepareViewerState(state) {
                        if (state.expandedObjects) {
                            state.expandedObjects = this.getFreshItems(state.expandedObjects);
                        }
                        if (state.selectedObjects) {
                            state.selectedObjects = this.getFreshItems(state.selectedObjects);
                        }
                    }
                    getFreshItems(items) {
                        const set = new Set();
                        for (const obj of items) {
                            if (obj instanceof phasereditor2d.pack.core.AssetPack) {
                                const pack = this._packs.find(p => p.getFile() === obj.getFile());
                                if (pack) {
                                    set.add(pack);
                                }
                            }
                            else if (obj instanceof phasereditor2d.pack.core.AssetPackItem) {
                                const item = this.getFreshItem(obj);
                                if (item) {
                                    set.add(item);
                                }
                            }
                            else if (obj instanceof phasereditor2d.pack.core.AssetPackImageFrame) {
                                const item = this.getFreshItem(obj.getPackItem());
                                if (item instanceof phasereditor2d.pack.core.ImageFrameContainerAssetPackItem) {
                                    const frame = item.findFrame(obj.getName());
                                    if (frame) {
                                        set.add(frame);
                                    }
                                }
                            }
                            else if (obj instanceof phasereditor2d.pack.core.SpineSkinItem) {
                                const item = this.getFreshItem(obj.spineAsset);
                                if (item && item instanceof phasereditor2d.pack.core.SpineAssetPackItem) {
                                    const skins = item.getGuessSkinItems();
                                    const newName = skins.find(n => n.skinName === obj.skinName);
                                    if (newName) {
                                        set.add(newName);
                                    }
                                }
                            }
                            else if (obj instanceof phasereditor2d.pack.core.AnimationConfigInPackItem) {
                                const item = this.getFreshItem(obj.getParent());
                                if (item) {
                                    const found = item.getAnimations().find(a => a.getKey() === obj.getKey());
                                    if (found) {
                                        set.add(found);
                                    }
                                }
                            }
                            else {
                                set.add(obj);
                            }
                        }
                        return set;
                    }
                    getFreshItem(item) {
                        const freshPack = this._packs.find(pack => pack.getFile() === item.getPack().getFile());
                        const finder = new phasereditor2d.pack.core.PackFinder(freshPack);
                        return finder.findAssetPackItem(item.getKey());
                    }
                    getContentProvider() {
                        return new blocks.SceneEditorBlocksContentProvider(this._editor, () => this._packs);
                    }
                    getLabelProvider() {
                        return new blocks.SceneEditorBlocksLabelProvider();
                    }
                    getStyledLabelProvider() {
                        return new blocks.SceneEditorBlocksStyledLabelProvider(this._editor);
                    }
                    getCellRendererProvider() {
                        return new blocks.SceneEditorBlocksCellRendererProvider();
                    }
                    getTreeViewerRenderer(viewer) {
                        // TODO: we should implements the Favorites section
                        return new blocks.SceneEditorBlocksTreeRendererProvider(this, viewer);
                    }
                    getUndoManager() {
                        return this._editor.getUndoManager();
                    }
                    getPropertySectionProvider() {
                        return new blocks.SceneEditorBlocksPropertyProvider();
                    }
                    getInput() {
                        return this;
                    }
                }
                blocks.SceneEditorBlocksProvider = SceneEditorBlocksProvider;
            })(blocks = ui.blocks || (ui.blocks = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var blocks;
            (function (blocks) {
                class SceneEditorBlocksStyledLabelProvider extends blocks.SceneEditorBlocksLabelProvider {
                    _scriptsLabelProvider = new ui.sceneobjects.ScriptStyledLabelProvider();
                    _editor;
                    constructor(editor) {
                        super();
                        this._editor = editor;
                    }
                    getStyledTexts(obj, dark) {
                        if (this._editor.getScene().isScriptNodePrefabScene()) {
                            return this._scriptsLabelProvider.getStyledTexts(obj, dark);
                        }
                        const text = super.getLabel(obj);
                        const isPrefab = obj instanceof colibri.core.io.FilePath
                            && scene.ScenePlugin.getInstance().getSceneFinder().isPrefabFile(obj);
                        return [{
                                text,
                                color: isPrefab ? scene.ScenePlugin.getInstance().getPrefabColor()
                                    : colibri.ui.controls.Controls.getTheme().viewerForeground
                            }];
                    }
                }
                blocks.SceneEditorBlocksStyledLabelProvider = SceneEditorBlocksStyledLabelProvider;
            })(blocks = ui.blocks || (ui.blocks = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var blocks;
            (function (blocks) {
                var io = colibri.core.io;
                blocks.BUILTIN_SECTION = "Built-In";
                blocks.PREFAB_SECTION = "Prefab";
                blocks.BLOCKS_ASSET_SECTIONS = [
                    phasereditor2d.pack.core.IMAGE_TYPE,
                    phasereditor2d.pack.core.SVG_TYPE,
                    phasereditor2d.pack.core.ATLAS_TYPE,
                    phasereditor2d.pack.core.SPRITESHEET_TYPE,
                    phasereditor2d.pack.core.ANIMATION_TYPE,
                    phasereditor2d.pack.core.BITMAP_FONT_TYPE,
                    phasereditor2d.pack.core.SPINE_JSON_TYPE,
                    phasereditor2d.pack.core.SPINE_BINARY_TYPE
                ];
                blocks.BLOCKS_SECTIONS = [
                    blocks.BUILTIN_SECTION,
                    blocks.PREFAB_SECTION,
                    ...blocks.BLOCKS_ASSET_SECTIONS
                ];
                class SceneEditorBlocksTreeRendererProvider extends phasereditor2d.pack.ui.viewers.AssetPackTreeViewerRenderer {
                    _blocksProvider;
                    constructor(provider, viewer) {
                        super(viewer, false);
                        this._blocksProvider = provider;
                    }
                    isObjectSection(obj) {
                        if (typeof obj === "string") {
                            if (this._blocksProvider.getSelectedTabSection() === blocks.TAB_SECTION_BUILT_IN
                                && scene.SCENE_OBJECT_CATEGORIES.indexOf(obj) >= 0) {
                                return true;
                            }
                            if (blocks.BLOCKS_SECTIONS.indexOf(obj) >= 0) {
                                return true;
                            }
                        }
                        return obj instanceof phasereditor2d.pack.core.AssetPack
                            || obj instanceof io.FilePath && obj.isFolder() || obj instanceof ui.viewers.PhaserTypeSymbol;
                    }
                    isShadowAsChild(obj) {
                        if (this._blocksProvider.getSelectedTabSection() === blocks.TAB_SECTION_BUILT_IN) {
                            return false;
                        }
                        if (obj instanceof ui.sceneobjects.SceneObjectExtension || obj === ui.sceneobjects.ObjectList) {
                            return true;
                        }
                        if (obj instanceof phasereditor2d.pack.core.SpineSkinItem) {
                            return true;
                        }
                        if (obj instanceof phasereditor2d.pack.core.AnimationConfigInPackItem) {
                            return true;
                        }
                        return super.isShadowAsChild(obj);
                    }
                    isSectionSorted(section) {
                        if (section === blocks.BUILTIN_SECTION) {
                            return false;
                        }
                        return true;
                    }
                }
                blocks.SceneEditorBlocksTreeRendererProvider = SceneEditorBlocksTreeRendererProvider;
            })(blocks = ui.blocks || (ui.blocks = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var codesnippets;
            (function (codesnippets) {
                class CodeSnippet {
                    _type;
                    _id;
                    constructor(type) {
                        this._type = type;
                        this._id = Phaser.Utils.String.UUID();
                    }
                    getId() {
                        return this._id;
                    }
                    getType() {
                        return this._type;
                    }
                    writeJSON(data) {
                        data.type = this._type;
                        data.id = this._id;
                    }
                    readJSON(data) {
                        this._id = data.id;
                    }
                }
                codesnippets.CodeSnippet = CodeSnippet;
            })(codesnippets = ui.codesnippets || (ui.codesnippets = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var codesnippets;
            (function (codesnippets) {
                class CodeSnippetExtension extends colibri.Extension {
                    static POINT_ID = "phasereditor2d.scene.ui.codesnippets.CodeSnippetExtension";
                    _name;
                    _type;
                    constructor(type, name) {
                        super(CodeSnippetExtension.POINT_ID);
                        this._type = type;
                        this._name = name;
                    }
                    getType() {
                        return this._type;
                    }
                    getName() {
                        return this._name;
                    }
                }
                codesnippets.CodeSnippetExtension = CodeSnippetExtension;
            })(codesnippets = ui.codesnippets || (ui.codesnippets = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_1) {
                var undo;
                (function (undo) {
                    var ide = colibri.ui.ide;
                    class SceneEditorOperation extends ide.undo.Operation {
                        _editor;
                        constructor(editor) {
                            super();
                            this._editor = editor;
                        }
                        getEditor() {
                            return this._editor;
                        }
                        getScene() {
                            return this._editor.getScene();
                        }
                    }
                    undo.SceneEditorOperation = SceneEditorOperation;
                })(undo = editor_1.undo || (editor_1.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../editor/undo/SceneEditorOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_11) {
        var ui;
        (function (ui) {
            var codesnippets;
            (function (codesnippets) {
                class CodeSnippetsSnapshotOperation extends ui.editor.undo.SceneEditorOperation {
                    _before;
                    _after;
                    _operation;
                    constructor(editor, operation) {
                        super(editor);
                        this._operation = operation;
                    }
                    async execute() {
                        this._before = this.takeSnapshot();
                        await this.performModification();
                        this._after = this.takeSnapshot();
                        this._editor.setDirty(true);
                        this._editor.refreshOutline();
                        this._editor.repaint();
                        this._editor.dispatchSelectionChanged();
                    }
                    async performModification() {
                        if (this._operation) {
                            await this._operation();
                        }
                    }
                    takeSnapshot() {
                        const scene = this.getScene();
                        return {
                            selection: this.getEditor().getSelectedCodeSnippets().map(s => s.getId()),
                            codeSnippets: scene.getCodeSnippets().toJSON()
                        };
                    }
                    loadSnapshot(snapshot) {
                        const editor = this.getEditor();
                        const scene = this.getScene();
                        scene.getCodeSnippets().readJSON(snapshot.codeSnippets);
                        editor.setDirty(true);
                        editor.repaint();
                        editor.refreshOutline();
                        editor.getSelectionManager().setSelectionByIds(snapshot.selection);
                    }
                    undo() {
                        this.loadSnapshot(this._before);
                    }
                    redo() {
                        this.loadSnapshot(this._after);
                    }
                }
                codesnippets.CodeSnippetsSnapshotOperation = CodeSnippetsSnapshotOperation;
            })(codesnippets = ui.codesnippets || (ui.codesnippets = {}));
        })(ui = scene_11.ui || (scene_11.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./CodeSnippetsSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var codesnippets;
            (function (codesnippets) {
                class CodeSnippetOrderOperation extends codesnippets.CodeSnippetsSnapshotOperation {
                    _depthMove;
                    constructor(editor, depthMove) {
                        super(editor);
                        this._depthMove = depthMove;
                    }
                    static allow(editor, move) {
                        // sort the selection and filter off non-game-objects
                        let sel = this.sortedSelection(editor);
                        // if the sorted selection contains all the selected objects
                        if (sel.length !== editor.getSelection().length) {
                            return false;
                        }
                        const siblings = editor.getScene().getCodeSnippets().getSnippets();
                        for (const obj of sel) {
                            const index = siblings.indexOf(obj);
                            let bottomIndex = 0;
                            const len = siblings.length;
                            if (move === "Bottom" || move === "Down") {
                                if (index === len - 1) {
                                    return false;
                                }
                            }
                            else { // Top || Up
                                if (index === bottomIndex) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    async performModification() {
                        const editor = this.getEditor();
                        const sel = CodeSnippetOrderOperation.sortedSelection(editor);
                        const siblings = editor.getScene().getCodeSnippets().getSnippets();
                        switch (this._depthMove) {
                            case "Bottom":
                                for (const obj of sel) {
                                    Phaser.Utils.Array.BringToTop(siblings, obj);
                                }
                                break;
                            case "Top":
                                for (let i = 0; i < sel.length; i++) {
                                    const obj = sel[sel.length - i - 1];
                                    Phaser.Utils.Array.SendToBack(siblings, obj);
                                }
                                break;
                            case "Down":
                                for (let i = 0; i < sel.length; i++) {
                                    const obj = sel[sel.length - i - 1];
                                    Phaser.Utils.Array.MoveUp(siblings, obj);
                                }
                                break;
                            case "Up":
                                for (const obj of sel) {
                                    Phaser.Utils.Array.MoveDown(siblings, obj);
                                }
                                break;
                        }
                        this.getEditor().repaint();
                    }
                    static sortedSelection(editor) {
                        const sel = editor.getSelectedCodeSnippets();
                        const siblings = editor.getScene().getCodeSnippets().getSnippets();
                        sel.sort((a, b) => {
                            const aa = siblings.indexOf(a);
                            const bb = siblings.indexOf(b);
                            return aa - bb;
                        });
                        return sel;
                    }
                }
                codesnippets.CodeSnippetOrderOperation = CodeSnippetOrderOperation;
            })(codesnippets = ui.codesnippets || (ui.codesnippets = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var codesnippets;
            (function (codesnippets) {
                class CodeSnippets {
                    _list = [];
                    add(snippet) {
                        this._list.push(snippet);
                    }
                    removeByIds(ids) {
                        const removeSet = new Set(ids);
                        this._list = this._list.filter(s => !removeSet.has(s.getId()));
                    }
                    getSnippets() {
                        return this._list;
                    }
                    readJSON(codeSnippets) {
                        this._list = [];
                        for (const snippetData of codeSnippets) {
                            const ext = scene.ScenePlugin.getInstance().getCodeSnippetExtensionByType(snippetData.type);
                            if (ext) {
                                const snippet = ext.createEmptyCodeSnippet();
                                snippet.readJSON(snippetData);
                                this.add(snippet);
                            }
                        }
                    }
                    toJSON() {
                        const result = [];
                        for (const snippet of this._list) {
                            const data = {};
                            snippet.writeJSON(data);
                            result.push(data);
                        }
                        return result;
                    }
                }
                codesnippets.CodeSnippets = CodeSnippets;
            })(codesnippets = ui.codesnippets || (ui.codesnippets = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var codesnippets;
            (function (codesnippets) {
                class CreateFromAsepriteCodeSnippet extends codesnippets.CodeSnippet {
                    assetKey;
                    constructor() {
                        super(codesnippets.CreateFromAsepriteCodeSnippetExtension.TYPE);
                    }
                    buildCodeDOM() {
                        const dom = new scene.core.code.MethodCallCodeDOM("createFromAseprite", "this.anims");
                        dom.argLiteral(this.assetKey);
                        return [dom];
                    }
                    getDisplayName() {
                        return `${this.assetKey} - anims.createFromAseprite`;
                    }
                    writeJSON(data) {
                        super.writeJSON(data);
                        data.key = this.assetKey;
                    }
                    readJSON(data) {
                        super.readJSON(data);
                        this.assetKey = data.key;
                    }
                }
                codesnippets.CreateFromAsepriteCodeSnippet = CreateFromAsepriteCodeSnippet;
            })(codesnippets = ui.codesnippets || (ui.codesnippets = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var codesnippets;
            (function (codesnippets) {
                class CreateFromAsepriteCodeSnippetExtension extends codesnippets.CodeSnippetExtension {
                    static TYPE = "animsCreateFromAseprite";
                    constructor() {
                        super(CreateFromAsepriteCodeSnippetExtension.TYPE, "Create Animations From Aseprite");
                    }
                    isEnabledFor(_editor) {
                        return !_editor.getScene().isPrefabSceneType();
                    }
                    createEmptyCodeSnippet() {
                        return new codesnippets.CreateFromAsepriteCodeSnippet();
                    }
                    async createAndConfigureCodeSnippets() {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        const input = finder.getAssets()
                            .filter(i => i instanceof phasereditor2d.pack.core.AsepriteAssetPackItem);
                        const dlg = new phasereditor2d.pack.ui.dialogs.AssetSelectionDialog("tree", false);
                        dlg.create();
                        dlg.setTitle("Select Aseprite File Key");
                        dlg.getViewer().setInput(input);
                        const result = await dlg.getResultPromise();
                        const snippets = (result || []).map(a => {
                            const snippet = new codesnippets.CreateFromAsepriteCodeSnippet();
                            snippet.assetKey = a.getKey();
                            return snippet;
                        });
                        return snippets;
                    }
                }
                codesnippets.CreateFromAsepriteCodeSnippetExtension = CreateFromAsepriteCodeSnippetExtension;
            })(codesnippets = ui.codesnippets || (ui.codesnippets = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    var controls = colibri.ui.controls;
                    class BaseSceneSection extends controls.properties.PropertySection {
                        getHelp(key) {
                            return "";
                        }
                        getSectionHelpPath() {
                            return undefined;
                        }
                        createMenu(menu) {
                            const path = this.getSectionHelpPath();
                            if (path) {
                                phasereditor2d.ide.IDEPlugin.getInstance().createHelpMenuItem(menu, path);
                            }
                        }
                        hasMenu() {
                            return true;
                        }
                        createToolMenuItem(menu, toolId) {
                            const manager = this.getEditor().getToolsManager();
                            const tool = manager.findTool(toolId);
                            menu.addCommand(tool.getCommandId(), {
                                selected: tool === manager.getActiveTool()
                            });
                        }
                        getEditor() {
                            return colibri.Platform.getWorkbench()
                                .getActiveWindow().getEditorArea()
                                .getSelectedEditor();
                        }
                        getUndoManager() {
                            return this.getEditor().getUndoManager();
                        }
                    }
                    properties.BaseSceneSection = BaseSceneSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../editor/properties/BaseSceneSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var codesnippets;
            (function (codesnippets) {
                var controls = colibri.ui.controls;
                class CreateFromAsepriteCodeSnippetSection extends ui.editor.properties.BaseSceneSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.codesnippets.CreateFromAsepriteCodeSnippetSection", "Create From Aseprite");
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 3);
                        comp.style.gridTemplateColumns = "auto 1fr auto";
                        this.createLabel(comp, "Aseprite File Key", "The Aseprite animations file key.");
                        {
                            const text = this.createText(comp, false);
                            this.addUpdater(() => {
                                text.value = this.getSelectionFirstElement().assetKey;
                            });
                        }
                        const btnUI = this.createButtonDialog({
                            dialogTittle: "Select Animation File Key",
                            createDialogViewer: async (revealValue) => {
                                const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.CreateFromAsepriteCodeSnippetSection." + this.getId());
                                viewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider(e => new phasereditor2d.pack.ui.viewers.AnimationsItemCellRenderer()));
                                viewer.setLabelProvider(new phasereditor2d.pack.ui.viewers.AssetPackLabelProvider());
                                viewer.setTreeRenderer(new controls.viewers.TreeViewerRenderer(viewer));
                                viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                                const finder = new phasereditor2d.pack.core.PackFinder();
                                await finder.preload();
                                const assetItems = finder
                                    .getAssets(i => i instanceof phasereditor2d.pack.core.AsepriteAssetPackItem);
                                viewer.setInput(assetItems);
                                viewer.revealAndSelect(assetItems.find(a => a.getKey() === revealValue));
                                return viewer;
                            },
                            getValue: () => {
                                return this.getSelectionFirstElement().assetKey || "";
                            },
                            onValueSelected: (value) => {
                                this.getEditor().getUndoManager().add(new codesnippets.CodeSnippetsSnapshotOperation(this.getEditor(), async () => {
                                    this.getSelectionFirstElement().assetKey = value;
                                }));
                            },
                            dialogElementToString: (viewer, value) => {
                                return value.getKey();
                            }
                        });
                        comp.appendChild(btnUI.buttonElement);
                    }
                    canEdit(obj, n) {
                        return obj instanceof codesnippets.CreateFromAsepriteCodeSnippet;
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                codesnippets.CreateFromAsepriteCodeSnippetSection = CreateFromAsepriteCodeSnippetSection;
            })(codesnippets = ui.codesnippets || (ui.codesnippets = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var dialogs;
            (function (dialogs) {
                var controls = colibri.ui.controls;
                class AbstractAddPrefabPropertyDialog extends controls.dialogs.ViewerDialog {
                    constructor() {
                        super(new UserPropertyTypesViewer(), false);
                        this.setSize(300, 400, true);
                    }
                    create(hideParentDialog) {
                        super.create(hideParentDialog);
                        this.setTitle("Add Property");
                        this.enableButtonOnlyWhenOneElementIsSelected(this.addOpenButton("Add Property", sel => {
                            this.addProperty(sel[0]);
                        }));
                        this.addCancelButton();
                    }
                }
                dialogs.AbstractAddPrefabPropertyDialog = AbstractAddPrefabPropertyDialog;
                class UserPropertyTypesViewer extends controls.viewers.TreeViewer {
                    constructor() {
                        super("phasereditor2d.scene.ui.dialogs.UserPropertyTypesViewer");
                        this.setLabelProvider(new UserPropertyTypeLabelProvider());
                        this.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        this.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider());
                        this.setInput(scene.ScenePlugin.getInstance().getUserPropertyTypes());
                    }
                }
                class UserPropertyTypeLabelProvider {
                    getLabel(obj) {
                        return `${obj.getName()} Property`;
                    }
                }
            })(dialogs = ui.dialogs || (ui.dialogs = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var dialogs;
            (function (dialogs) {
                var controls = colibri.ui.controls;
                class AddObjectDialog extends controls.dialogs.ViewerDialog {
                    static createViewer(editor) {
                        const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.dialogs.AddObjectDialog");
                        viewer.setContentProvider(new AddObjectContentProvider(editor));
                        viewer.setLabelProvider(new ui.blocks.SceneEditorBlocksLabelProvider());
                        viewer.setStyledLabelProvider(new ui.blocks.SceneEditorBlocksStyledLabelProvider(editor));
                        viewer.setCellRendererProvider(new ui.blocks.SceneEditorBlocksCellRendererProvider());
                        viewer.setInput([]);
                        viewer.expandRoots(true);
                        return viewer;
                    }
                    _editor;
                    constructor(editor) {
                        super(AddObjectDialog.createViewer(editor), true);
                        this._editor = editor;
                    }
                    create() {
                        super.create();
                        this.setTitle("Add Object");
                        const addButton = this.addButton("Add Object", () => {
                            const obj = this.getViewer().getSelectionFirstElement();
                            this._editor.getDropManager().dropDataAtCenter([obj]);
                            this.close();
                        });
                        const filter = obj => scene.SCENE_OBJECT_CATEGORIES.indexOf(obj) < 0;
                        this.enableButtonOnlyWhenOneElementIsSelected(addButton, filter);
                        this.getViewer().setExpandWhenOpenParentItem();
                        this.getViewer().eventOpenItem.addListener(obj => {
                            if (filter(obj)) {
                                addButton.click();
                            }
                        });
                        this.addCancelButton();
                    }
                }
                dialogs.AddObjectDialog = AddObjectDialog;
                class AddObjectContentProvider extends ui.blocks.SceneEditorBlocksContentProvider {
                    constructor(editor) {
                        super(editor, () => []);
                    }
                    getRoots(input) {
                        if (this._editor.getScene().isScriptNodePrefabScene()) {
                            return [ui.sceneobjects.ScriptNodeExtension.getInstance()];
                        }
                        return scene.SCENE_OBJECT_CATEGORIES;
                    }
                }
            })(dialogs = ui.dialogs || (ui.dialogs = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./AbstractAddPrefabPropertyDialog.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var dialogs;
            (function (dialogs) {
                class AddPrefabPropertyDialog extends dialogs.AbstractAddPrefabPropertyDialog {
                    addProperty(propType) {
                        const editor = colibri.Platform.getWorkbench().getActiveEditor();
                        ui.editor.properties.ChangePrefabPropertiesOperation.runPropertiesOperation(editor, (props) => {
                            const prop = props.createProperty(propType);
                            props.add(prop);
                            editor.setSelection([prop]);
                        });
                    }
                }
                dialogs.AddPrefabPropertyDialog = AddPrefabPropertyDialog;
            })(dialogs = ui.dialogs || (ui.dialogs = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var dialogs;
            (function (dialogs) {
                class NewPrefabFileDialogExtension extends phasereditor2d.files.ui.dialogs.NewFileContentExtension {
                    getCreatePrefabFileContentFunc(displayList) {
                        return (args) => {
                            const settings = scene.ScenePlugin.getInstance().getDefaultSceneSettings();
                            const sceneData = {
                                id: Phaser.Utils.String.UUID(),
                                settings: {
                                    createMethodName: "",
                                    preloadMethodName: "",
                                    compilerOutputLanguage: settings.compilerOutputLanguage,
                                    exportClass: settings.exportClass,
                                    autoImport: settings.autoImport,
                                    generateAwakeHandler: false,
                                    compilerInsertSpaces: settings.compilerInsertSpaces,
                                    compilerTabSize: settings.compilerTabSize,
                                    borderWidth: settings.borderWidth,
                                    borderHeight: settings.borderHeight,
                                    borderX: settings.borderX,
                                    borderY: settings.borderY,
                                },
                                sceneType: scene.core.json.SceneType.PREFAB,
                                displayList,
                                meta: {
                                    app: "Phaser Editor 2D - Scene Editor",
                                    url: "https://phasereditor2d.com",
                                    contentType: scene.core.CONTENT_TYPE_SCENE
                                }
                            };
                            return JSON.stringify(sceneData, null, 4);
                        };
                    }
                    getCreateFileContentFunc() {
                        return this.getCreatePrefabFileContentFunc([]);
                    }
                    constructor() {
                        super({
                            dialogName: "Prefab File",
                            dialogIconDescriptor: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_GROUP),
                            fileExtension: "scene",
                            initialFileName: "Prefab"
                        });
                    }
                    getInitialFileLocation() {
                        return super.findInitialFileLocationBasedOnContentType(scene.core.CONTENT_TYPE_SCENE);
                    }
                }
                dialogs.NewPrefabFileDialogExtension = NewPrefabFileDialogExtension;
            })(dialogs = ui.dialogs || (ui.dialogs = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var dialogs;
            (function (dialogs) {
                class NewPrefabFileFromObjectDialogExtension extends dialogs.NewPrefabFileDialogExtension {
                    _objectData;
                    constructor(objectData) {
                        super();
                        this._objectData = objectData;
                    }
                    getCreateFileContentFunc() {
                        return this.getCreatePrefabFileContentFunc([this._objectData]);
                    }
                }
                dialogs.NewPrefabFileFromObjectDialogExtension = NewPrefabFileFromObjectDialogExtension;
            })(dialogs = ui.dialogs || (ui.dialogs = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var dialogs;
            (function (dialogs) {
                class NewSceneFileDialogExtension extends phasereditor2d.files.ui.dialogs.NewFileContentExtension {
                    constructor() {
                        super({
                            dialogName: "Scene File",
                            dialogIconDescriptor: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_GROUP),
                            fileExtension: "scene",
                            initialFileName: "Scene"
                        });
                        this.setCreatedCallback(file => this.compileTypeScriptFile(file));
                    }
                    compileTypeScriptFile(file) {
                        console.log(`Compiling scene ${file.getName()}`);
                        scene.core.code.SceneCompileAllExtension.compileSceneFile(file);
                    }
                    getCreateFileContentFunc() {
                        return (args) => {
                            let name = args.fileName;
                            const i = name.lastIndexOf(".");
                            if (i > 0) {
                                name = name.substring(0, i);
                            }
                            const settings = scene.ScenePlugin.getInstance().getDefaultSceneSettings();
                            const sceneData = {
                                id: Phaser.Utils.String.UUID(),
                                settings: {
                                    compilerOutputLanguage: settings.compilerOutputLanguage,
                                    javaScriptInitFieldsInConstructor: settings.javaScriptInitFieldsInConstructor,
                                    exportClass: settings.exportClass,
                                    autoImport: settings.autoImport,
                                    createMethodName: "editorCreate",
                                    compilerInsertSpaces: settings.compilerInsertSpaces,
                                    compilerTabSize: settings.compilerTabSize,
                                    borderWidth: settings.borderWidth,
                                    borderHeight: settings.borderHeight,
                                    borderX: settings.borderX,
                                    borderY: settings.borderY,
                                    sceneKey: name,
                                },
                                sceneType: scene.core.json.SceneType.SCENE,
                                displayList: [],
                                meta: {
                                    app: "Phaser Editor 2D - Scene Editor",
                                    url: "https://phasereditor2d.com",
                                    contentType: scene.core.CONTENT_TYPE_SCENE
                                }
                            };
                            return JSON.stringify(sceneData, null, 2);
                        };
                    }
                    getInitialFileLocation() {
                        return super.findInitialFileLocationBasedOnContentType(scene.core.CONTENT_TYPE_SCENE);
                    }
                }
                dialogs.NewSceneFileDialogExtension = NewSceneFileDialogExtension;
            })(dialogs = ui.dialogs || (ui.dialogs = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var dialogs;
            (function (dialogs) {
                class NewUserComponentsFileDialogExtension extends phasereditor2d.files.ui.dialogs.NewFileContentExtension {
                    constructor() {
                        super({
                            dialogName: "User Components File",
                            dialogIconDescriptor: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_USER_COMPONENT),
                            fileExtension: "components",
                            initialFileName: "Behaviors"
                        });
                    }
                    getCreateFileContentFunc() {
                        return (args) => {
                            let name = args.fileName;
                            const i = name.lastIndexOf(".");
                            if (i > 0) {
                                name = name.substring(0, i);
                            }
                            const model = new ui.editor.usercomponent.UserComponentsModel();
                            const sceneSettings = scene.ScenePlugin.getInstance().getDefaultSceneSettings();
                            model.insertSpaces = sceneSettings.compilerInsertSpaces;
                            model.javaScriptInitFieldsInConstructor = sceneSettings.javaScriptInitFieldsInConstructor;
                            model.tabSize = sceneSettings.compilerTabSize;
                            model.outputLang = sceneSettings.compilerOutputLanguage;
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            const models = [...finder.getUserComponentsModels()];
                            if (models.length > 0) {
                                models.sort((a, b) => a.file.getModTime() - b.file.getModTime());
                                const lastModel = models[models.length - 1];
                                model.outputLang = lastModel.model.outputLang;
                                model.tabSize = lastModel.model.tabSize;
                                model.insertSpaces = lastModel.model.insertSpaces;
                            }
                            const data = model.toJSON();
                            return JSON.stringify(data, null, 2);
                        };
                    }
                    getInitialFileLocation() {
                        return super.findInitialFileLocationBasedOnContentType(scene.core.CONTENT_TYPE_USER_COMPONENTS);
                    }
                }
                dialogs.NewUserComponentsFileDialogExtension = NewUserComponentsFileDialogExtension;
            })(dialogs = ui.dialogs || (ui.dialogs = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var dialogs;
            (function (dialogs) {
                var controls = colibri.ui.controls;
                var io = colibri.core.io;
                const grouping = phasereditor2d.pack.ui.viewers.AssetPackGrouping;
                class OpenSceneFileDialog extends controls.dialogs.ViewerDialog {
                    constructor() {
                        super(new controls.viewers.TreeViewer("phasereditor2d.scene.ui.dialogs.OpenSceneFileDialog"), true);
                        this.setSize(900, 500, true);
                    }
                    create() {
                        super.create();
                        this.setTitle("Go To Scene");
                        const viewer = this.getViewer();
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        viewer.setContentProvider(new ContentProvider(finder));
                        viewer.setLabelProvider(new ui.blocks.SceneEditorBlocksLabelProvider());
                        viewer.setCellRendererProvider(new ui.blocks.SceneEditorBlocksCellRendererProvider());
                        viewer.setTreeRenderer(new TreeRenderer(viewer));
                        viewer.setInput([]);
                        viewer.expandRoots();
                        this.enableButtonOnlyWhenOneElementIsSelected(this.addOpenButton("Open", () => {
                            colibri.Platform.getWorkbench().openEditor(viewer.getSelectionFirstElement());
                        }));
                        this.getFilteredViewer().setMenuProvider(new controls.viewers.DefaultViewerMenuProvider((viewer1, menu) => {
                            const currentType = getSceneGroupingPreference();
                            for (const type of [grouping.GROUP_ASSETS_BY_TYPE, grouping.GROUP_ASSETS_BY_LOCATION]) {
                                menu.addAction({
                                    text: "Group By " + grouping.GROUP_ASSET_TYPE_LABEL_MAP[type],
                                    selected: type === currentType,
                                    callback: () => {
                                        setSceneGroupingPreference(type);
                                        viewer.setScrollY(0);
                                        viewer.expandRoots();
                                    }
                                });
                            }
                        }));
                    }
                }
                dialogs.OpenSceneFileDialog = OpenSceneFileDialog;
                function getSceneGroupingPreference() {
                    return window.localStorage["phasereditor2d.scene.ui.dialogs.OpenSceneFileDialog.groupingType"] || grouping.GROUP_ASSETS_BY_TYPE;
                }
                function setSceneGroupingPreference(type) {
                    window.localStorage["phasereditor2d.scene.ui.dialogs.OpenSceneFileDialog.groupingType"] = type;
                }
                class TreeRenderer extends controls.viewers.GridTreeViewerRenderer {
                    constructor(viewer) {
                        super(viewer);
                        this.setPaintItemShadow(true);
                        this.setSectionCriteria(obj => typeof obj === "string"
                            || obj instanceof io.FilePath && obj.isFolder() || obj instanceof ui.viewers.PhaserTypeSymbol);
                    }
                }
                class ContentProvider {
                    finder;
                    constructor(finder) {
                        this.finder = finder;
                    }
                    getRoots(input) {
                        const type = getSceneGroupingPreference();
                        if (type === grouping.GROUP_ASSETS_BY_TYPE) {
                            return ui.viewers.PhaserTypeSymbol.getSymbols().filter(s => this.getChildren(s).length > 0);
                        }
                        return colibri.ui.ide.FileUtils.distinct(this.finder.getSceneFiles().map(f => f.getParent()));
                    }
                    getChildren(parent) {
                        if (parent instanceof ui.viewers.PhaserTypeSymbol) {
                            return this.finder.getSceneFiles()
                                .filter(file => this.finder.getScenePhaserType(file) === parent.getPhaserType());
                        }
                        if (parent instanceof io.FilePath && parent.isFolder()) {
                            return this.finder.getSceneFiles().filter(f => f.getParent() === parent);
                        }
                        return [];
                    }
                }
            })(dialogs = ui.dialogs || (ui.dialogs = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var controls = colibri.ui.controls;
                class BaseOverlayLayer {
                    _canvas;
                    _ctx;
                    _loading;
                    constructor() {
                        this._canvas = document.createElement("canvas");
                        this._canvas.style.position = "absolute";
                    }
                    setLoading(loading) {
                        this._loading = loading;
                    }
                    isLoading() {
                        return this._loading;
                    }
                    createLoadingMonitor() {
                        return new controls.CanvasProgressMonitor(this.getCanvas());
                    }
                    getCanvas() {
                        return this._canvas;
                    }
                    resetContext() {
                        this._ctx = this._canvas.getContext("2d");
                        controls.Controls.adjustCanvasDPI(this._canvas);
                        this._ctx.imageSmoothingEnabled = false;
                        this._ctx.font = "12px Monospace";
                    }
                    resizeTo() {
                        const parent = this._canvas.parentElement;
                        this._canvas.width = Math.floor(parent.clientWidth);
                        this._canvas.height = Math.floor(parent.clientHeight);
                        this._canvas.style.width = this._canvas.width + "px";
                        this._canvas.style.height = this._canvas.height + "px";
                        this.resetContext();
                    }
                    render() {
                        if (!this._ctx) {
                            this.resetContext();
                        }
                        if (!this._loading) {
                            const canvasWidth = this.getCanvas().width;
                            const canvasHeight = this.getCanvas().height;
                            this._ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                            this.renderLayer();
                        }
                    }
                    getContext() {
                        return this._ctx;
                    }
                }
                editor.BaseOverlayLayer = BaseOverlayLayer;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_12) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_2) {
                var controls = colibri.ui.controls;
                class CameraManager {
                    _editor;
                    _dragStartPoint;
                    _dragStartCameraScroll;
                    _state;
                    constructor(editor) {
                        this._editor = editor;
                        this._dragStartPoint = null;
                        const canvas = this._editor.getOverlayLayer().getCanvas();
                        canvas.addEventListener("wheel", e => this.onWheel(e));
                        canvas.addEventListener("mousedown", e => this.onMouseDown(e));
                        canvas.addEventListener("mousemove", e => this.onMouseMove(e));
                        canvas.addEventListener("mouseup", e => this.onMouseUp(e));
                        this._state = {
                            scrollX: 0,
                            scrollY: 0,
                            zoom: 1
                        };
                        const zoomIcon = new controls.ZoomControl({ showReset: true });
                        zoomIcon.setCallback(z => this.controlZoom(z * 100));
                        this._editor.getCanvasContainer().appendChild(zoomIcon.getElement());
                    }
                    getCamera() {
                        return this._editor.getScene().getCamera();
                    }
                    onMouseDown(e) {
                        if (e.button === 1 || e.button === 0 && e.altKey) {
                            const camera = this.getCamera();
                            this._dragStartPoint = new Phaser.Math.Vector2(e.offsetX, e.offsetY);
                            this._dragStartCameraScroll = new Phaser.Math.Vector2(camera.scrollX, camera.scrollY);
                            e.preventDefault();
                        }
                    }
                    onMouseMove(e) {
                        if (this._dragStartPoint === null) {
                            return;
                        }
                        const dx = this._dragStartPoint.x - e.offsetX;
                        const dy = this._dragStartPoint.y - e.offsetY;
                        const camera = this.getCamera();
                        camera.scrollX = this._dragStartCameraScroll.x + dx / camera.zoom;
                        camera.scrollY = this._dragStartCameraScroll.y + dy / camera.zoom;
                        this.updateState();
                        this._editor.repaint();
                        e.preventDefault();
                    }
                    updateState() {
                        const camera = this.getCamera();
                        this._state.scrollX = camera.scrollX;
                        this._state.scrollY = camera.scrollY;
                        this._state.zoom = camera.zoom;
                    }
                    onMouseUp(e) {
                        this._dragStartPoint = null;
                        this._dragStartCameraScroll = null;
                    }
                    onWheel(e) {
                        e.preventDefault();
                        this.zoom(e.deltaY, e.offsetX, e.offsetY);
                    }
                    zoom(deltaY, offsetX, offsetY) {
                        const scene = this._editor.getScene();
                        const camera = scene.getCamera();
                        const point1 = camera.getWorldPoint(offsetX, offsetY);
                        const scrollWidth = Math.abs(deltaY) * 2;
                        const screenWidth = this._editor.getElement().getBoundingClientRect().width;
                        const zoomDelta = scrollWidth / (screenWidth + scrollWidth);
                        const zoomFactor = (deltaY > 0 ? 1 - zoomDelta : 1 + zoomDelta);
                        camera.zoom = camera.zoom * zoomFactor;
                        // update the camera matrix
                        camera.preRender();
                        const point2 = camera.getWorldPoint(offsetX, offsetY);
                        const dx = point2.x - point1.x;
                        const dy = point2.y - point1.y;
                        camera.scrollX += -dx;
                        camera.scrollY += -dy;
                        this.updateState();
                        this._editor.repaint();
                    }
                    controlZoom(z) {
                        if (z === 0) {
                            // reset zoom
                            const { borderX, borderY } = this._editor.getScene().getSettings();
                            const camera = this.getCamera();
                            camera.scrollX = borderX;
                            camera.scrollY = borderY;
                            camera.zoom = 1;
                            this.updateState();
                            this._editor.repaint();
                        }
                        else {
                            const b = this._editor.getCanvasContainer().getBoundingClientRect();
                            this.zoom(-z, b.width / 2, b.height / 2);
                        }
                    }
                    getState() {
                        return this._state;
                    }
                    setState(state) {
                        if (state) {
                            const camera = this.getCamera();
                            camera.scrollX = state.scrollX;
                            camera.scrollY = state.scrollY;
                            camera.zoom = state.zoom;
                            this._state = state;
                        }
                    }
                }
                editor_2.CameraManager = CameraManager;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_12.ui || (scene_12.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_13) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var controls = colibri.ui.controls;
                class CellRendererCache {
                    _imageMap;
                    _hashMap;
                    _promiseMap;
                    constructor() {
                        this._imageMap = new Map();
                        this._hashMap = new Map();
                        this._promiseMap = new Map();
                    }
                    getImage(obj) {
                        const objId = obj.getEditorSupport().getId();
                        const imageInCache = this._imageMap.get(objId);
                        return imageInCache;
                    }
                    async preloadImage(obj) {
                        const objId = obj.getEditorSupport().getId();
                        if (this._promiseMap.has(objId)) {
                            return this._promiseMap.get(objId);
                        }
                        const hash = obj.getEditorSupport().computeContentHash();
                        const hashInCache = this._hashMap.get(objId);
                        if (hashInCache === hash) {
                            return controls.PreloadResult.NOTHING_LOADED;
                        }
                        if (this._promiseMap.has(objId)) {
                            return this._promiseMap.get(objId);
                        }
                        const makeImagePromise = new Promise((resolve, reject) => {
                            const sprite = obj;
                            const angle = sprite.angle;
                            const originX = sprite.originX;
                            const originY = sprite.originY;
                            const scaleX = sprite.scaleX;
                            const scaleY = sprite.scaleY;
                            sprite.setAngle(0);
                            sprite.setOrigin(0, 0);
                            sprite.setScale(1, 1);
                            let renderX = 0;
                            let renderY = 0;
                            let renderWidth = sprite.width;
                            let renderHeight = sprite.height;
                            if (sprite instanceof ui.sceneobjects.TilemapLayer) {
                                const layer = sprite;
                                if (layer.getEditorSupport().getOrientation() === Phaser.Tilemaps.Orientation.ISOMETRIC) {
                                    renderX = layer.width / 2;
                                    renderY = 0;
                                    renderWidth = layer.width * 2;
                                    renderHeight = layer.height * 2;
                                }
                            }
                            renderWidth = Math.max(1, Math.min(1024, renderWidth));
                            renderHeight = Math.max(1, Math.min(1024, renderHeight));
                            const scene = sprite.getEditorSupport().getScene();
                            const render = new Phaser.GameObjects.RenderTexture(scene, 0, 0, renderWidth, renderHeight);
                            render.draw(sprite, renderX, renderY);
                            try {
                                render.snapshot(imgElement => {
                                    const img = new controls.ImageWrapper(imgElement);
                                    this._hashMap.set(objId, hash);
                                    this._imageMap.set(objId, img);
                                    this._promiseMap.delete(objId);
                                    resolve(controls.PreloadResult.RESOURCES_LOADED);
                                });
                            }
                            catch (e) {
                                console.error(obj.getEditorSupport().getLabel() + ": " + e.message);
                            }
                            sprite.setAngle(angle);
                            sprite.setOrigin(originX, originY);
                            sprite.setScale(scaleX, scaleY);
                            render.destroy();
                        });
                        this._promiseMap.set(objId, makeImagePromise);
                        return makeImagePromise;
                    }
                    clear() {
                        this._imageMap.clear();
                        this._hashMap.clear();
                        this._promiseMap.clear();
                    }
                }
                editor.CellRendererCache = CellRendererCache;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_13.ui || (scene_13.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_3) {
                class ClipboardManager {
                    static _clipboard = [];
                    _editor;
                    constructor(editor) {
                        this._editor = editor;
                    }
                    static getClipboard() {
                        return this._clipboard;
                    }
                    static getClipboardCopy() {
                        return this._clipboard.map(obj => JSON.parse(JSON.stringify(obj)));
                    }
                    copy() {
                        ClipboardManager._clipboard = [];
                        this.copyGameObjects();
                        this.copyPlainObjects();
                        this.copyObjectLists();
                        this.copyPrefabProperties();
                    }
                    copyPlainObjects() {
                        for (const obj of this._editor.getSelectedPlainObjects()) {
                            const data = {};
                            obj.getEditorSupport().writeJSON(data);
                            ClipboardManager._clipboard.push({
                                data,
                                type: "IScenePlainObject"
                            });
                        }
                    }
                    copyPrefabProperties() {
                        for (const prop of this._editor.getSelectedPrefabProperties()) {
                            const data = {};
                            prop.writeJSON(data);
                            ClipboardManager._clipboard.push({
                                data,
                                type: "PrefabProperty"
                            });
                        }
                    }
                    copyObjectLists() {
                        for (const list of this._editor.getSelectedLists()) {
                            const listData = {};
                            list.writeJSON(listData);
                            ClipboardManager._clipboard.push({
                                type: "ObjectList",
                                data: listData
                            });
                        }
                    }
                    copyGameObjects() {
                        let minX = Number.MAX_SAFE_INTEGER;
                        let minY = Number.MAX_SAFE_INTEGER;
                        const p = new Phaser.Math.Vector2();
                        const selection = new Set(this._editor.getSelectedGameObjects());
                        const copyObjects = [];
                        // filter off the children of selected parents
                        for (const obj of selection) {
                            let include = true;
                            const objES = obj.getEditorSupport();
                            const parents = objES.getAllParents();
                            for (const parent of parents) {
                                if (selection.has(parent)) {
                                    include = false;
                                    break;
                                }
                            }
                            if (include) {
                                copyObjects.push(obj);
                            }
                        }
                        // record game objects positions
                        for (const obj of copyObjects) {
                            const sprite = obj;
                            if (sprite.getWorldTransformMatrix) {
                                sprite.getWorldTransformMatrix().transformPoint(0, 0, p);
                            }
                            else {
                                // the case of Layer
                                p.set(0, 0);
                            }
                            minX = Math.min(minX, p.x);
                            minY = Math.min(minY, p.y);
                        }
                        // serialize objects
                        for (const obj of copyObjects) {
                            const objData = {};
                            obj.getEditorSupport().writeJSON(objData);
                            const sprite = obj;
                            if (sprite.getWorldTransformMatrix) {
                                sprite.getWorldTransformMatrix().transformPoint(0, 0, p);
                            }
                            else {
                                // the case of Layer
                                p.set(0, 0);
                            }
                            p.x -= minX;
                            p.y -= minY;
                            objData["__shiftLeft_x"] = p.x;
                            objData["__shiftLeft_y"] = p.y;
                            ClipboardManager._clipboard.push({
                                type: "ISceneObject",
                                data: objData
                            });
                        }
                    }
                    paste(pasteInPlace) {
                        if (ClipboardManager._clipboard.length > 0) {
                            this._editor.getUndoManager().add(new editor_3.undo.PasteOperation(this._editor, pasteInPlace));
                        }
                    }
                    cut() {
                        if (this._editor.getSelection().length > 0) {
                            this._editor.getUndoManager().add(new editor_3.undo.CutOperation(this._editor));
                        }
                    }
                }
                editor_3.ClipboardManager = ClipboardManager;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_4) {
                var controls = colibri.ui.controls;
                class ConvertTypeDialog extends controls.dialogs.ViewerFormDialog {
                    _editor;
                    _keepOriginalTexture;
                    constructor(editor) {
                        super(new ui.viewers.ObjectExtensionAndPrefabViewer(), true);
                        this._editor = editor;
                        this.setSize(900, 500, true);
                    }
                    static canConvert(editor) {
                        return this.getObjectsToMorph(editor).length > 0;
                    }
                    static getObjectsToMorph(editor) {
                        return editor.getSelectedGameObjects()
                            .filter(obj => ui.sceneobjects.isGameObject(obj))
                            .filter(obj => !(obj instanceof ui.sceneobjects.FXObject));
                    }
                    create() {
                        const viewer = this.getViewer();
                        super.create();
                        this.setTitle("Replace Type");
                        this.enableButtonOnlyWhenOneElementIsSelected(this.addOpenButton("Replace", async (sel) => {
                            const targetType = viewer.getSelectionFirstElement();
                            let extraData = {};
                            if (targetType instanceof ui.sceneobjects.SceneGameObjectExtension) {
                                const result = await targetType.collectExtraDataForCreateDefaultObject(this._editor, true);
                                if (result.abort) {
                                    return;
                                }
                                if (result.dataNotFoundMessage) {
                                    alert(result.dataNotFoundMessage);
                                    return;
                                }
                                extraData = result.data;
                            }
                            if (typeof extraData !== "object") {
                                extraData = {};
                            }
                            extraData.keepOriginalTexture = this._keepOriginalTexture;
                            this._editor.getUndoManager().add(new editor_4.undo.ConvertTypeOperation(this._editor, targetType, extraData));
                            this.close();
                        }));
                        viewer.expandRoots();
                        viewer.selectFirst();
                        this.addCancelButton();
                    }
                    createFormArea(formArea) {
                        this._keepOriginalTexture = window.localStorage["phasereditor2d.scene.ui.editor.ConvertTypeDialog.keepOriginalTexture"] === "true";
                        const checkbox = document.createElement("input");
                        checkbox.id = "checkbox1";
                        checkbox.type = "checkbox";
                        checkbox.checked = this._keepOriginalTexture;
                        checkbox.addEventListener("change", e => {
                            this._keepOriginalTexture = checkbox.checked;
                            window.localStorage["phasereditor2d.scene.ui.editor.ConvertTypeDialog.keepOriginalTexture"] = this._keepOriginalTexture;
                        });
                        const label = document.createElement("label");
                        label.innerHTML = "Keep the original texture.";
                        label.htmlFor = "checkbox1";
                        const fieldElement = document.createElement("div");
                        fieldElement.style.gridColumn = "1 / span 2";
                        fieldElement.style.display = "flex";
                        fieldElement.style.alignItems = "center";
                        fieldElement.appendChild(checkbox);
                        fieldElement.appendChild(label);
                        formArea.appendChild(fieldElement);
                    }
                }
                editor_4.ConvertTypeDialog = ConvertTypeDialog;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_14) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_5) {
                var controls = colibri.ui.controls;
                var ide = colibri.ui.ide;
                var io = colibri.core.io;
                class DropManager {
                    _editor;
                    constructor(editor) {
                        this._editor = editor;
                        const canvas = this._editor.getOverlayLayer().getCanvas();
                        canvas.addEventListener("dragover", e => this.onDragOver(e));
                        canvas.addEventListener("drop", e => this.onDragDrop_async(e));
                    }
                    async onDragDrop_async(e) {
                        const dataArray = controls.Controls.getApplicationDragDataAndClean();
                        for (const data of dataArray) {
                            if (data instanceof io.FilePath) {
                                if (data.getExtension() !== "scene") {
                                    alert("<p>Only items shown in the Blocks view can be added to the scene.</p>" +
                                        "<p>The Blocks view shows Scene Prefabs and items defined in the Asset Pack files.</p>" +
                                        "<p>You can add files to a Pack File using the Inspector view or opening a pack file in the Asset Pack editor.</p>");
                                    return;
                                }
                            }
                        }
                        if (this.acceptDropDataArray(dataArray)) {
                            e.preventDefault();
                            await this.dropData(dataArray, e.offsetX, e.offsetY);
                        }
                    }
                    async dropDataAtCenter(dataArray) {
                        controls.Controls.setApplicationDragData(dataArray);
                        const rect = this._editor.getElement().getClientRects().item(0);
                        const offsetX = rect.width / 2;
                        const offsetY = rect.height / 2;
                        this.dropData(dataArray, offsetX, offsetY);
                    }
                    async dropData(dataArray, offsetX, offsetY) {
                        await this._editor.getUndoManager()
                            .add(new editor_5.undo.CreateObjectWithAssetOperation(this._editor, dataArray, offsetX, offsetY));
                        await this._editor.refreshDependenciesHash();
                        ide.Workbench.getWorkbench().setActivePart(this._editor);
                    }
                    async createWithDropEvent(dropAssetArray, offsetX, offsetY, alternativeSelection) {
                        const scene = this._editor.getScene();
                        const sceneMaker = scene.getMaker();
                        const exts = scene_14.ScenePlugin.getInstance().getGameObjectExtensions();
                        const nameMaker = this.buildNameMaker();
                        const worldPoint = scene.getCamera().getWorldPoint(offsetX, offsetY);
                        const x = Math.floor(worldPoint.x);
                        const y = Math.floor(worldPoint.y);
                        const sceneFinder = scene_14.ScenePlugin.getInstance().getSceneFinder();
                        for (const data of dropAssetArray) {
                            if (data instanceof io.FilePath) {
                                const file = data;
                                if (sceneMaker.isPrefabFile(file)) {
                                    const sceneData = sceneFinder.getSceneData(file);
                                    if (sceneData) {
                                        await sceneMaker.updateSceneLoader(sceneData);
                                    }
                                }
                            }
                        }
                        for (const data of dropAssetArray) {
                            const ext = scene_14.ScenePlugin.getInstance().getLoaderUpdaterForAsset(data);
                            if (ext) {
                                await ext.updateLoader(scene, data);
                            }
                        }
                        const prefabObj = scene.getPrefabObject();
                        const newSprites = [];
                        const newLists = [];
                        const newPlainObjects = [];
                        for (const data of dropAssetArray) {
                            if (data instanceof io.FilePath) {
                                if (sceneMaker.isPrefabFile(data)) {
                                    const sprite = await sceneMaker.createPrefabInstanceWithFile(data);
                                    const spriteES = sprite.getEditorSupport();
                                    if (spriteES.hasComponent(ui.sceneobjects.TransformComponent)) {
                                        spriteES.setUnlockedProperty(ui.sceneobjects.TransformComponent.x, true);
                                        spriteES.setUnlockedProperty(ui.sceneobjects.TransformComponent.y, true);
                                        sprite.setPosition(x, y);
                                    }
                                    if (sprite) {
                                        newSprites.push(sprite);
                                    }
                                    continue;
                                }
                            }
                            for (const ext of exts) {
                                if (ext.acceptsDropData(data)) {
                                    const result = ext.createSceneObjectWithAsset({
                                        x: x,
                                        y: y,
                                        asset: data,
                                        scene: scene
                                    });
                                    // for compatibility with external plugins,
                                    // I set returning a promise as optional
                                    const sprite = result instanceof Promise ? await result : result;
                                    if (sprite) {
                                        newSprites.push(sprite);
                                    }
                                    break;
                                }
                            }
                            if (data instanceof ui.sceneobjects.SceneObjectExtension) {
                                let extraData;
                                if (data instanceof ui.sceneobjects.SceneObjectExtension) {
                                    const result = await data.collectExtraDataForCreateDefaultObject(this._editor);
                                    if (result.abort) {
                                        continue;
                                    }
                                    if (result.dataNotFoundMessage) {
                                        alert(result.dataNotFoundMessage);
                                        continue;
                                    }
                                    extraData = result.data;
                                    const defaultObjects = this._editor.getSceneMaker()
                                        .createDefaultObject(data, extraData, x, y);
                                    for (const defaultObject of defaultObjects) {
                                        if (ui.sceneobjects.isGameObject(defaultObject)) {
                                            newSprites.push(defaultObject);
                                        }
                                        else {
                                            scene.addPlainObject(defaultObject);
                                            newPlainObjects.push(defaultObject);
                                        }
                                    }
                                }
                            }
                            else if (data === ui.sceneobjects.ObjectList) {
                                const list = new ui.sceneobjects.ObjectList();
                                list.setLabel(nameMaker.makeName("list"));
                                scene.getObjectLists().getLists().push(list);
                                newLists.push(list);
                            }
                        }
                        for (const sceneObject of [...newSprites, ...newPlainObjects]) {
                            const sceneObjectES = sceneObject.getEditorSupport();
                            let label = sceneObjectES.getLabel();
                            if (sceneObjectES instanceof ui.sceneobjects.GameObjectEditorSupport) {
                                label = sceneObjectES.isPrefabInstance() ? sceneObjectES.getPrefabName() : sceneObjectES.getLabel();
                            }
                            label = scene_14.core.code.formatToValidVarName(label);
                            label = nameMaker.makeName(label);
                            sceneObjectES.setLabel(label);
                        }
                        scene.getMaker().afterDropObjects(prefabObj, newSprites, alternativeSelection);
                        ui.sceneobjects.sortGameObjects(newSprites);
                        return [...newSprites, ...newPlainObjects, ...newLists];
                    }
                    buildNameMaker() {
                        const scene = this._editor.getScene();
                        const nameMaker = new ide.utils.NameMaker(obj => {
                            if (obj instanceof ui.sceneobjects.ObjectList) {
                                return obj.getLabel();
                            }
                            return obj.getEditorSupport().getLabel();
                        });
                        scene.visitAll(obj => nameMaker.update([obj]));
                        nameMaker.update(scene.getPlainObjects());
                        nameMaker.update(scene.getObjectLists().getLists());
                        return nameMaker;
                    }
                    addFXObjects(factory) {
                        const nameMaker = this.buildNameMaker();
                        const allParents = this._editor.getSelectedGameObjects()
                            .filter(obj => obj.getEditorSupport().isDisplayObject() || obj instanceof ui.sceneobjects.FXObject)
                            .map(obj => obj instanceof ui.sceneobjects.FXObject ? obj.getParent() : obj);
                        const parents = new Set(allParents);
                        const scene = this._editor.getScene();
                        const op = new ui.editor.undo.SceneSnapshotOperation(this._editor, async () => {
                            const fxList = [];
                            for (const parent of parents) {
                                const isPreFX = ui.sceneobjects.FXObjectExtension.isDefaultPipelinePreFX(parent);
                                const fx = factory.createFXObject(scene, parent, isPreFX);
                                parent.getEditorSupport().addObjectChild(fx);
                                const fxES = fx.getEditorSupport();
                                fxES.setLabel(nameMaker.makeName(fxES.getLabel() + "Fx"));
                                fxList.push(fx);
                            }
                            this._editor.setSelection(fxList);
                        });
                        this._editor.getUndoManager().add(op);
                    }
                    onDragOver(e) {
                        const dataArray = controls.Controls.getApplicationDragData();
                        // accept any kind of file, so we can show a message when the drop is done.
                        for (const data of dataArray) {
                            if (data instanceof io.FilePath) {
                                e.preventDefault();
                                return;
                            }
                        }
                        if (this.acceptDropDataArray(dataArray)) {
                            e.preventDefault();
                        }
                    }
                    acceptDropData(data) {
                        if (data instanceof io.FilePath) {
                            return ui.SceneMaker.acceptDropFile(data, this._editor.getInput());
                        }
                        for (const ext of scene_14.ScenePlugin.getInstance().getGameObjectExtensions()) {
                            if (ext.acceptsDropData(data)) {
                                return true;
                            }
                        }
                        if (data instanceof ui.sceneobjects.SceneObjectExtension) {
                            return true;
                        }
                        if (data === ui.sceneobjects.ObjectList) {
                            return true;
                        }
                        return false;
                    }
                    acceptDropDataArray(dataArray) {
                        if (this._editor.isLoading()) {
                            return false;
                        }
                        if (!dataArray) {
                            return false;
                        }
                        for (const item of dataArray) {
                            if (!this.acceptDropData(item)) {
                                return false;
                            }
                        }
                        return true;
                    }
                }
                editor_5.DropManager = DropManager;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_14.ui || (scene_14.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_6) {
                var controls = colibri.ui.controls;
                class LayoutToolsManager {
                    _pane;
                    _editor;
                    _paneVisible;
                    _parametersElement;
                    constructor(editor) {
                        this._editor = editor;
                    }
                    togglePaneVisible() {
                        this.setPaneVisible(!this.isPaneVisible());
                    }
                    setPaneVisible(visible) {
                        this._paneVisible = visible;
                        if (visible) {
                            this._pane.style.display = "grid";
                        }
                        else {
                            this._pane.style.display = "none";
                        }
                        window.localStorage.setItem("phasereditor2d.scene.ui.editor.layoutPaneVisible", visible ? "true" : "false");
                    }
                    isPaneVisible() {
                        return this._paneVisible;
                    }
                    createElement() {
                        const pane = document.createElement("div");
                        pane.classList.add("LayoutPane");
                        const centerPane = document.createElement("div");
                        centerPane.classList.add("CenterPane", "Pane");
                        pane.appendChild(centerPane);
                        this._parametersElement = document.createElement("div");
                        this._parametersElement.classList.add("Parameters");
                        centerPane.appendChild(this._parametersElement);
                        const groupItemsToolbarElement = document.createElement("div");
                        groupItemsToolbarElement.classList.add("Toolbar");
                        centerPane.appendChild(groupItemsToolbarElement);
                        groupItemsToolbarElement.style.display = "none";
                        const groupToolbarElement = document.createElement("div");
                        groupToolbarElement.classList.add("Toolbar");
                        centerPane.appendChild(groupToolbarElement);
                        const extsByGroup = scene.ScenePlugin.getInstance().getLayoutExtensionsByGroup();
                        const groupToolbar = new controls.ToolbarManager(groupToolbarElement);
                        const actions = [];
                        for (const group of extsByGroup) {
                            if (group.extensions.length <= 3) {
                                for (const ext of group.extensions) {
                                    const config = ext.getConfig();
                                    const action = groupToolbar.addAction({
                                        text: config.name,
                                        icon: config.icon,
                                        showText: false,
                                        callback: (e, action) => {
                                            this.clearParameters();
                                            groupItemsToolbarElement.style.display = "none";
                                            this.clearHtmlElementChildren(groupItemsToolbarElement);
                                            for (const a of actions) {
                                                a.setSelected(false);
                                            }
                                            action.setSelected(true);
                                            ext.performLayout(this._editor);
                                        }
                                    });
                                    actions.push(action);
                                }
                            }
                            else {
                                const action = groupToolbar.addAction({
                                    text: group.group,
                                    showText: false,
                                    icon: group.extensions[0].getConfig().icon,
                                    callback: (e, action) => {
                                        for (const a of actions) {
                                            a.setSelected(false);
                                        }
                                        action.setSelected(true);
                                        this.showGroupToolbar(groupItemsToolbarElement, group.group, group.extensions);
                                    }
                                });
                                actions.push(action);
                            }
                        }
                        this._editor.getCanvasContainer().appendChild(pane);
                        this._pane = pane;
                        {
                            const item = window.localStorage.getItem("phasereditor2d.scene.ui.editor.layoutPaneVisible");
                            this.setPaneVisible(item !== "false");
                        }
                    }
                    clearHtmlElementChildren(parent) {
                        while (parent.firstChild) {
                            parent.removeChild(parent.firstChild);
                        }
                    }
                    showGroupToolbar(parent, group, extensions) {
                        this.clearParameters();
                        this.clearHtmlElementChildren(parent);
                        parent.style.display = "initial";
                        // the title pane
                        const titlePane = document.createElement("div");
                        titlePane.classList.add("Title");
                        parent.appendChild(titlePane);
                        const titleLabel = document.createElement("label");
                        titleLabel.textContent = group;
                        titlePane.appendChild(titleLabel);
                        const buttonPane = document.createElement("div");
                        buttonPane.classList.add("Buttons");
                        titlePane.appendChild(buttonPane);
                        const closeIcon = new controls.IconControl(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_CONTROL_CLOSE));
                        closeIcon.getCanvas().classList.add("IconButton");
                        closeIcon.getCanvas().addEventListener("click", () => {
                            parent.style.display = "none";
                            this.clearHtmlElementChildren(parent);
                        });
                        buttonPane.appendChild(closeIcon.getCanvas());
                        // the toolbar
                        const toolbar = new controls.ToolbarManager(parent);
                        for (const ext of extensions) {
                            const config = ext.getConfig();
                            toolbar.addAction({
                                text: config.name,
                                icon: config.icon,
                                showText: false,
                                callback: () => ext.performLayout(this._editor)
                            });
                        }
                    }
                    clearParameters() {
                        while (this._parametersElement.firstChild) {
                            this._parametersElement.removeChild(this._parametersElement.firstChild);
                        }
                    }
                    async showParametersPane(ext) {
                        const paneWasVisible = this.isPaneVisible();
                        if (!paneWasVisible) {
                            this.togglePaneVisible();
                        }
                        return new Promise((resolve, reject) => {
                            const params = ext.getConfig().params || [];
                            this.clearParameters();
                            if (params.length === 0) {
                                resolve(null);
                                return;
                            }
                            const formParent = document.createElement("div");
                            formParent.classList.add("Form");
                            this._parametersElement.appendChild(formParent);
                            const form = new controls.properties.EasyFormBuilder(formParent);
                            const titlePane = document.createElement("div");
                            titlePane.classList.add("Title");
                            formParent.appendChild(titlePane);
                            const titleLabel = document.createElement("label");
                            titleLabel.textContent = ext.getConfig().name;
                            titlePane.appendChild(titleLabel);
                            const buttonPane = document.createElement("div");
                            buttonPane.classList.add("Buttons");
                            titlePane.appendChild(buttonPane);
                            const applyIcon = new controls.IconControl(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_CHECKED));
                            applyIcon.getCanvas().classList.add("IconButton");
                            applyIcon.getCanvas().addEventListener("click", () => {
                                applyResult();
                            });
                            buttonPane.appendChild(applyIcon.getCanvas());
                            const closeIcon = new controls.IconControl(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_CONTROL_CLOSE));
                            closeIcon.getCanvas().classList.add("IconButton");
                            closeIcon.getCanvas().addEventListener("click", () => {
                                this.clearParameters();
                                resolve(null);
                            });
                            buttonPane.appendChild(closeIcon.getCanvas());
                            const elementMap = new Map();
                            const applyResult = () => {
                                const result = {};
                                for (const paramName of elementMap.keys()) {
                                    const text = elementMap.get(paramName);
                                    window.localStorage.setItem(this.getLocalStorageKey(ext, paramName), text.value);
                                    const val = Number.parseFloat(text.value);
                                    result[paramName] = val;
                                }
                                this.clearParameters();
                                if (!paneWasVisible) {
                                    this.setPaneVisible(false);
                                }
                                resolve(result);
                            };
                            for (const param of params) {
                                form.createLabel(param.label);
                                const text = form.createText();
                                const memo = window.localStorage.getItem(this.getLocalStorageKey(ext, param.name));
                                text.value = memo || param.defaultValue.toString();
                                text.addEventListener("keypress", e => {
                                    if (e.code === "Enter" || e.code === "NumpadEnter") {
                                        applyResult();
                                    }
                                });
                                elementMap.set(param.name, text);
                            }
                        });
                    }
                    getLocalStorageKey(ext, key) {
                        const config = ext.getConfig();
                        return "phasereditor2d.scene.ui.editor.LayoutToolsManager.parameters." + config.group + "." + config.name + "." + key;
                    }
                }
                editor_6.LayoutToolsManager = LayoutToolsManager;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_7) {
                class MouseManager {
                    _editor;
                    _toolInAction;
                    _mousePosition;
                    constructor(editor) {
                        this._editor = editor;
                        this._toolInAction = false;
                        const canvas = editor.getOverlayLayer().getCanvas();
                        this._mousePosition = { x: 0, y: 0 };
                        canvas.addEventListener("dblclick", e => this.onDoubleClick(e));
                        canvas.addEventListener("click", e => this.onClick(e));
                        canvas.addEventListener("mousedown", e => this.onMouseDown(e));
                        canvas.addEventListener("mouseup", e => this.onMouseUp(e));
                        canvas.addEventListener("mousemove", e => this.onMouseMove(e));
                    }
                    createArgs(e) {
                        return {
                            camera: this._editor.getScene().getCamera(),
                            editor: this._editor,
                            localCoords: this._editor.isLocalCoords(),
                            objects: this._editor.getSelection(),
                            x: e.offsetX,
                            y: e.offsetY,
                            event: e
                        };
                    }
                    onDoubleClick(e) {
                        if (this._editor.getToolsManager().handleDoubleClick()) {
                            e.preventDefault();
                            e.stopImmediatePropagation();
                        }
                    }
                    onMouseDown(e) {
                        if (e.button !== 0 || e.altKey) {
                            return;
                        }
                        const toolsManager = this._editor.getToolsManager();
                        const tool = toolsManager.getActiveTool();
                        if (tool) {
                            const args = this.createArgs(e);
                            if (tool.isObjectTool()) {
                                if (!tool.isValidForAll(args.objects)) {
                                    return;
                                }
                                for (const obj of args.objects) {
                                    if (!tool.canEdit(obj)) {
                                        return;
                                    }
                                }
                                if (tool.containsPoint(args)) {
                                    this._toolInAction = true;
                                    tool.onStartDrag(args);
                                }
                            }
                            else {
                                this._toolInAction = true;
                                tool.onStartDrag(args);
                            }
                        }
                    }
                    getMousePosition() {
                        return this._mousePosition;
                    }
                    getDropPosition() {
                        const p = this._editor.getScene().getCamera()
                            .getWorldPoint(this._mousePosition.x, this._mousePosition.y);
                        return this._editor.getScene().snapPoint(p.x, p.y);
                    }
                    onMouseMove(e) {
                        if (e.button !== 0 || e.altKey) {
                            return;
                        }
                        this._mousePosition.x = e.offsetX;
                        this._mousePosition.y = e.offsetY;
                        const toolsManager = this._editor.getToolsManager();
                        const tool = toolsManager.getActiveTool();
                        if (tool && tool.requiresRepaintOnMouseMove()) {
                            if (this._editor.getScene().cameras) {
                                this._editor.getOverlayLayer().render();
                            }
                        }
                        if (tool && this._toolInAction) {
                            const args = this.createArgs(e);
                            tool.onDrag(args);
                        }
                    }
                    onMouseUp(e) {
                        if (e.button !== 0 || e.altKey) {
                            return;
                        }
                        const toolsManager = this._editor.getToolsManager();
                        const tool = toolsManager.getActiveTool();
                        if (tool) {
                            const args = this.createArgs(e);
                            if (tool.isObjectTool()) {
                                for (const obj of args.objects) {
                                    if (!tool.canEdit(obj)) {
                                        return;
                                    }
                                }
                            }
                            tool.onStopDrag(args);
                        }
                    }
                    onClick(e) {
                        if (e.button !== 0 || e.altKey) {
                            return;
                        }
                        if (this._toolInAction) {
                            this._toolInAction = false;
                            return;
                        }
                        const selManager = this._editor.getSelectionManager();
                        const toolsManager = this._editor.getToolsManager();
                        const tool = toolsManager.getActiveTool();
                        if (tool) {
                            const args = this.createArgs(e);
                            let canEdit = true;
                            for (const obj of args.objects) {
                                if (!tool.canEdit(obj)) {
                                    canEdit = false;
                                    break;
                                }
                            }
                            if (canEdit && tool.containsPoint(args)) {
                                return;
                            }
                        }
                        selManager.onMouseClick(e);
                    }
                }
                editor_7.MouseManager = MouseManager;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseOverlayLayer.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_8) {
                var controls = colibri.ui.controls;
                class OverlayLayer extends editor_8.BaseOverlayLayer {
                    _editor;
                    constructor(editor) {
                        super();
                        this._editor = editor;
                    }
                    renderLayer() {
                        this.renderGrid();
                        this.renderSelection();
                        this.renderTools();
                    }
                    renderTools() {
                        const manager = this._editor.getToolsManager();
                        const tool = manager.getActiveTool();
                        if (!tool) {
                            return;
                        }
                        if (!tool.isValidForAll(this._editor.getSelectedGameObjects())) {
                            return;
                        }
                        const renderSel = this._editor.getSelection().filter(obj => tool.canRender(obj));
                        if (renderSel.length === 0 && tool.isObjectTool()) {
                            return;
                        }
                        const editSel = this._editor.getSelection().filter(obj => tool.canEdit(obj));
                        const ctx = this.getContext();
                        ctx.save();
                        tool.render({
                            editor: this._editor,
                            localCoords: this._editor.isLocalCoords(),
                            canvasContext: ctx,
                            objects: renderSel,
                            canEdit: editSel.length === renderSel.length,
                            camera: this._editor.getScene().getCamera()
                        });
                        ctx.restore();
                    }
                    renderSelection() {
                        const ctx = this.getContext();
                        const camera = this._editor.getScene().getCamera();
                        const selection = this._editor.getSelection();
                        for (const obj of selection) {
                            ctx.save();
                            const isGameObject = ui.sceneobjects.isGameObject(obj);
                            const isUserCompNode = obj instanceof ui.sceneobjects.UserComponentNode;
                            const isScriptNodeOrFXObj = obj instanceof ui.sceneobjects.ScriptNode
                                || obj instanceof ui.sceneobjects.FXObject;
                            const isNonDisplayObject = isUserCompNode || isScriptNodeOrFXObj;
                            if (isGameObject || isNonDisplayObject) {
                                let sprite;
                                if (isUserCompNode) {
                                    sprite = obj.getObject();
                                }
                                else if (isScriptNodeOrFXObj) {
                                    sprite = obj.getParentDisplayObject();
                                }
                                else {
                                    sprite = obj;
                                }
                                if (!sprite) {
                                    continue;
                                }
                                const spriteES = sprite.getEditorSupport();
                                const points = spriteES.getScreenBounds(camera);
                                if (points.length === 4) {
                                    ctx.strokeStyle = "black";
                                    ctx.lineWidth = isNonDisplayObject ? 1 : 4;
                                    ctx.beginPath();
                                    ctx.moveTo(points[0].x, points[0].y);
                                    ctx.lineTo(points[1].x, points[1].y);
                                    ctx.lineTo(points[2].x, points[2].y);
                                    ctx.lineTo(points[3].x, points[3].y);
                                    ctx.closePath();
                                    ctx.stroke();
                                    ctx.strokeStyle = "#00ff00";
                                    // ctx.strokeStyle = controls.Controls.getTheme().viewerSelectionBackground;
                                    if (isNonDisplayObject) {
                                        ctx.lineWidth = 1;
                                        ctx.setLineDash([1, 2]);
                                    }
                                    else {
                                        ctx.lineWidth = 2;
                                    }
                                    ctx.beginPath();
                                    ctx.moveTo(points[0].x, points[0].y);
                                    ctx.lineTo(points[1].x, points[1].y);
                                    ctx.lineTo(points[2].x, points[2].y);
                                    ctx.lineTo(points[3].x, points[3].y);
                                    ctx.closePath();
                                    ctx.stroke();
                                }
                            }
                            ctx.restore();
                        }
                    }
                    renderGrid() {
                        const settings = this._editor.getScene().getSettings();
                        const camera = this._editor.getScene().getCamera();
                        // parameters from settings
                        const snapEnabled = settings.snapEnabled;
                        const snapX = settings.snapWidth;
                        const snapY = settings.snapHeight;
                        const borderX = settings.borderX;
                        const borderY = settings.borderY;
                        const borderWidth = settings.borderWidth;
                        const borderHeight = settings.borderHeight;
                        const canvasWidth = this.getCanvas().width;
                        const canvasHeight = this.getCanvas().height;
                        const ctx = this.getContext();
                        // render grid
                        const theme = controls.Controls.getTheme();
                        ctx.strokeStyle = theme.dark ? "#6e6e6eaa" : "#bebebecc";
                        ctx.lineWidth = 1;
                        let gapX = 4;
                        let gapY = 4;
                        if (snapEnabled) {
                            gapX = snapX;
                            gapY = snapY;
                        }
                        {
                            for (let i = 1; true; i++) {
                                const delta = camera.getScreenPoint(gapX * i, gapY * i).subtract(camera.getScreenPoint(0, 0));
                                if (delta.x > 64 && delta.y > 64) {
                                    gapX = gapX * i;
                                    gapY = gapY * i;
                                    break;
                                }
                            }
                        }
                        const worldStartPoint = camera.getWorldPoint(0, 0);
                        worldStartPoint.x = Phaser.Math.Snap.Floor(worldStartPoint.x, gapX);
                        worldStartPoint.y = Phaser.Math.Snap.Floor(worldStartPoint.y, gapY);
                        const worldEndPoint = camera.getWorldPoint(canvasWidth, canvasHeight);
                        const grid = (render) => {
                            let worldY = worldStartPoint.y;
                            while (worldY < worldEndPoint.y) {
                                const point = camera.getScreenPoint(0, worldY);
                                render.horizontal(worldY, Math.floor(point.y));
                                worldY += gapY;
                            }
                            let worldX = worldStartPoint.x;
                            while (worldX < worldEndPoint.x) {
                                const point = camera.getScreenPoint(worldX, 0);
                                render.vertical(worldX, Math.floor(point.x));
                                worldX += gapX;
                            }
                        };
                        let labelWidth = 0;
                        ctx.save();
                        ctx.fillStyle = ctx.strokeStyle;
                        // labels
                        grid({
                            horizontal: (worldY, screenY) => {
                                const w = ctx.measureText(worldY.toString()).width;
                                labelWidth = Math.max(labelWidth, w + 2);
                                ctx.save();
                                ctx.fillStyle = "#000000";
                                ctx.fillText(worldY.toString(), 0 + 1, screenY + 4 + 1);
                                ctx.restore();
                                ctx.fillText(worldY.toString(), 0, screenY + 4);
                            },
                            vertical: (worldX, screenX) => {
                                if (screenX < labelWidth) {
                                    return;
                                }
                                const w = ctx.measureText(worldX.toString()).width;
                                ctx.save();
                                ctx.fillStyle = "#000000";
                                ctx.fillText(worldX.toString(), screenX - w / 2 + 1, 15 + 1);
                                ctx.restore();
                                ctx.fillText(worldX.toString(), screenX - w / 2, 15);
                            }
                        });
                        // lines
                        grid({
                            horizontal: (worldY, screenY) => {
                                if (screenY < 20) {
                                    return;
                                }
                                ctx.beginPath();
                                ctx.moveTo(labelWidth, screenY);
                                ctx.lineTo(canvasWidth, screenY);
                                ctx.stroke();
                            },
                            vertical: (worldX, screenX) => {
                                if (screenX < labelWidth) {
                                    return;
                                }
                                ctx.beginPath();
                                ctx.moveTo(screenX, 20);
                                ctx.lineTo(screenX, canvasHeight);
                                ctx.stroke();
                            }
                        });
                        ctx.restore();
                        {
                            ctx.save();
                            ctx.lineWidth = 2;
                            const a = camera.getScreenPoint(borderX, borderY);
                            const b = camera.getScreenPoint(borderX + borderWidth, borderY + borderHeight);
                            ctx.save();
                            ctx.strokeStyle = theme.dark ? "#0a0a0a" : "#404040";
                            ctx.strokeRect(a.x - 2, a.y - 2, b.x - a.x + 4, b.y - a.y + 4);
                            ctx.restore();
                            ctx.lineWidth = 1;
                            ctx.strokeStyle = theme.dark ? "#a0a0a0" : "#f0f0f0";
                            ctx.strokeRect(a.x - 1, a.y - 1, b.x - a.x + 2, b.y - a.y + 2);
                            ctx.restore();
                        }
                    }
                }
                editor_8.OverlayLayer = OverlayLayer;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_9) {
                var controls = colibri.ui.controls;
                var json = scene.core.json;
                var FileUtils = colibri.ui.ide.FileUtils;
                class SceneEditor extends colibri.ui.ide.FileEditor {
                    static _factory;
                    static getFactory() {
                        return this._factory || (this._factory = new colibri.ui.ide.ContentTypeEditorFactory("Scene Editor", scene.core.CONTENT_TYPE_SCENE, () => new SceneEditor()));
                    }
                    _menuCreator;
                    _canvasContainer;
                    _layoutToolsManager;
                    _blocksProvider;
                    _outlineProvider;
                    _propertyProvider;
                    _game;
                    _overlayLayer;
                    _gameCanvas;
                    _scene;
                    _dropManager;
                    _cameraManager;
                    _selectionManager;
                    _toolsManager;
                    _mouseManager;
                    _clipboardManager;
                    _gameBooted;
                    _sceneRead;
                    _currentRefreshHash;
                    _editorState;
                    _localCoords;
                    _cellRendererCache;
                    constructor() {
                        super("phasereditor2d.SceneEditor", SceneEditor.getFactory());
                        this.addClass("SceneEditor");
                        this._blocksProvider = new ui.blocks.SceneEditorBlocksProvider(this);
                        this._outlineProvider = new editor_9.outline.SceneEditorOutlineProvider(this);
                        this._propertyProvider = new editor_9.properties.SceneEditorSectionProvider(this);
                        this._menuCreator = new editor_9.SceneEditorMenuCreator(this);
                        this._localCoords = true;
                        this._cellRendererCache = new editor_9.CellRendererCache();
                    }
                    getMenuCreator() {
                        return this._menuCreator;
                    }
                    isLocalCoords() {
                        return this._localCoords;
                    }
                    setLocalCoords(local, repaint = true) {
                        this._localCoords = local;
                        if (repaint) {
                            this.repaint();
                        }
                    }
                    async confirmUnlockProperty(props, propLabel, ...sectionId) {
                        const lockedObjects = this.getSelectedGameObjects().filter(obj => {
                            for (const prop of props) {
                                if (!obj.getEditorSupport().isUnlockedProperty(prop)) {
                                    return true;
                                }
                                return false;
                            }
                        });
                        if (lockedObjects.length > 0) {
                            return new Promise((resolve, _) => {
                                controls.dialogs.ConfirmDialog.show(`The ${propLabel} property is locked in ${lockedObjects.length} objects. Do you want to unlock it?`, "Unlock")
                                    .then(ok => {
                                    if (ok) {
                                        this.getUndoManager()
                                            .add(new ui.sceneobjects.PropertyUnlockOperation(this, lockedObjects, props, true));
                                        for (const id of sectionId) {
                                            this.updateInspectorViewSection(id);
                                        }
                                    }
                                    resolve(ok);
                                });
                            });
                        }
                        return true;
                    }
                    openSourceFileInEditor() {
                        const lang = this._scene.getSettings().compilerOutputLanguage;
                        const ext = lang === phasereditor2d.ide.core.code.SourceLang.JAVA_SCRIPT ? ".js" : ".ts";
                        const file = this.getInput().getSibling(this.getInput().getNameWithoutExtension() + ext);
                        if (file) {
                            colibri.Platform.getWorkbench().openEditor(file);
                        }
                    }
                    async doSave() {
                        // compile first because the SceneFinder will be updated after the file is changed.
                        await this.compile();
                        // saves the file
                        const sceneFile = this.getInput();
                        const writer = new json.SceneWriter(this.getScene());
                        const data = writer.toJSON();
                        const content = JSON.stringify(data, null, 4);
                        try {
                            await FileUtils.setFileString_async(sceneFile, content);
                            this.setDirty(false);
                            await this.updateTitleIcon();
                        }
                        catch (e) {
                            console.error(e);
                        }
                    }
                    _outputFileEditorState;
                    openOutputFileQuickEditorDialog() {
                        const file = this.getOutputFile();
                        if (!file) {
                            alert("The scene is not compiled yet. There isn't any file to edit.");
                            return;
                        }
                        const dlg = new colibri.ui.ide.QuickEditorDialog(file, this._outputFileEditorState);
                        dlg.create();
                        dlg.addButton("Play", () => {
                            colibri.Platform.getWorkbench().getCommandManager()
                                .executeCommand(phasereditor2d.ide.ui.actions.CMD_PLAY_PROJECT);
                        });
                        dlg.eventDialogClose.addListener(() => {
                            this._outputFileEditorState = dlg.getEditorState();
                            colibri.Platform.getWorkbench().setActiveEditor(this);
                        });
                    }
                    getOutputFile() {
                        const compiler = new scene.core.code.SceneCompiler(this._scene, this.getInput());
                        const outputFile = compiler.getOutputFile();
                        return outputFile;
                    }
                    async compile() {
                        const compiler = new scene.core.code.SceneCompiler(this._scene, this.getInput());
                        const outputFile = compiler.getOutputFile();
                        const dirtyEditors = colibri.Platform.getWorkbench()
                            .getOpenEditorsWithInput(outputFile)
                            .filter(editor => editor.isDirty());
                        if (dirtyEditors.length > 0) {
                            alert("Cannot overwrite the '" + outputFile.getName() + "' file, it is open in a dirty editor.");
                            return;
                        }
                        await compiler.compile();
                    }
                    saveState(state) {
                        if (!this._scene) {
                            return;
                        }
                        state.cameraState = this._cameraManager.getState();
                        state.toolsState = this._toolsManager.getState();
                        state.selectionState = this._selectionManager.getState();
                    }
                    restoreState(state) {
                        this._editorState = state;
                        this._toolsManager.setState(state.toolsState);
                    }
                    async onEditorInputContentChangedByExternalEditor() {
                        const file = this.getInput();
                        const str = await colibri.ui.ide.FileUtils.preloadAndGetFileString(file);
                        const sceneData = JSON.parse(str);
                        this.refreshSceneWithData(sceneData);
                    }
                    setInput(file) {
                        super.setInput(file);
                        // we do this here because the icon should be shown even if the editor is not created yet.
                        this.updateTitleIcon(true);
                    }
                    createPart() {
                        this.setLayoutChildren(false);
                        const container = document.createElement("div");
                        container.classList.add("SceneEditorContainer");
                        this.getElement().appendChild(container);
                        this._gameCanvas = scene.ScenePlugin.getInstance().getCanvasManager().takeCanvas();
                        this._gameCanvas.style.visibility = "hidden";
                        this._gameCanvas.classList.add("GameCanvas");
                        this._gameCanvas.style.position = "absolute";
                        container.appendChild(this._gameCanvas);
                        this._overlayLayer = new editor_9.OverlayLayer(this);
                        container.appendChild(this._overlayLayer.getCanvas());
                        this._canvasContainer = container;
                        this.createGame();
                        // init managers and factories
                        this._dropManager = new editor_9.DropManager(this);
                        this._selectionManager = new editor_9.SelectionManager(this);
                        this._toolsManager = new editor_9.tools.SceneToolsManager(this);
                        this._mouseManager = new editor_9.MouseManager(this);
                        this._cameraManager = new editor_9.CameraManager(this);
                        this._clipboardManager = new editor_9.ClipboardManager(this);
                        this._layoutToolsManager = new editor_9.LayoutToolsManager(this);
                        this._overlayLayer.getCanvas().addEventListener("contextmenu", e => this.onMenu(e));
                        this._layoutToolsManager.createElement();
                    }
                    getLayoutToolsManager() {
                        return this._layoutToolsManager;
                    }
                    getCanvasContainer() {
                        return this._canvasContainer;
                    }
                    registerThemeListener() {
                        colibri.Platform.getWorkbench().eventThemeChanged.addListener((theme) => {
                            const color = Phaser.Display.Color.HexStringToColor(theme.sceneBackground);
                            this._scene.renderer.config["backgroundColor"] = color;
                            this.repaint();
                        });
                    }
                    createGame() {
                        this._scene = new ui.Scene(this);
                        this._game = new Phaser.Game({
                            type: scene.ScenePlugin.DEFAULT_EDITOR_CANVAS_CONTEXT,
                            canvas: this._gameCanvas,
                            scale: {
                                mode: Phaser.Scale.NONE
                            },
                            // resolution: window.devicePixelRatio,
                            backgroundColor: controls.Controls.getTheme().sceneBackground,
                            render: {
                                pixelArt: scene.ScenePlugin.DEFAULT_EDITOR_PIXEL_ART,
                                transparent: false
                            },
                            audio: {
                                noAudio: true
                            },
                            physics: {
                                default: "arcade"
                            },
                            plugins: {
                                scene: [
                                    { key: "spine.SpinePlugin", plugin: spine.SpinePlugin, mapping: "spine" }
                                ]
                            },
                            scene: this._scene,
                        });
                        this._sceneRead = false;
                        this._gameBooted = false;
                        this._game.config.postBoot = () => {
                            // the scene is created just at this moment!
                            this.onGameBoot();
                        };
                        this.registerThemeListener();
                    }
                    async updateTitleIcon(force = false) {
                        const file = this.getInput();
                        await ui.SceneThumbnailCache.getInstance().preload(file, force);
                        const img = this.getIcon();
                        if (img) {
                            await img.preload();
                            this.dispatchTitleUpdatedEvent();
                        }
                        else {
                            this.dispatchTitleUpdatedEvent();
                        }
                    }
                    getIcon() {
                        const file = this.getInput();
                        if (file) {
                            if (scene.ScenePlugin.getInstance().getSceneFinder().isScriptPrefabFile(file)) {
                                return phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_BUILD);
                            }
                            const img = ui.SceneThumbnailCache.getInstance().getContent(file);
                            if (img) {
                                return img;
                            }
                        }
                        return super.getIcon();
                    }
                    _toolbarActionMap;
                    _toolsInToolbar;
                    createToolbarActions() {
                        if (this._toolbarActionMap) {
                            return;
                        }
                        this._toolbarActionMap = new Map();
                        this._toolsInToolbar = [
                            ui.sceneobjects.TranslateTool.ID,
                            ui.sceneobjects.ScaleTool.ID,
                            ui.sceneobjects.RotateTool.ID,
                            ui.sceneobjects.OriginTool.ID,
                            ui.sceneobjects.SelectionRegionTool.ID
                        ];
                        for (const toolId of this._toolsInToolbar) {
                            const tool = scene.ScenePlugin.getInstance().getTool(toolId);
                            this._toolbarActionMap.set(toolId, new controls.Action({
                                commandId: tool.getCommandId(),
                                showText: false
                            }));
                        }
                    }
                    getToolbarActionMap() {
                        return this._toolbarActionMap;
                    }
                    createEditorToolbar(parent) {
                        this.createToolbarActions();
                        const manager = new controls.ToolbarManager(parent);
                        for (const toolID of this._toolsInToolbar) {
                            const action = this._toolbarActionMap.get(toolID);
                            manager.add(action);
                        }
                        return manager;
                    }
                    onMenu(e) {
                        e.preventDefault();
                        const menu = new controls.Menu();
                        this.fillContextMenu(menu);
                        menu.createWithEvent(e);
                    }
                    fillContextMenu(menu) {
                        this._menuCreator.fillMenu(menu);
                    }
                    toggleSnapping() {
                        const enabled = !this.getScene().getSettings().snapEnabled;
                        this.getUndoManager().add(new editor_9.properties.ChangeSettingsPropertyOperation({
                            editor: this,
                            props: [
                                {
                                    name: "snapEnabled",
                                    value: enabled,
                                }
                            ],
                            repaint: true
                        }));
                    }
                    setSnappingToObjectSize() {
                        const obj = this.getSelectedGameObjects()[0];
                        if (obj) {
                            if (obj.width !== undefined && obj.height !== undefined) {
                                this.getUndoManager().add(new editor_9.properties.ChangeSettingsPropertyOperation({
                                    editor: this,
                                    props: [
                                        {
                                            name: "snapEnabled",
                                            value: true,
                                        },
                                        {
                                            name: "snapWidth",
                                            value: obj.width
                                        },
                                        {
                                            name: "snapHeight",
                                            value: obj.height
                                        }
                                    ],
                                    repaint: true
                                }));
                            }
                        }
                    }
                    async readScene() {
                        const maker = this._scene.getMaker();
                        this._sceneRead = true;
                        try {
                            const file = this.getInput();
                            await FileUtils.preloadFileString(file);
                            const content = FileUtils.getFileString(file);
                            const data = JSON.parse(content);
                            scene.ScenePlugin.getInstance().runSceneDataMigrations(data);
                            if (ui.SceneMaker.isValidSceneDataFormat(data)) {
                                this._overlayLayer.setLoading(true);
                                this._overlayLayer.render();
                                await maker.preload();
                                await maker.updateSceneLoader(data, this._overlayLayer.createLoadingMonitor());
                                const errors = [];
                                maker.createScene(data, errors);
                                this._overlayLayer.setLoading(false);
                                this._overlayLayer.render();
                                if (errors.length > 0) {
                                    alert(errors.join("<br>"));
                                }
                                this.refreshBlocks();
                            }
                            else {
                                alert("Invalid file format.");
                            }
                        }
                        catch (e) {
                            alert(e.message);
                            throw e;
                        }
                    }
                    isLoading() {
                        return this._overlayLayer && this._overlayLayer.isLoading();
                    }
                    getSelectedGameObjects() {
                        return this.getSelection()
                            .filter(obj => ui.sceneobjects.isGameObject(obj));
                    }
                    getSelectedLists() {
                        return this.getSelection()
                            .filter(obj => obj instanceof ui.sceneobjects.ObjectList);
                    }
                    getSelectedListItems() {
                        return this.getSelection()
                            .filter(obj => obj instanceof ui.sceneobjects.ObjectListItem);
                    }
                    getSelectedPlainObjects() {
                        return this.getSelection().filter(obj => ui.sceneobjects.ScenePlainObjectEditorSupport.hasEditorSupport(obj));
                    }
                    getSelectedCodeSnippets() {
                        return this.getSelection()
                            .filter(obj => obj instanceof ui.codesnippets.CodeSnippet);
                    }
                    getSelectedUserComponentNodes() {
                        return this.getSelection().filter(obj => obj instanceof ui.sceneobjects.UserComponentNode);
                    }
                    getSelectedPrefabProperties() {
                        return this.getSelection().filter(obj => obj instanceof ui.sceneobjects.UserProperty);
                    }
                    getCameraManager() {
                        return this._cameraManager;
                    }
                    getDropManager() {
                        return this._dropManager;
                    }
                    getClipboardManager() {
                        return this._clipboardManager;
                    }
                    getToolsManager() {
                        return this._toolsManager;
                    }
                    getMouseManager() {
                        return this._mouseManager;
                    }
                    getSelectionManager() {
                        return this._selectionManager;
                    }
                    getOverlayLayer() {
                        return this._overlayLayer;
                    }
                    getScene() {
                        return this._scene;
                    }
                    getGame() {
                        return this._game;
                    }
                    getSceneMaker() {
                        return this._scene.getMaker();
                    }
                    getPackFinder() {
                        return this.getSceneMaker().getPackFinder();
                    }
                    layout() {
                        super.layout();
                        if (!this._game) {
                            return;
                        }
                        this._overlayLayer.resizeTo();
                        const parent = this._gameCanvas.parentElement;
                        const w = parent.clientWidth;
                        const h = parent.clientHeight;
                        this._game.scale.resize(w, h);
                        if (this._gameBooted) {
                            this._scene.getCamera().setSize(w, h);
                            this.repaint();
                        }
                    }
                    updateInspectorViewSection(sectionId, repaint = true) {
                        if (repaint) {
                            this.repaint();
                        }
                        const window = colibri.Platform.getWorkbench().getActiveWindow();
                        const view = window.getView(colibri.inspector.ui.views.InspectorView.VIEW_ID);
                        const section = view.getPropertyPage().getSection(sectionId);
                        if (section) {
                            section.updateWithSelection();
                        }
                    }
                    getPropertyProvider() {
                        return this._propertyProvider;
                    }
                    getCellRendererCache() {
                        return this._cellRendererCache;
                    }
                    onPartClosed() {
                        if (super.onPartClosed()) {
                            if (this._scene) {
                                this._scene.destroyGame();
                                scene.ScenePlugin.getInstance().getCanvasManager().releaseCanvas(this._game.canvas);
                            }
                            this._cellRendererCache.clear();
                            return true;
                        }
                        return false;
                    }
                    async refreshScene() {
                        console.log("Scene Editor: refreshing.");
                        const writer = new json.SceneWriter(this._scene);
                        const sceneData = writer.toJSON();
                        await this.refreshSceneWithData(sceneData);
                    }
                    async refreshSceneWithData(sceneData) {
                        for (const obj of this._scene.getGameObjects()) {
                            obj.getEditorSupport().destroy();
                        }
                        this._scene.removeAll();
                        const maker = this.getSceneMaker();
                        await maker.preload();
                        await maker.updateSceneLoader(sceneData);
                        maker.createScene(sceneData);
                        const sel = this.getSelection()
                            .map(obj => ui.sceneobjects.isGameObject(obj) ?
                            this._scene.getByEditorId(obj.getEditorSupport().getId())
                            : obj)
                            .filter(v => v !== null && v !== undefined);
                        this.setSelection(sel);
                        this._currentRefreshHash = await this.buildDependenciesHash();
                        this.refreshOutline();
                        await this.updateTitleIcon(true);
                    }
                    async buildDependenciesHash() {
                        const maker = this._scene.getMaker();
                        await maker.getPackFinder().preload();
                        const hash = await maker.buildDependenciesHash();
                        return hash;
                    }
                    async refreshDependenciesHash() {
                        this._currentRefreshHash = await this.buildDependenciesHash();
                    }
                    async onPartActivated() {
                        super.onPartActivated();
                        await this.updateWithExternalChanges();
                    }
                    onFileStorageChanged(change) {
                        if (change.getCause() === colibri.core.io.FileStorageChangeCause.WINDOW_FOCUS) {
                            this.updateWithExternalChanges();
                        }
                    }
                    async updateWithExternalChanges() {
                        console.log("SceneEditor.updateWithExternalChanges()");
                        if (this._scene) {
                            const hash = await this.buildDependenciesHash();
                            if (this._currentRefreshHash !== null
                                && this._currentRefreshHash !== undefined
                                && hash !== this._currentRefreshHash) {
                                console.log("Scene Editor: " + this.getInput().getFullName() + " dependency changed.");
                                await this.refreshScene();
                            }
                        }
                        await this.refreshBlocks();
                    }
                    async refreshBlocks() {
                        if (this._blocksProvider) {
                            await this._blocksProvider.preload();
                            this._blocksProvider.repaint();
                        }
                    }
                    getEditorViewerProvider(key) {
                        switch (key) {
                            case phasereditor2d.blocks.ui.views.BlocksView.EDITOR_VIEWER_PROVIDER_KEY:
                                return this._blocksProvider;
                            case phasereditor2d.outline.ui.views.OutlineView.EDITOR_VIEWER_PROVIDER_KEY:
                                return this._outlineProvider;
                            default:
                                break;
                        }
                        return null;
                    }
                    getBlocksProvider() {
                        return this._blocksProvider;
                    }
                    getOutlineProvider() {
                        return this._outlineProvider;
                    }
                    refreshOutline() {
                        this._outlineProvider.repaint();
                    }
                    async onGameBoot() {
                        this._gameBooted = true;
                        this._gameCanvas.style.visibility = "visible";
                        if (!this._sceneRead) {
                            await this.readScene();
                            if (this._editorState) {
                                this._cameraManager.setState(this._editorState.cameraState);
                                this._selectionManager.setState(this._editorState.selectionState);
                            }
                            else {
                                this.setSelection([]);
                            }
                            this._editorState = null;
                            this._currentRefreshHash = await this.buildDependenciesHash();
                        }
                        this.layout();
                        this.refreshOutline();
                        // for some reason, we should do this after a time, or the game is not stopped well.
                        setTimeout(() => {
                            this._game.loop.stop();
                        }, 500);
                        await this.updateTitleIcon(true);
                    }
                    repaint() {
                        if (!this._gameBooted) {
                            return;
                        }
                        try {
                            this._game.loop.tick();
                            this._overlayLayer.render();
                        }
                        catch (e) {
                            console.log(e);
                            alert(e.message);
                        }
                    }
                }
                editor_9.SceneEditor = SceneEditor;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_10) {
                var controls = colibri.ui.controls;
                class SceneEditorMenuCreator {
                    _editor;
                    constructor(editor) {
                        this._editor = editor;
                    }
                    fillMenu(menu) {
                        menu.addMenu(this.createToolsMenu());
                        menu.addMenu(this.createCoordsMenu());
                        menu.addMenu(this.createLayoutMenu());
                        menu.addSeparator();
                        menu.addMenu(this.createAddObjectMenu());
                        menu.addMenu(this.createAddCodeSnippetMenu());
                        menu.addSeparator();
                        menu.addMenu(this.createPrefabMenu());
                        menu.addMenu(this.createScriptingMenu());
                        menu.addMenu(this.createTypeMenu());
                        menu.addMenu(this.createOriginMenu());
                        menu.addMenu(this.createTextureMenu());
                        menu.addMenu(this.createArcadePhysicsMenu());
                        menu.addMenu(this.createFXMenu());
                        menu.addMenu(this.createParentMenu());
                        menu.addSeparator();
                        menu.addMenu(this.createSnappingMenu());
                        menu.addMenu(this.createEditMenu());
                        menu.addSeparator();
                        menu.addMenu(this.createSceneMenu());
                        menu.addMenu(this.createCompilerMenu());
                    }
                    createFXMenu() {
                        const menu = new controls.Menu("FX");
                        const exts = scene.ScenePlugin.getInstance().getFXExtensions();
                        const selection = this._editor.getSelectedGameObjects();
                        const parents = selection.map(obj => {
                            if (obj.getEditorSupport().isDisplayObject()) {
                                return obj;
                            }
                            if (obj instanceof ui.sceneobjects.FXObject) {
                                return obj.getParent();
                            }
                            return undefined;
                        }).filter(obj => obj && ui.sceneobjects.FXObjectExtension.allowGameObject(obj));
                        const enabled = parents.length > 0;
                        for (const ext of exts) {
                            const factories = ext.getFXObjectFactories();
                            if (factories.length > 0) {
                                const menu2 = new controls.Menu(ext.getTypeName(), ext.getIcon());
                                menu.addMenu(menu2);
                                for (const factory of factories) {
                                    menu2.addAction({
                                        text: "Add " + factory.factoryName,
                                        icon: ext.getIcon(),
                                        enabled,
                                        callback: () => {
                                            this._editor.getDropManager().addFXObjects(factory);
                                        }
                                    });
                                }
                            }
                            else {
                                menu.addAction({
                                    text: "Add " + ext.getTypeName(),
                                    icon: ext.getIcon(),
                                    enabled,
                                    callback: () => {
                                        this._editor.getDropManager().addFXObjects(ext);
                                    }
                                });
                            }
                        }
                        return menu;
                    }
                    createAddCodeSnippetMenu() {
                        const menu = new controls.Menu("Code Snippets");
                        for (const ext of scene.ScenePlugin.getInstance().getCodeSnippetExtensions()) {
                            menu.addAction({
                                text: "Add " + ext.getName(),
                                icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_BUILD),
                                enabled: ext.isEnabledFor(this._editor),
                                callback: async () => {
                                    const snippets = await ext.createAndConfigureCodeSnippets();
                                    if (snippets) {
                                        this._editor.getUndoManager().add(new ui.codesnippets.CodeSnippetsSnapshotOperation(this._editor, async () => {
                                            for (const snippet of snippets) {
                                                this._editor.getScene().addCodeSnippet(snippet);
                                            }
                                            this._editor.setSelection(snippets);
                                        }));
                                    }
                                }
                            });
                        }
                        return menu;
                    }
                    createScriptingMenu() {
                        const menu = new controls.Menu("Scripting");
                        menu.addCommand(editor_10.commands.CMD_OPEN_ADD_SCRIPT_DIALOG);
                        menu.addCommand(editor_10.commands.CMD_OPEN_SCRIPT_DIALOG);
                        menu.addSeparator();
                        menu.addCommand(editor_10.commands.CMD_ADD_USER_COMPONENT);
                        menu.addCommand(editor_10.commands.CMD_BROWSE_USER_COMPONENTS);
                        return menu;
                    }
                    createArcadePhysicsMenu() {
                        const menu = new controls.Menu("Arcade Physics");
                        menu.addCommand(editor.commands.CMD_ARCADE_ENABLE_BODY, {
                            text: "Add Body"
                        });
                        menu.addCommand(editor.commands.CMD_ARCADE_DISABLE_BODY, {
                            text: "Remove Body"
                        });
                        menu.addSeparator();
                        menu.addCommand(editor.commands.CMD_ARCADE_CENTER_BODY, {
                            text: "Center Body"
                        });
                        menu.addCommand(editor.commands.CMD_ARCADE_RESIZE_TO_OBJECT_BODY, {
                            text: "Resize Body To Object Size"
                        });
                        return menu;
                    }
                    createAddObjectMenu() {
                        const blocksProvider = this._editor.getEditorViewerProvider(phasereditor2d.blocks.ui.views.BlocksView.EDITOR_VIEWER_PROVIDER_KEY);
                        const contentProvider = blocksProvider.getContentProvider();
                        const labelProvider = blocksProvider.getLabelProvider();
                        const cellRendererProvider = blocksProvider.getCellRendererProvider();
                        const menu = new controls.Menu("Add Object");
                        menu.addCommand(editor_10.commands.CMD_ADD_OBJECT, {
                            text: "Add..."
                        });
                        for (const cat of scene.SCENE_OBJECT_CATEGORIES) {
                            const menu2 = new controls.Menu(cat);
                            const list = contentProvider.getChildren(cat);
                            for (const obj of list) {
                                menu2.addAction({
                                    text: labelProvider.getLabel(obj),
                                    icon: new controls.viewers.ImageFromCellRenderer(obj, cellRendererProvider.getCellRenderer(obj), controls.RENDER_ICON_SIZE, controls.RENDER_ICON_SIZE),
                                    callback: () => {
                                        this._editor.getDropManager().dropDataAtCenter([obj]);
                                    }
                                });
                            }
                            menu.addMenu(menu2);
                        }
                        return menu;
                    }
                    createSceneMenu() {
                        const menu = new controls.Menu("Scene");
                        menu.addCommand(colibri.ui.ide.actions.CMD_UPDATE_CURRENT_EDITOR, {
                            text: "Refresh Scene"
                        });
                        menu.addCommand(editor_10.commands.CMD_DUPLICATE_SCENE_FILE, {
                            text: "Duplicate Scene"
                        });
                        menu.addAction({
                            text: "Settings",
                            callback: () => this._editor.setSelection([])
                        });
                        menu.addCommand(editor_10.commands.CMD_PREVIEW_SCENE, {
                            text: "Preview"
                        });
                        return menu;
                    }
                    createCompilerMenu(menu = new controls.Menu("Compiler")) {
                        menu.addCommand(editor_10.commands.CMD_COMPILE_SCENE_EDITOR);
                        menu.addSeparator();
                        menu.addCommand(editor_10.commands.CMD_OPEN_COMPILED_FILE);
                        if (phasereditor2d.ide.IDEPlugin.getInstance().isDesktopMode()) {
                            menu.addCommand(editor_10.commands.CMD_OPEN_OUTPUT_FILE_IN_VSCODE);
                        }
                        menu.addCommand(editor_10.commands.CMD_QUICK_EDIT_OUTPUT_FILE);
                        return menu;
                    }
                    createEditMenu() {
                        const menu = new controls.Menu("Edit");
                        menu.addCommand(colibri.ui.ide.actions.CMD_UNDO);
                        menu.addCommand(colibri.ui.ide.actions.CMD_REDO);
                        menu.addSeparator();
                        menu.addCommand(colibri.ui.ide.actions.CMD_CUT);
                        menu.addCommand(colibri.ui.ide.actions.CMD_COPY);
                        menu.addCommand(colibri.ui.ide.actions.CMD_PASTE);
                        menu.addCommand(editor_10.commands.CMD_PASTE_IN_PLACE);
                        menu.addCommand(colibri.ui.ide.actions.CMD_DELETE);
                        menu.addSeparator();
                        menu.addCommand(editor_10.commands.CMD_SORT_OBJ_UP);
                        menu.addCommand(editor_10.commands.CMD_SORT_OBJ_DOWN);
                        menu.addCommand(editor_10.commands.CMD_SORT_OBJ_TOP);
                        menu.addCommand(editor_10.commands.CMD_SORT_OBJ_BOTTOM);
                        return menu;
                    }
                    createOriginMenu() {
                        const menu = new controls.Menu("Origin");
                        this.createOriginMenuItems(menu);
                        return menu;
                    }
                    createOriginMenuItems(menu) {
                        for (const data of editor_10.commands.SceneEditorCommands.computeOriginCommandData()) {
                            menu.addCommand(data.command);
                        }
                    }
                    createCoordsMenuItems(menu) {
                        menu.add(new controls.Action({
                            callback: () => this._editor.setLocalCoords(true),
                            text: "Local",
                            selected: this._editor.isLocalCoords()
                        }));
                        menu.add(new controls.Action({
                            callback: () => this._editor.setLocalCoords(false),
                            text: "Global",
                            selected: !this._editor.isLocalCoords()
                        }));
                    }
                    createCoordsMenu() {
                        const menu = new controls.Menu("Coords");
                        this.createCoordsMenuItems(menu);
                        return menu;
                    }
                    createLayoutMenu() {
                        const menu = new controls.Menu("Layout");
                        menu.addAction({
                            text: "Show Layout Bar",
                            callback: () => this._editor.getLayoutToolsManager().togglePaneVisible(),
                            selected: this._editor.getLayoutToolsManager().isPaneVisible()
                        });
                        const extsByGroup = scene.ScenePlugin.getInstance().getLayoutExtensionsByGroup();
                        for (const groupSet of extsByGroup) {
                            const groupMenu = new controls.Menu(groupSet.group);
                            menu.addMenu(groupMenu);
                            for (const ext of groupSet.extensions) {
                                const config = ext.getConfig();
                                groupMenu.addAction({
                                    text: config.name,
                                    icon: config.icon,
                                    callback: () => ext.performLayout(this._editor)
                                });
                            }
                        }
                        return menu;
                    }
                    createToolsMenu() {
                        const menu = new controls.Menu("Tools");
                        const activeTool = this._editor.getToolsManager().getActiveTool();
                        const exts = colibri.Platform.getExtensions(editor_10.tools.SceneToolExtension.POINT_ID);
                        for (const ext of exts) {
                            for (const tool of ext.getTools()) {
                                menu.addCommand(tool.getCommandId(), {
                                    selected: activeTool === tool
                                });
                            }
                        }
                        return menu;
                    }
                    createPrefabMenu() {
                        const menu = new controls.Menu("Prefab");
                        menu.addCommand(editor_10.commands.CMD_OPEN_PREFAB);
                        menu.addCommand(editor_10.commands.CMD_CREATE_PREFAB_WITH_OBJECT);
                        menu.addSeparator();
                        menu.addCommand(editor_10.commands.CMD_ADD_PREFAB_PROPERTY);
                        return menu;
                    }
                    createTypeMenuItems(menu) {
                        menu.addCommand(editor_10.commands.CMD_CONVERT_OBJECTS);
                        menu.addCommand(editor_10.commands.CMD_CONVERT_TO_TILE_SPRITE_OBJECTS);
                    }
                    createTypeMenu() {
                        const menu = new controls.Menu("Type");
                        this.createTypeMenuItems(menu);
                        return menu;
                    }
                    createParentMenu() {
                        const menu = new controls.Menu("Parent");
                        menu.addCommand(editor_10.commands.CMD_JOIN_IN_LAYER);
                        menu.addSeparator();
                        menu.addCommand(editor_10.commands.CMD_JOIN_IN_CONTAINER);
                        menu.addCommand(editor_10.commands.CMD_TRIM_CONTAINER);
                        menu.addSeparator();
                        menu.addCommand(editor_10.commands.CMD_BREAK_PARENT);
                        menu.addCommand(editor_10.commands.CMD_MOVE_TO_PARENT);
                        menu.addCommand(editor_10.commands.CMD_SELECT_PARENT);
                        menu.addCommand(editor_10.commands.CMD_SELECT_CHILDREN);
                        return menu;
                    }
                    createSnappingMenu() {
                        const menu = new controls.Menu("Snapping");
                        menu.addCommand(editor_10.commands.CMD_TOGGLE_SNAPPING);
                        menu.addCommand(editor_10.commands.CMD_SET_SNAPPING_TO_OBJECT_SIZE);
                        menu.addSeparator();
                        menu.addCommand(editor_10.commands.CMD_MOVE_OBJECT_LEFT);
                        menu.addCommand(editor_10.commands.CMD_MOVE_OBJECT_RIGHT);
                        menu.addCommand(editor_10.commands.CMD_MOVE_OBJECT_UP);
                        menu.addCommand(editor_10.commands.CMD_MOVE_OBJECT_DOWN);
                        menu.addCommand(editor_10.commands.CMD_MOVE_OBJECT_LEFT + "Large");
                        menu.addCommand(editor_10.commands.CMD_MOVE_OBJECT_RIGHT + "Large");
                        menu.addCommand(editor_10.commands.CMD_MOVE_OBJECT_UP + "Large");
                        menu.addCommand(editor_10.commands.CMD_MOVE_OBJECT_DOWN + "Large");
                        return menu;
                    }
                    createTextureMenu() {
                        const menu = new controls.Menu("Texture");
                        this.createTextureMenuItems(menu);
                        return menu;
                    }
                    createTextureMenuItems(menu) {
                        menu.addCommand(editor_10.commands.CMD_SELECT_ALL_OBJECTS_SAME_TEXTURE);
                        menu.addCommand(editor_10.commands.CMD_REPLACE_TEXTURE);
                        menu.addCommand(editor_10.commands.CMD_REPLACE_TEXTURE_FRAME);
                        const obj = this._editor.getSelectedGameObjects()[0];
                        if (obj) {
                            if (obj.getEditorSupport().hasComponent(ui.sceneobjects.TextureComponent)) {
                                const comp = obj.getEditorSupport().getComponent(ui.sceneobjects.TextureComponent);
                                const keys = comp.getTextureKeys();
                                if (keys) {
                                    const item = this._editor.getScene().getMaker().getPackFinder().findAssetPackItem(keys.key);
                                    if (item) {
                                        menu.addAction({
                                            text: "Show Texture In Asset Pack Editor",
                                            callback: () => {
                                                const file = item.getPack().getFile();
                                                const editor = colibri.Platform.getWorkbench().openEditor(file);
                                                editor.revealKey(item.getKey());
                                            }
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
                editor_10.SceneEditorMenuCreator = SceneEditorMenuCreator;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_15) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_11) {
                class SelectionManager {
                    _editor;
                    constructor(editor) {
                        this._editor = editor;
                        this._editor.eventSelectionChanged.addListener(() => this.updateOutlineSelection());
                    }
                    getSelectionIds() {
                        const list = [];
                        const selection = this._editor.getSelection();
                        const selectedObjects = this._editor.getSelectedGameObjects();
                        const selectedPlainObjects = this._editor.getSelectedPlainObjects();
                        const selectedCodeSnippets = this._editor.getSelectedCodeSnippets();
                        list.push(...selectedObjects
                            .map(obj => obj.getEditorSupport().getId()));
                        list.push(...selectedPlainObjects
                            .map(obj => obj.getEditorSupport().getId()));
                        list.push(...selectedCodeSnippets
                            .map((s) => s.getId()));
                        list.push(...selection
                            .filter(obj => obj instanceof ui.sceneobjects.ObjectList)
                            .map(obj => obj.getId()));
                        list.push(...selection
                            .filter(obj => obj instanceof ui.sceneobjects.ObjectListItem)
                            .map(obj => obj.getId()));
                        list.push(...selection
                            .filter(i => i instanceof ui.sceneobjects.UserComponentNode)
                            .map((i) => i.getId()));
                        list.push(...selection
                            .filter(obj => obj instanceof ui.sceneobjects.UserProperty)
                            .map((p) => `prefabProperty#${p.getName()}`));
                        return list;
                    }
                    setSelectionByIds(selectionIds) {
                        const scene = this._editor.getScene();
                        const objMap = scene.buildObjectIdMap();
                        const userCompMap = scene.buildUserComponentIdMap();
                        const map = new Map([...objMap, ...userCompMap]);
                        for (const [k, v] of objMap) {
                            map.set(k, v);
                        }
                        for (const [k, v] of objMap) {
                            map.set(k, v);
                        }
                        for (const obj of scene.getPlainObjects()) {
                            map.set(obj.getEditorSupport().getId(), obj);
                        }
                        for (const list of this._editor.getScene().getObjectLists().getLists()) {
                            map.set(list.getId(), list);
                            for (const item of list.getItems()) {
                                map.set(item.getId(), item);
                            }
                        }
                        for (const prop of scene.getPrefabUserProperties().getProperties()) {
                            map.set(`prefabProperty#${prop.getName()}`, prop);
                        }
                        for (const snippet of scene.getCodeSnippets().getSnippets()) {
                            map.set(snippet.getId(), snippet);
                        }
                        const sel = selectionIds
                            .map(id => map.get(id))
                            .filter(obj => obj !== undefined);
                        this._editor.setSelection(sel);
                    }
                    getState() {
                        return this.getSelectionIds();
                    }
                    setState(state) {
                        if (state) {
                            this.setSelectionByIds(state);
                        }
                        else {
                            this._editor.setSelection([]);
                        }
                    }
                    clearSelection() {
                        this._editor.setSelection([]);
                        this._editor.repaint();
                    }
                    refreshSelection() {
                        this._editor.setSelection(this._editor.getSelection()
                            .map(obj => {
                            const scene = this._editor.getScene();
                            const objMap = scene.buildObjectIdMap();
                            if (ui.sceneobjects.isGameObject(obj)) {
                                return objMap.get(obj.getEditorSupport().getId());
                            }
                            if (ui.sceneobjects.ScenePlainObjectEditorSupport.hasEditorSupport(obj)) {
                                return scene.getPlainObjectById(obj.getEditorSupport().getId());
                            }
                            if (obj instanceof ui.sceneobjects.ObjectList) {
                                return scene.getObjectLists().getListById(obj.getId());
                            }
                            if (obj instanceof ui.sceneobjects.UserProperty) {
                                return scene.getPrefabUserProperties().getProperties()
                                    .find(p => p.getName() === obj.getName());
                            }
                            return undefined;
                        })
                            .filter(obj => obj !== undefined && obj !== null));
                    }
                    selectAll() {
                        const sel = this._editor.getScene().getGameObjects();
                        this._editor.setSelection(sel);
                        this._editor.repaint();
                    }
                    updateOutlineSelection() {
                        const provider = this._editor.getOutlineProvider();
                        const sel = this._editor.getSelection();
                        provider.setSelection(sel, true, true);
                        provider.repaint();
                    }
                    canPickObject(obj) {
                        const objES = obj.getEditorSupport();
                        if (objES.isPrefabInstanceElement()) {
                            if (objES.isPrefeabInstanceAppendedChild() || objES.isMutableNestedPrefabInstance()) {
                                return true;
                            }
                            return false;
                        }
                        return this.parentsAllowPickingChildren(obj);
                    }
                    parentsAllowPickingChildren(obj) {
                        const parent = obj.getEditorSupport().getObjectParent();
                        if (parent) {
                            return parent.getEditorSupport().isAllowPickChildren() && this.canPickObject(parent);
                        }
                        return true;
                    }
                    findPickableObject(obj) {
                        const objES = obj.getEditorSupport();
                        if (objES.isPrefabInstanceElement()) {
                            if (objES.isMutableNestedPrefabInstance() || objES.isPrefeabInstanceAppendedChild()) {
                                if (this.parentsAllowPickingChildren(obj)) {
                                    return obj;
                                }
                            }
                            const parent = obj.getEditorSupport().getObjectParent();
                            return this.findPickableObject(parent);
                        }
                        return obj;
                    }
                    onMouseClick(e) {
                        const result = this.hitTestOfActivePointer();
                        let next = [];
                        if (result && result.length > 0) {
                            const current = this._editor.getSelection();
                            let selected = result[result.length - 1];
                            if (selected) {
                                selected = this.findPickableObject(selected);
                            }
                            if (selected) {
                                const objParent = selected.getEditorSupport().getObjectParent();
                                if (objParent) {
                                    if (!objParent.getEditorSupport().isAllowPickChildren()) {
                                        selected = objParent;
                                    }
                                }
                            }
                            if (e.ctrlKey || e.metaKey) {
                                if (new Set(current).has(selected)) {
                                    next = current.filter(obj => obj !== selected);
                                }
                                else {
                                    next = current;
                                    next.push(selected);
                                }
                            }
                            else if (selected) {
                                next = [selected];
                            }
                        }
                        this._editor.setSelection(next);
                        this._editor.repaint();
                    }
                    hitTestOfActivePointer() {
                        const scene = this._editor.getScene();
                        const manager = scene.input.manager;
                        const objects = scene.getInputSortedObjects();
                        const result = manager.hitTest(scene.input.activePointer, objects, scene.getCamera());
                        return result;
                    }
                }
                editor_11.SelectionManager = SelectionManager;
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_15.ui || (scene_15.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_16) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_12) {
                var commands;
                (function (commands) {
                    var controls = colibri.ui.controls;
                    commands.CAT_SCENE_EDITOR = "phasereditor2d.scene.ui.editor.commands.SceneEditor";
                    commands.CMD_ADD_OBJECT = "phasereditor2d.scene.ui.editor.commands.AddObject";
                    commands.CMD_JOIN_IN_CONTAINER = "phasereditor2d.scene.ui.editor.commands.JoinInContainer";
                    commands.CMD_JOIN_IN_LAYER = "phasereditor2d.scene.ui.editor.commands.JoinInLayer";
                    commands.CMD_BREAK_PARENT = "phasereditor2d.scene.ui.editor.commands.BreakContainer";
                    commands.CMD_TRIM_CONTAINER = "phasereditor2d.scene.ui.editor.commands.TrimContainer";
                    commands.CMD_MOVE_TO_PARENT = "phasereditor2d.scene.ui.editor.commands.MoveToParent";
                    commands.CMD_SELECT_PARENT = "phasereditor2d.scene.ui.editor.commands.SelectParent";
                    commands.CMD_SELECT_CHILDREN = "phasereditor2d.scene.ui.editor.commands.SelectChildren";
                    commands.CMD_TOGGLE_VISIBLE = "phasereditor2d.scene.ui.editor.commands.ToggleVisibility";
                    commands.CMD_OPEN_COMPILED_FILE = "phasereditor2d.scene.ui.editor.commands.OpenCompiledFile";
                    commands.CMD_COMPILE_SCENE_EDITOR = "phasereditor2d.scene.ui.editor.commands.CompileSceneEditor";
                    commands.CMD_TRANSLATE_SCENE_OBJECT = "phasereditor2d.scene.ui.editor.commands.MoveSceneObject";
                    commands.CMD_SET_ORIGIN_SCENE_OBJECT = "phasereditor2d.scene.ui.editor.commands.SetOriginSceneObject";
                    commands.CMD_ROTATE_SCENE_OBJECT = "phasereditor2d.scene.ui.editor.commands.RotateSceneObject";
                    commands.CMD_SCALE_SCENE_OBJECT = "phasereditor2d.scene.ui.editor.commands.ScaleSceneObject";
                    commands.CMD_EDIT_POLYGON_OBJECT = "phasereditor2d.scene.ui.editor.commands.EditPolygonObject";
                    commands.CMD_RESIZE_SCENE_OBJECT = "phasereditor2d.scene.ui.editor.commands.ResizeSceneObject";
                    commands.CMD_EDIT_SLICE_SCENE_OBJECT = "phasereditor2d.scene.ui.editor.commands.EditSliceSceneObject";
                    commands.CMD_EDIT_ARCADE_BODY = "phasereditor2d.scene.ui.editor.commands.EditArcadeBody";
                    commands.CMD_SELECT_REGION = "phasereditor2d.scene.ui.editor.commands.SelectRegion";
                    commands.CMD_PAN_SCENE = "phasereditor2d.scene.ui.editor.commands.PanScene";
                    commands.CMD_TOGGLE_SNAPPING = "phasereditor2d.scene.ui.editor.commands.ToggleSnapping";
                    commands.CMD_SET_SNAPPING_TO_OBJECT_SIZE = "phasereditor2d.scene.ui.editor.commands.SetSnappingToObjectSize";
                    commands.CMD_CONVERT_OBJECTS = "phasereditor2d.scene.ui.editor.commands.MorphObjects";
                    commands.CMD_CONVERT_TO_TILE_SPRITE_OBJECTS = "phasereditor2d.scene.ui.editor.commands.ConvertToTileSprite";
                    commands.CMD_SELECT_ALL_OBJECTS_SAME_TEXTURE = "phasereditor2d.scene.ui.editor.commands.SelectAllObjectsWithSameTexture";
                    commands.CMD_REPLACE_TEXTURE = "phasereditor2d.scene.ui.editor.commands.ReplaceTexture";
                    commands.CMD_REPLACE_TEXTURE_FRAME = "phasereditor2d.scene.ui.editor.commands.ReplaceTextureFrame";
                    commands.CMD_OPEN_PREFAB = "phasereditor2d.scene.ui.editor.commands.OpenPrefab";
                    commands.CMD_CREATE_PREFAB_WITH_OBJECT = "phasereditor2d.scene.ui.editor.commands.CreatePrefabWithObject";
                    commands.CMD_QUICK_EDIT_OUTPUT_FILE = "phasereditor2d.scene.ui.editor.commands.QuickEditOutputFile";
                    commands.CMD_OPEN_OUTPUT_FILE_IN_VSCODE = "phasereditor2d.scene.ui.editor.commands.OpenOutputFileInVSCode";
                    commands.CMD_MOVE_OBJECT_LEFT = "phasereditor2d.scene.ui.editor.commands.MoveObjectLeft";
                    commands.CMD_MOVE_OBJECT_RIGHT = "phasereditor2d.scene.ui.editor.commands.MoveObjectRight";
                    commands.CMD_MOVE_OBJECT_UP = "phasereditor2d.scene.ui.editor.commands.MoveObjectUp";
                    commands.CMD_MOVE_OBJECT_DOWN = "phasereditor2d.scene.ui.editor.commands.MoveObjectDown";
                    commands.CMD_FIX_SCENE_FILES_ID = "phasereditor2d.scene.ui.editor.commands.FixSceneFilesID";
                    commands.CMD_DUPLICATE_SCENE_FILE = "phasereditor2d.scene.ui.editor.commands.DuplicateSceneFile";
                    commands.CMD_CLEAR_SCENE_THUMBNAIL_CACHE = "phasereditor2d.scene.ui.editor.commands.ClearSceneThumbnailCache";
                    commands.CMD_MIGRATE_AND_BUILD_ALL_SCENE_FILES = "phasereditor2d.scene.ui.editor.commands.MigrateAndBuildAllSceneFiles";
                    commands.CMD_OPEN_SCENE_FILE = "phasereditor2d.scene.ui.editor.commands.OpenSceneFile";
                    commands.CMD_DISABLE_AWAKE_EVENT_PREFABS = "phasereditor2d.scene.ui.editor.commands.DisableAwakeEventPrefabs";
                    commands.CMD_SET_DEFAULT_RENDER_TYPE_TO_CANVAS = "phasereditor2d.scene.ui.editor.commands.SetDefaultRenderTypeToCanvas";
                    commands.CMD_SET_DEFAULT_RENDER_TYPE_TO_WEBGL = "phasereditor2d.scene.ui.editor.commands.SetDefaultRenderTypeToWebGL";
                    commands.CMD_ENABLE_PIXEL_ART_RENDERING = "phasereditor2d.scene.ui.editor.commands.EnablePixelArtRendering";
                    commands.CMD_DISABLE_PIXEL_ART_RENDERING = "phasereditor2d.scene.ui.editor.commands.DisablePixelArtRendering";
                    commands.CMD_PASTE_IN_PLACE = "phasereditor2d.scene.ui.editor.commands.PasteInPlace";
                    commands.CMD_ARCADE_ENABLE_BODY = "phasereditor2d.scene.ui.editor.commands.ArcadeEnableBody";
                    commands.CMD_ARCADE_DISABLE_BODY = "phasereditor2d.scene.ui.editor.commands.ArcadeDisableBody";
                    commands.CMD_ARCADE_CENTER_BODY = "phasereditor2d.scene.ui.editor.commands.ArcadeCenterBody";
                    commands.CMD_ARCADE_RESIZE_TO_OBJECT_BODY = "phasereditor2d.scene.ui.editor.commands.ArcadeResizeBodyToObject";
                    commands.CMD_OPEN_SCRIPT_DIALOG = "phasereditor2d.scene.ui.editor.commands.OpenScriptDialog";
                    commands.CMD_OPEN_ADD_SCRIPT_DIALOG = "phasereditor2d.scene.ui.editor.commands.OpenAddScriptDialog";
                    commands.CMD_PREVIEW_SCENE = "phasereditor2d.scene.ui.editor.commands.PreviewScene";
                    commands.CMD_EDIT_HIT_AREA = "phasereditor2d.scene.ui.editor.commands.ResizeHitArea";
                    commands.CMD_ADD_PREFAB_PROPERTY = "phasereditor2d.scene.ui.editor.commands.AddPrefabProperty";
                    commands.CMD_SORT_OBJ_UP = "phasereditor2d.scene.ui.editor.commands.SortObjectUp";
                    commands.CMD_SORT_OBJ_DOWN = "phasereditor2d.scene.ui.editor.commands.SortObjectDown";
                    commands.CMD_SORT_OBJ_TOP = "phasereditor2d.scene.ui.editor.commands.SortObjectTop";
                    commands.CMD_SORT_OBJ_BOTTOM = "phasereditor2d.scene.ui.editor.commands.SortObjectBottom";
                    commands.CMD_ADD_USER_COMPONENT = "phasereditor2d.scene.ui.editor.commands.AddUserComponent";
                    commands.CMD_BROWSE_USER_COMPONENTS = "phasereditor2d.scene.ui.editor.commands.BrowseUserComponents";
                    commands.CMD_SELECT_ALL_OBJECTS_SAME_SPINE_SKIN = "phasereditor2d.scene.ui.editor.commands.SelectAllObjectsWithSameSpineSkin";
                    commands.CMD_SELECT_ALL_OBJECTS_SAME_SPINE_SKELETON = "phasereditor2d.scene.ui.editor.commands.SelectAllObjectsWithSameSpineSkeleton";
                    function isCommandDialogActive() {
                        return colibri.Platform.getWorkbench()
                            .getActiveDialog() instanceof controls.dialogs.CommandDialog;
                    }
                    function isSceneScope(args) {
                        if (args.activeDialog) {
                            return false;
                        }
                        return args.activePart instanceof editor_12.SceneEditor
                            || (args.activeEditor instanceof editor_12.SceneEditor &&
                                (args.activePart instanceof phasereditor2d.outline.ui.views.OutlineView
                                    || args.activePart instanceof colibri.inspector.ui.views.InspectorView));
                    }
                    function noNestedPrefabSelected(args) {
                        return args.activeEditor.getSelection()
                            .filter(obj => ui.sceneobjects.isGameObject(obj))
                            .filter((obj) => obj.getEditorSupport().isNestedPrefabInstance())
                            .length === 0;
                    }
                    function noUserComponentsNodeInPrefabSelected(args) {
                        return args.activeEditor.getSelection()
                            .filter(obj => obj instanceof ui.sceneobjects.UserComponentNode && obj.isPrefabDefined())
                            .length === 0;
                    }
                    function isOnlyContainerSelected(args) {
                        return isSceneScope(args) && editorHasSelection(args)
                            && args.activeEditor.getSelectedGameObjects()
                                .filter(obj => obj instanceof ui.sceneobjects.Container)
                                .length === args.activeEditor.getSelection().length;
                    }
                    function editorHasSelection(args) {
                        return args.activeEditor && args.activeEditor.getSelection().length > 0;
                    }
                    function onlyGameObjectsSelected(args) {
                        if (args.activeEditor instanceof editor_12.SceneEditor) {
                            for (const obj of args.activeEditor.getSelection()) {
                                if (!ui.sceneobjects.isGameObject(obj)) {
                                    return false;
                                }
                            }
                            return args.activeEditor.getSelection().length > 0;
                        }
                        return false;
                    }
                    class SceneEditorCommands {
                        static registerCommands(manager) {
                            manager.addCategory({
                                id: commands.CAT_SCENE_EDITOR,
                                name: "Scene Editor"
                            });
                            this.registerGlobalCommands(manager);
                            this.registerEditCommands(manager);
                            this.registerAddObjectCommands(manager);
                            this.registerSceneCommands(manager);
                            this.registerVisibilityCommands(manager);
                            this.registerSelectionCommands(manager);
                            this.registerParentCommands(manager);
                            this.registerCompilerCommands(manager);
                            this.registerToolsCommands(manager);
                            this.registerOriginCommands(manager);
                            this.registerGameObjectDepthCommands(manager);
                            this.registerPlainObjectOrderCommands(manager);
                            this.registerListCommands(manager);
                            this.registerTypeCommands(manager);
                            this.registerTranslateObjectCommands(manager);
                            this.registerTextureCommands(manager);
                            this.registerSnappingCommands(manager);
                            this.registerArcadeCommands(manager);
                            this.registerScriptNodeCommands(manager);
                            this.registerUserComponentCommands(manager);
                            this.registerPrefabCommands(manager);
                            this.registerPropertiesCommands(manager);
                            this.registerSpineCommands(manager);
                            this.registerCodeSnippetOrderCommands(manager);
                        }
                        static registerCodeSnippetOrderCommands(manager) {
                            const moves = [
                                ["Up", commands.CMD_SORT_OBJ_UP],
                                ["Down", commands.CMD_SORT_OBJ_DOWN],
                                ["Top", commands.CMD_SORT_OBJ_TOP],
                                ["Bottom", commands.CMD_SORT_OBJ_BOTTOM]
                            ];
                            for (const tuple of moves) {
                                const move = tuple[0];
                                const cmd = tuple[1];
                                manager.addHandlerHelper(cmd, 
                                // testFunc 
                                args => isSceneScope(args) && args.activeEditor.getSelection().length > 0
                                    && ui.codesnippets.CodeSnippetOrderOperation.allow(args.activeEditor, move), 
                                // execFunc
                                args => args.activeEditor.getUndoManager().add(new ui.codesnippets.CodeSnippetOrderOperation(args.activeEditor, move)));
                            }
                        }
                        static registerPlainObjectOrderCommands(manager) {
                            const moves = [
                                ["Up", commands.CMD_SORT_OBJ_UP],
                                ["Down", commands.CMD_SORT_OBJ_DOWN],
                                ["Top", commands.CMD_SORT_OBJ_TOP],
                                ["Bottom", commands.CMD_SORT_OBJ_BOTTOM]
                            ];
                            for (const tuple of moves) {
                                const move = tuple[0];
                                const cmd = tuple[1];
                                manager.addHandlerHelper(cmd, 
                                // testFunc 
                                args => isSceneScope(args) && args.activeEditor.getSelection().length > 0
                                    && editor_12.undo.PlainObjectOrderOperation.allow(args.activeEditor, move), 
                                // execFunc
                                args => args.activeEditor.getUndoManager().add(new editor_12.undo.PlainObjectOrderOperation(args.activeEditor, move)));
                            }
                        }
                        static registerPrefabCommands(manager) {
                            manager.add({
                                command: {
                                    id: commands.CMD_ADD_PREFAB_PROPERTY,
                                    name: "Add Prefab Property",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Add a new property to the current prefab"
                                },
                                handler: {
                                    testFunc: args => {
                                        if (isSceneScope(args)) {
                                            const editor = args.activeEditor;
                                            return editor.getScene().isPrefabSceneType();
                                        }
                                        return false;
                                    },
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        const dialog = new ui.dialogs.AddPrefabPropertyDialog();
                                        dialog.create();
                                        //    ui.editor.properties.PrefabPropertySection.runPropertiesOperation(editor, () => {
                                        //         // TODO: show the Add Property dialog
                                        //    }, true);
                                    }
                                }
                            });
                        }
                        static registerUserComponentCommands(manager) {
                            // add user component
                            manager.add({
                                command: {
                                    id: commands.CMD_ADD_USER_COMPONENT,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Add User Component",
                                    tooltip: "Pick a User Component and add it to the selected objects"
                                },
                                keys: {
                                    key: "KeyM",
                                    keyLabel: "M"
                                },
                                handler: {
                                    testFunc: onlyGameObjectsSelected,
                                    executeFunc: args => {
                                        const finder = scene_16.ScenePlugin.getInstance().getSceneFinder();
                                        const editor = args.activeEditor;
                                        const editorCompList = args.activeEditor.getSelection()
                                            .map(obj => ui.sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, ui.sceneobjects.UserComponentsEditorComponent));
                                        const used = new Set([...editorCompList
                                                .flatMap(editorComp => editorComp.getLocalUserComponents())
                                                .map(info => info.component.getName()),
                                            ...editorCompList.flatMap(editorComp => editorComp.getPrefabUserComponents())
                                                .flatMap(info => info.components)
                                                .map(c => c.getName())
                                        ]);
                                        class ContentProvider {
                                            getRoots(input) {
                                                return finder.getUserComponentsModels()
                                                    .filter(info => info.model.getComponents().filter(c => !used.has(c.getName())).length > 0);
                                            }
                                            getChildren(parentObj) {
                                                if (parentObj instanceof editor_12.usercomponent.UserComponent) {
                                                    return [];
                                                }
                                                return parentObj.model.getComponents().filter(c => !used.has(c.getName()));
                                            }
                                        }
                                        const viewer = new controls.viewers.TreeViewer("UserComponentInstancePropertySection.addComponentDialogViewer");
                                        viewer.setStyledLabelProvider({
                                            getStyledTexts: (obj, dark) => {
                                                const theme = controls.Controls.getTheme();
                                                if (obj instanceof editor_12.usercomponent.UserComponent) {
                                                    return [{
                                                            text: obj.getDisplayNameOrName(),
                                                            color: theme.viewerForeground
                                                        }];
                                                }
                                                const folder = obj.file.getParent();
                                                let folderName = folder.getName();
                                                const isNodeLibraryFolder = phasereditor2d.ide.core.code.isNodeLibraryFile(folder);
                                                if (isNodeLibraryFolder) {
                                                    folderName = phasereditor2d.ide.core.code.findNodeModuleName(folder);
                                                }
                                                return [{
                                                        text: obj.file.getNameWithoutExtension(),
                                                        color: theme.viewerForeground
                                                    }, {
                                                        text: " - " + folderName,
                                                        color: isNodeLibraryFolder ?
                                                            scene_16.ScenePlugin.getInstance().getScriptsLibraryColor()
                                                            : theme.viewerForeground + "90"
                                                    }];
                                            }
                                        });
                                        viewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider((obj) => new controls.viewers.IconImageCellRenderer(obj instanceof editor_12.usercomponent.UserComponent ?
                                            phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_USER_COMPONENT)
                                            : colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER))));
                                        viewer.setContentProvider(new ContentProvider());
                                        viewer.setInput([]);
                                        viewer.expandRoots(false);
                                        const dlg = new controls.dialogs.ViewerDialog(viewer, false);
                                        dlg.setSize(undefined, 400, true);
                                        dlg.create();
                                        dlg.setTitle("Add User Component");
                                        dlg.enableButtonOnlyWhenOneElementIsSelected(dlg.addOpenButton("Add Component", () => {
                                            const selComp = viewer.getSelectionFirstElement();
                                            if (selComp) {
                                                editor.getUndoManager().add(new ui.editor.undo.SimpleSceneSnapshotOperation(editor, () => {
                                                    for (const editorComp of editorCompList) {
                                                        editorComp.addUserComponent(selComp.getName());
                                                    }
                                                }));
                                                // section.updateWithSelection();
                                                editor.dispatchSelectionChanged();
                                            }
                                        }), obj => obj instanceof editor_12.usercomponent.UserComponent);
                                        dlg.addCancelButton();
                                    }
                                }
                            });
                            // browse user component
                            manager.add({
                                command: {
                                    id: commands.CMD_BROWSE_USER_COMPONENTS,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Browse User Components",
                                    tooltip: "Browse all user components in the scene's objects."
                                },
                                keys: {
                                    key: "KeyM",
                                    shift: true,
                                    keyLabel: "M"
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => {
                                        const dlg = new ui.sceneobjects.BrowseUserComponentsDialog(args.activeEditor);
                                        dlg.create();
                                    }
                                }
                            });
                        }
                        static registerScriptNodeCommands(manager) {
                            manager.add({
                                command: {
                                    id: commands.CMD_OPEN_SCRIPT_DIALOG,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Browse Scripts",
                                    tooltip: "Opens the Browse Scripts dialog",
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => {
                                        const dlg = new ui.sceneobjects.BrowseScriptsDialog(args.activeEditor);
                                        dlg.create();
                                    }
                                },
                                keys: {
                                    key: "KeyU",
                                    shift: true
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_OPEN_ADD_SCRIPT_DIALOG,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Add Script",
                                    tooltip: "Opens the Add Script Dialog",
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => {
                                        const dlg = new ui.sceneobjects.AddScriptDialog(args.activeEditor);
                                        dlg.create();
                                    }
                                },
                                keys: {
                                    key: "KeyU",
                                }
                            });
                        }
                        static registerArcadeCommands(manager) {
                            // enable body
                            manager.add({
                                command: {
                                    id: commands.CMD_ARCADE_ENABLE_BODY,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Add Arcade Physics Body",
                                    tooltip: "Add an Arcade physics body to the selected objects.",
                                },
                                handler: {
                                    testFunc: args => {
                                        const editor = args.activeEditor;
                                        if (isSceneScope(args)) {
                                            if (editor.getSelectedGameObjects().length !== editor.getSelection().length) {
                                                return false;
                                            }
                                            for (const obj of editor.getSelectedGameObjects()) {
                                                const objES = obj.getEditorSupport();
                                                if (!objES.isDisplayObject()) {
                                                    return false;
                                                }
                                                if (objES.hasComponent(ui.sceneobjects.ArcadeComponent)) {
                                                    return false;
                                                }
                                                if (objES.isPrefabInstance()) {
                                                    return false;
                                                }
                                            }
                                            return true;
                                        }
                                        return false;
                                    },
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        editor.getUndoManager().add(new ui.sceneobjects.EnableArcadeBodyOperation(editor, true));
                                    },
                                }
                            });
                            // disable body
                            manager.add({
                                command: {
                                    id: commands.CMD_ARCADE_DISABLE_BODY,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Remove Arcade Physics Body",
                                    tooltip: "Remove the Arcade physics body from the selected objects.",
                                },
                                handler: {
                                    testFunc: args => {
                                        const editor = args.activeEditor;
                                        if (isSceneScope(args)) {
                                            if (editor.getSelectedGameObjects().length !== editor.getSelection().length) {
                                                return false;
                                            }
                                            for (const obj of editor.getSelectedGameObjects()) {
                                                const objES = obj.getEditorSupport();
                                                if (!objES.hasComponent(ui.sceneobjects.ArcadeComponent)
                                                    || obj instanceof ui.sceneobjects.ArcadeImage
                                                    || obj instanceof ui.sceneobjects.ArcadeSprite) {
                                                    return false;
                                                }
                                            }
                                            return true;
                                        }
                                        return false;
                                    },
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        editor.getUndoManager().add(new ui.sceneobjects.EnableArcadeBodyOperation(editor, false));
                                    },
                                }
                            });
                            // center body
                            manager.add({
                                command: {
                                    id: commands.CMD_ARCADE_CENTER_BODY,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Center Arcade Physics Body",
                                    tooltip: "Center the Arcade Physics Body of the selected objects.",
                                },
                                handler: {
                                    testFunc: args => {
                                        const editor = args.activeEditor;
                                        if (isSceneScope(args)) {
                                            if (editor.getSelectedGameObjects().length !== editor.getSelection().length) {
                                                return false;
                                            }
                                            for (const obj of editor.getSelectedGameObjects()) {
                                                const objES = obj.getEditorSupport();
                                                if (!objES.hasComponent(ui.sceneobjects.ArcadeComponent)) {
                                                    return false;
                                                }
                                                if (!objES.isUnlockedProperty(ui.sceneobjects.ArcadeComponent.offset.x)
                                                    || !objES.isUnlockedProperty(ui.sceneobjects.ArcadeComponent.offset.y)) {
                                                    return false;
                                                }
                                            }
                                            return true;
                                        }
                                        return false;
                                    },
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        editor.getUndoManager().add(new ui.sceneobjects.ArcadeCenterBodyOperation(editor, editor.getSelectedGameObjects()));
                                    },
                                }
                            });
                            // resize body
                            manager.add({
                                command: {
                                    id: commands.CMD_ARCADE_RESIZE_TO_OBJECT_BODY,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Resize Arcade Physics Body To Object Size",
                                    tooltip: "Resize & center the Arcade Physics Body to fill the whole object's size.",
                                },
                                handler: {
                                    testFunc: args => {
                                        const editor = args.activeEditor;
                                        if (isSceneScope(args)) {
                                            if (editor.getSelectedGameObjects().length !== editor.getSelection().length) {
                                                return false;
                                            }
                                            for (const obj of editor.getSelectedGameObjects()) {
                                                const objES = obj.getEditorSupport();
                                                if (!objES.hasComponent(ui.sceneobjects.ArcadeComponent)) {
                                                    return false;
                                                }
                                                if (!objES.isUnlockedProperty(ui.sceneobjects.ArcadeComponent.offset.x)
                                                    || !objES.isUnlockedProperty(ui.sceneobjects.ArcadeComponent.offset.x)) {
                                                    return false;
                                                }
                                                if (ui.sceneobjects.ArcadeComponent.isCircleBody(obj)) {
                                                    if (!objES.isUnlockedProperty(ui.sceneobjects.ArcadeComponent.radius)) {
                                                        return false;
                                                    }
                                                }
                                                else {
                                                    if (!objES.isUnlockedProperty(ui.sceneobjects.ArcadeComponent.size.x)
                                                        || !objES.isUnlockedProperty(ui.sceneobjects.ArcadeComponent.size.y)) {
                                                        return false;
                                                    }
                                                }
                                            }
                                            return true;
                                        }
                                        return false;
                                    },
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        editor.getUndoManager().add(new ui.sceneobjects.ArcadeResizeBodyToObjectOperation(editor, editor.getSelectedGameObjects()));
                                    },
                                }
                            });
                        }
                        static registerAddObjectCommands(manager) {
                            manager.add({
                                command: {
                                    id: commands.CMD_ADD_OBJECT,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Add Object",
                                    tooltip: "Add a built-in object to the scene."
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => {
                                        const dlg = new ui.dialogs.AddObjectDialog(args.activeEditor);
                                        dlg.create();
                                    }
                                },
                                keys: {
                                    key: "KeyA"
                                }
                            });
                        }
                        static registerGlobalCommands(manager) {
                            // preview scene
                            manager.add({
                                command: {
                                    id: commands.CMD_PREVIEW_SCENE,
                                    name: "Preview Scene",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Run the game and jump to the scene of the active scene editor"
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => {
                                        let name = localStorage.getItem("phasereditor2d.lastPreviewScene");
                                        const file = args.activeEditor.getInput();
                                        const isPrefab = scene_16.ScenePlugin.getInstance().getSceneFinder().isPrefabFile(file);
                                        if (!isPrefab) {
                                            name = file.getNameWithoutExtension();
                                        }
                                        phasereditor2d.ide.IDEPlugin.getInstance().playProject(name);
                                    }
                                },
                                keys: {
                                    control: true,
                                    key: "Digit0",
                                    keyLabel: "0"
                                }
                            });
                            // set default renderer type
                            manager.add({
                                command: {
                                    id: commands.CMD_SET_DEFAULT_RENDER_TYPE_TO_CANVAS,
                                    name: "Set Default Render Type To CANVAS",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Set the default render type of the scenes to Phaser.CANVAS"
                                },
                                handler: {
                                    testFunc: phasereditor2d.ide.ui.actions.isNotWelcomeWindowScope,
                                    executeFunc: args => {
                                        scene_16.ScenePlugin.getInstance().setDefaultRenderType("canvas");
                                    }
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_SET_DEFAULT_RENDER_TYPE_TO_WEBGL,
                                    name: "Set Default Render Type To WEBGL",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Set the default render type of the scenes to Phaser.WEBGL"
                                },
                                handler: {
                                    testFunc: phasereditor2d.ide.ui.actions.isNotWelcomeWindowScope,
                                    executeFunc: args => {
                                        scene_16.ScenePlugin.getInstance().setDefaultRenderType("webgl");
                                    }
                                }
                            });
                            // enable pixel art rendering
                            manager.add({
                                command: {
                                    id: commands.CMD_ENABLE_PIXEL_ART_RENDERING,
                                    name: "Enable Pixel Art Rendering",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Enable pixel-art rendering in the scenes"
                                },
                                handler: {
                                    testFunc: phasereditor2d.ide.ui.actions.isNotWelcomeWindowScope,
                                    executeFunc: args => {
                                        scene_16.ScenePlugin.getInstance().setDefaultRenderPixelArt(true);
                                    }
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_DISABLE_PIXEL_ART_RENDERING,
                                    name: "Disable Pixel Art Rendering",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Disable pixel-art rendering in the scenes"
                                },
                                handler: {
                                    testFunc: phasereditor2d.ide.ui.actions.isNotWelcomeWindowScope,
                                    executeFunc: args => {
                                        scene_16.ScenePlugin.getInstance().setDefaultRenderPixelArt(false);
                                    }
                                }
                            });
                            // fix scene id
                            manager.add({
                                command: {
                                    id: commands.CMD_FIX_SCENE_FILES_ID,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Fix Duplicated Scenes ID",
                                    tooltip: "Fix the duplicated ID of the scene files."
                                },
                                handler: {
                                    testFunc: phasereditor2d.ide.ui.actions.isNotWelcomeWindowScope,
                                    executeFunc: async (args) => {
                                        const files = await colibri.ui.ide.FileUtils.getFilesWithContentType(scene_16.core.CONTENT_TYPE_SCENE);
                                        files.sort((a, b) => a.getModTime() - b.getModTime());
                                        const usedIds = new Set();
                                        const dlg = new controls.dialogs.ProgressDialog();
                                        const monitor = new controls.dialogs.ProgressDialogMonitor(dlg);
                                        dlg.create();
                                        dlg.setTitle("Fix Duplicated Scenes ID");
                                        monitor.addTotal(files.length);
                                        const finder = scene_16.ScenePlugin.getInstance().getSceneFinder();
                                        finder.setEnabled(false);
                                        let someoneFixed = false;
                                        for (const file of files) {
                                            const content = await colibri.ui.ide.FileUtils.preloadAndGetFileString(file);
                                            const data = JSON.parse(content);
                                            const id = data.id;
                                            if (usedIds.has(id)) {
                                                data.id = Phaser.Utils.String.UUID();
                                                console.log(`Fix Scene ID of "${file.getFullName()}". New id: ` + data.id);
                                                const newContent = JSON.stringify(data, null, 4);
                                                await colibri.ui.ide.FileUtils.setFileString_async(file, newContent);
                                                someoneFixed = true;
                                            }
                                            else {
                                                usedIds.add(id);
                                            }
                                            monitor.step();
                                        }
                                        finder.setEnabled(true);
                                        dlg.close();
                                        if (someoneFixed) {
                                            await finder.preload(monitor);
                                        }
                                        else {
                                            alert("No scene files found with a duplicated ID.");
                                        }
                                    }
                                }
                            });
                            // migrate scene files
                            manager.add({
                                command: {
                                    id: commands.CMD_MIGRATE_AND_BUILD_ALL_SCENE_FILES,
                                    name: "Migrate All Scene Files",
                                    tooltip: "Run the migration process in all scene files and compile the project.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    executeFunc: async (args) => {
                                        const dlg = new controls.dialogs.ProgressDialog();
                                        dlg.create();
                                        dlg.setTitle("Migrating & Compiling Scene Files");
                                        const finder = scene_16.ScenePlugin.getInstance().getSceneFinder();
                                        const files = finder.getSceneFiles(false);
                                        const monitor = new controls.dialogs.ProgressDialogMonitor(dlg);
                                        monitor.addTotal(files.length);
                                        for (const file of files) {
                                            try {
                                                const finder = scene_16.ScenePlugin.getInstance().getSceneFinder();
                                                const data1 = finder.getSceneData(file);
                                                const scene = await ui.OfflineScene.createScene(data1);
                                                // compile code
                                                const compiler = new scene_16.core.code.SceneCompiler(scene, file);
                                                await compiler.compile();
                                                // write scene data
                                                const writer = new scene_16.core.json.SceneWriter(scene);
                                                const data2 = writer.toJSON();
                                                const content = JSON.stringify(data2, null, 4);
                                                await colibri.ui.ide.FileUtils.setFileString_async(file, content);
                                            }
                                            catch (e) {
                                                alert(e.message);
                                            }
                                            monitor.step();
                                        }
                                        dlg.close();
                                    }
                                }
                            });
                            // clear scene thumbnail database
                            manager.add({
                                command: {
                                    id: commands.CMD_CLEAR_SCENE_THUMBNAIL_CACHE,
                                    name: "Clear Scene Thumbnail Cache",
                                    tooltip: "Clear the thumbnail images cache.",
                                    category: commands.CAT_SCENE_EDITOR,
                                },
                                handler: {
                                    executeFunc: args => {
                                        ui.SceneThumbnailCache.getInstance().clearCache();
                                        scene_16.ScenePlugin.getInstance().getSpineThumbnailCache().clearCache();
                                    }
                                }
                            });
                            // open scene file
                            manager.add({
                                command: {
                                    id: commands.CMD_OPEN_SCENE_FILE,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Go To Scene",
                                    tooltip: "Quick dialog to open a scene file."
                                },
                                handler: {
                                    testFunc: args => colibri.Platform.getWorkbench().getActiveWindow() instanceof phasereditor2d.ide.ui.DesignWindow,
                                    executeFunc: args => {
                                        const dlg = new ui.dialogs.OpenSceneFileDialog();
                                        dlg.create();
                                    }
                                },
                                keys: {
                                    control: true,
                                    alt: true,
                                    key: "KeyO"
                                }
                            });
                        }
                        static registerSnappingCommands(manager) {
                            // snapping
                            manager.add({
                                command: {
                                    id: commands.CMD_TOGGLE_SNAPPING,
                                    name: "Toggle Snapping",
                                    tooltip: "Enable/disable the snapping.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        editor.toggleSnapping();
                                    }
                                },
                                keys: {
                                    key: "KeyE"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_SET_SNAPPING_TO_OBJECT_SIZE,
                                    name: "Snap To Object Size",
                                    tooltip: "Enable snapping and set size to the selected object.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args)
                                        && args.activeEditor.getSelectedGameObjects().length > 0,
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        editor.setSnappingToObjectSize();
                                    }
                                },
                                keys: {
                                    key: "KeyW"
                                }
                            });
                        }
                        static registerSpineCommands(manager) {
                            // select all same skeleton
                            manager.add({
                                command: {
                                    id: commands.CMD_SELECT_ALL_OBJECTS_SAME_SPINE_SKELETON,
                                    name: "Select All With Same Spine Skeleton",
                                    tooltip: "Select all the objects with the same Spine skeleton.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args)
                                        && args.activeEditor.getSelection()
                                            .filter(obj => obj instanceof ui.sceneobjects.SpineObject)
                                            .length > 0,
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        const skeletons = new Set();
                                        for (const obj of args.activeEditor.getSelection()) {
                                            if (obj instanceof ui.sceneobjects.SpineObject) {
                                                skeletons.add(obj.dataKey);
                                            }
                                        }
                                        const sel = [];
                                        editor.getScene().visitAll(obj => {
                                            if (obj instanceof ui.sceneobjects.SpineObject) {
                                                if (skeletons.has(obj.dataKey)) {
                                                    sel.push(obj);
                                                }
                                            }
                                        });
                                        editor.setSelection(sel);
                                    }
                                }
                            });
                            // select all same skin
                            manager.add({
                                command: {
                                    id: commands.CMD_SELECT_ALL_OBJECTS_SAME_SPINE_SKIN,
                                    name: "Select All With Same Spine Skin",
                                    tooltip: "Select all the objects with the same Spine skin.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args)
                                        && args.activeEditor.getSelection()
                                            .filter(obj => obj instanceof ui.sceneobjects.SpineObject)
                                            .length > 0,
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        const skins = new Set();
                                        for (const obj of args.activeEditor.getSelection()) {
                                            if (obj instanceof ui.sceneobjects.SpineObject) {
                                                skins.add(`${obj.dataKey}+${obj.skeleton.skin?.name}`);
                                            }
                                        }
                                        const sel = [];
                                        editor.getScene().visitAll(obj => {
                                            if (obj instanceof ui.sceneobjects.SpineObject) {
                                                const skin = `${obj.dataKey}+${obj.skeleton.skin?.name}`;
                                                if (skins.has(skin)) {
                                                    sel.push(obj);
                                                }
                                            }
                                        });
                                        editor.setSelection(sel);
                                    }
                                }
                            });
                        }
                        static registerTextureCommands(manager) {
                            // texture
                            manager.add({
                                command: {
                                    id: commands.CMD_SELECT_ALL_OBJECTS_SAME_TEXTURE,
                                    name: "Select All With Same Texture",
                                    tooltip: "Select all the objects with the same texture.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args)
                                        && args.activeEditor.getSelection()
                                            .filter(obj => ui.sceneobjects.isGameObject(obj)
                                            && ui.sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, ui.sceneobjects.TextureComponent))
                                            .length > 0,
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        const textures = new Set();
                                        for (const obj of args.activeEditor.getSelection()) {
                                            const textureComponent = ui.sceneobjects.GameObjectEditorSupport
                                                .getObjectComponent(obj, ui.sceneobjects.TextureComponent);
                                            const keys = textureComponent.getTextureKeys();
                                            textures.add(JSON.stringify(keys));
                                        }
                                        const sel = [];
                                        editor.getScene().visitAll(obj => {
                                            const textureComponent = ui.sceneobjects.GameObjectEditorSupport
                                                .getObjectComponent(obj, ui.sceneobjects.TextureComponent);
                                            if (textureComponent) {
                                                const keys = textureComponent.getTextureKeys();
                                                if (textures.has(JSON.stringify(keys))) {
                                                    sel.push(obj);
                                                }
                                            }
                                        });
                                        editor.setSelection(sel);
                                    }
                                }
                            });
                            // change texture
                            manager.add({
                                command: {
                                    id: commands.CMD_REPLACE_TEXTURE,
                                    name: "Replace Texture",
                                    tooltip: "Change the texture of the selected objects.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args)
                                        && args.activeEditor.getSelection().length > 0
                                        && args.activeEditor.getSelection()
                                            .filter(obj => ui.sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, ui.sceneobjects.TextureComponent))
                                            .length > 0,
                                    executeFunc: args => {
                                        ui.sceneobjects.ChangeTextureOperation.runDialog(args.activeEditor);
                                    }
                                },
                                keys: {
                                    key: "KeyX"
                                }
                            });
                            // change texture frame
                            manager.add({
                                command: {
                                    id: commands.CMD_REPLACE_TEXTURE_FRAME,
                                    name: "Replace Texture Frame",
                                    tooltip: "Change the texture's frame of the selected objects.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args)
                                        && args.activeEditor.getSelection().length > 0
                                        && args.activeEditor.getSelection()
                                            .filter(obj => ui.sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, ui.sceneobjects.TextureComponent))
                                            .length === 1,
                                    executeFunc: args => {
                                        const obj = args.activeEditor.getSelection()[0];
                                        const comp = obj.getEditorSupport().getComponent(ui.sceneobjects.TextureComponent);
                                        const keys = comp.getTextureKeys();
                                        ui.sceneobjects.ChangeTextureOperation.runDialog(args.activeEditor, keys.key);
                                    }
                                },
                                keys: {
                                    shift: true,
                                    key: "KeyF"
                                }
                            });
                        }
                        static registerSceneCommands(manager) {
                            // update current editor
                            manager.addHandlerHelper(colibri.ui.ide.actions.CMD_UPDATE_CURRENT_EDITOR, args => args.activeEditor instanceof editor_12.SceneEditor, args => args.activeEditor.refreshScene());
                            manager.add({
                                command: {
                                    id: commands.CMD_DUPLICATE_SCENE_FILE,
                                    name: "Duplicate Scene File",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Duplicate the scene file, with a new ID.",
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: async (args) => {
                                        const editor = args.activeEditor;
                                        const file = editor.getInput();
                                        const content = await colibri.ui.ide.FileUtils.preloadAndGetFileString(file);
                                        const data = JSON.parse(content);
                                        data.id = Phaser.Utils.String.UUID();
                                        const newContent = JSON.stringify(data, null, 4);
                                        const newName = colibri.ui.ide.FileUtils.getFileCopyName(file);
                                        const newFile = await colibri.ui.ide.FileUtils.createFile_async(file.getParent(), newName, newContent);
                                        colibri.Platform.getWorkbench().openEditor(newFile);
                                    }
                                }
                            });
                        }
                        static registerSelectionCommands(manager) {
                            // select all
                            manager.addHandlerHelper(colibri.ui.ide.actions.CMD_SELECT_ALL, args => args.activePart instanceof editor_12.SceneEditor, args => {
                                const editor = args.activeEditor;
                                editor.getSelectionManager().selectAll();
                            });
                            // clear selection
                            manager.addHandlerHelper(colibri.ui.ide.actions.CMD_ESCAPE, args => {
                                if (controls.dialogs.Dialog.getActiveDialog()
                                    || controls.ColorPickerManager.isActivePicker()) {
                                    return false;
                                }
                                return isSceneScope(args);
                            }, args => {
                                const editor = args.activeEditor;
                                editor.getSelectionManager().clearSelection();
                            });
                        }
                        static registerEditCommands(manager) {
                            // copy
                            manager.addHandlerHelper(colibri.ui.ide.actions.CMD_COPY, args => isSceneScope(args) && args.activeEditor.getSelection().length > 0, args => {
                                args.activeEditor.getClipboardManager().copy();
                            });
                            // paste
                            manager.addHandlerHelper(colibri.ui.ide.actions.CMD_PASTE, args => isSceneScope(args), args => {
                                args.activeEditor.getClipboardManager().paste(false);
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_PASTE_IN_PLACE,
                                    category: colibri.ui.ide.actions.CAT_EDIT,
                                    name: "Paste In Place",
                                    tooltip: "Paste the objects in destiny at the same original locations.",
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args),
                                    executeFunc: args => args.activeEditor
                                        .getClipboardManager().paste(true),
                                },
                                keys: {
                                    control: true,
                                    shift: true,
                                    key: "KeyV"
                                }
                            });
                            // cut
                            manager.addHandlerHelper(colibri.ui.ide.actions.CMD_CUT, args => isSceneScope(args) && args.activeEditor.getSelection().length > 0, args => {
                                args.activeEditor.getClipboardManager().cut();
                            });
                            // delete
                            manager.addHandlerHelper(colibri.ui.ide.actions.CMD_DELETE, args => isSceneScope(args) && args.activeEditor.getSelection().length > 0 && noNestedPrefabSelected(args) && noUserComponentsNodeInPrefabSelected(args), args => args.activeEditor.getUndoManager()
                                .add(new editor_12.undo.DeleteOperation(args.activeEditor)));
                            // sort
                            manager.add({
                                command: {
                                    id: commands.CMD_SORT_OBJ_UP,
                                    name: "Move Up",
                                    tooltip: "Move up object in the list.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                keys: [{ key: "PageUp" }, { key: "Numpad9" }]
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_SORT_OBJ_DOWN,
                                    name: "Move Down",
                                    tooltip: "Move down object in the list.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                keys: [{ key: "PageDown" }, { key: "Numpad3" }]
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_SORT_OBJ_TOP,
                                    name: "Move Top",
                                    tooltip: "Move top object in the list.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                keys: [{ key: "Home" }, { key: "Numpad7" }]
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_SORT_OBJ_BOTTOM,
                                    name: "Move Bottom",
                                    tooltip: "Move bottom object in the list.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                keys: [{ key: "End" }, { key: "Numpad1" }]
                            });
                        }
                        static registerTranslateObjectCommands(manager) {
                            class Operation extends editor_12.undo.SceneSnapshotOperation {
                                _dx;
                                _dy;
                                constructor(editor, dx, dy) {
                                    super(editor);
                                    this._dx = dx;
                                    this._dy = dy;
                                }
                                async performModification() {
                                    for (const obj of this._editor.getSelection()) {
                                        const sprite = obj;
                                        sprite.x += this._dx;
                                        sprite.y += this._dy;
                                    }
                                    this.getEditor().dispatchSelectionChanged();
                                }
                            }
                            const dxMap = {};
                            const dyMap = {};
                            const nameMap = {};
                            dxMap[commands.CMD_MOVE_OBJECT_LEFT] = -1;
                            dxMap[commands.CMD_MOVE_OBJECT_RIGHT] = 1;
                            dxMap[commands.CMD_MOVE_OBJECT_UP] = 0;
                            dxMap[commands.CMD_MOVE_OBJECT_DOWN] = 0;
                            dyMap[commands.CMD_MOVE_OBJECT_LEFT] = 0;
                            dyMap[commands.CMD_MOVE_OBJECT_RIGHT] = 0;
                            dyMap[commands.CMD_MOVE_OBJECT_UP] = -1;
                            dyMap[commands.CMD_MOVE_OBJECT_DOWN] = 1;
                            nameMap[commands.CMD_MOVE_OBJECT_LEFT] = "Left";
                            nameMap[commands.CMD_MOVE_OBJECT_RIGHT] = "Right";
                            nameMap[commands.CMD_MOVE_OBJECT_UP] = "Up";
                            nameMap[commands.CMD_MOVE_OBJECT_DOWN] = "Down";
                            for (const cmd of [commands.CMD_MOVE_OBJECT_LEFT, commands.CMD_MOVE_OBJECT_RIGHT, commands.CMD_MOVE_OBJECT_UP, commands.CMD_MOVE_OBJECT_DOWN]) {
                                for (const large of [true, false]) {
                                    manager.add({
                                        command: {
                                            id: cmd + (large ? "Large" : ""),
                                            category: commands.CAT_SCENE_EDITOR,
                                            name: "Move Object Position " + (large ? "10x " : "") + nameMap[cmd],
                                            tooltip: (large ? "10x " : "") + "Move selected objects position in the '" + nameMap[cmd] + "' direction"
                                        },
                                        handler: {
                                            testFunc: args => {
                                                if (!isSceneScope(args)) {
                                                    return false;
                                                }
                                                if (isCommandDialogActive()) {
                                                    return false;
                                                }
                                                if (args.activeEditor.getSelection().length === 0) {
                                                    return false;
                                                }
                                                for (const obj of args.activeEditor.getSelection()) {
                                                    if (!ui.sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, ui.sceneobjects.TransformComponent)) {
                                                        return false;
                                                    }
                                                }
                                                return true;
                                            },
                                            executeFunc: args => {
                                                const editor = args.activeEditor;
                                                const settings = editor.getScene().getSettings();
                                                const dx = dxMap[cmd] * (large ? 10 : 1) * (settings.snapEnabled ? settings.snapWidth : 1);
                                                const dy = dyMap[cmd] * (large ? 10 : 1) * (settings.snapEnabled ? settings.snapHeight : 1);
                                                editor.getUndoManager().add(new Operation(editor, dx, dy));
                                            }
                                        },
                                        keys: {
                                            key: "Arrow" + nameMap[cmd],
                                            shift: large ? true : undefined
                                        }
                                    });
                                }
                            }
                        }
                        static registerParentCommands(manager) {
                            // join in layer
                            manager.add({
                                command: {
                                    id: commands.CMD_JOIN_IN_LAYER,
                                    name: "Create Layer With Selection",
                                    tooltip: "Create a layer with the selected objects",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => {
                                        if (isSceneScope(args)) {
                                            const editor = args.activeEditor;
                                            if (editor.getSelectedGameObjects().length !== editor.getSelection().length) {
                                                return false;
                                            }
                                            for (const obj of editor.getSelectedGameObjects()) {
                                                const objES = obj.getEditorSupport();
                                                if (!objES.isDisplayObject()) {
                                                    return false;
                                                }
                                                if (objES.isNestedPrefabInstance()) {
                                                    return false;
                                                }
                                                if (obj instanceof ui.sceneobjects.Layer) {
                                                    return false;
                                                }
                                            }
                                            return true;
                                        }
                                        return false;
                                    },
                                    executeFunc: args => args.activeEditor.getUndoManager().add(new ui.sceneobjects.CreateLayerWithObjectsOperation(args.activeEditor))
                                }
                            });
                            // join in container
                            manager.add({
                                command: {
                                    id: commands.CMD_JOIN_IN_CONTAINER,
                                    name: "Create Container With Selection",
                                    tooltip: "Create a container with the selected objects",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => {
                                        if (isSceneScope(args)) {
                                            const editor = args.activeEditor;
                                            if (editor.getSelectedGameObjects().length !== editor.getSelection().length) {
                                                return false;
                                            }
                                            for (const obj of editor.getSelectedGameObjects()) {
                                                const objES = obj.getEditorSupport();
                                                if (!objES.isDisplayObject()) {
                                                    return false;
                                                }
                                                if (objES.isNestedPrefabInstance()) {
                                                    return false;
                                                }
                                                if (obj instanceof ui.sceneobjects.Layer) {
                                                    return false;
                                                }
                                            }
                                            return true;
                                        }
                                        return false;
                                    },
                                    executeFunc: args => args.activeEditor.getUndoManager().add(new ui.sceneobjects.CreateContainerWithObjectsOperation(args.activeEditor))
                                },
                                keys: {
                                    key: "KeyJ"
                                }
                            });
                            // trim container
                            manager.add({
                                command: {
                                    id: commands.CMD_TRIM_CONTAINER,
                                    name: "Trim Container",
                                    tooltip: "Remove left/top margin of children.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isOnlyContainerSelected,
                                    executeFunc: args => args.activeEditor.getUndoManager().add(new ui.sceneobjects.TrimContainerOperation(args.activeEditor))
                                },
                                keys: {
                                    key: "KeyT",
                                    shift: true
                                }
                            });
                            // break container
                            manager.add({
                                command: {
                                    id: commands.CMD_BREAK_PARENT,
                                    name: "Break Parent",
                                    tooltip: "Destroy container and re-parent children.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => {
                                        return isSceneScope(args) && editorHasSelection(args)
                                            && args.activeEditor.getSelectedGameObjects()
                                                .filter(obj => obj instanceof ui.sceneobjects.Container || obj instanceof ui.sceneobjects.Layer)
                                                .filter(obj => !obj.getEditorSupport().isPrefabInstance())
                                                .length === args.activeEditor.getSelection().length;
                                    },
                                    executeFunc: args => args.activeEditor.getUndoManager().add(new ui.sceneobjects.BreakParentOperation(args.activeEditor))
                                },
                                keys: {
                                    key: "KeyB",
                                    shift: true
                                }
                            });
                            // select parent
                            manager.add({
                                command: {
                                    id: commands.CMD_SELECT_PARENT,
                                    name: "Select Parent",
                                    tooltip: "Select the parent container",
                                    category: commands.CAT_SCENE_EDITOR,
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args) && args.activeEditor
                                        .getSelectedGameObjects()
                                        .map(obj => obj.getEditorSupport().getObjectParent())
                                        .filter(parent => parent !== undefined && parent !== null)
                                        .length > 0,
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        const sel = editor.getSelectedGameObjects()
                                            .map(obj => obj.getEditorSupport().getObjectParent())
                                            .filter(parent => parent !== undefined && parent !== null);
                                        editor.setSelection(sel);
                                    }
                                },
                                keys: {
                                    key: "KeyP"
                                }
                            });
                            // select children
                            manager.add({
                                command: {
                                    id: commands.CMD_SELECT_CHILDREN,
                                    name: "Select Children",
                                    tooltip: "Select the children",
                                    category: commands.CAT_SCENE_EDITOR,
                                },
                                handler: {
                                    testFunc: args => {
                                        if (!isSceneScope(args)) {
                                            return false;
                                        }
                                        const sel = args.activeEditor.getSelection();
                                        return (sel.filter(obj => obj instanceof ui.sceneobjects.Container
                                            || obj instanceof ui.sceneobjects.Layer))
                                            .length === sel.length;
                                    },
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        const sel = editor.getSelection()
                                            .filter(obj => ui.sceneobjects.isGameObject(obj))
                                            .flatMap((obj) => obj.getEditorSupport().getObjectChildren())
                                            .filter(obj => {
                                            const editorSupport = obj.getEditorSupport();
                                            if (editorSupport.isMutableNestedPrefabInstance()) {
                                                return true;
                                            }
                                            if (editorSupport.isPrefabInstanceElement()) {
                                                return false;
                                            }
                                            return true;
                                        });
                                        editor.setSelection(sel);
                                    }
                                },
                                keys: {
                                    key: "KeyN"
                                }
                            });
                            // move to parent
                            manager.add({
                                command: {
                                    id: commands.CMD_MOVE_TO_PARENT,
                                    name: "Move To Parent",
                                    tooltip: "Re-parent the selected objects.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => {
                                        const editor = args.activeEditor;
                                        if (isSceneScope(args) && editorHasSelection(args)) {
                                            for (const obj of editor.getSelection()) {
                                                if (ui.sceneobjects.isGameObject(obj)) {
                                                    if (obj
                                                        .getEditorSupport().isNestedPrefabInstance()) {
                                                        return false;
                                                    }
                                                    if (obj instanceof ui.sceneobjects.Layer) {
                                                        return false;
                                                    }
                                                    if (obj instanceof ui.sceneobjects.FXObject) {
                                                        return false;
                                                    }
                                                }
                                                else {
                                                    return false;
                                                }
                                            }
                                            return true;
                                        }
                                        return false;
                                    },
                                    executeFunc: args => {
                                        const dlg = new ui.sceneobjects.ParentDialog(args.activeEditor);
                                        dlg.create();
                                    }
                                },
                                keys: {
                                    shift: true,
                                    key: "KeyP"
                                }
                            });
                        }
                        static registerTypeCommands(manager) {
                            // change type dialog
                            manager.add({
                                command: {
                                    id: commands.CMD_CONVERT_OBJECTS,
                                    name: "Replace Type",
                                    tooltip: "Replace the type of the selected objects.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args)
                                        && editor_12.ConvertTypeDialog.canConvert(args.activeEditor),
                                    executeFunc: args => {
                                        const dlg = new editor.ConvertTypeDialog(args.activeEditor);
                                        dlg.create();
                                    }
                                }
                            });
                            // change type to tile sprite
                            manager.add({
                                command: {
                                    id: commands.CMD_CONVERT_TO_TILE_SPRITE_OBJECTS,
                                    name: "Convert To TileSprite",
                                    tooltip: "Convert the selected objects into TileSprite instances. Or resize it if it is a TileSprite.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => isSceneScope(args)
                                        && editor_12.ConvertTypeDialog.canConvert(args.activeEditor),
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        editor.getUndoManager().add(new editor_12.undo.ConvertTypeOperation(editor, ui.sceneobjects.TileSpriteExtension.getInstance()));
                                    }
                                },
                                keys: {
                                    key: "KeyL"
                                }
                            });
                            // open prefab
                            manager.add({
                                command: {
                                    id: commands.CMD_OPEN_PREFAB,
                                    name: "Open Prefab",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Open the Prefab file of the selected prefab instance."
                                },
                                handler: {
                                    testFunc: args => {
                                        if (!isSceneScope(args)) {
                                            return false;
                                        }
                                        const selection = args.activeEditor.getSelection();
                                        const prefabsLen = selection.filter(obj => ui.sceneobjects.isGameObject(obj)
                                            && obj
                                                .getEditorSupport().isPrefabInstance()).length;
                                        return selection.length === prefabsLen;
                                    },
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        const sel = editor.getSelectedGameObjects();
                                        for (const obj of sel) {
                                            const file = obj.getEditorSupport().getPrefabFile();
                                            if (file) {
                                                colibri.Platform.getWorkbench().openEditor(file);
                                            }
                                        }
                                    }
                                },
                                keys: {
                                    key: "KeyF"
                                }
                            });
                            // create prefab
                            manager.add({
                                command: {
                                    id: commands.CMD_CREATE_PREFAB_WITH_OBJECT,
                                    name: "Create Prefab With Object",
                                    tooltip: "Create a new prefab file with the selected object.",
                                    category: commands.CAT_SCENE_EDITOR,
                                },
                                handler: {
                                    testFunc: args => {
                                        if (!isSceneScope(args)) {
                                            return false;
                                        }
                                        const sel = args.activeEditor.getSelection();
                                        if (sel.length !== 1) {
                                            return false;
                                        }
                                        const obj = sel[0];
                                        return ui.sceneobjects.isGameObject(obj);
                                    },
                                    executeFunc: args => {
                                        const obj = args.activeEditor.getSelection()[0];
                                        const objData = {
                                            unlock: ["x", "y"]
                                        };
                                        obj.getEditorSupport().writeJSON(objData);
                                        objData.id = Phaser.Utils.String.UUID();
                                        objData["x"] = 0;
                                        objData["y"] = 0;
                                        const ext = new ui.dialogs.NewPrefabFileFromObjectDialogExtension(objData);
                                        ext.setOpenInEditor(false);
                                        ext.setCreatedCallback(newFile => {
                                            const editor = args.activeEditor;
                                            editor.getUndoManager().add(new editor_12.undo.ConvertTypeOperation(editor, newFile));
                                            editor.refreshBlocks();
                                            console.log(`Compiling scene ${newFile.getName()}`);
                                            scene_16.core.code.SceneCompileAllExtension.compileSceneFile(newFile);
                                        });
                                        const dlg = ext.createDialog({
                                            initialFileLocation: args.activeEditor.getInput().getParent()
                                        });
                                        dlg.setTitle("New Prefab File");
                                    }
                                }
                            });
                            // quick source edit
                            manager.add({
                                command: {
                                    id: commands.CMD_QUICK_EDIT_OUTPUT_FILE,
                                    name: "Quick Edit Output File",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Shortcut to edit the compiled code in a popup editor."
                                },
                                handler: {
                                    testFunc: args => args.activeEditor instanceof editor_12.SceneEditor,
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        editor.openOutputFileQuickEditorDialog();
                                    }
                                },
                                keys: {
                                    key: "KeyQ"
                                }
                            });
                            if (phasereditor2d.ide.IDEPlugin.getInstance().isDesktopMode()) {
                                const editorName = phasereditor2d.ide.IDEPlugin.getInstance().getExternalEditorName();
                                manager.add({
                                    command: {
                                        id: commands.CMD_OPEN_OUTPUT_FILE_IN_VSCODE,
                                        name: "Open Output File in " + editorName,
                                        category: commands.CAT_SCENE_EDITOR,
                                        tooltip: "Open the compiler output file in the configured external editor (" + editorName + ")"
                                    },
                                    handler: {
                                        testFunc: args => args.activeEditor instanceof editor_12.SceneEditor,
                                        executeFunc: args => {
                                            const editor = args.activeEditor;
                                            const file = editor.getOutputFile();
                                            if (file) {
                                                phasereditor2d.ide.IDEPlugin.getInstance().openFileExternalEditor(file);
                                            }
                                            else {
                                                alert(`Output from "${editor.getInput().getProjectRelativeName()}" not found.`);
                                            }
                                        }
                                    }, keys: {
                                        control: true,
                                        alt: true,
                                        key: "KeyE"
                                    }
                                });
                            }
                        }
                        static registerCompilerCommands(manager) {
                            // open compiled file
                            manager.add({
                                command: {
                                    id: commands.CMD_OPEN_COMPILED_FILE,
                                    icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_FILE_SCRIPT),
                                    name: "Open Output File",
                                    tooltip: "Open the output source file of the scene.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => args.activeEditor instanceof editor_12.SceneEditor,
                                    executeFunc: args => args.activeEditor.openSourceFileInEditor()
                                }
                            });
                            // compile scene editor
                            manager.add({
                                command: {
                                    id: commands.CMD_COMPILE_SCENE_EDITOR,
                                    icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_BUILD),
                                    name: "Compile Scene",
                                    tooltip: "Compile the editor's Scene.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: args => args.activeEditor instanceof editor_12.SceneEditor,
                                    executeFunc: args => args.activeEditor.compile(),
                                }
                            });
                        }
                        static registerToolsCommands(manager) {
                            manager.add({
                                command: {
                                    id: commands.CMD_TRANSLATE_SCENE_OBJECT,
                                    name: "Translate Tool",
                                    icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_TRANSLATE),
                                    tooltip: "Translate the selected scene objects",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.TranslateTool.ID)
                                },
                                keys: {
                                    key: "KeyT"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_ROTATE_SCENE_OBJECT,
                                    name: "Rotate Tool",
                                    icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_ANGLE),
                                    tooltip: "Rotate the selected scene objects",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.RotateTool.ID)
                                },
                                keys: {
                                    key: "KeyR"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_EDIT_POLYGON_OBJECT,
                                    name: "Polygon Tool",
                                    tooltip: "Edit the points of the polygon.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.PolygonTool.ID)
                                },
                                keys: {
                                    key: "KeyY"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_SCALE_SCENE_OBJECT,
                                    name: "Scale Tool",
                                    icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_SCALE),
                                    tooltip: "Scale the selected scene objects",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.ScaleTool.ID)
                                },
                                keys: {
                                    key: "KeyS"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_SET_ORIGIN_SCENE_OBJECT,
                                    name: "Origin Tool",
                                    icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_ORIGIN),
                                    tooltip: "Change the origin of the selected scene object",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.OriginTool.ID)
                                },
                                keys: {
                                    key: "KeyO"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_SELECT_REGION,
                                    name: "Select Region Tool",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Select all objects inside a region",
                                    icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_SELECT_REGION)
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.SelectionRegionTool.ID)
                                },
                                keys: {
                                    shift: true,
                                    key: "KeyS"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_PAN_SCENE,
                                    name: "Pan Tool",
                                    category: commands.CAT_SCENE_EDITOR,
                                    tooltip: "Pan the scene viewport"
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        editor.getToolsManager().swapTool(ui.sceneobjects.PanTool.ID);
                                    }
                                },
                                keys: {
                                    key: "Space"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_RESIZE_SCENE_OBJECT,
                                    name: "Resize Tool",
                                    tooltip: "Resize selected objects.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.SizeTool.ID)
                                },
                                keys: {
                                    key: "KeyZ"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_EDIT_ARCADE_BODY,
                                    name: "Arcade Physics Body Tool",
                                    tooltip: "Edit body of selected objects.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.ArcadeBodyTool.ID)
                                },
                                keys: {
                                    key: "KeyB"
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_EDIT_SLICE_SCENE_OBJECT,
                                    name: "Slice Tool",
                                    tooltip: "Edit selected slice objects.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.SliceTool.ID)
                                }
                            });
                            manager.add({
                                command: {
                                    id: commands.CMD_EDIT_HIT_AREA,
                                    name: "Hit Area Tool",
                                    tooltip: "Resize the hit area of the selected objects.",
                                    category: commands.CAT_SCENE_EDITOR
                                },
                                handler: {
                                    testFunc: isSceneScope,
                                    executeFunc: args => args.activeEditor
                                        .getToolsManager().swapTool(ui.sceneobjects.EditHitAreaTool.ID)
                                },
                                keys: {
                                    key: "KeyI"
                                }
                            });
                        }
                        static registerVisibilityCommands(manager) {
                            manager.add({
                                command: {
                                    id: commands.CMD_TOGGLE_VISIBLE,
                                    category: commands.CAT_SCENE_EDITOR,
                                    name: "Toggle Visibility",
                                    tooltip: "Toggle the visible property of the object"
                                },
                                handler: {
                                    testFunc: e => {
                                        if (!isSceneScope(e)) {
                                            return false;
                                        }
                                        const sel = e.activeEditor.getSelection();
                                        for (const obj of sel) {
                                            if (!ui.sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, ui.sceneobjects.VisibleComponent)) {
                                                return false;
                                            }
                                        }
                                        return sel.length > 0;
                                    },
                                    executeFunc: async (e) => {
                                        let visible = false;
                                        const sel = e.activeEditor.getSelection();
                                        for (const obj of sel) {
                                            const objVisible = ui.sceneobjects.VisibleComponent.visible.getValue(obj);
                                            if (objVisible) {
                                                visible = true;
                                                break;
                                            }
                                        }
                                        const editor = e.activeEditor;
                                        const unlocked = await editor.confirmUnlockProperty([ui.sceneobjects.VisibleComponent.visible], "Visible", ui.sceneobjects.VisibleSection.SECTION_ID);
                                        if (unlocked) {
                                            editor.getUndoManager().add(new ui.sceneobjects.SimpleOperation(editor, sel, ui.sceneobjects.VisibleComponent.visible, !visible));
                                        }
                                    }
                                },
                                keys: {
                                    key: "KeyV"
                                }
                            });
                        }
                        static registerGameObjectDepthCommands(manager) {
                            const moves = [
                                ["Up", commands.CMD_SORT_OBJ_UP],
                                ["Down", commands.CMD_SORT_OBJ_DOWN],
                                ["Top", commands.CMD_SORT_OBJ_TOP],
                                ["Bottom", commands.CMD_SORT_OBJ_BOTTOM]
                            ];
                            for (const tuple of moves) {
                                const move = tuple[0];
                                const cmd = tuple[1];
                                manager.addHandlerHelper(cmd, 
                                // testFunc 
                                args => isSceneScope(args) && args.activeEditor.getSelection().length > 0
                                    && editor_12.undo.GameObjectDepthOperation.allow(args.activeEditor, move), 
                                // execFunc
                                args => args.activeEditor.getUndoManager().add(new editor_12.undo.GameObjectDepthOperation(args.activeEditor, move)));
                            }
                        }
                        static registerPropertiesCommands(manager) {
                            // order commands
                            const moves = [
                                ["Up", commands.CMD_SORT_OBJ_UP],
                                ["Down", commands.CMD_SORT_OBJ_DOWN],
                                ["Top", commands.CMD_SORT_OBJ_TOP],
                                ["Bottom", commands.CMD_SORT_OBJ_BOTTOM]
                            ];
                            for (const tuple of moves) {
                                const move = tuple[0];
                                const cmd = tuple[1];
                                manager.addHandlerHelper(cmd, 
                                // testFunc
                                args => isSceneScope(args) && args.activeEditor.getSelection().length > 0
                                    && editor_12.properties.PrefabPropertyOrderAction.allow(args.activeEditor, move), 
                                // execFunc
                                args => editor_12.properties.ChangePrefabPropertiesOperation.runPropertiesOperation(args.activeEditor, props => {
                                    editor_12.properties.PrefabPropertyOrderAction.execute(args.activeEditor, move);
                                }));
                            }
                        }
                        static registerListCommands(manager) {
                            // order commands
                            const moves = [
                                ["Up", commands.CMD_SORT_OBJ_UP],
                                ["Down", commands.CMD_SORT_OBJ_DOWN],
                                ["Top", commands.CMD_SORT_OBJ_TOP],
                                ["Bottom", commands.CMD_SORT_OBJ_BOTTOM]
                            ];
                            for (const tuple of moves) {
                                const move = tuple[0];
                                const cmd = tuple[1];
                                manager.addHandlerHelper(cmd, 
                                // testFunc
                                args => isSceneScope(args) && args.activeEditor.getSelection().length > 0
                                    && ui.sceneobjects.ListOrderOperation.allow(args.activeEditor, move), 
                                // execFunc
                                args => args.activeEditor.getUndoManager().add(new ui.sceneobjects.ListOrderOperation(args.activeEditor, move)));
                            }
                        }
                        static computeOriginCommandData() {
                            const values = [
                                { x: 0, y: 0, k: 7, n: "Top/Left" },
                                { x: 0.5, y: 0, k: 8, n: "Top/Center" },
                                { x: 1, y: 0, k: 9, n: "Top/Right" },
                                { x: 0, y: 0.5, k: 4, n: "Middle/Left" },
                                { x: 0.5, y: 0.5, k: 5, n: "Middle/Center" },
                                { x: 1, y: 0.5, k: 6, n: "Middle/Right" },
                                { x: 0, y: 1, k: 1, n: "Bottom/Left" },
                                { x: 0.5, y: 1, k: 2, n: "Bottom/Center" },
                                { x: 1, y: 1, k: 3, n: "Bottom/Right" },
                            ];
                            return values.map(value => {
                                return {
                                    command: "phasereditor2d.scene.ui.editor.commands.SetOrigin_" + value.n + "_ToObject",
                                    name: "Set Origin To " + value.n,
                                    icon: "origin-" + value.n.replace("/", "").toLowerCase(),
                                    x: value.x,
                                    y: value.y,
                                    key: "Numpad" + value.k,
                                    keyLabel: "Numpad " + value.k
                                };
                            });
                        }
                        static registerOriginCommands(manager) {
                            const originProperty = {
                                name: "origin",
                                defValue: undefined,
                                getValue: obj => ({ x: obj.originX, y: obj.originY }),
                                setValue: (obj, value) => {
                                    // obj.setOrigin(value.x, value.y);
                                    ui.sceneobjects.OriginToolItem
                                        .simpleChangeOriginKeepPosition(obj, value.x, value.y);
                                }
                            };
                            for (const data of this.computeOriginCommandData()) {
                                manager.add({
                                    command: {
                                        id: data.command,
                                        name: data.name,
                                        tooltip: `Set the origin of the object to (${data.x},${data.y})`,
                                        icon: phasereditor2d.resources.getIcon(data.icon),
                                        category: commands.CAT_SCENE_EDITOR
                                    },
                                    keys: {
                                        key: data.key,
                                        keyLabel: data.keyLabel,
                                        control: true,
                                    },
                                    handler: {
                                        testFunc: args => {
                                            if (!isSceneScope(args)) {
                                                return false;
                                            }
                                            const sel = args.activeEditor.getSelection();
                                            const len = sel
                                                .filter(obj => ui.sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, ui.sceneobjects.OriginComponent))
                                                .length;
                                            return len > 0 && len === sel.length;
                                        },
                                        executeFunc: async (args) => {
                                            const editor = args.activeEditor;
                                            const objects = editor.getSelectedGameObjects()
                                                .filter(obj => ui.sceneobjects.GameObjectEditorSupport
                                                .hasObjectComponent(obj, ui.sceneobjects.OriginComponent));
                                            const unlocked = await editor.confirmUnlockProperty([
                                                ui.sceneobjects.OriginComponent.originX,
                                                ui.sceneobjects.OriginComponent.originY
                                            ], "Origin", ui.sceneobjects.OriginSection.SECTION_ID);
                                            if (unlocked) {
                                                editor.getUndoManager().add(new ui.sceneobjects.SimpleOperation(args.activeEditor, objects, originProperty, {
                                                    x: data.x,
                                                    y: data.y
                                                }));
                                            }
                                        }
                                    },
                                });
                            }
                        }
                    }
                    commands.SceneEditorCommands = SceneEditorCommands;
                })(commands = editor_12.commands || (editor_12.commands = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_16.ui || (scene_16.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_13) {
                var layout;
                (function (layout) {
                    class LayoutExtension extends colibri.Extension {
                        static POINT_ID = "phasereditor2d.scene.ui.editor.layout.LayoutExtension";
                        _config;
                        constructor(config) {
                            super(LayoutExtension.POINT_ID);
                            this._config = config;
                        }
                        getConfig() {
                            return this._config;
                        }
                    }
                    layout.LayoutExtension = LayoutExtension;
                })(layout = editor_13.layout || (editor_13.layout = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_14) {
                var layout;
                (function (layout) {
                    class TransformLayoutExtension extends layout.LayoutExtension {
                        constructor(config) {
                            super(config);
                        }
                        async performLayout(editor) {
                            const params = await editor.getLayoutToolsManager().showParametersPane(this);
                            const transform = ui.sceneobjects.TransformComponent;
                            const sprites = editor.getSelectedGameObjects()
                                .filter(obj => obj.getEditorSupport().hasComponent(transform));
                            const unlocked = await editor.confirmUnlockProperty([
                                transform.x,
                                transform.y,
                            ], "position", ui.sceneobjects.TransformSection.SECTION_ID);
                            if (!unlocked) {
                                return;
                            }
                            const positions = sprites.map(obj => {
                                if (obj instanceof ui.sceneobjects.Container) {
                                    const b = obj.getBounds();
                                    const originX = (obj.x - b.x) / b.width;
                                    const originY = (obj.y - b.y) / b.height;
                                    return {
                                        x: obj.x - originX * b.width,
                                        y: obj.y - originY * b.height,
                                        size: {
                                            x: b.width,
                                            y: b.height
                                        }
                                    };
                                }
                                const sprite = obj;
                                const { displayOriginX, displayOriginY } = obj.getEditorSupport().computeDisplayOrigin();
                                const { scaleX, scaleY } = sprite;
                                return {
                                    x: sprite.x - displayOriginX * scaleX,
                                    y: sprite.y - displayOriginY * scaleY,
                                    size: {
                                        x: sprite.displayWidth,
                                        y: sprite.displayHeight
                                    }
                                };
                            });
                            const spritePosMap = new Map();
                            for (let i = 0; i < sprites.length; i++) {
                                spritePosMap.set(sprites[i], positions[i]);
                            }
                            const settings = editor.getScene().getSettings();
                            const border = {
                                x: settings.borderX,
                                y: settings.borderY,
                                size: {
                                    x: settings.borderWidth,
                                    y: settings.borderHeight
                                }
                            };
                            const op = new editor_14.undo.SimpleSceneSnapshotOperation(editor, () => {
                                this.getConfig().action({ border, positions, params });
                                for (const obj of sprites) {
                                    const pos = spritePosMap.get(obj);
                                    if (obj instanceof ui.sceneobjects.Container) {
                                        const b = obj.getBounds();
                                        const originX = (obj.x - b.x) / b.width;
                                        const originY = (obj.y - b.y) / b.height;
                                        obj.x = pos.x + originX * b.width;
                                        obj.y = pos.y + originY * b.height;
                                    }
                                    else {
                                        const sprite = obj;
                                        const { displayOriginX, displayOriginY } = sprite.getEditorSupport().computeDisplayOrigin();
                                        const { scaleX, scaleY } = sprite;
                                        sprite.x = pos.x + displayOriginX * scaleX;
                                        sprite.y = pos.y + displayOriginY * scaleY;
                                    }
                                }
                            });
                            editor.getUndoManager().add(op);
                        }
                    }
                    layout.TransformLayoutExtension = TransformLayoutExtension;
                })(layout = editor_14.layout || (editor_14.layout = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./LayoutExtension.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_15) {
                var layout;
                (function (layout) {
                    function getXName(origin) {
                        switch (origin) {
                            case 0:
                                return "Left";
                            case 0.5:
                                return "Center";
                            case 1:
                                return "Right";
                        }
                    }
                    function getYName(origin) {
                        switch (origin) {
                            case 0:
                                return "Top";
                            case 0.5:
                                return "Middle";
                            case 1:
                                return "Bottom";
                        }
                    }
                    class OriginLayoutExtension extends layout.LayoutExtension {
                        _originX;
                        _originY;
                        constructor(originX, originY) {
                            super({
                                name: `Origin ${getYName(originY)}/${getXName(originX)}`,
                                group: "Origin",
                                icon: phasereditor2d.resources.getIcon(("origin-" + getYName(originY) + getXName(originX)).toLowerCase()),
                            });
                            this._originX = originX;
                            this._originY = originY;
                        }
                        async performLayout(editor) {
                            const name = getYName(this._originY) + "/" + getXName(this._originX);
                            colibri.Platform.getWorkbench().getCommandManager()
                                .executeCommand(`phasereditor2d.scene.ui.editor.commands.SetOrigin_${name}_ToObject`);
                        }
                    }
                    layout.OriginLayoutExtension = OriginLayoutExtension;
                })(layout = editor_15.layout || (editor_15.layout = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./LayoutExtension.ts" />
/// <reference path="./TransformLayoutExtension.ts" />
/// <reference path="./OriginLayoutExtension.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var layout;
                (function (layout) {
                    function minValue(values) {
                        let min = Number.MAX_SAFE_INTEGER;
                        for (const v of values) {
                            min = Math.min(v, min);
                        }
                        return min;
                    }
                    layout.minValue = minValue;
                    function maxValue(values) {
                        let max = Number.MIN_SAFE_INTEGER;
                        for (const v of values) {
                            max = Math.max(v, max);
                        }
                        return max;
                    }
                    layout.maxValue = maxValue;
                    function avgValue(values) {
                        let total = 0;
                        for (const v of values) {
                            total += v;
                        }
                        return total / values.length;
                    }
                    layout.avgValue = avgValue;
                    function makeSimpleAxisAction(reduceFunc, axis) {
                        return (args) => {
                            const value = reduceFunc(args.positions.map(p => p[axis]));
                            for (const pos of args.positions) {
                                pos[axis] = value;
                            }
                        };
                    }
                    layout.makeSimpleAxisAction = makeSimpleAxisAction;
                    function makeBorderAction(axis, factor) {
                        return (args) => {
                            for (const pos of args.positions) {
                                pos[axis] = args.border[axis] + args.border.size[axis] * factor;
                            }
                        };
                    }
                    layout.makeBorderAction = makeBorderAction;
                    function makeAlignAction(axis, reduceFunc, origin) {
                        return (args) => {
                            const value = reduceFunc(args.positions.map(p => p[axis] + p.size[axis] * origin));
                            args.positions.forEach(pos => (pos[axis] = value - pos.size[axis] * origin));
                        };
                    }
                    layout.makeAlignAction = makeAlignAction;
                    function makeShiftAction(axis, origin) {
                        return (args) => {
                            const value = args.border[axis] + args.border.size[axis] * origin;
                            args.positions.forEach(pos => (pos[axis] = value - pos.size[axis] * origin));
                        };
                    }
                    layout.makeShiftAction = makeShiftAction;
                    class DefaultLayoutExtensions {
                        // align
                        static ALIGN_LEFT = new layout.TransformLayoutExtension({
                            name: "Left",
                            group: "Align",
                            icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_ALIGN_LEFT),
                            action: makeAlignAction("x", minValue, 0)
                        });
                        static ALIGN_CENTER = new layout.TransformLayoutExtension({
                            name: "Center",
                            group: "Align",
                            icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_ALIGN_CENTER),
                            action: makeAlignAction("x", avgValue, 0.5)
                        });
                        static ALIGN_RIGHT = new layout.TransformLayoutExtension({
                            name: "Right",
                            group: "Align",
                            icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_ALIGN_RIGHT),
                            action: makeAlignAction("x", maxValue, 1)
                        });
                        static ALIGN_TOP = new layout.TransformLayoutExtension({
                            name: "Top",
                            group: "Align",
                            icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_ALIGN_TOP),
                            action: makeAlignAction("y", minValue, 0)
                        });
                        static ALIGN_MIDDLE = new layout.TransformLayoutExtension({
                            name: "Middle",
                            group: "Align",
                            icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_ALIGN_MIDDLE),
                            action: makeAlignAction("y", avgValue, 0.5)
                        });
                        static ALIGN_BOTTOM = new layout.TransformLayoutExtension({
                            name: "Bottom",
                            group: "Align",
                            icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_ALIGN_BOTTOM),
                            action: makeAlignAction("y", maxValue, 1)
                        });
                        // Shift To
                        static ALIGN_BORDER_LEFT = new layout.TransformLayoutExtension({
                            name: "Border Left",
                            group: "Align To Border",
                            icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_BORDER_LEFT),
                            action: makeShiftAction("x", 0)
                        });
                        static ALIGN_BORDER_CENTER = new layout.TransformLayoutExtension({
                            name: "Border Center",
                            group: "Align To Border",
                            icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_BORDER_CENTER),
                            action: makeShiftAction("x", 0.5)
                        });
                        static ALIGN_BORDER_RIGHT = new layout.TransformLayoutExtension({
                            name: "Border Right",
                            group: "Align To Border",
                            icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_BORDER_RIGHT),
                            action: makeShiftAction("x", 1)
                        });
                        static ALIGN_BORDER_TOP = new layout.TransformLayoutExtension({
                            name: "Border Top",
                            group: "Align To Border",
                            icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_BORDER_TOP),
                            action: makeShiftAction("y", 0)
                        });
                        static ALIGN_BORDER_MIDDLE = new layout.TransformLayoutExtension({
                            name: "Border Middle",
                            group: "Align To Border",
                            icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_BORDER_MIDDLE),
                            action: makeShiftAction("y", 0.5)
                        });
                        static ALIGN_BORDER_BOTTOM = new layout.TransformLayoutExtension({
                            name: "Border Bottom",
                            group: "Align To Border",
                            icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_BORDER_BOTTOM),
                            action: makeShiftAction("y", 1)
                        });
                        // grid
                        static STACK_HORIZONTAL = new layout.TransformLayoutExtension({
                            name: "Row",
                            group: "Grid",
                            params: [{
                                    name: "padding",
                                    label: "Padding",
                                    defaultValue: 0
                                }],
                            icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_ROW),
                            action: args => {
                                args.positions.sort((a, b) => a.x - b.x);
                                const padding = args.params.padding;
                                const minX = minValue(args.positions.map(p => p.x));
                                const avgY = avgValue(args.positions.map(p => p.y));
                                let x = minX;
                                for (const pos of args.positions) {
                                    pos.x = x;
                                    pos.y = avgY;
                                    x += pos.size.x + padding;
                                }
                            }
                        });
                        static STACK_VERTICAL = new layout.TransformLayoutExtension({
                            name: "Column",
                            group: "Grid",
                            params: [{
                                    name: "padding",
                                    label: "Padding",
                                    defaultValue: 0
                                }],
                            icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_COLUMN),
                            action: args => {
                                args.positions.sort((a, b) => a.y - b.y);
                                const padding = args.params.padding;
                                const avgX = avgValue(args.positions.map(p => p.x));
                                const minY = minValue(args.positions.map(p => p.y));
                                let y = minY;
                                for (const pos of args.positions) {
                                    pos.x = avgX;
                                    pos.y = y;
                                    y += pos.size.y + padding;
                                }
                            }
                        });
                        static ROWS_AND_COLUMNS = new layout.TransformLayoutExtension({
                            name: "Grid",
                            group: "Grid",
                            params: [{
                                    name: "cols",
                                    label: "Columns",
                                    defaultValue: 3
                                }, {
                                    name: "padding",
                                    label: "Padding",
                                    defaultValue: 0
                                }, {
                                    name: "cellWidth",
                                    label: "Cell Width",
                                    defaultValue: 0
                                }, {
                                    name: "cellHeight",
                                    label: "Cell Height",
                                    defaultValue: 0
                                }],
                            icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_GRID),
                            action: args => {
                                const minX = minValue(args.positions.map(p => p.x));
                                const minY = minValue(args.positions.map(p => p.y));
                                let cols = args.params.cols;
                                let cellWidth = args.params.cellWidth;
                                let cellHeight = args.params.cellHeight;
                                const padding = args.params.padding;
                                if (cellWidth === 0) {
                                    cellWidth = maxValue(args.positions.map(p => p.size.x));
                                }
                                if (cellHeight === 0) {
                                    cellHeight = maxValue(args.positions.map(p => p.size.y));
                                }
                                cellWidth += padding;
                                cellHeight += padding;
                                let x = minX;
                                let y = minY;
                                let currentCol = 0;
                                const processed = new Set();
                                const findCloserPosition = (x, y) => {
                                    let result;
                                    let min = Number.MAX_SAFE_INTEGER;
                                    for (const pos of args.positions) {
                                        if (processed.has(pos)) {
                                            continue;
                                        }
                                        const d = Phaser.Math.Distance.Between(x, y, pos.x + pos.size.x / 2, pos.y + pos.size.y / 2);
                                        if (d < min) {
                                            result = pos;
                                            min = d;
                                        }
                                    }
                                    return result;
                                };
                                while (processed.size < args.positions.length) {
                                    const pos = findCloserPosition(x + cellWidth / 2, y + cellHeight / 2);
                                    processed.add(pos);
                                    pos.x = x + cellWidth / 2 - pos.size.x / 2;
                                    pos.y = y + cellHeight / 2 - pos.size.y / 2;
                                    x += cellWidth;
                                    currentCol++;
                                    if (currentCol === cols) {
                                        currentCol = 0;
                                        x = minX;
                                        y += cellHeight;
                                    }
                                }
                            }
                        });
                        // origin
                        static ORIGIN_TOP_LEFT = new layout.OriginLayoutExtension(0, 0);
                        static ORIGIN_TOP_CENTER = new layout.OriginLayoutExtension(0.5, 0);
                        static ORIGIN_TOP_RIGHT = new layout.OriginLayoutExtension(1, 0);
                        static ORIGIN_MIDDLE_LEFT = new layout.OriginLayoutExtension(0, 0.5);
                        static ORIGIN_MIDDLE_CENTER = new layout.OriginLayoutExtension(0.5, 0.5);
                        static ORIGIN_MIDDLE_RIGHT = new layout.OriginLayoutExtension(1, 0.5);
                        static ORIGIN_BOTTOM_LEFT = new layout.OriginLayoutExtension(0, 1);
                        static ORIGIN_BOTTOM_CENTER = new layout.OriginLayoutExtension(0.5, 1);
                        static ORIGIN_BOTTOM_RIGHT = new layout.OriginLayoutExtension(1, 1);
                        static ALL = [
                            DefaultLayoutExtensions.ALIGN_LEFT,
                            DefaultLayoutExtensions.ALIGN_CENTER,
                            DefaultLayoutExtensions.ALIGN_RIGHT,
                            DefaultLayoutExtensions.ALIGN_TOP,
                            DefaultLayoutExtensions.ALIGN_MIDDLE,
                            DefaultLayoutExtensions.ALIGN_BOTTOM,
                            DefaultLayoutExtensions.ALIGN_BORDER_LEFT,
                            DefaultLayoutExtensions.ALIGN_BORDER_CENTER,
                            DefaultLayoutExtensions.ALIGN_BORDER_RIGHT,
                            DefaultLayoutExtensions.ALIGN_BORDER_TOP,
                            DefaultLayoutExtensions.ALIGN_BORDER_MIDDLE,
                            DefaultLayoutExtensions.ALIGN_BORDER_BOTTOM,
                            DefaultLayoutExtensions.ORIGIN_TOP_LEFT,
                            DefaultLayoutExtensions.ORIGIN_TOP_CENTER,
                            DefaultLayoutExtensions.ORIGIN_TOP_RIGHT,
                            DefaultLayoutExtensions.ORIGIN_MIDDLE_LEFT,
                            DefaultLayoutExtensions.ORIGIN_MIDDLE_CENTER,
                            DefaultLayoutExtensions.ORIGIN_MIDDLE_RIGHT,
                            DefaultLayoutExtensions.ORIGIN_BOTTOM_LEFT,
                            DefaultLayoutExtensions.ORIGIN_BOTTOM_CENTER,
                            DefaultLayoutExtensions.ORIGIN_BOTTOM_RIGHT,
                            DefaultLayoutExtensions.ROWS_AND_COLUMNS,
                            DefaultLayoutExtensions.STACK_HORIZONTAL,
                            DefaultLayoutExtensions.STACK_VERTICAL
                        ];
                    }
                    layout.DefaultLayoutExtensions = DefaultLayoutExtensions;
                })(layout = editor.layout || (editor.layout = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_17) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_16) {
                var outline;
                (function (outline) {
                    class SceneEditorOutlineContentProvider {
                        _editor;
                        _includeUserComponents;
                        constructor(editor, includeUserComponents = false) {
                            this._editor = editor;
                            this._includeUserComponents = includeUserComponents;
                        }
                        getRoots(input) {
                            const scene = this._editor.getScene();
                            if (!scene) {
                                return [];
                            }
                            const displayList = scene.sys.displayList;
                            const roots = [];
                            if (displayList) {
                                roots.push(displayList);
                            }
                            if (scene.getObjectLists().getLists().length > 0) {
                                roots.push(scene.getObjectLists());
                            }
                            if (!scene.isScriptNodePrefabScene()) {
                                roots.push(...scene_17.ScenePlugin.getInstance().getPlainObjectCategories().filter(cat => {
                                    return this.getChildren(cat).length > 0;
                                }));
                            }
                            if (!scene.isPrefabSceneType()
                                && scene.getCodeSnippets().getSnippets().length > 0) {
                                roots.push(scene.getCodeSnippets());
                            }
                            if (scene.isPrefabSceneType()) {
                                roots.push(scene.getPrefabUserProperties());
                            }
                            return roots;
                        }
                        getChildren(parent) {
                            if (parent instanceof ui.codesnippets.CodeSnippets) {
                                return parent.getSnippets();
                            }
                            if (parent instanceof ui.sceneobjects.PrefabUserProperties) {
                                return parent.getProperties();
                            }
                            if (ui.sceneobjects.GameObjectEditorSupport.hasEditorSupport(parent)) {
                                const parentObj = parent;
                                let list = [];
                                const parentES = parentObj.getEditorSupport();
                                if (!parentES.isShowChildrenInOutline()) {
                                    list = [];
                                }
                                else if (parentES.isPrefabInstance()) {
                                    const prefabChildren = [];
                                    this.getPublicMutableNestedPrefabChildren(parent, prefabChildren);
                                    const appendedChildren = parentES.getAppendedChildren();
                                    list = [...prefabChildren.reverse(), ...appendedChildren.reverse()];
                                }
                                else {
                                    list = [...parentES.getObjectChildren()];
                                    list.reverse();
                                }
                                if (this._includeUserComponents) {
                                    // prepend the user components
                                    const compNodes = parentES
                                        .getUserComponentsComponent()
                                        .getUserComponentNodes()
                                        .filter(n => n.isPublished());
                                    list = [...compNodes, ...list];
                                }
                                return list;
                            }
                            if (parent instanceof Phaser.GameObjects.DisplayList) {
                                const list = [...parent.getChildren()];
                                list.reverse();
                                return list;
                            }
                            else if (parent instanceof ui.sceneobjects.ObjectLists) {
                                return parent.getLists();
                            }
                            else if (parent instanceof ui.sceneobjects.ObjectList) {
                                const scene = this._editor.getScene();
                                return parent.getItemsWithObjects(scene);
                            }
                            else if (typeof parent === "string") {
                                return this._editor.getScene().getPlainObjectsByCategory(parent);
                            }
                            const extensions = scene_17.ScenePlugin.getInstance().getSceneEditorOutlineExtensions();
                            for (const ext of extensions) {
                                if (ext.isContentProviderFor(parent)) {
                                    return ext.getContentProvider().getChildren(parent);
                                }
                            }
                            return [];
                        }
                        getPublicMutableNestedPrefabChildren(parent, list) {
                            const parentES = parent.getEditorSupport();
                            for (const child of parentES.getMutableNestedPrefabChildren()) {
                                const childES = child.getEditorSupport();
                                if (childES.isMutableNestedPrefabInstance()) {
                                    if (childES.isPrivateNestedPrefabInstance()) {
                                        this.getPublicMutableNestedPrefabChildren(child, list);
                                    }
                                    else {
                                        list.push(child);
                                    }
                                }
                            }
                        }
                    }
                    outline.SceneEditorOutlineContentProvider = SceneEditorOutlineContentProvider;
                })(outline = editor_16.outline || (editor_16.outline = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_17.ui || (scene_17.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var outline;
                (function (outline) {
                    class SceneEditorOutlineExtension extends colibri.Extension {
                        static POINT_ID = "phasereditor2d.scene.ui.editor.outline.SceneEditorOutlineProviderExtension";
                        constructor() {
                            super(SceneEditorOutlineExtension.POINT_ID);
                        }
                    }
                    outline.SceneEditorOutlineExtension = SceneEditorOutlineExtension;
                })(outline = editor.outline || (editor.outline = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var outline;
                (function (outline) {
                    var controls = colibri.ui.controls;
                    class SceneEditorOutlineLabelProvider extends controls.viewers.LabelProviderFromStyledLabelProvider {
                        constructor() {
                            super(new outline.SceneEditorOutlineStyledLabelProvider());
                        }
                    }
                    outline.SceneEditorOutlineLabelProvider = SceneEditorOutlineLabelProvider;
                })(outline = editor.outline || (editor.outline = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_17) {
                var outline;
                (function (outline) {
                    var ide = colibri.ui.ide;
                    class SceneEditorOutlineProvider extends ide.EditorViewerProvider {
                        _editor;
                        constructor(editor) {
                            super();
                            this._editor = editor;
                        }
                        fillContextMenu(menu) {
                            this._editor.fillContextMenu(menu);
                        }
                        getUndoManager() {
                            return this._editor.getUndoManager();
                        }
                        getContentProvider() {
                            return new outline.SceneEditorOutlineContentProvider(this._editor);
                        }
                        getLabelProvider() {
                            return new outline.SceneEditorOutlineLabelProvider();
                        }
                        getStyledLabelProvider() {
                            return new outline.SceneEditorOutlineStyledLabelProvider();
                        }
                        getCellRendererProvider() {
                            return new outline.SceneEditorOutlineRendererProvider();
                        }
                        getTreeViewerRenderer(viewer) {
                            return new outline.SceneEditorOutlineViewerRenderer(viewer);
                        }
                        getPropertySectionProvider() {
                            return this._editor.getPropertyProvider();
                        }
                        getInput() {
                            return this._editor;
                        }
                        preload() {
                            return;
                        }
                        onViewerSelectionChanged(selection) {
                            this._editor.setSelection(selection, false);
                            this._editor.repaint();
                        }
                    }
                    outline.SceneEditorOutlineProvider = SceneEditorOutlineProvider;
                })(outline = editor_17.outline || (editor_17.outline = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var outline;
                (function (outline) {
                    var controls = colibri.ui.controls;
                    class SceneEditorOutlineRendererProvider {
                        getCellRenderer(element) {
                            const support = ui.sceneobjects.EditorSupport.getEditorSupport(element);
                            if (support) {
                                return support.getCellRenderer();
                            }
                            else if (element instanceof Phaser.GameObjects.DisplayList
                                || element instanceof ui.sceneobjects.ObjectLists
                                || typeof element === "string"
                                || element instanceof ui.sceneobjects.PrefabUserProperties) {
                                return new controls.viewers.IconImageCellRenderer(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                            }
                            else if (element instanceof ui.sceneobjects.ObjectList) {
                                return new controls.viewers.IconImageCellRenderer(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_LIST));
                            }
                            else if (element instanceof ui.sceneobjects.ObjectListItem) {
                                return new ui.sceneobjects.ObjectListItemCellRenderer(this.getCellRenderer(element.getObject()));
                            }
                            else if (element instanceof ui.sceneobjects.UserComponentNode) {
                                return new controls.viewers.IconImageCellRenderer(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_USER_COMPONENT));
                            }
                            else if (element instanceof ui.sceneobjects.UserProperty) {
                                return new controls.viewers.IconImageCellRenderer(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_USER_PROPERTY));
                            }
                            else if (element instanceof ui.codesnippets.CodeSnippets) {
                                return new controls.viewers.IconImageCellRenderer(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                            }
                            else if (element instanceof ui.codesnippets.CodeSnippet) {
                                return new controls.viewers.IconImageCellRenderer(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_BUILD));
                            }
                            const extensions = scene.ScenePlugin.getInstance().getSceneEditorOutlineExtensions();
                            for (const ext of extensions) {
                                if (ext.isCellRendererProviderFor(element)) {
                                    return ext.getCellRendererProvider().getCellRenderer(element);
                                }
                            }
                            return new controls.viewers.EmptyCellRenderer(false);
                        }
                        async preload(args) {
                            return controls.Controls.resolveNothingLoaded();
                        }
                    }
                    outline.SceneEditorOutlineRendererProvider = SceneEditorOutlineRendererProvider;
                })(outline = editor.outline || (editor.outline = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var outline;
                (function (outline) {
                    var controls = colibri.ui.controls;
                    class SceneEditorOutlineStyledLabelProvider {
                        getLabel(obj) {
                            if (ui.sceneobjects.ScenePlainObjectEditorSupport.hasEditorSupport(obj)) {
                                const plainObject = obj;
                                return plainObject.getEditorSupport().getLabel();
                            }
                            else if (ui.sceneobjects.isGameObject(obj)) {
                                const objES = obj.getEditorSupport();
                                if (objES.getScene().isPrefabSceneType() && obj === objES.getScene().getPrefabObject()) {
                                    const file = objES.getScene().getEditor().getInput();
                                    return `${file.getNameWithoutExtension()} (Prefab Object: ${objES.isPrefabInstance() ? objES.getPrefabName() : objES.getObjectType()})`;
                                }
                                let label = ui.sceneobjects.formatObjectDisplayText(obj);
                                return label;
                            }
                            else if (obj instanceof Phaser.GameObjects.DisplayList) {
                                return "Scene";
                            }
                            else if (obj instanceof ui.sceneobjects.ObjectLists) {
                                return "Lists";
                            }
                            else if (obj instanceof ui.sceneobjects.ObjectList) {
                                return obj.getLabel();
                            }
                            else if (obj instanceof ui.sceneobjects.ObjectListItem) {
                                return this.getLabel(obj.getObject());
                            }
                            else if (obj instanceof ui.sceneobjects.UserComponentNode) {
                                return obj.getUserComponent().getDisplayNameOrName();
                            }
                            else if (obj instanceof ui.sceneobjects.PrefabUserProperties) {
                                return "Prefab Properties";
                            }
                            else if (obj instanceof ui.sceneobjects.UserProperty) {
                                return obj.getLabel();
                            }
                            else if (obj instanceof ui.codesnippets.CodeSnippets) {
                                return "Code Snippets";
                            }
                            else if (obj instanceof ui.codesnippets.CodeSnippet) {
                                return obj.getDisplayName();
                            }
                            const extensions = scene.ScenePlugin.getInstance().getSceneEditorOutlineExtensions();
                            for (const ext of extensions) {
                                if (ext.isLabelProviderFor(obj)) {
                                    return ext.getLabelProvider().getLabel(obj);
                                }
                            }
                            return "" + obj;
                        }
                        getStyledTexts(obj, dark) {
                            const theme = controls.Controls.getTheme();
                            let color = theme.viewerForeground;
                            const baseLabel = this.getLabel(obj);
                            let hintText = "";
                            if (obj instanceof ui.sceneobjects.UserComponentNode) {
                                if (obj.isPrefabDefined()) {
                                    hintText += ` (comp ← ${obj.getPrefabFile().getNameWithoutExtension()})`;
                                    if (obj.getObject().getEditorSupport().isMutableNestedPrefabInstance()) {
                                        color = scene.ScenePlugin.getInstance().getNestedPrefabColor();
                                    }
                                    else {
                                        color = scene.ScenePlugin.getInstance().getPrefabColor();
                                    }
                                }
                                else {
                                    hintText += " (comp)";
                                }
                            }
                            if (ui.sceneobjects.isGameObject(obj) && ui.sceneobjects.findObjectDisplayFormat(obj)) {
                                const objES = obj.getEditorSupport();
                                hintText += ` (${objES.getLabel()})`;
                            }
                            if (ui.sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, ui.sceneobjects.VisibleComponent)) {
                                const visible = ui.sceneobjects.VisibleComponent.visible.getValue(obj);
                                if (!visible) {
                                    hintText += "(hidden)";
                                }
                            }
                            if (ui.sceneobjects.isGameObject(obj)) {
                                const objES = obj.getEditorSupport();
                                if (obj instanceof ui.sceneobjects.FXObject) {
                                    hintText += " #" + (obj.isPreFX ? "preFX" : "postFX");
                                }
                                if (obj instanceof ui.sceneobjects.ScriptNode) {
                                    hintText += " #script";
                                }
                                if (objES.isMutableNestedPrefabInstance()) {
                                    hintText += " #nested_prefab_inst";
                                    color = scene.ScenePlugin.getInstance().getNestedPrefabColor();
                                }
                                else if (objES.isPrefabInstance()) {
                                    hintText += " #prefab_inst";
                                    color = scene.ScenePlugin.getInstance().getPrefabColor();
                                }
                                if (!objES.isNestedPrefabInstance()) {
                                    hintText += ` #scope_${objES.getScope().toLocaleLowerCase()}`;
                                }
                            }
                            if (hintText === "") {
                                return [
                                    {
                                        text: baseLabel,
                                        color: theme.viewerForeground
                                    }
                                ];
                            }
                            return [
                                {
                                    text: baseLabel,
                                    color
                                },
                                {
                                    text: " " + hintText,
                                    color: theme.viewerForeground + "45"
                                }
                            ];
                        }
                    }
                    outline.SceneEditorOutlineStyledLabelProvider = SceneEditorOutlineStyledLabelProvider;
                })(outline = editor.outline || (editor.outline = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var outline;
                (function (outline) {
                    var controls = colibri.ui.controls;
                    class SceneEditorOutlineViewerRenderer extends controls.viewers.TreeViewerRenderer {
                        constructor(viewer) {
                            super(viewer, 48);
                        }
                        prepareContextForRenderCell(args) {
                            if (this.isNonTopPrefabObject(args.obj)) {
                                args.canvasContext.globalAlpha = 0.3;
                            }
                        }
                        isNonTopPrefabObject(obj) {
                            const support = ui.sceneobjects.GameObjectEditorSupport.getEditorSupport(obj);
                            if (support) {
                                return support.getScene().isNonTopPrefabObject(obj);
                            }
                            return false;
                        }
                        prepareContextForText(args) {
                            if (ui.sceneobjects.isGameObject(args.obj)) {
                                const obj = args.obj;
                                if (obj.getEditorSupport().isPrefabInstance()) {
                                    args.canvasContext.font = `italic ${controls.getCanvasFontHeight()}px ${controls.FONT_FAMILY}`;
                                }
                            }
                            if (this.isNonTopPrefabObject(args.obj)) {
                                args.canvasContext.globalAlpha = 0.3;
                            }
                            super.prepareContextForText(args);
                        }
                    }
                    outline.SceneEditorOutlineViewerRenderer = SceneEditorOutlineViewerRenderer;
                })(outline = editor.outline || (editor.outline = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_18) {
                var properties;
                (function (properties) {
                    class SceneSection extends properties.BaseSceneSection {
                        getScene() {
                            return this.getEditor().getScene();
                        }
                        canEdit(obj, n) {
                            return obj instanceof ui.Scene;
                        }
                        canEditNumber(n) {
                            return n === 1;
                        }
                        getSettings() {
                            return this.getScene().getSettings();
                        }
                        getHelp(key) {
                            return "TODO";
                        }
                        createStringField(comp, name, label, tooltip) {
                            const labelElement = this.createLabel(comp, label, tooltip);
                            const textElement = this.createText(comp);
                            this.addUpdater(() => {
                                const value = this.getSettings()[name];
                                textElement.value = value === undefined ? "" : value.toString();
                            });
                            textElement.addEventListener("change", e => {
                                const editor = this.getEditor();
                                editor.getUndoManager().add(new properties.ChangeSettingsPropertyOperation({
                                    editor: editor,
                                    props: [{
                                            name,
                                            value: textElement.value,
                                        }],
                                    repaint: true
                                }));
                            });
                            return {
                                label: labelElement,
                                text: textElement
                            };
                        }
                        createIntegerField(comp, name, label, tooltip) {
                            const labelElement = this.createLabel(comp, label, tooltip);
                            const textElement = this.createText(comp);
                            this.addUpdater(() => {
                                textElement.value = this.getSettings()[name].toString();
                            });
                            textElement.addEventListener("change", e => {
                                const editor = this.getEditor();
                                const value = this.parseNumberExpression(textElement, true);
                                if (isNaN(value)) {
                                    this.updateWithSelection();
                                }
                                else {
                                    editor.getUndoManager().add(new properties.ChangeSettingsPropertyOperation({
                                        editor: editor,
                                        props: [{
                                                name: name,
                                                value: value,
                                            }],
                                        repaint: true
                                    }));
                                }
                            });
                            return {
                                label: labelElement,
                                text: textElement
                            };
                        }
                        createMenuField(comp, getItems, name, label, tooltip) {
                            this.createLabel(comp, label, tooltip);
                            const btn = this.createMenuButton(comp, "-", getItems, value => {
                                const editor = this.getEditor();
                                editor.getUndoManager().add(new properties.ChangeSettingsPropertyOperation({
                                    editor: editor,
                                    props: [{
                                            name: name,
                                            value: value,
                                        }],
                                    repaint: true
                                }));
                            });
                            this.addUpdater(() => {
                                const item = getItems().find(i => i.value === this.getSettings()[name]);
                                btn.textContent = item ? item.name : "-";
                            });
                        }
                        createBooleanField(comp, name, label) {
                            const checkElement = this.createCheckbox(comp, label);
                            this.addUpdater(() => {
                                checkElement.checked = this.getSettings()[name];
                            });
                            checkElement.addEventListener("change", e => {
                                const editor = this.getEditor();
                                editor.getUndoManager().add(new properties.ChangeSettingsPropertyOperation({
                                    editor: editor,
                                    props: [{
                                            name: name,
                                            value: checkElement.checked,
                                        }],
                                    repaint: true
                                }));
                            });
                            return checkElement;
                        }
                    }
                    properties.SceneSection = SceneSection;
                })(properties = editor_18.properties || (editor_18.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class BorderSection extends properties.SceneSection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.properties.DisplaySection", "Border", false, true);
                        }
                        getSectionHelpPath() {
                            return "scene-editor/border-properties.html";
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 3);
                            comp.style.gridTemplateColumns = "auto auto 1fr auto 1fr";
                            this.createLabel(comp, "Border");
                            this.createIntegerField(comp, "borderX", "X", "Scene border position (X)");
                            this.createIntegerField(comp, "borderY", "Y", "Scene border position (Y)");
                            this.createLabel(comp, "");
                            this.createIntegerField(comp, "borderWidth", "Width", "Scene border width");
                            this.createIntegerField(comp, "borderHeight", "Height", "Scene border height");
                        }
                    }
                    properties.BorderSection = BorderSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../undo/SceneEditorOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_18) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_19) {
                var properties;
                (function (properties) {
                    class ChangePrefabPropertiesOperation extends editor_19.undo.SceneEditorOperation {
                        _before;
                        _after;
                        constructor(editor, before, after) {
                            super(editor);
                            this._before = before;
                            this._after = after;
                        }
                        static snapshot(editor) {
                            const data = [];
                            editor.getScene().getPrefabUserProperties().writeJSON(data);
                            return data;
                        }
                        static runPropertiesOperation(editor, action, updateSelection) {
                            const scene = editor.getScene();
                            const before = this.snapshot(editor);
                            action(scene.getPrefabUserProperties());
                            const after = this.snapshot(editor);
                            editor.getUndoManager()
                                .add(new ChangePrefabPropertiesOperation(editor, before, after));
                            editor.setDirty(true);
                            editor.refreshOutline();
                            if (updateSelection) {
                                editor.getSelectionManager().refreshSelection();
                            }
                        }
                        load(data) {
                            const editor = this.getEditor();
                            editor.getScene().getPrefabUserProperties().readJSON(data);
                            editor.setDirty(true);
                            editor.getSelectionManager().refreshSelection();
                            editor.refreshOutline();
                            editor.dispatchSelectionChanged();
                        }
                        undo() {
                            this.load(this._before);
                        }
                        redo() {
                            this.load(this._after);
                        }
                    }
                    properties.ChangePrefabPropertiesOperation = ChangePrefabPropertiesOperation;
                })(properties = editor_19.properties || (editor_19.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_18.ui || (scene_18.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../undo/SceneEditorOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class ChangeSettingsPropertyOperation extends editor.undo.SceneEditorOperation {
                        _props;
                        _before;
                        _after;
                        _repaint;
                        constructor(args) {
                            super(args.editor);
                            this._props = args.props;
                            this._repaint = args.repaint;
                        }
                        async execute() {
                            const settings = this._editor.getScene().getSettings();
                            this._before = new Map();
                            this._after = new Map();
                            for (const prop of this._props) {
                                this._before.set(prop.name, settings[prop.name]);
                                this._after.set(prop.name, prop.value);
                            }
                            this.setValue(this._after);
                        }
                        setValue(value) {
                            const settings = this._editor.getScene().getSettings();
                            for (const prop of this._props) {
                                settings[prop.name] = value.get(prop.name);
                            }
                            this._editor.setSelection(this._editor.getSelection());
                            this._editor.setDirty(true);
                            if (this._repaint) {
                                this._editor.repaint();
                            }
                        }
                        undo() {
                            this.setValue(this._before);
                        }
                        redo() {
                            this.setValue(this._after);
                        }
                    }
                    properties.ChangeSettingsPropertyOperation = ChangeSettingsPropertyOperation;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class CompilerSection extends properties.SceneSection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.properties.CompilerSection", "Compiler General Settings", false, true);
                        }
                        getSectionHelpPath() {
                            return "scene-editor/scene-compiler-general-settings.html";
                        }
                        createMenu(menu) {
                            this.getEditor().getMenuCreator().createCompilerMenu(menu);
                            menu.addSeparator();
                            super.createMenu(menu);
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 3);
                            comp.style.gridTemplateColumns = "auto 1fr";
                            // this.createMenuField(
                            //     comp, [
                            //     {
                            //         name: "Scene",
                            //         value: core.json.SceneType.SCENE,
                            //     },
                            //     {
                            //         name: "Prefab",
                            //         value: core.json.SceneType.PREFAB,
                            //     }],
                            //     "sceneType", "Scene Type",
                            //     "If this is a regular scene or a prefab.");
                            this.createBooleanField(comp, "compilerEnabled", this.createLabel(comp, "Generate Code", "Compiles the scene into code."));
                            this.createMenuField(comp, () => [
                                {
                                    name: "JavaScript",
                                    value: phasereditor2d.ide.core.code.SourceLang.JAVA_SCRIPT,
                                },
                                {
                                    name: "TypeScript",
                                    value: phasereditor2d.ide.core.code.SourceLang.TYPE_SCRIPT
                                }
                            ], "compilerOutputLanguage", "Output Language", "The scene compiler output language.");
                            this.createBooleanField(comp, "javaScriptInitFieldsInConstructor", this.createLabel(comp, "Fields In Constructor (JS)", "Generate the initialization of the fields in the constructor. This is valid only when the output is JavaScript."));
                            this.createBooleanField(comp, "exportClass", this.createLabel(comp, "Export Class (ES Module)", "Export the generated class."));
                            this.createBooleanField(comp, "autoImport", this.createLabel(comp, "Auto Import (ES Module)", "Automatic import used classes like prefabs and user components."));
                            this.createStringField(comp, "superClassName", "Super Class", "The super class used for the scene. If it is blank (no-value) then use default value.");
                            this.createBooleanField(comp, "compilerInsertSpaces", this.createLabel(comp, "Insert Spaces", "Insert convert tabs to spaces"));
                            this.createIntegerField(comp, "compilerTabSize", "Tab Size", "The size of tabs, in spaces.");
                        }
                    }
                    properties.CompilerSection = CompilerSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class DocsSection extends editor.properties.BaseSceneSection {
                        _converter;
                        constructor(page, id) {
                            super(page, id, "Documentation", true, false);
                            this._converter = new window["showdown"].Converter();
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 1);
                            comp.style.alignItems = "self-start";
                            const docElement = document.createElement("div");
                            docElement.style.height = "100%";
                            docElement.classList.add("UserSelectText");
                            comp.appendChild(docElement);
                            this.addUpdater(() => {
                                const help = this.getHelp();
                                const html = this._converter.makeHtml(help);
                                docElement.innerHTML = html;
                            });
                        }
                        hasMenu() {
                            return false;
                        }
                        canEditNumber(n) {
                            return n === 1;
                        }
                    }
                    properties.DocsSection = DocsSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_19) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                /**
                 * A base for objects added to the scene.
                 * It doesn't need to be a game object (like an Image), it could be a plain object.
                 * You can take a look to the `SceneGameObjectSection` and the `PlainObjectSection`.
                 */
                class SceneObjectSection extends ui.editor.properties.BaseSceneSection {
                    createEnumField(parent, property, checkUnlocked = true, filter) {
                        const getItems = () => (property.values ?? property.getEnumValues(this.getSelection()[0]))
                            .filter(v => !filter || filter(v))
                            .map(value => {
                            return {
                                name: property.getValueLabel(value),
                                value
                            };
                        });
                        const btn = this.createMenuButton(parent, "", getItems, value => {
                            this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), property, value));
                        });
                        this.addUpdater(() => {
                            btn.disabled = checkUnlocked && !this.isUnlocked(property);
                            btn.textContent = this.flatValues_StringJoinDifferent(this.getSelection()
                                .map(obj => property.getValueLabel(property.getValue(obj))));
                        });
                        return btn;
                    }
                    createIncrementableStringField(parent, property) {
                        const text = this.createIncrementableText(parent, false, property.increment, property.incrementMin, property.incrementMax, property.incrementValueComputer);
                        const makeListener = (isPreview) => {
                            return (e) => {
                                const textValue = text.value;
                                let value;
                                if (textValue.trim() === "") {
                                    value = property.defValue;
                                }
                                else {
                                    value = textValue;
                                }
                                if (isPreview) {
                                    for (const obj of this.getSelection()) {
                                        property.setValue(obj, value);
                                    }
                                    this.getEditor().repaint();
                                }
                                else {
                                    if (e instanceof CustomEvent) {
                                        // this is a custom event then it is setting the value
                                        // from alternative methods like mouse wheel or dragging the label
                                        // so let's restore the initial value of the objects
                                        if (e.detail) {
                                            const initValue = e.detail.initText;
                                            for (const obj of this.getSelection()) {
                                                property.setValue(obj, initValue);
                                            }
                                        }
                                    }
                                    this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), property, value));
                                }
                            };
                        };
                        text.addEventListener("preview", makeListener(true));
                        text.addEventListener("change", makeListener(false));
                        this.addUpdater(() => {
                            text.disabled = !this.isUnlocked(property);
                            const values = this.getSelection()
                                .map(obj => property.getValue(obj));
                            text.value = this.flatValues_StringOneOrNothing(values);
                        });
                        return text;
                    }
                    // tslint:disable-next-line:ban-types
                    createFloatField(parent, property) {
                        const text = this.createIncrementableText(parent, false, property.increment, property.incrementMin, property.incrementMax);
                        const makeListener = (isPreview) => {
                            return (e) => {
                                const textValue = text.value;
                                let value;
                                if (textValue.trim() === "") {
                                    value = property.defValue;
                                }
                                else {
                                    value = this.parseNumberExpression(text);
                                }
                                if (isNaN(value)) {
                                    this.updateWithSelection();
                                }
                                else {
                                    if (isPreview) {
                                        for (const obj of this.getSelection()) {
                                            property.setValue(obj, value);
                                        }
                                        this.getEditor().repaint();
                                    }
                                    else {
                                        if (e instanceof CustomEvent) {
                                            // this is a custom event then it is setting the value
                                            // from alternative methods like mouse wheel or dragging the label
                                            // so let's restore the initial value of the objects
                                            if (e.detail) {
                                                const initText = e.detail.initText;
                                                const value = this.parseNumberExpressionString(initText);
                                                if (typeof value === "number") {
                                                    for (const obj of this.getSelection()) {
                                                        property.setValue(obj, value);
                                                    }
                                                }
                                            }
                                        }
                                        this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), property, value));
                                    }
                                }
                            };
                        };
                        text.addEventListener("preview", makeListener(true));
                        text.addEventListener("change", makeListener(false));
                        this.addUpdater(() => {
                            text.disabled = !this.isUnlocked(property);
                            const values = this.getSelection()
                                .map(obj => property.getValue(obj));
                            text.value = this.flatValues_Number(values);
                        });
                        return text;
                    }
                    createStringField(parent, property, checkUnlock = true, readOnlyOnMultiple = false, multiLine = false, forceReadOnly = false) {
                        const text = multiLine ? this.createTextArea(parent, false) : this.createText(parent, false);
                        text.addEventListener("change", e => {
                            const value = text.value;
                            this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), property, value));
                        });
                        this.addUpdater(() => {
                            text.readOnly = forceReadOnly || checkUnlock && !this.isUnlocked(property);
                            if (readOnlyOnMultiple) {
                                text.readOnly = text.readOnly || readOnlyOnMultiple && this.getSelection().length > 1;
                            }
                            text.value = this.flatValues_StringOneOrNothing(this.getSelection()
                                .map(obj => property.getValue(obj)));
                        });
                        return text;
                    }
                    createStringDialogField(parent, property, checkUnlock = true, readOnlyOnMultiple = false) {
                        const { text, btn } = this.createTextDialog(parent, property.label, false);
                        text.addEventListener("change", e => {
                            const value = text.value;
                            this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), property, value));
                        });
                        this.addUpdater(() => {
                            text.readOnly = checkUnlock && !this.isUnlocked(property);
                            if (readOnlyOnMultiple) {
                                text.readOnly = text.readOnly || readOnlyOnMultiple && this.getSelection().length > 1;
                            }
                            text.value = this.flatValues_StringOneOrNothing(this.getSelection()
                                .map(obj => property.getValue(obj)));
                            btn.disabled = text.readOnly;
                        });
                        return text;
                    }
                    createColorField(parent, property, allowAlpha = true, checkUnlock = true, readOnlyOnMultiple = false) {
                        const colorElement = this.createColor(parent, false, allowAlpha);
                        const text = colorElement.text;
                        const btn = colorElement.btn;
                        const currentColor = text.value;
                        text.addEventListener("preview", e => {
                            const value = text.value;
                            console.log("preview color", value);
                            for (const obj of this.getSelection()) {
                                property.setValue(obj, value);
                            }
                            this.getEditor().repaint();
                        });
                        text.addEventListener("change", e => {
                            const value = text.value;
                            this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), property, value));
                        });
                        this.addUpdater(() => {
                            text.readOnly = checkUnlock && !this.isUnlocked(property);
                            if (readOnlyOnMultiple) {
                                text.readOnly = text.readOnly || readOnlyOnMultiple && this.getSelection().length > 1;
                            }
                            btn.disabled = text.readOnly;
                            text.value = this.flatValues_StringOneOrNothing(this.getSelection()
                                .map(obj => property.getValue(obj)));
                            btn.style.background = text.value.endsWith("selected)") ? "transparent" : text.value;
                        });
                        return colorElement;
                    }
                    createKeyCodeField(parent, property, checkUnlock = true) {
                        const btn = this.createButton(parent, "KeyCode", e => {
                            const viewer = new sceneobjects.KeyboardKeysViewer();
                            const selObj = this.getSelectionFirstElement();
                            const keyCode = property.getValue(selObj);
                            viewer.revealAndSelect(keyCode);
                            const dlg = new controls.dialogs.ViewerDialog(viewer, false);
                            dlg.create();
                            dlg.setTitle("Select Key Code");
                            dlg.addOpenButton("Select", (sel) => {
                                const value = sel[0];
                                const keys = this.getSelection();
                                this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), keys, property, value));
                            }, false);
                            dlg.addCancelButton();
                        });
                        this.addUpdater(() => {
                            btn.textContent = this.flatValues_StringOneOrNothing(this.getSelection().map(obj => property.getValue(obj)));
                            btn.disabled = checkUnlock && !this.isUnlocked(property);
                        });
                    }
                    createBooleanField(parent, property, checkUnlock = true) {
                        const labelElement = this.createLabel(parent, property.label, scene_19.PhaserHelp(property.tooltip));
                        const checkElement = this.createCheckbox(parent, labelElement);
                        checkElement.addEventListener("change", e => {
                            const value = checkElement.checked;
                            this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), property, value));
                        });
                        this.addUpdater(() => {
                            checkElement.disabled = checkUnlock && !this.isUnlocked(property);
                            const list = this.getSelection()
                                .map(obj => property.getValue(obj))
                                .filter(b => !b);
                            checkElement.checked = list.length === 0;
                        });
                        return {
                            labelElement,
                            checkElement
                        };
                    }
                    createObjectVarField(parent, property, checkUnlock = true, readOnlyOnMultiple = false) {
                        const fieldElement = document.createElement("div");
                        fieldElement.classList.add("formGrid");
                        fieldElement.style.gridTemplateColumns = "1fr auto";
                        parent.appendChild(fieldElement);
                        const text = this.createText(fieldElement, false);
                        const getValue = () => this.flatValues_StringOneOrNothing(this.getSelection()
                            .map(obj => property.getValue(obj)));
                        text.addEventListener("change", e => {
                            const value = text.value;
                            this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), property, value));
                        });
                        this.addUpdater(() => {
                            text.readOnly = checkUnlock && !this.isUnlocked(property);
                            if (readOnlyOnMultiple) {
                                text.readOnly = text.readOnly || readOnlyOnMultiple && this.getSelection().length > 1;
                            }
                            text.value = getValue();
                        });
                        const dlgArgs = {
                            getValue: () => getValue(),
                            createDialogViewer: async (revealValue) => {
                                const sceneEditor = this.getEditor();
                                const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.editor.ObjectVarExpressionType.Dialog");
                                viewer.setCellRendererProvider(new ui.editor.outline.SceneEditorOutlineRendererProvider());
                                viewer.setLabelProvider(new ui.editor.outline.SceneEditorOutlineLabelProvider());
                                viewer.setStyledLabelProvider(new ui.editor.outline.SceneEditorOutlineStyledLabelProvider());
                                viewer.setContentProvider(new sceneobjects.ObjectVarContentProvider(sceneEditor));
                                const scene = sceneEditor.getScene();
                                const input = [
                                    ...scene.getGameObjects(),
                                    ...scene.getObjectLists().getLists()
                                ];
                                viewer.setInput(input);
                                const found = scene.findByEditorLabel(revealValue);
                                if (found) {
                                    viewer.setSelection([found]);
                                    viewer.reveal(found);
                                }
                                return viewer;
                            },
                            dialogElementToString: (viewer, value) => {
                                const support = sceneobjects.EditorSupport.getEditorSupport(value);
                                if (support) {
                                    return support.getLabel();
                                }
                                return viewer.getLabelProvider().getLabel(value);
                            },
                            dialogTittle: "Select Object",
                            onValueSelected: (value) => {
                                text.value = value;
                                this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), property, value));
                            },
                            updateIconCallback: async (iconControl, value) => {
                                const scene = this.getEditor().getScene();
                                const found = scene.findByEditorLabel(value);
                                if (found) {
                                    const renderer = new ui.editor.outline.SceneEditorOutlineRendererProvider()
                                        .getCellRenderer(found);
                                    const icon = new controls.viewers.ImageFromCellRenderer(found, renderer, controls.RENDER_ICON_SIZE, controls.RENDER_ICON_SIZE);
                                    await icon.preload();
                                    iconControl.setIcon(icon);
                                }
                                else {
                                    iconControl.setIcon(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                                }
                            },
                        };
                        const result = this.createButtonDialog(dlgArgs);
                        fieldElement.appendChild(result.buttonElement);
                        this.addUpdater(() => {
                            result.updateDialogButtonIcon();
                        });
                        return {
                            textElement: text,
                            btnElement: result.buttonElement
                        };
                    }
                    isUnlocked(...properties) {
                        for (const obj of this.getSelection()) {
                            for (const property of properties) {
                                const objES = obj.getEditorSupport();
                                const locked = !objES.isUnlockedProperty(property);
                                if (locked) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                }
                sceneobjects.SceneObjectSection = SceneObjectSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_19.ui || (scene_19.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneObjectSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_20) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class SceneGameObjectSection extends sceneobjects.SceneObjectSection {
                    isPrefabSceneObject(obj) {
                        const support = sceneobjects.GameObjectEditorSupport.getEditorSupport(obj);
                        if (support) {
                            const scene = support.getScene();
                            if (scene.isPrefabSceneType()) {
                                if (scene.getPrefabObject() === obj) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                    createSeparatorForXYGrid(parent, text) {
                        const label = this.createSeparator(parent, text);
                        label.style.gridColumn = "span 6";
                        return label;
                    }
                    createGridElementWithPropertiesXY(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto auto 1fr auto 1fr";
                        return comp;
                    }
                    createGridElementWithPropertiesBoolXY(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto auto 1fr auto 1fr";
                        return comp;
                    }
                    createLock(parent, ...properties) {
                        const mutableIcon = new controls.IconControl();
                        const element = mutableIcon.getCanvas();
                        element.classList.add("PropertyLockIcon");
                        parent.appendChild(element);
                        const lockedIcon = phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_LOCKED);
                        const unlockedIcon = phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_UNLOCKED);
                        element.addEventListener("click", e => {
                            const unlocked = !this.isUnlocked(...properties);
                            this.getEditor().getUndoManager().add(new sceneobjects.PropertyUnlockOperation(this.getEditor(), this.getSelection(), properties, unlocked));
                        });
                        this.addUpdater(() => {
                            const thereIsPrefabInstances = this.getSelection()
                                .map(obj => obj.getEditorSupport().isPrefabInstance())
                                .find(b => b);
                            if (thereIsPrefabInstances) {
                                element.style.width = controls.RENDER_ICON_SIZE + "px";
                                const unlocked = this.isUnlocked(...properties);
                                mutableIcon.setIcon(unlocked ? unlockedIcon : lockedIcon);
                            }
                            else {
                                element.style.width = "0px";
                            }
                        });
                    }
                    createNumberPropertyRow(parent, prop, fullWidth = true) {
                        this.createLock(parent, prop);
                        const label = this.createLabel(parent, prop.label, scene_20.PhaserHelp(prop.tooltip));
                        label.style.gridColumn = "2 / span 2";
                        const text = this.createFloatField(parent, prop);
                        text.style.gridColumn = fullWidth ? "4 / span 3" : "4";
                        this.createPropertyLabelToTextNumericLink(prop, label, text);
                        return {
                            labelElement: label,
                            textElement: text
                        };
                    }
                    createPropertyLabelToTextNumericLink(prop, label, text) {
                        if (prop.increment) {
                            this.createLabelToTextNumericLink(label, text, prop.increment, prop.incrementMin, prop.incrementMax, prop.incrementValueComputer);
                        }
                    }
                    createNumberProperty(parent, prop) {
                        this.createLock(parent, prop);
                        const label = this.createLabel(parent, prop.label, scene_20.PhaserHelp(prop.tooltip));
                        const text = this.createFloatField(parent, prop);
                        this.createPropertyLabelToTextNumericLink(prop, label, text);
                    }
                    createPropertyBoolean(parent, prop, lockIcon = true) {
                        if (lockIcon) {
                            this.createLock(parent, prop);
                        }
                        const elements = this.createBooleanField(parent, prop, lockIcon);
                        elements.labelElement.style.gridColumn = "2 / auto";
                        return elements;
                    }
                    createPropertyBoolXYRow(parent, propXY, lockIcon = true) {
                        if (lockIcon) {
                            this.createLock(parent, propXY.x, propXY.y);
                            this.createLabel(parent, propXY.label, scene_20.PhaserHelp(propXY.tooltip));
                        }
                        else {
                            const label = this.createLabel(parent, propXY.label, scene_20.PhaserHelp(propXY.tooltip));
                            label.style.gridColumn = "2";
                        }
                        for (const prop of [propXY.x, propXY.y]) {
                            this.createBooleanField(parent, prop);
                        }
                    }
                    createPropertyFloatRow(parent, prop, lockIcon = true) {
                        if (lockIcon) {
                            this.createLock(parent, prop);
                        }
                        const label = this.createLabel(parent, prop.label, scene_20.PhaserHelp(prop.tooltip));
                        label.style.gridColumn = "2";
                        const text = this.createFloatField(parent, prop);
                        this.createPropertyLabelToTextNumericLink(prop, label, text);
                        return text;
                    }
                    createPropertyStringRow(parent, prop, lockIcon = true, readOnly = false, incrementable = false) {
                        if (lockIcon) {
                            this.createLock(parent, prop);
                        }
                        const label = this.createLabel(parent, prop.label, scene_20.PhaserHelp(prop.tooltip));
                        label.style.gridColumn = "2";
                        let text;
                        if (incrementable) {
                            text = this.createIncrementableStringField(parent, prop);
                            this.createPropertyLabelToTextNumericLink(prop, label, text);
                        }
                        else {
                            text = this.createStringField(parent, prop, true, false, false, readOnly);
                        }
                        return { label, text };
                    }
                    createPropertyStringDialogRow(parent, prop, lockIcon = true) {
                        if (lockIcon) {
                            this.createLock(parent, prop);
                        }
                        const label = this.createLabel(parent, prop.label, scene_20.PhaserHelp(prop.tooltip));
                        label.style.gridColumn = "2";
                        return this.createStringDialogField(parent, prop);
                    }
                    createPropertyColorRow(parent, prop, allowAlpha = true, lockIcon = true) {
                        if (lockIcon) {
                            this.createLock(parent, prop);
                        }
                        const label = this.createLabel(parent, prop.label, scene_20.PhaserHelp(prop.tooltip));
                        label.style.gridColumn = "2";
                        const text = this.createColorField(parent, prop, allowAlpha);
                        return text;
                    }
                    createKeyCodeRow(parent, prop, lockIcon = true) {
                        if (lockIcon) {
                            this.createLock(parent, prop);
                        }
                        const labelElement = this.createLabel(parent, prop.label, scene_20.PhaserHelp(prop.tooltip));
                        labelElement.style.gridColumn = "2";
                        const buttonElement = this.createKeyCodeField(parent, prop, lockIcon);
                        return { labelElement, buttonElement };
                    }
                    createPropertyEnumRow(parent, prop, lockIcon = true, filter) {
                        if (lockIcon) {
                            this.createLock(parent, prop);
                        }
                        const label = this.createLabel(parent, prop.label, scene_20.PhaserHelp(prop.tooltip));
                        label.style.gridColumn = "2";
                        const btn = this.createEnumField(parent, prop, undefined, filter);
                        return btn;
                    }
                    createPropertyXYRow(parent, propXY, lockIcon = true, colorAxis = true) {
                        const inputElements = [];
                        if (lockIcon) {
                            this.createLock(parent, propXY.x, propXY.y);
                            this.createLabel(parent, propXY.label, scene_20.PhaserHelp(propXY.tooltip));
                        }
                        else {
                            const label = this.createLabel(parent, propXY.label, scene_20.PhaserHelp(propXY.tooltip));
                            label.style.gridColumn = "2";
                        }
                        for (const i of [{ prop: propXY.x, axis: "x" }, { prop: propXY.y, axis: "y" }]) {
                            let { prop, axis } = i;
                            const label = this.createLabel(parent, prop.label, scene_20.PhaserHelp(prop.tooltip));
                            const text = this.createFloatField(parent, prop);
                            inputElements.push(text);
                            if (colorAxis) {
                                label.classList.add("label-axis-" + axis);
                                text.classList.add("input-axis-" + axis);
                            }
                            this.createPropertyLabelToTextNumericLink(propXY.x, label, text);
                        }
                        return inputElements;
                    }
                }
                sceneobjects.SceneGameObjectSection = SceneGameObjectSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_20.ui || (scene_20.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../sceneobjects/object/properties/SceneGameObjectSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_21) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_20) {
                var properties;
                (function (properties) {
                    class DynamicUserComponentSection extends ui.sceneobjects.SceneGameObjectSection {
                        _componentName;
                        _componentDisplayName;
                        constructor(page, componentName, componentDisplayName, hash) {
                            super(page, DynamicUserComponentSection.computeId(componentName, hash), componentName, false, true, phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_USER_COMPONENT), `DynamicUserComponentSection_${componentName}}`);
                            this._componentName = componentName;
                            this._componentDisplayName = componentDisplayName;
                        }
                        static computeId(compName, hash) {
                            return `phasereditor2d.scene.ui.editor.properties.DynamicPropertySection_${compName}_${hash}`;
                        }
                        isDynamicTitle() {
                            return true;
                        }
                        getTitle() {
                            const prefabNames = this.getSelection()
                                .flatMap((obj) => obj.getEditorSupport()
                                .getUserComponentsComponent()
                                .getPrefabUserComponents())
                                .filter(i => i.components.find(c => c.getName() === this._componentName))
                                .map(i => ui.sceneobjects.getSceneDisplayName(i.prefabFile));
                            const distinctPrefabNames = [];
                            if (prefabNames.length > 0) {
                                const used = new Set();
                                for (const prefabName of prefabNames) {
                                    if (used.has(prefabName)) {
                                        continue;
                                    }
                                    used.add(prefabName);
                                    distinctPrefabNames.push(prefabName);
                                }
                                return `${this._componentDisplayName} <span class="UserComponentTitle_PrefabsPart">← ${distinctPrefabNames.join(" &amp; ")}</span>`;
                            }
                            return this._componentDisplayName;
                        }
                        createMenu(menu) {
                            const obj = this.getSelectionFirstElement();
                            const objES = obj.getEditorSupport();
                            menu.addAction({
                                text: `Select Objects With ${this._componentDisplayName}`,
                                callback: () => {
                                    const sel = [];
                                    this.getEditor().getScene().visitAll(obj => {
                                        if (ui.sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, ui.sceneobjects.UserComponentsEditorComponent)) {
                                            const userComp = ui.sceneobjects.GameObjectEditorSupport
                                                .getObjectComponent(obj, ui.sceneobjects.UserComponentsEditorComponent);
                                            if (userComp.hasUserComponent(this._componentName)) {
                                                sel.push(obj);
                                            }
                                        }
                                    });
                                    this.getEditor().setSelection(sel);
                                }
                            });
                            menu.addAction({
                                text: "Open Definition Of " + this._componentDisplayName,
                                callback: () => this.openComponentEditor()
                            });
                            // the Reveal In Prefab File options
                            {
                                const prefabFiles = [];
                                for (const obj of this.getSelection()) {
                                    const objES = obj.getEditorSupport();
                                    if (objES.isPrefabInstance()) {
                                        const file = objES.getPrefabFile();
                                        if (prefabFiles.indexOf(file) < 0) {
                                            prefabFiles.push(file);
                                        }
                                    }
                                }
                                for (const prefabFile of prefabFiles) {
                                    menu.addAction({
                                        text: `Reveal In ${ui.sceneobjects.getSceneDisplayName(prefabFile)} File`,
                                        callback: () => this.openPrefabDefInSceneEditor(prefabFile)
                                    });
                                }
                            }
                            const allLocalNodes = this.getSelection()
                                .filter(obj => obj.getEditorSupport()
                                .getUserComponentsComponent()
                                .hasLocalUserComponent(this._componentName))
                                .length === this.getSelection().length;
                            if (allLocalNodes) {
                                if (this.getSelection().length === 1) {
                                    const editorComp = objES.getUserComponentsComponent();
                                    menu.addAction({
                                        text: "Move Up",
                                        callback: () => {
                                            this.runOperation(() => {
                                                editorComp.moveUpUserComponent(this._componentName);
                                            });
                                            this.updateWithSelection();
                                        }
                                    });
                                    menu.addAction({
                                        text: "Move Down",
                                        callback: () => {
                                            this.runOperation(() => {
                                                editorComp.moveDownUserComponent(this._componentName);
                                            });
                                            this.updateWithSelection();
                                        }
                                    });
                                }
                                menu.addAction({
                                    text: "Delete",
                                    callback: () => {
                                        const editor = this.getEditor();
                                        const selIds = editor.getSelectionManager().getSelectionIds();
                                        this.runOperation(() => {
                                            for (const obj of this.getSelection()) {
                                                const objEs = obj.getEditorSupport();
                                                objEs.getUserComponentsComponent()
                                                    .removeUserComponent(this._componentName);
                                            }
                                        });
                                        editor.getSelectionManager().setSelectionByIds(selIds);
                                    }
                                });
                            }
                        }
                        runOperation(action) {
                            const editor = this.getEditor();
                            editor.getUndoManager().add(new ui.editor.undo.SimpleSceneSnapshotOperation(editor, action));
                        }
                        openPrefabDefInSceneEditor(prefabFile) {
                            const prefabEditor = colibri.Platform.getWorkbench().openEditor(prefabFile);
                            if (prefabEditor && prefabEditor instanceof ui.editor.SceneEditor) {
                                setTimeout(() => {
                                    const obj = this.getSelectionFirstElement();
                                    const objES = obj.getEditorSupport();
                                    let selObj;
                                    if (objES.isNestedPrefabInstance()) {
                                        selObj = prefabEditor.getScene().getByEditorId(objES.getPrefabId());
                                    }
                                    else {
                                        selObj = prefabEditor.getScene().getPrefabObject();
                                    }
                                    if (selObj) {
                                        prefabEditor.setSelection([selObj]);
                                    }
                                }, 10);
                            }
                        }
                        openComponentEditor() {
                            const finder = scene_21.ScenePlugin.getInstance().getSceneFinder();
                            const info = finder.getUserComponentByName(this._componentName);
                            const editor = colibri.Platform.getWorkbench().openEditor(info.file);
                            editor.revealComponent(this._componentName);
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent);
                            comp.style.gridTemplateColumns = "auto auto 1fr";
                            {
                                // export property
                                const result = this.createBooleanField(comp, this.getExportProperty(), false);
                                result.labelElement.style.gridColumn = "2";
                                this.addUpdater(() => {
                                    const scene = this.getEditor().getScene();
                                    const values = this.getSelection().map(obj => {
                                        const objES = obj.getEditorSupport();
                                        if (scene.isPrefabSceneType()
                                            && (objES.isScenePrefabObject() || objES.isNestedPrefabScope())) {
                                            if (objES.getUserComponentsComponent()
                                                .hasLocalUserComponent(this._componentName)) {
                                                return true;
                                            }
                                        }
                                        return false;
                                    });
                                    const visible = this.flatValues_BooleanAnd(values);
                                    result.labelElement.style.display = visible ? "" : "none";
                                    result.checkElement.style.display = visible ? "" : "none";
                                });
                            }
                            // user properties
                            const finder = scene_21.ScenePlugin.getInstance().getSceneFinder();
                            const compInfo = finder.getUserComponentByName(this._componentName);
                            {
                                const props = compInfo.component.getUserProperties().getProperties();
                                if (props.length > 0) {
                                    const atLeastOnePrefab = this.getSelection()
                                        .map(obj => obj.getEditorSupport())
                                        .filter(objES => objES.isPrefabInstance()
                                        && !objES.getUserComponentsComponent()
                                            .hasLocalUserComponent(this._componentName))
                                        .length > 0;
                                    for (const prop of props) {
                                        prop.getType().createInspectorPropertyEditor(this, comp, prop, atLeastOnePrefab);
                                    }
                                }
                            }
                        }
                        getExportProperty() {
                            return {
                                name: "isExported",
                                label: "Export",
                                getValue: obj => {
                                    const value = obj.getEditorSupport()
                                        .getUserComponentsComponent().isExportComponent(this._componentName);
                                    return value;
                                },
                                setValue: (obj, value) => {
                                    const compName = this._componentName;
                                    obj.getEditorSupport()
                                        .getUserComponentsComponent()
                                        .setExportComponent(compName, value);
                                },
                                defValue: true,
                            };
                        }
                        canEdit(obj, n) {
                            if (ui.sceneobjects.isGameObject(obj)) {
                                const objES = ui.sceneobjects.GameObjectEditorSupport.getEditorSupport(obj);
                                const userComp = objES.getUserComponentsComponent();
                                if (userComp.hasUserComponent(this._componentName)) {
                                    if (userComp.hasLocalUserComponent(this._componentName)) {
                                        return true;
                                    }
                                    const exported = userComp.isComponentPublished(this._componentName);
                                    return exported;
                                }
                            }
                            return false;
                        }
                        canEditNumber(n) {
                            return n > 0;
                        }
                    }
                    properties.DynamicUserComponentSection = DynamicUserComponentSection;
                })(properties = editor_20.properties || (editor_20.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_21.ui || (scene_21.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_21) {
                var properties;
                (function (properties) {
                    class SceneEditorPropertySectionExtension extends colibri.Extension {
                        static POINT_ID = "phasereditor2d.scene.ui.editor.properties.SceneEditorPropertySectionExtension";
                        _sectionProviders;
                        constructor(...sectionProviders) {
                            super(SceneEditorPropertySectionExtension.POINT_ID);
                            this._sectionProviders = sectionProviders;
                        }
                        getSectionProviders(editor) {
                            return this._sectionProviders;
                        }
                    }
                    properties.SceneEditorPropertySectionExtension = SceneEditorPropertySectionExtension;
                })(properties = editor_21.properties || (editor_21.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneEditorPropertySectionExtension.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_22) {
                var properties;
                (function (properties) {
                    class DynamicUserSectionExtension extends properties.SceneEditorPropertySectionExtension {
                        getSectionProviders(editor) {
                            const result = [];
                            const visitedPrefabs = new Set();
                            const visitedComps = new Set();
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            // add local user components
                            for (const obj of editor.getSelectedGameObjects()) {
                                const objES = obj.getEditorSupport();
                                const localComps = objES.getUserComponentsComponent()
                                    .getLocalUserComponents();
                                for (const compInfo of localComps) {
                                    const compName = compInfo.component.getName();
                                    const compDisplayName = compInfo.component.getDisplayNameOrName();
                                    visitedComps.add(compName);
                                    result.push(page => new properties.DynamicUserComponentSection(page, compName, compDisplayName, `${compInfo.file.getModTime()}`));
                                }
                            }
                            // add properties from prefab
                            for (const obj of editor.getSelectedGameObjects()) {
                                const objES = obj.getEditorSupport();
                                if (!objES.isPrefabInstance()) {
                                    continue;
                                }
                                const prefabId = objES.getPrefabId();
                                if (visitedPrefabs.has(prefabId)) {
                                    continue;
                                }
                                visitedPrefabs.add(prefabId);
                                const prefabUserProps = objES.getComponent(ui.sceneobjects.PrefabUserPropertyComponent);
                                const prefabInfoList = prefabUserProps.getPropertiesByPrefab();
                                // add all properties from prefabs
                                for (const prefabInfo of prefabInfoList) {
                                    // add section for the current prefab info
                                    result.push(page => new ui.sceneobjects.DynamicPrefabInstanceSection(page, prefabInfo.prefabFile, prefabInfo.properties));
                                    // add all user component properties defined in the current prefab
                                    const userComps = objES.getUserComponentsComponent();
                                    const components = userComps
                                        .getPrefabUserComponents()
                                        .filter(i => i.prefabFile === prefabInfo.prefabFile)
                                        .flatMap(i => i.components)
                                        .filter(c => !visitedComps.has(c.getName()));
                                    for (const comp of components) {
                                        const compName = comp.getName();
                                        const compDisplayName = comp.getDisplayNameOrName();
                                        visitedComps.add(compName);
                                        const findResult = finder.getUserComponentByName(compName);
                                        if (findResult) {
                                            result.push(page => new properties.DynamicUserComponentSection(page, compName, compDisplayName, `${findResult.file.getModTime()}`));
                                        }
                                    }
                                }
                            }
                            return result;
                        }
                    }
                    properties.DynamicUserSectionExtension = DynamicUserSectionExtension;
                })(properties = editor_22.properties || (editor_22.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class PrefabCompilerSection extends properties.SceneSection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.properties.PrefabCompilerSection", "Compiler Prefab Settings", false, true);
                        }
                        getSectionHelpPath() {
                            return "scene-editor/scene-compiler-scene-settings.html";
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 3);
                            comp.style.gridTemplateColumns = "auto 1fr";
                            this.createBooleanField(comp, "generateAwakeHandler", this.createLabel(comp, "Generate Awake Handler", "Generate a handler for the 'scene-awake' event."));
                        }
                        canEdit(obj, n) {
                            return obj instanceof ui.Scene && obj.getSceneType() === scene.core.json.SceneType.PREFAB;
                        }
                    }
                    properties.PrefabCompilerSection = PrefabCompilerSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class PrefabDisplaySection extends properties.SceneSection {
                        static SECTION_ID = "phasereditor2d.scene.ui.editor.properties.PrefabDisplaySection";
                        constructor(page) {
                            super(page, PrefabDisplaySection.SECTION_ID, "Prefab Display", false, false);
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 3);
                            comp.style.gridTemplateColumns = "auto 1fr";
                            this.createStringField(comp, "prefabObjDisplayFmt", "Object Display Format", "To format the object's display label.");
                        }
                        canEdit(obj, n) {
                            return obj instanceof ui.Scene && obj.getSceneType() === scene.core.json.SceneType.PREFAB;
                        }
                    }
                    properties.PrefabDisplaySection = PrefabDisplaySection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    var controls = colibri.ui.controls;
                    class PrefabPropertiesSection extends properties.SceneSection {
                        static SECTION_ID = "phasereditor2d.scene.ui.editor.properties.PrefabPropertiesSection";
                        constructor(page) {
                            super(page, PrefabPropertiesSection.SECTION_ID, "Prefab Properties", false, true);
                        }
                        getSectionHelpPath() {
                            return "scene-editor/prefab-user-properties.html";
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 1);
                            const selector = (obj) => {
                                this.getEditor().setSelection([obj]);
                            };
                            const linksComp = this.createGridElement(comp, 1);
                            comp.appendChild(linksComp);
                            this.addUpdater(() => {
                                linksComp.innerHTML = "";
                                const prefabProps = this.getScene().getPrefabUserProperties();
                                const props = prefabProps.getProperties();
                                for (const prop of props) {
                                    const link = document.createElement("a");
                                    link.href = "#";
                                    link.textContent = prop.getLabel();
                                    link.addEventListener("click", () => {
                                        this.getEditor().setSelection([prop]);
                                    });
                                    linksComp.appendChild(link);
                                    controls.Tooltip.tooltip(link, prop.getName() + ": " + prop.getType().getName());
                                }
                            });
                            properties.SingleUserPropertySection.createAddPropertyButton(comp, this, action => this.runOperation(action), selector);
                        }
                        runOperation(action, updateSelection = true) {
                            ui.editor.properties.ChangePrefabPropertiesOperation.runPropertiesOperation(this.getEditor(), action, updateSelection);
                        }
                        canEdit(obj, n) {
                            return obj instanceof ui.Scene && obj.isPrefabSceneType()
                                || obj instanceof ui.sceneobjects.PrefabUserProperties
                                || obj instanceof ui.sceneobjects.UserProperty;
                        }
                        canEditNumber(n) {
                            return n > 0;
                        }
                    }
                    properties.PrefabPropertiesSection = PrefabPropertiesSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_23) {
                var properties;
                (function (properties) {
                    class PrefabPropertyOrderAction {
                        static allow(editor, move) {
                            const sel = this.sortedSelection(editor);
                            if (sel.length === 0) {
                                return false;
                            }
                            for (const prop of sel) {
                                if (!(prop instanceof ui.sceneobjects.UserProperty)) {
                                    return false;
                                }
                            }
                            const siblings = sel[0].getManager().getProperties();
                            for (const prop of sel) {
                                const index = siblings.indexOf(prop);
                                const len = siblings.length;
                                if (move === "Bottom" || move === "Down") {
                                    if (index === len - 1) {
                                        return false;
                                    }
                                }
                                else { // Top || Up
                                    if (index === 0) {
                                        return false;
                                    }
                                }
                            }
                            return true;
                        }
                        static execute(editor, depthMove) {
                            const sel = this.sortedSelection(editor);
                            switch (depthMove) {
                                case "Bottom":
                                    for (const prop of sel) {
                                        const siblings = prop.getManager().getProperties();
                                        Phaser.Utils.Array.BringToTop(siblings, prop);
                                    }
                                    break;
                                case "Top":
                                    for (let i = 0; i < sel.length; i++) {
                                        const prop = sel[sel.length - i - 1];
                                        const siblings = prop.getManager().getProperties();
                                        Phaser.Utils.Array.SendToBack(siblings, prop);
                                    }
                                    break;
                                case "Down":
                                    for (let i = 0; i < sel.length; i++) {
                                        const prop = sel[sel.length - i - 1];
                                        const siblings = prop.getManager().getProperties();
                                        Phaser.Utils.Array.MoveUp(siblings, prop);
                                    }
                                    break;
                                case "Up":
                                    for (const prop of sel) {
                                        const siblings = prop.getManager().getProperties();
                                        Phaser.Utils.Array.MoveDown(siblings, prop);
                                    }
                                    break;
                            }
                        }
                        static sortedSelection(editor) {
                            const sel = editor.getSelection();
                            const props = editor.getScene().getPrefabUserProperties().getProperties();
                            sel.sort((a, b) => {
                                const aa = props.indexOf(a);
                                const bb = props.indexOf(b);
                                return aa - bb;
                            });
                            return sel;
                        }
                    }
                    properties.PrefabPropertyOrderAction = PrefabPropertyOrderAction;
                })(properties = editor_23.properties || (editor_23.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    var controls = colibri.ui.controls;
                    class SingleUserPropertySection extends controls.properties.PropertySection {
                        _propArea;
                        static createAddPropertyButton(comp, formBuilder, runOperation, selector) {
                            const propTypes = scene.ScenePlugin.getInstance().getUserPropertyTypes();
                            const buttonElement = formBuilder.createButton(comp, "Add Property", () => {
                                class Dlg extends ui.dialogs.AbstractAddPrefabPropertyDialog {
                                    addProperty(propType) {
                                        runOperation(userProps => {
                                            const prop = userProps.createProperty(propType);
                                            userProps.add(prop);
                                            selector(prop);
                                        });
                                    }
                                }
                                const dlg = new Dlg();
                                dlg.create();
                            });
                            return { buttonElement };
                        }
                        hasMenu() {
                            return true;
                        }
                        createMenu(menu) {
                            const prop = this.getProperty();
                            menu.addMenu(this.createMorphMenu(prop));
                            menu.addAction({
                                text: "Delete",
                                callback: () => {
                                    this.runOperation(userProps => {
                                        userProps.deleteProperty(prop.getName());
                                    }, true);
                                }
                            });
                            menu.addSeparator();
                            phasereditor2d.ide.IDEPlugin.getInstance().createHelpMenuItem(menu, this.getSectionHelpPath());
                        }
                        createForm(parent) {
                            const comp1 = this.createGridElement(parent);
                            comp1.style.gridTemplateColumns = "1fr";
                            this._propArea = this.createGridElement(comp1, 2);
                            comp1.appendChild(this._propArea);
                            this.addUpdater(() => {
                                this._propArea.innerHTML = "";
                                const prop = this.getProperty();
                                const info = prop.getInfo();
                                this.simpleField(this._propArea, info, "name", "Name", "The property name. Like in 'speedMin'.");
                                this.simpleField(this._propArea, info, "label", "Label", "The property display label. Like in 'Speed Min'.", () => {
                                    this.componentTitleUpdated();
                                });
                                this.simpleField(this._propArea, info, "tooltip", "Tooltip", "The property tooltip.");
                                {
                                    this.createLabel(this._propArea, "Type", "The property type.");
                                    const text = this.createText(this._propArea, true);
                                    text.value = prop.getType().getName();
                                }
                                if (prop.getType() instanceof ui.sceneobjects.OptionPropertyType) {
                                    this.createOptionsField(this._propArea, prop);
                                }
                                else if (prop.getType().hasCustomPropertyType()) {
                                    this.createExpressionTypeField(this._propArea, prop);
                                }
                                {
                                    this.createLabel(this._propArea, "Default", "The property default value.");
                                    const propEditor = info.type.createEditorElement(() => {
                                        return prop.getInfo().defValue;
                                    }, value => {
                                        this.runOperation(() => {
                                            prop.getInfo().defValue = value;
                                        }, true);
                                    });
                                    this._propArea.appendChild(propEditor.element);
                                    propEditor.update();
                                }
                                {
                                    const check = this.createCheckbox(this._propArea, this.createLabel(this._propArea, "Custom Definition", "The compiler delegates the property's definition to the user."));
                                    check.checked = prop.isCustomDefinition();
                                    check.addEventListener("change", e => {
                                        this.runOperation(() => {
                                            prop.getInfo().customDefinition = check.checked;
                                        }, false);
                                    });
                                }
                            }); // updater;
                        }
                        createPropertiesMenu(titlePanel, prop) {
                            const icon = new controls.IconControl(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_SMALL_MENU));
                            icon.getCanvas().classList.add("IconButton");
                            titlePanel.appendChild(icon.getCanvas());
                            icon.getCanvas().addEventListener("click", e => {
                                const menu = new controls.Menu();
                                menu.addAction({
                                    text: "Move Up",
                                    callback: () => {
                                        this.runOperation(userProps => {
                                            const list = userProps.getProperties();
                                            const i = list.indexOf(prop);
                                            if (i > 0) {
                                                const temp = list[i - 1];
                                                list[i - 1] = prop;
                                                list[i] = temp;
                                            }
                                        }, true);
                                    }
                                });
                                menu.addAction({
                                    text: "Move Down",
                                    callback: () => {
                                        this.runOperation(userProps => {
                                            const list = userProps.getProperties();
                                            const i = list.indexOf(prop);
                                            if (i < list.length - 1) {
                                                const temp = list[i + 1];
                                                list[i + 1] = prop;
                                                list[i] = temp;
                                            }
                                        }, true);
                                    }
                                });
                                menu.addSeparator();
                                menu.addMenu(this.createMorphMenu(prop));
                                menu.addSeparator();
                                menu.addAction({
                                    text: "Delete",
                                    callback: () => {
                                        this.runOperation(userProps => {
                                            const list = userProps.getProperties();
                                            const i = list.indexOf(prop);
                                            list.splice(i, 1);
                                        }, true);
                                    }
                                });
                                menu.createWithEvent(e);
                            });
                        }
                        createMorphMenu(prop) {
                            const menu = new controls.Menu("Change Type");
                            const propTypes = scene.ScenePlugin.getInstance().getUserPropertyTypes();
                            for (const propType of propTypes) {
                                menu.addAction({
                                    text: propType.getName(),
                                    callback: () => {
                                        this.runOperation(userProps => {
                                            prop.getInfo().type = propType;
                                        }, true);
                                    }
                                });
                            }
                            return menu;
                        }
                        createExpressionTypeField(parent, prop) {
                            const type = prop.getType();
                            this.createLabel(parent, "Expression Type", "The type of the expression. Like <code>'ICustomType'</code> or <code>'() => void'</code>.");
                            const text = this.createText(parent);
                            text.value = type.getExpressionType();
                            text.addEventListener("change", e => {
                                this.runOperation(() => {
                                    type.setExpressionType(text.value);
                                }, true);
                            });
                        }
                        createOptionsField(parent, prop) {
                            const type = prop.getType();
                            this.createLabel(parent, "Options", "An array of possible string values, like in <code>['good', 'bad', 'ugly']</code>.");
                            const text = this.createTextArea(parent);
                            text.value = JSON.stringify(type.getOptions());
                            text.addEventListener("change", e => {
                                this.runOperation(() => {
                                    const array = JSON.parse(text.value);
                                    if (Array.isArray(array)) {
                                        const array2 = array.filter(v => typeof v === "string" || typeof v === "number")
                                            .map(v => v.toString());
                                        type.setOptions(array2);
                                    }
                                }, true);
                            });
                        }
                        simpleField(parent, propInfo, infoProp, fieldLabel, fieldTooltip, updateCallback) {
                            this.createLabel(parent, fieldLabel, fieldTooltip);
                            const text = this.createText(parent);
                            text.value = propInfo[infoProp];
                            text.addEventListener("change", e => {
                                this.runOperation(() => {
                                    propInfo[infoProp] = text.value;
                                    if (updateCallback) {
                                        updateCallback();
                                    }
                                }, false);
                            });
                        }
                    }
                    properties.SingleUserPropertySection = SingleUserPropertySection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SingleUserPropertySection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class PrefabPropertySection extends properties.SingleUserPropertySection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.properties.PrefabPropertySection", "Prefab Property", false, false);
                        }
                        getSectionHelpPath() {
                            return "scene-editor/prefab-user-properties.html";
                        }
                        getUserProperties() {
                            return this.getProperty().getManager();
                        }
                        getProperty() {
                            return this.getSelectionFirstElement();
                        }
                        componentTitleUpdated() {
                            this.getEditor().refreshOutline();
                            this.getEditor().updateInspectorViewSection(properties.PrefabPropertiesSection.SECTION_ID);
                        }
                        getEditor() {
                            return colibri.ui.ide.Workbench.getWorkbench().getActiveEditor();
                        }
                        runOperation(action, updateSelection) {
                            ui.editor.properties.ChangePrefabPropertiesOperation.runPropertiesOperation(this.getEditor(), action, updateSelection);
                        }
                        canEdit(obj, n) {
                            return obj instanceof ui.sceneobjects.UserProperty;
                        }
                        canEditNumber(n) {
                            return n === 1;
                        }
                    }
                    properties.PrefabPropertySection = PrefabPropertySection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    var controls = colibri.ui.controls;
                    class SceneCompilerSection extends properties.SceneSection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.properties.SceneCompilerSection", "Compiler Scene Settings", false, true);
                        }
                        getSectionHelpPath() {
                            return "scene-editor/scene-compiler-scene-settings.html";
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 3);
                            comp.style.gridTemplateColumns = "auto 1fr";
                            this.createStringField(comp, "sceneKey", "Scene Key", "The key of the scene. Used when the scene is loaded with the Phaser loader.");
                            this.createBooleanField(comp, "onlyGenerateMethods", this.createLabel(comp, "Only Generate Methods", "No class code is generated, only the \"create\" or \"preload\" methods."));
                            this.createStringField(comp, "createMethodName", "Create Method", "The name of the create method.");
                            this.createPreloadPackFilesField(comp);
                            this.createStringField(comp, "preloadMethodName", "Preload Method", "The name of the preload method. It may be empty.");
                        }
                        createPreloadPackFilesField(parent) {
                            this.createLabel(parent, "Preload Pack Files", "The Pack files to be loaded in this scene.");
                            const btn = this.createButton(parent, "0 selected", async (e) => {
                                const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.editor.properties.SceneCompilerSection.SelectPackDialog");
                                viewer.setLabelProvider(new phasereditor2d.files.ui.viewers.FileLabelProvider());
                                viewer.setCellRendererProvider(new phasereditor2d.files.ui.viewers.FileCellRendererProvider("tree"));
                                viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                                const finder = this.getEditor().getPackFinder();
                                viewer.setInput(finder.getPacks().map(pack => pack.getFile()));
                                viewer.setSelection(this.getSettings().preloadPackFiles
                                    .map(name => finder.getPacks().find(pack => pack.getFile().getFullName() === name))
                                    .filter(pack => pack !== null && pack !== undefined)
                                    .map(pack => pack.getFile()));
                                const dlg = new controls.dialogs.ViewerDialog(viewer, false);
                                const selectionCallback = (files) => {
                                    const names = files.map(file => file.getFullName());
                                    this.getEditor().getUndoManager().add(new properties.ChangeSettingsPropertyOperation({
                                        editor: this.getEditor(),
                                        props: [{
                                                name: "preloadPackFiles",
                                                value: names
                                            }],
                                        repaint: false
                                    }));
                                    this.updateWithSelection();
                                    dlg.close();
                                };
                                dlg.create();
                                dlg.setTitle("Select Pack Files");
                                const selectBtn = dlg.addButton("Select", () => {
                                    selectionCallback(viewer.getSelection());
                                });
                                selectBtn.textContent = "Select " + viewer.getSelection().length + " Files";
                                viewer.eventSelectionChanged.addListener(() => {
                                    selectBtn.textContent = "Select " + viewer.getSelection().length + " Files";
                                });
                                dlg.addButton("Clear", () => {
                                    viewer.setSelection([]);
                                });
                                dlg.addButton("Cancel", () => {
                                    dlg.close();
                                });
                                viewer.eventOpenItem.addListener(() => {
                                    selectionCallback([viewer.getSelection()[0]]);
                                });
                            });
                            this.addUpdater(() => {
                                const settings = this.getSettings();
                                btn.textContent = settings.preloadPackFiles.length + " selected";
                                const files = settings.preloadPackFiles;
                                const tooltip = files.length === 0 ? "Click to select the Asset Pack files."
                                    : files.map(f => `<code>${f}</code>`)
                                        .join("<br>");
                                controls.Tooltip.tooltip(btn, tooltip);
                            });
                        }
                        canEdit(obj, n) {
                            return obj instanceof ui.Scene && obj.getSceneType() === scene.core.json.SceneType.SCENE;
                        }
                    }
                    properties.SceneCompilerSection = SceneCompilerSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class SceneDisplaySection extends properties.SceneSection {
                        static SECTION_ID = "phasereditor2d.scene.ui.editor.properties.SceneDisplaySection";
                        constructor(page) {
                            super(page, SceneDisplaySection.SECTION_ID, "Scene Display", false, false);
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 3);
                            comp.style.gridTemplateColumns = "auto 1fr";
                            this.createStringField(comp, "displayName", "Scene Display Name", "The display name of the scene.");
                        }
                        canEdit(obj, n) {
                            return obj instanceof ui.Scene;
                        }
                    }
                    properties.SceneDisplaySection = SceneDisplaySection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_24) {
                var properties;
                (function (properties) {
                    var controls = colibri.ui.controls;
                    class SceneEditorSectionProvider extends controls.properties.PropertySectionProvider {
                        _editor;
                        constructor(editor) {
                            super("phasereditor2d.scene.ui.editor.properties.SceneEditorSectionProvider");
                            this._editor = editor;
                        }
                        getEmptySelectionObject() {
                            return this._editor.getScene();
                        }
                        addSections(page, sections) {
                            sections.push(new properties.SnappingSection(page), new properties.BorderSection(page), new properties.CompilerSection(page), new properties.SceneCompilerSection(page), new properties.PrefabCompilerSection(page), new properties.SceneDisplaySection(page), new properties.PrefabDisplaySection(page), new properties.PrefabPropertiesSection(page));
                            const exts = colibri.Platform
                                .getExtensions(properties.SceneEditorPropertySectionExtension.POINT_ID);
                            for (const ext of exts) {
                                const providers = ext.getSectionProviders(this._editor);
                                for (const provider of providers) {
                                    sections.push(provider(page));
                                }
                            }
                            sections.push(new ui.editor.properties.PrefabPropertySection(page));
                        }
                    }
                    properties.SceneEditorSectionProvider = SceneEditorSectionProvider;
                })(properties = editor_24.properties || (editor_24.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties) {
                    class SnappingSection extends properties.SceneSection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.properties.SnappingSection", "Snapping");
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 3);
                            comp.style.gridTemplateColumns = "auto auto 1fr auto 1fr";
                            {
                                const label = this.createLabel(comp, "Enabled", "Enable snapping");
                                label.style.gridColumn = "1 / span 2";
                                this.createBooleanField(comp, "snapEnabled", label)
                                    .style.gridColumn = "3 / span 3";
                            }
                            this.createLabel(comp, "Size");
                            this.createIntegerField(comp, "snapWidth", "Width", "Scene snapping width.");
                            this.createIntegerField(comp, "snapHeight", "Height", "Scene snapping height.");
                        }
                        getSectionHelpPath() {
                            return "scene-editor/snapping-properties.html";
                        }
                    }
                    properties.SnappingSection = SnappingSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var properties;
                (function (properties_1) {
                    var controls = colibri.ui.controls;
                    class UserPropertiesSection extends controls.properties.PropertySection {
                        _propArea;
                        hasMenu() {
                            return true;
                        }
                        createMenu(menu) {
                            phasereditor2d.ide.IDEPlugin.getInstance().createHelpMenuItem(menu, this.getSectionHelpPath());
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent);
                            comp.style.gridTemplateColumns = "1fr";
                            this._propArea = this.createGridElement(comp, 2);
                            comp.appendChild(this._propArea);
                            const propTypes = scene.ScenePlugin.getInstance().getUserPropertyTypes();
                            const btn = this.createMenuButton(comp, "Add Property", () => propTypes.map(t => ({
                                name: t.getName() + " Property",
                                value: t.getId()
                            })), (typeId) => {
                                const newType = scene.ScenePlugin.getInstance().getUserPropertyType(typeId);
                                this.runOperation(userProps => {
                                    const prop = userProps.createProperty(newType);
                                    userProps.add(prop);
                                    this.setExpandedStateInStorage(prop, true);
                                }, true);
                            });
                            btn.style.gridColumn = "1 / span 2";
                            btn.style.justifySelf = "center";
                            this.addUpdater(() => {
                                this._propArea.innerHTML = "";
                                const properties = this.getUserProperties().getProperties();
                                for (const prop of properties) {
                                    const propPane = this.createGridElement(this._propArea, 2);
                                    propPane.style.gridColumn = "1 / span 2";
                                    const titleLabel = this.createTitlePanel(propPane, prop);
                                    this._propArea.appendChild(propPane);
                                    const info = prop.getInfo();
                                    this.simpleField(propPane, info, "name", "Name", "The property name. Like in 'speedMin'.");
                                    this.simpleField(propPane, info, "label", "Label", "The property display label. Like in 'Speed Min'.", () => {
                                        titleLabel.innerHTML = prop.getInfo().label;
                                    });
                                    this.simpleField(propPane, info, "tooltip", "Tooltip", "The property tooltip.");
                                    {
                                        this.createLabel(propPane, "Type", "The property type.");
                                        const text = this.createText(propPane, true);
                                        text.value = prop.getType().getName();
                                    }
                                    if (prop.getType() instanceof ui.sceneobjects.OptionPropertyType) {
                                        this.createOptionsField(propPane, prop);
                                    }
                                    else if (prop.getType().hasCustomPropertyType()) {
                                        this.createExpressionTypeField(propPane, prop);
                                    }
                                    {
                                        this.createLabel(propPane, "Default", "The property default value.");
                                        const propEditor = info.type.createEditorElement(() => {
                                            return prop.getInfo().defValue;
                                        }, value => {
                                            this.runOperation(() => {
                                                prop.getInfo().defValue = value;
                                                this.setExpandedStateInStorage(prop, true);
                                            }, true);
                                        });
                                        propPane.appendChild(propEditor.element);
                                        propEditor.update();
                                    }
                                    {
                                        const check = this.createCheckbox(propPane, this.createLabel(propPane, "Custom Definition", "The compiler delegates the property's definition to the user."));
                                        check.checked = prop.isCustomDefinition();
                                        check.addEventListener("change", e => {
                                            this.runOperation(() => {
                                                prop.getInfo().customDefinition = check.checked;
                                            }, false);
                                        });
                                    }
                                }
                            });
                        }
                        setExpandedStateInStorage(prop, value) {
                            window.localStorage[`PrefabPropertiesSection[${prop.getName()}].expanded`] = value;
                        }
                        getExpandedStateInStorage(prop) {
                            return window.localStorage[`PrefabPropertiesSection[${prop.getName()}].expanded`];
                        }
                        createTitlePanel(propPane, prop) {
                            const titlePanel = document.createElement("div");
                            titlePanel.classList.add("PropertySubTitlePanel");
                            this._propArea.insertBefore(titlePanel, propPane);
                            const collapsedIcon = colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_CONTROL_TREE_COLLAPSE);
                            const expandedIcon = colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_CONTROL_TREE_EXPAND);
                            const expanderControl = new controls.IconControl();
                            titlePanel.appendChild(expanderControl.getCanvas());
                            const titleLabel = this.createLabel(titlePanel, prop.getLabel());
                            titleLabel.classList.add("PropertySubTitleLabel");
                            const expanded = this.getExpandedStateInStorage(prop) === "true";
                            propPane.style.display = expanded ? "grid" : "none";
                            expanderControl.setIcon(expanded ? collapsedIcon : expandedIcon);
                            const expandListener = () => {
                                const expandIt = propPane.style.display === "none";
                                propPane.style.display = expandIt ? "grid" : "none";
                                this.setExpandedStateInStorage(prop, expandIt);
                                expanderControl.setIcon(expandIt ? collapsedIcon : expandedIcon);
                            };
                            expanderControl.getCanvas().addEventListener("click", expandListener);
                            titleLabel.addEventListener("click", expandListener);
                            this.createPropertiesMenu(titlePanel, prop);
                            return titleLabel;
                        }
                        createPropertiesMenu(titlePanel, prop) {
                            const icon = new controls.IconControl(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_SMALL_MENU));
                            icon.getCanvas().classList.add("IconButton");
                            titlePanel.appendChild(icon.getCanvas());
                            icon.getCanvas().addEventListener("click", e => {
                                const menu = new controls.Menu();
                                menu.addAction({
                                    text: "Move Up",
                                    callback: () => {
                                        this.runOperation(userProps => {
                                            const list = userProps.getProperties();
                                            const i = list.indexOf(prop);
                                            if (i > 0) {
                                                const temp = list[i - 1];
                                                list[i - 1] = prop;
                                                list[i] = temp;
                                            }
                                        }, true);
                                    }
                                });
                                menu.addAction({
                                    text: "Move Down",
                                    callback: () => {
                                        this.runOperation(userProps => {
                                            const list = userProps.getProperties();
                                            const i = list.indexOf(prop);
                                            if (i < list.length - 1) {
                                                const temp = list[i + 1];
                                                list[i + 1] = prop;
                                                list[i] = temp;
                                            }
                                        }, true);
                                    }
                                });
                                menu.addSeparator();
                                menu.addMenu(this.createMorphMenu(prop));
                                menu.addSeparator();
                                menu.addAction({
                                    text: "Delete",
                                    callback: () => {
                                        this.runOperation(userProps => {
                                            const list = userProps.getProperties();
                                            const i = list.indexOf(prop);
                                            list.splice(i, 1);
                                        }, true);
                                    }
                                });
                                menu.createWithEvent(e);
                            });
                        }
                        createMorphMenu(prop) {
                            const menu = new controls.Menu("Change Type");
                            const propTypes = scene.ScenePlugin.getInstance().getUserPropertyTypes();
                            for (const propType of propTypes) {
                                menu.addAction({
                                    text: propType.getName(),
                                    callback: () => {
                                        this.runOperation(userProps => {
                                            prop.getInfo().type = propType;
                                        }, true);
                                    }
                                });
                            }
                            // const btn = this.createMenuButton(comp, "Add Property", propTypes.map(t => ({
                            //     name: t.getName() + " Property",
                            //     value: t.getId()
                            // })), (typeId: string) => {
                            //     const newType = ScenePlugin.getInstance().createUserPropertyType(typeId);
                            //     this.runOperation(userProps => {
                            //         const prop = userProps.createProperty(newType);
                            //         userProps.add(prop);
                            //         this.setExpandedStateInStorage(prop, true);
                            //     }, true);
                            // });
                            return menu;
                        }
                        createExpressionTypeField(parent, prop) {
                            const type = prop.getType();
                            this.createLabel(parent, "Expression Type", "The type of the expression. Like <code>'ICustomType'</code> or <code>'() => void'</code>.");
                            const text = this.createText(parent);
                            text.value = type.getExpressionType();
                            text.addEventListener("change", e => {
                                this.runOperation(() => {
                                    type.setExpressionType(text.value);
                                    this.setExpandedStateInStorage(prop, true);
                                }, true);
                            });
                        }
                        createOptionsField(parent, prop) {
                            const type = prop.getType();
                            this.createLabel(parent, "Options", "An array of possible string values, like in <code>['good', 'bad', 'ugly']</code>.");
                            const text = this.createTextArea(parent);
                            text.value = JSON.stringify(type.getOptions());
                            text.addEventListener("change", e => {
                                this.runOperation(() => {
                                    const array = JSON.parse(text.value);
                                    if (Array.isArray(array)) {
                                        const array2 = array.filter(v => typeof v === "string" || typeof v === "number")
                                            .map(v => v.toString());
                                        type.setOptions(array2);
                                    }
                                    this.setExpandedStateInStorage(prop, true);
                                }, true);
                            });
                        }
                        simpleField(parent, propInfo, infoProp, fieldLabel, fieldTooltip, updateCallback) {
                            this.createLabel(parent, fieldLabel, fieldTooltip);
                            const text = this.createText(parent);
                            text.value = propInfo[infoProp];
                            text.addEventListener("change", e => {
                                this.runOperation(() => {
                                    propInfo[infoProp] = text.value;
                                    if (updateCallback) {
                                        updateCallback();
                                    }
                                }, false);
                            });
                        }
                    }
                    properties_1.UserPropertiesSection = UserPropertiesSection;
                })(properties = editor.properties || (editor.properties = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var tools;
                (function (tools) {
                    class SceneToolItem {
                        isValidFor(objects) {
                            return true;
                        }
                        getTranslationInAxisWorldDelta(axis, initCursorX, initCursorY, args) {
                            const dx = args.x - initCursorX;
                            const dy = args.y - initCursorY;
                            let worldDx = dx / args.camera.zoom;
                            let worldDy = dy / args.camera.zoom;
                            const rot = Phaser.Math.DegToRad(this.getAvgGlobalAngle(args));
                            const worldDelta = new Phaser.Math.Vector2();
                            const xAxis = axis === "x" || axis === "xy" ? 1 : 0;
                            const yAxis = axis === "y" || axis === "xy" ? 1 : 0;
                            if (args.localCoords && axis !== "xy") {
                                const axisVector = new Phaser.Math.Vector2(xAxis, yAxis);
                                axisVector.rotate(rot);
                                let worldDeltaVector = new Phaser.Math.Vector2(worldDx, worldDy);
                                const projectionLength = worldDeltaVector.dot(axisVector);
                                worldDeltaVector = axisVector.clone().scale(projectionLength);
                                worldDx = worldDeltaVector.x;
                                worldDy = worldDeltaVector.y;
                                worldDelta.add(worldDeltaVector);
                                return worldDeltaVector;
                            }
                            return new Phaser.Math.Vector2(worldDx * xAxis, worldDy * yAxis);
                        }
                        getSimpleTranslationPoint(axis, args) {
                            const { x, y } = this.getAvgScreenPointOfObjects(args);
                            const xAxis = axis === "x" || axis === "xy" ? 1 : 0;
                            const yAxis = axis === "y" || axis === "xy" ? 1 : 0;
                            const axisVector = new Phaser.Math.Vector2(xAxis, yAxis);
                            if (args.localCoords) {
                                const angle = this.getAvgGlobalAngle(args);
                                axisVector.rotate(Phaser.Math.DegToRad(angle));
                            }
                            axisVector.scale(100);
                            if (axis === "xy") {
                                return { x, y };
                            }
                            return {
                                x: x + axisVector.x,
                                y: y + axisVector.y
                            };
                        }
                        renderSimpleAxis(axis, centerX, centerY, dotColor, args) {
                            const ctx = args.canvasContext;
                            ctx.strokeStyle = "#000";
                            if (axis === "xy") {
                                ctx.save();
                                ctx.translate(centerX, centerY);
                                this.drawCircle(ctx, args.canEdit ? dotColor : editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                                ctx.restore();
                            }
                            else {
                                ctx.save();
                                ctx.translate(centerX, centerY);
                                if (args.localCoords) {
                                    const angle = this.getAvgGlobalAngle(args);
                                    ctx.rotate(Phaser.Math.DegToRad(angle));
                                }
                                if (axis === "y") {
                                    ctx.rotate(Math.PI / 2);
                                }
                                this.drawArrowPath(ctx, args.canEdit ? (axis === "x" ? "#f00" : "#0f0") : editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                                ctx.restore();
                            }
                        }
                        getScreenPointOfObject(args, obj, fx, fy, removeRotation = false) {
                            const worldPoint = new Phaser.Geom.Point(0, 0);
                            const sprite = obj;
                            const { width, height } = this.computeSize(sprite);
                            const x = width * fx;
                            const y = height * fy;
                            const tx = sprite.getWorldTransformMatrix();
                            if (removeRotation) {
                                tx.rotate(-tx.rotation);
                            }
                            tx.transformPoint(x, y, worldPoint);
                            return args.camera.getScreenPoint(worldPoint.x, worldPoint.y);
                        }
                        computeSize(obj) {
                            const size = obj.getEditorSupport().computeSize();
                            return size;
                        }
                        getScreenToObjectScale(args, obj) {
                            let x = args.camera.zoom;
                            let y = args.camera.zoom;
                            const sprite = obj;
                            let next = sprite.parentContainer;
                            while (next) {
                                x *= next.scaleX;
                                y *= next.scaleY;
                                next = next.parentContainer;
                            }
                            return { x, y };
                        }
                        globalAngle(sprite) {
                            return SceneToolItem.getGlobalAngle(sprite);
                        }
                        static getGlobalAngle(sprite) {
                            let a = sprite.angle;
                            const parent = sprite.parentContainer;
                            if (parent) {
                                a += this.getGlobalAngle(parent);
                            }
                            return a;
                        }
                        drawLinePath(ctx, color, x1, y1, x2, y2, dashed = false) {
                            ctx.save();
                            if (dashed) {
                                ctx.setLineDash([5, 10]);
                                ctx.lineCap = "square";
                            }
                            ctx.strokeStyle = "#000";
                            ctx.lineWidth = 1.5;
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                            ctx.closePath();
                            ctx.stroke();
                            ctx.strokeStyle = color;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                            ctx.closePath();
                            ctx.stroke();
                            ctx.restore();
                        }
                        drawArrowPath(ctx, color) {
                            ctx.save();
                            ctx.fillStyle = color;
                            ctx.strokeStyle = "#000";
                            ctx.beginPath();
                            ctx.moveTo(0, -6);
                            ctx.lineTo(12, 0);
                            ctx.lineTo(0, 6);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            ctx.restore();
                        }
                        drawCircle(ctx, color) {
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.arc(0, 0, 6, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = "#000";
                            ctx.stroke();
                        }
                        drawRect(ctx, color, borderColor = "#000") {
                            ctx.save();
                            ctx.translate(-5, -5);
                            ctx.beginPath();
                            ctx.rect(0, 0, 10, 10);
                            ctx.fillStyle = color;
                            ctx.strokeStyle = borderColor;
                            ctx.fill();
                            ctx.stroke();
                            ctx.restore();
                        }
                        getAvgGlobalAngle(args) {
                            let total = 0;
                            let count = 0;
                            for (const obj of args.objects) {
                                total += this.globalAngle(obj);
                                count++;
                            }
                            return total / count;
                        }
                        getAvgScreenPointOfObjects(args, fx = obj => 0, fy = obj => 0, removeRotation = false) {
                            let avgY = 0;
                            let avgX = 0;
                            for (const obj of args.objects) {
                                const point = this.getScreenPointOfObject(args, obj, fx(obj), fy(obj), removeRotation);
                                avgX += point.x;
                                avgY += point.y;
                            }
                            avgX /= args.objects.length;
                            avgY /= args.objects.length;
                            return new Phaser.Math.Vector2(avgX, avgY);
                        }
                    }
                    tools.SceneToolItem = SceneToolItem;
                })(tools = editor.tools || (editor.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneToolItem.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var tools;
                (function (tools) {
                    class PointToolItem extends tools.SceneToolItem {
                        _color;
                        constructor(color) {
                            super();
                            this._color = color;
                        }
                        render(args) {
                            const point = this.getPoint(args);
                            const ctx = args.canvasContext;
                            ctx.fillStyle = args.canEdit ? this._color : editor.tools.SceneTool.COLOR_CANNOT_EDIT;
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = "#000";
                            ctx.stroke();
                        }
                        containsPoint(args) {
                            return false;
                        }
                        onStartDrag(args) {
                            // nothing
                        }
                        onDrag(args) {
                            // nothing
                        }
                        onStopDrag(args) {
                            // nothing
                        }
                    }
                    tools.PointToolItem = PointToolItem;
                })(tools = editor.tools || (editor.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./PointToolItem.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var tools;
                (function (tools) {
                    class CenterPointToolItem extends tools.PointToolItem {
                        constructor(color) {
                            super(color);
                        }
                        getPoint(args) {
                            return this.getAvgScreenPointOfObjects(args);
                        }
                    }
                    tools.CenterPointToolItem = CenterPointToolItem;
                })(tools = editor.tools || (editor.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneToolItem.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var tools;
                (function (tools_1) {
                    class LineToolItem extends tools_1.SceneToolItem {
                        _tools;
                        _color;
                        constructor(color, ...tools) {
                            super();
                            this._color = color;
                            this._tools = tools;
                        }
                        isValidFor(objects) {
                            for (const tool of this._tools) {
                                if (!tool.isValidFor(objects)) {
                                    return false;
                                }
                            }
                            return true;
                        }
                        render(args) {
                            const ctx = args.canvasContext;
                            ctx.save();
                            ctx.beginPath();
                            let start = true;
                            for (const tool of this._tools) {
                                const { x, y } = tool.getPoint(args);
                                if (start) {
                                    ctx.moveTo(x, y);
                                }
                                else {
                                    ctx.lineTo(x, y);
                                }
                                start = false;
                            }
                            ctx.strokeStyle = "#000";
                            ctx.lineWidth = 4;
                            ctx.stroke();
                            ctx.strokeStyle = args.canEdit ? this._color : tools_1.SceneTool.COLOR_CANNOT_EDIT;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            ctx.restore();
                        }
                        containsPoint(args) {
                            return false;
                        }
                        onStartDrag(args) {
                            // nothing
                        }
                        onDrag(args) {
                            // nothing
                        }
                        onStopDrag(args) {
                            // nothing
                        }
                    }
                    tools_1.LineToolItem = LineToolItem;
                })(tools = editor.tools || (editor.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var tools;
                (function (tools) {
                    class SceneTool {
                        static COLOR_CANNOT_EDIT = "#808080";
                        _config;
                        _items;
                        constructor(config) {
                            this._config = config;
                            this._items = [];
                        }
                        handleDoubleClick(args) {
                            return false;
                        }
                        handleDeleteCommand(args) {
                            return false;
                        }
                        getId() {
                            return this._config.id;
                        }
                        getCommandId() {
                            return this._config.command;
                        }
                        getItems() {
                            return this._items;
                        }
                        addItems(...items) {
                            this._items.push(...items);
                        }
                        clearItems() {
                            this._items = [];
                        }
                        isValidForAll(objects) {
                            return true;
                        }
                        requiresRepaintOnMouseMove() {
                            return false;
                        }
                        isObjectTool() {
                            return true;
                        }
                        render(args) {
                            for (const item of this._items) {
                                if (item.isValidFor(args.objects)) {
                                    item.render(args);
                                }
                            }
                        }
                        containsPoint(args) {
                            for (const item of this._items) {
                                if (item.isValidFor(args.objects)) {
                                    if (item.containsPoint(args)) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        }
                        onStartDrag(args) {
                            for (const item of this._items) {
                                if (item.isValidFor(args.objects)) {
                                    item.onStartDrag(args);
                                }
                            }
                        }
                        onDrag(args) {
                            for (const item of this._items) {
                                if (item.isValidFor(args.objects)) {
                                    item.onDrag(args);
                                }
                            }
                        }
                        onStopDrag(args) {
                            for (const item of this._items) {
                                if (item.isValidFor(args.objects)) {
                                    item.onStopDrag(args);
                                }
                            }
                        }
                        onActivated(args) {
                            // nothing
                        }
                        onDeactivated(args) {
                            // nothing
                        }
                    }
                    tools.SceneTool = SceneTool;
                })(tools = editor.tools || (editor.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var tools;
                (function (tools_2) {
                    class SceneToolExtension extends colibri.Extension {
                        static POINT_ID = "phasereditor2d.scene.ui.editor.tools.SceneToolExtension";
                        _tools;
                        constructor(...tools) {
                            super(SceneToolExtension.POINT_ID);
                            this._tools = tools;
                        }
                        getTools() {
                            return this._tools;
                        }
                    }
                    tools_2.SceneToolExtension = SceneToolExtension;
                })(tools = editor.tools || (editor.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var tools;
                (function (tools) {
                    class SceneToolOperation extends editor.undo.SceneEditorOperation {
                        _objects;
                        _values0;
                        _values1;
                        constructor(toolArgs) {
                            super(toolArgs.editor);
                            this._objects = toolArgs.objects;
                            this._values0 = new Map();
                            this._values1 = new Map();
                        }
                        async execute() {
                            for (const obj of this._objects) {
                                const sprite = obj;
                                const value0 = this.getInitialValue(sprite);
                                const value1 = this.getFinalValue(sprite);
                                const id = sprite.getEditorSupport().getId();
                                this._values0.set(id, value0);
                                this._values1.set(id, value1);
                            }
                            this.getEditor().setDirty(true);
                        }
                        setValues(values) {
                            for (const obj of this._objects) {
                                const sprite = obj;
                                const id = sprite.getEditorSupport().getId();
                                const value = values.get(id);
                                this.setValue(obj, value);
                            }
                            this._editor.setDirty(true);
                            this._editor.dispatchSelectionChanged();
                        }
                        undo() {
                            this.setValues(this._values0);
                        }
                        redo() {
                            this.setValues(this._values1);
                        }
                    }
                    tools.SceneToolOperation = SceneToolOperation;
                })(tools = editor.tools || (editor.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_25) {
                var tools;
                (function (tools) {
                    class SceneToolsManager {
                        _editor;
                        _activeTool;
                        _tools;
                        constructor(editor) {
                            this._editor = editor;
                            this._tools = scene.ScenePlugin.getInstance().getTools();
                            this.setActiveTool(this.findTool(ui.sceneobjects.TranslateTool.ID));
                        }
                        setState(state) {
                            if (state) {
                                const id = state.selectedId;
                                const tool = this.findTool(id);
                                if (tool) {
                                    this.setActiveTool(tool);
                                }
                                this._editor.setLocalCoords(state.localCoords || state.localCoords === undefined, false);
                            }
                        }
                        getState() {
                            return {
                                selectedId: this._activeTool ? this._activeTool.getId() : undefined,
                                localCoords: this._editor.isLocalCoords()
                            };
                        }
                        findTool(toolId) {
                            return this._tools.find(tool => tool.getId() === toolId);
                        }
                        getActiveTool() {
                            return this._activeTool;
                        }
                        activateTool(toolId) {
                            const tool = this.findTool(toolId);
                            if (tool) {
                                this.setActiveTool(tool);
                            }
                            else {
                                console.error(`Tool not found ${toolId}`);
                            }
                        }
                        setActiveTool(tool) {
                            const args = this.createToolArgs();
                            if (this._activeTool) {
                                this._activeTool.onDeactivated(args);
                            }
                            this.updateAction(this._activeTool, false);
                            this.updateAction(tool, true);
                            this._activeTool = tool;
                            if (this._activeTool) {
                                this._activeTool.onActivated(args);
                            }
                            this._editor.repaint();
                        }
                        handleDoubleClick() {
                            if (this._activeTool) {
                                return this._activeTool.handleDoubleClick(this.createToolArgs());
                            }
                            return false;
                        }
                        handleDeleteCommand() {
                            if (this._activeTool) {
                                return this._activeTool.handleDeleteCommand(this.createToolArgs());
                            }
                            return false;
                        }
                        createToolArgs() {
                            return {
                                camera: null,
                                editor: this._editor,
                                localCoords: this._editor.isLocalCoords(),
                                objects: this._editor.getSelection()
                            };
                        }
                        updateAction(tool, selected) {
                            if (tool) {
                                const action = this._editor.getToolbarActionMap().get(tool.getId());
                                if (action) {
                                    action.setSelected(selected);
                                }
                            }
                        }
                        swapTool(toolId) {
                            const tool = this.findTool(toolId);
                            this.setActiveTool(tool === this._activeTool ? null : tool);
                        }
                    }
                    tools.SceneToolsManager = SceneToolsManager;
                })(tools = editor_25.tools || (editor_25.tools = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_22) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_26) {
                var undo;
                (function (undo) {
                    class ObjectSnapshotOperation extends undo.SceneEditorOperation {
                        _before;
                        _after;
                        _objects;
                        constructor(editor, objects) {
                            super(editor);
                            this._objects = objects;
                        }
                        async execute() {
                            this._before = this.takeSnapshot(this._objects);
                            this._after = this.makeChangeSnapshot(this._objects);
                            this.loadSnapshot(this._after);
                        }
                        takeSnapshot(objects) {
                            const snapshot = {
                                objects: []
                            };
                            for (const obj of objects) {
                                const data = {};
                                obj.getEditorSupport().writeJSON(data);
                                let parentId;
                                const parent = obj.getEditorSupport().getObjectParent();
                                if (parent) {
                                    parentId = parent.getEditorSupport().getId();
                                }
                                snapshot.objects.push({
                                    parentId,
                                    objData: data
                                });
                            }
                            return snapshot;
                        }
                        async loadSnapshot(snapshot) {
                            const scene = this.getScene();
                            const maker = scene.getMaker();
                            const selectionIds = this.getEditor().getSelectionManager().getSelectionIds();
                            const finder = new phasereditor2d.pack.core.PackFinder();
                            await finder.preload();
                            await maker.updateSceneLoaderWithGameObjectDataList(finder, snapshot.objects.map(objSnapshot => objSnapshot.objData));
                            for (const objSnapshot of snapshot.objects) {
                                const oldObj = scene.getByEditorId(objSnapshot.objData.id);
                                if (oldObj) {
                                    const objData = objSnapshot.objData;
                                    const newObj = maker.createObject(objData);
                                    if (newObj) {
                                        scene.removeGameObject(newObj);
                                        if (objSnapshot.parentId) {
                                            const parent = scene.getByEditorId(objSnapshot.parentId);
                                            if (parent) {
                                                parent.replace(oldObj, newObj);
                                            }
                                        }
                                        else {
                                            scene.sys.displayList.replace(oldObj, newObj);
                                        }
                                    }
                                    oldObj.getEditorSupport().destroy();
                                }
                            }
                            await this.getEditor().refreshDependenciesHash();
                            this._editor.setDirty(true);
                            this._editor.getSelectionManager().setSelectionByIds(selectionIds);
                        }
                        undo() {
                            this.loadSnapshot(this._before);
                        }
                        redo() {
                            this.loadSnapshot(this._after);
                        }
                    }
                    undo.ObjectSnapshotOperation = ObjectSnapshotOperation;
                })(undo = editor_26.undo || (editor_26.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_22.ui || (scene_22.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./ObjectSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_27) {
                var undo;
                (function (undo) {
                    var io = colibri.core.io;
                    class ConvertTypeOperation extends undo.ObjectSnapshotOperation {
                        _targetType;
                        _extraData;
                        constructor(editor, targetType, extraData) {
                            super(editor, ConvertTypeOperation.filterObjects(editor.getSelectedGameObjects(), targetType));
                            this._targetType = targetType;
                            this._extraData = extraData || {};
                        }
                        async execute() {
                            if (this._targetType instanceof io.FilePath) {
                                const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                                const sceneData = finder.getSceneData(this._targetType);
                                await this.getEditor().getSceneMaker().updateSceneLoader(sceneData);
                            }
                            await super.execute();
                        }
                        makeChangeSnapshot(input) {
                            const result = {
                                objects: []
                            };
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            for (const obj of input) {
                                const parentId = obj.getEditorSupport().getParentId();
                                const support = obj.getEditorSupport();
                                const objData = {};
                                support.writeJSON(objData);
                                if (support.isPrefabInstance()) {
                                    delete objData.prefabId;
                                }
                                else {
                                    delete objData.type;
                                }
                                if (this._targetType instanceof io.FilePath) {
                                    objData.prefabId = finder.getPrefabId(this._targetType);
                                    objData.components = [];
                                    objData.list = [];
                                }
                                else {
                                    objData.type = this._targetType.getTypeName();
                                }
                                const ser = this._editor.getScene().getMaker().getSerializer(objData);
                                const type = ser.getType();
                                const ext = scene.ScenePlugin.getInstance().getGameObjectExtensionByObjectType(type);
                                if (obj.getEditorSupport().isUnlockedPropertyXY(ui.sceneobjects.TransformComponent.position)) {
                                    ser.setUnlocked(ui.sceneobjects.TransformComponent.x.name, true);
                                    ser.setUnlocked(ui.sceneobjects.TransformComponent.y.name, true);
                                }
                                ext.adaptDataAfterTypeConversion(ser, obj, this._extraData);
                                result.objects.push({
                                    objData,
                                    parentId
                                });
                            }
                            return result;
                        }
                        static filterObjects(input, targetType) {
                            return input.filter(obj => {
                                if (obj.getEditorSupport().isPrefabInstance()) {
                                    if (obj.getEditorSupport().getPrefabFile() === targetType) {
                                        return false;
                                    }
                                }
                                else if (obj.getEditorSupport().getExtension() === targetType) {
                                    return false;
                                }
                                return true;
                            });
                        }
                    }
                    undo.ConvertTypeOperation = ConvertTypeOperation;
                })(undo = editor_27.undo || (editor_27.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_23) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_28) {
                var undo;
                (function (undo) {
                    class SceneSnapshotOperation extends undo.SceneEditorOperation {
                        _before;
                        _after;
                        _operation;
                        constructor(editor, operation) {
                            super(editor);
                            this._operation = operation;
                        }
                        async execute() {
                            this._before = this.takeSnapshot();
                            await this.performModification();
                            this._after = this.takeSnapshot();
                            this._editor.setDirty(true);
                            this._editor.refreshOutline();
                            this._editor.repaint();
                            this._editor.dispatchSelectionChanged();
                        }
                        async performModification() {
                            if (this._operation) {
                                await this._operation();
                            }
                        }
                        takeSnapshot() {
                            const scene = this.getScene();
                            return {
                                displayList: scene.getGameObjects().map(obj => {
                                    const data = {};
                                    obj.getEditorSupport().writeJSON(data);
                                    return data;
                                }),
                                lists: scene.getObjectLists().getLists().map(list => {
                                    const data = {};
                                    list.writeJSON(data);
                                    return data;
                                }),
                                plainObjects: scene.getPlainObjects().map(obj => {
                                    const data = {};
                                    obj.getEditorSupport().writeJSON(data);
                                    return data;
                                }),
                                prefabUserProperties: scene.getPrefabUserProperties().toJSON(),
                                codeSnippets: scene.getCodeSnippets().toJSON(),
                                selection: this.getEditor().getSelectionManager().getSelectionIds(),
                            };
                        }
                        loadSnapshot(snapshot) {
                            const editor = this.getEditor();
                            const scene = this.getScene();
                            const maker = scene.getMaker();
                            scene.removeAll();
                            scene.readPlainObjects(snapshot.plainObjects);
                            for (const data of snapshot.displayList) {
                                maker.createObject(data);
                            }
                            scene.getObjectLists().readJSON_lists(snapshot.lists);
                            scene.getCodeSnippets().readJSON(snapshot.codeSnippets);
                            scene.getPrefabUserProperties().readJSON(snapshot.prefabUserProperties);
                            editor.setDirty(true);
                            editor.repaint();
                            editor.refreshOutline();
                            editor.getSelectionManager().setSelectionByIds(snapshot.selection);
                        }
                        undo() {
                            this.loadSnapshot(this._before);
                        }
                        redo() {
                            this.loadSnapshot(this._after);
                        }
                    }
                    undo.SceneSnapshotOperation = SceneSnapshotOperation;
                })(undo = editor_28.undo || (editor_28.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_23.ui || (scene_23.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_29) {
                var undo;
                (function (undo) {
                    var io = colibri.core.io;
                    class CreateObjectWithAssetOperation extends undo.SceneSnapshotOperation {
                        _offsetX;
                        _offsetY;
                        _data;
                        constructor(editor, data, offsetX = 0, offsetY = 0) {
                            super(editor);
                            this._offsetX = offsetX;
                            this._offsetY = offsetY;
                            this._data = data;
                        }
                        async performModification() {
                            const editor = this.getEditor();
                            let isScriptNode = false;
                            if (this._data.length === 1) {
                                const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                                const asset = this._data[0];
                                isScriptNode = asset instanceof io.FilePath
                                    && finder.isScriptPrefabFile(asset)
                                    || asset instanceof ui.sceneobjects.ScriptNodeExtension;
                            }
                            const sel = editor.getSelectedGameObjects();
                            if (isScriptNode && sel.length > 0) {
                                // We are dropping a script node,
                                // so we should go for every object selected in the scene
                                // and add the script.
                                // It is different from adding a regular game object,
                                // where only one instance is created
                                const newSprites = [];
                                const script = this._data[0];
                                for (const obj of sel) {
                                    const sprites = await editor.getDropManager()
                                        .createWithDropEvent([script], 0, 0, [obj]);
                                    newSprites.push(...sprites);
                                }
                                editor.setSelection(newSprites);
                            }
                            else {
                                const sprites = await editor.getDropManager()
                                    .createWithDropEvent(this._data, this._offsetX, this._offsetY);
                                editor.setSelection(sprites);
                            }
                        }
                    }
                    undo.CreateObjectWithAssetOperation = CreateObjectWithAssetOperation;
                })(undo = editor_29.undo || (editor_29.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_24) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_30) {
                var undo;
                (function (undo) {
                    class CutOperation extends undo.SceneSnapshotOperation {
                        constructor(editor) {
                            super(editor);
                        }
                        async performModification() {
                            this._editor.getClipboardManager().copy();
                            const scene = this.getScene();
                            const lists = this._editor.getScene().getObjectLists();
                            // delete game objects
                            for (const obj of this._editor.getSelectedGameObjects()) {
                                const objES = obj.getEditorSupport();
                                objES.destroy();
                                lists.removeObjectById(objES.getId());
                            }
                            // delete plain objects
                            const plainObjects = this._editor.getSelectedPlainObjects();
                            if (plainObjects.length > 0) {
                                scene.removePlainObjects(plainObjects);
                            }
                            // delete ObjectLists
                            for (const objectList of this._editor.getSelectedLists()) {
                                lists.removeListById(objectList.getId());
                            }
                            // delete prefab properties
                            for (const prop of this._editor.getSelectedPrefabProperties()) {
                                prop.getManager().deleteProperty(prop.getName());
                            }
                            // clear selection
                            this._editor.setSelection([]);
                        }
                    }
                    undo.CutOperation = CutOperation;
                })(undo = editor_30.undo || (editor_30.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_24.ui || (scene_24.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_25) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_31) {
                var undo;
                (function (undo) {
                    class DeleteOperation extends undo.SceneSnapshotOperation {
                        constructor(editor) {
                            super(editor);
                        }
                        async performModification() {
                            const editor = this._editor;
                            if (editor.getToolsManager().handleDeleteCommand()) {
                                return;
                            }
                            const scene = this._editor.getScene();
                            const lists = scene.getObjectLists();
                            for (const obj of editor.getSelectedGameObjects()) {
                                obj.getEditorSupport().destroy();
                                lists.removeObjectById(obj.getEditorSupport().getId());
                            }
                            for (const obj of editor.getSelectedLists()) {
                                lists.removeListById(obj.getId());
                            }
                            for (const obj of editor.getSelectedListItems()) {
                                for (const list of lists.getLists()) {
                                    list.removeItem(obj.getId());
                                }
                            }
                            for (const obj of editor.getSelectedPrefabProperties()) {
                                obj.getManager().deleteProperty(obj.getName());
                            }
                            scene.removePlainObjects(editor.getSelectedPlainObjects());
                            const codeSnippetIds = editor.getSelectedCodeSnippets().map(s => s.getId());
                            editor.getScene().getCodeSnippets().removeByIds(codeSnippetIds);
                            const nodes = editor.getSelectedUserComponentNodes();
                            for (const node of nodes) {
                                node.getUserComponentsComponent()
                                    .removeUserComponent(node.getComponentName());
                            }
                            editor.setSelection([]);
                        }
                    }
                    undo.DeleteOperation = DeleteOperation;
                })(undo = editor_31.undo || (editor_31.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_25.ui || (scene_25.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_32) {
                var undo;
                (function (undo) {
                    class GameObjectDepthOperation extends undo.SceneSnapshotOperation {
                        _depthMove;
                        constructor(editor, depthMove) {
                            super(editor);
                            this._depthMove = depthMove;
                        }
                        static allow(editor, move) {
                            // sort the selection and filter off non-game-objects
                            let sel = this.sortedSelection(editor);
                            // if the sorted selection contains all the selected objects
                            if (sel.length !== editor.getSelection().length) {
                                return false;
                            }
                            for (const obj of sel) {
                                const parent = obj.getEditorSupport().getObjectParent();
                                const siblings = obj.getEditorSupport().getObjectSiblings();
                                const index = siblings.indexOf(obj);
                                let bottomIndex = 0;
                                const len = siblings.length;
                                if (ui.sceneobjects.isGameObject(parent)) {
                                    const parentES = parent.getEditorSupport();
                                    bottomIndex = parentES.getCountPrefabChildren();
                                }
                                if (move === "Top" || move === "Up") {
                                    if (index === len - 1) {
                                        return false;
                                    }
                                }
                                else { // Bottom || Down
                                    if (index === bottomIndex) {
                                        return false;
                                    }
                                }
                            }
                            return true;
                        }
                        static sortedSelection(editor) {
                            const sel = editor.getSelectedGameObjects();
                            sel.sort((a, b) => {
                                const aParent = a.getEditorSupport().getObjectSiblings();
                                const bParent = b.getEditorSupport().getObjectSiblings();
                                const aa = aParent.indexOf(a);
                                const bb = bParent.indexOf(b);
                                return aa - bb;
                            });
                            return sel;
                        }
                        async performModification() {
                            const sel = GameObjectDepthOperation.sortedSelection(this.getEditor());
                            switch (this._depthMove) {
                                case "Top":
                                    for (const obj of sel) {
                                        const siblings = obj.getEditorSupport().getObjectSiblings();
                                        Phaser.Utils.Array.BringToTop(siblings, obj);
                                    }
                                    break;
                                case "Bottom":
                                    for (let i = 0; i < sel.length; i++) {
                                        const obj = sel[sel.length - i - 1];
                                        const objES = obj.getEditorSupport();
                                        const parent = objES.getObjectParent();
                                        const siblings = objES.getObjectSiblings();
                                        let bottomIndex = 0;
                                        if (parent && ui.sceneobjects.isGameObject(parent)) {
                                            const parentES = parent.getEditorSupport();
                                            bottomIndex = parentES.getCountPrefabChildren();
                                        }
                                        if (bottomIndex === 0) {
                                            Phaser.Utils.Array.SendToBack(siblings, obj);
                                        }
                                        else {
                                            let i = siblings.indexOf(obj);
                                            for (; i > bottomIndex; i--) {
                                                Phaser.Utils.Array.MoveDown(siblings, obj);
                                            }
                                        }
                                    }
                                    break;
                                case "Up":
                                    for (let i = 0; i < sel.length; i++) {
                                        const obj = sel[sel.length - i - 1];
                                        const siblings = obj.getEditorSupport().getObjectSiblings();
                                        Phaser.Utils.Array.MoveUp(siblings, obj);
                                    }
                                    break;
                                case "Down":
                                    for (const obj of sel) {
                                        const siblings = obj.getEditorSupport().getObjectSiblings();
                                        Phaser.Utils.Array.MoveDown(siblings, obj);
                                    }
                                    break;
                            }
                            ui.sceneobjects.sortGameObjects(sel);
                            const objectsToSyncFxSet = new Set();
                            for (const obj of sel) {
                                if (obj instanceof ui.sceneobjects.FXObject) {
                                    objectsToSyncFxSet.add(obj.getParent());
                                }
                            }
                            if (objectsToSyncFxSet.size > 0) {
                                const selManager = this.getEditor().getSelectionManager();
                                const selIds = selManager.getSelectionIds();
                                for (const obj of objectsToSyncFxSet) {
                                    const objES = obj.getEditorSupport();
                                    const data = {};
                                    objES.writeJSON(data);
                                    const sprite = obj;
                                    sprite.preFX?.clear();
                                    sprite.postFX?.clear();
                                    objES.readJSON(data);
                                }
                                selManager.setSelectionByIds(selIds);
                            }
                            this.getEditor().repaint();
                        }
                    }
                    undo.GameObjectDepthOperation = GameObjectDepthOperation;
                })(undo = editor_32.undo || (editor_32.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_26) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_33) {
                var undo;
                (function (undo) {
                    class PasteOperation extends undo.SceneSnapshotOperation {
                        _pasteInPlace;
                        constructor(editor, pasteInPlace) {
                            super(editor);
                            this._pasteInPlace = pasteInPlace;
                        }
                        // TODO: keep an eye on this. I did a full refreshScene() for loading all the required assets,
                        // but I'm now using the data loaders in the performModification() method.
                        // So I'm commenting this, but let's see if it doesn't introduce regressions.
                        // async execute() {
                        //     await super.execute();
                        //     await this.getEditor().refreshScene();
                        // }
                        async performModification() {
                            const items = editor_33.ClipboardManager.getClipboardCopy();
                            const sel = [];
                            await this.pasteGameObjects(items, sel);
                            await this.pastePlainObjects(items, sel);
                            this.pastePrefabProperties(items, sel);
                            this._editor.setSelection(sel);
                        }
                        async pastePlainObjects(clipboardItems, sel) {
                            const scene = this._editor.getScene();
                            const nameMaker = scene.createNameMaker();
                            const plainObjects = [];
                            const dataList = clipboardItems.filter(i => i.type === "IScenePlainObject").map(i => i.data);
                            await scene.getMaker().updateLoaderWithData([], dataList);
                            for (const data of dataList) {
                                this.setNewObjectId(data);
                                const obj = scene.readPlainObject(data);
                                if (obj) {
                                    plainObjects.push(obj);
                                    sel.push(obj);
                                }
                            }
                            for (const newObj of plainObjects) {
                                const oldLabel = newObj.getEditorSupport().getLabel();
                                const newLabel = nameMaker.makeName(oldLabel);
                                newObj.getEditorSupport().setLabel(newLabel);
                            }
                        }
                        pastePrefabProperties(clipboardItems, sel) {
                            const scene = this._editor.getScene();
                            if (!scene.isPrefabSceneType()) {
                                return;
                            }
                            for (const item of clipboardItems) {
                                if (item.type === "PrefabProperty") {
                                    const data = item.data;
                                    const id = data.type.id;
                                    const propType = scene_26.ScenePlugin.getInstance().getUserPropertyType(id);
                                    if (propType) {
                                        const userProps = scene.getPrefabUserProperties();
                                        const dataName = colibri.ui.ide.utils.NameMaker.trimNumbering(data.name);
                                        const dataLabel = colibri.ui.ide.utils.NameMaker.trimNumbering(data.label);
                                        const { name, label } = userProps.createNewPropertyNameInfo(dataName, dataLabel);
                                        data.name = name;
                                        data.label = label;
                                        const prop = userProps.createPropertyFromData(data);
                                        userProps.add(prop);
                                        sel.push(prop);
                                    }
                                }
                            }
                        }
                        async pasteGameObjects(clipboardItems, newSelection) {
                            const scene = this._editor.getScene();
                            const maker = this._editor.getSceneMaker();
                            const nameMaker = scene.createNameMaker();
                            const prefabObj = scene.getPrefabObject();
                            const sprites = [];
                            const displayList = clipboardItems.filter(i => i.type === "ISceneObject").map(i => i.data);
                            await scene.getMaker().updateLoaderWithData([], displayList);
                            for (const item of clipboardItems) {
                                if (item.type === "ISceneObject") {
                                    const data = item.data;
                                    this.setNewObjectId(data);
                                    if (!this._pasteInPlace) {
                                        const { x, y } = this.getEditor().getMouseManager().getDropPosition();
                                        data["x"] = data["__shiftLeft_x"] + x;
                                        data["y"] = data["__shiftLeft_y"] + y;
                                    }
                                    const loaders = scene_26.ScenePlugin.getInstance().getLoaderUpdaters();
                                    for (const loader of loaders) {
                                        await loader.updateLoaderWithObjData(this.getScene(), data);
                                    }
                                    const ser = maker.getSerializer(data);
                                    const type = ser.getType();
                                    if (scene_26.ScenePlugin.getInstance().isFXType(type)) {
                                        // ok, with the FX objects it is different, I can't create them without a parent
                                        // so I have to find the parent right now!
                                        const editorSelection = this.getEditor().getSelection();
                                        for (const parent of editorSelection) {
                                            if (ui.sceneobjects.isGameObject(parent)) {
                                                const parentES = parent.getEditorSupport();
                                                if (parentES.isDisplayObject()) {
                                                    const obj = maker.createObject(data, undefined, parent);
                                                    parentES.addObjectChild(obj);
                                                    sprites.push(obj);
                                                    newSelection.push(obj);
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        // it isn't an FX object,
                                        // so I can create it without a parent
                                        const obj = maker.createObject(data);
                                        if (obj) {
                                            sprites.push(obj);
                                            newSelection.push(obj);
                                        }
                                    }
                                }
                            }
                            for (const newObj of sprites) {
                                this.updateGameObjectName(newObj, nameMaker);
                            }
                            const nonFXObjects = sprites.filter(s => !(s instanceof ui.sceneobjects.FXObject));
                            maker.afterDropObjects(prefabObj, nonFXObjects);
                        }
                        updateGameObjectName(obj, nameMaker) {
                            const objES = obj.getEditorSupport();
                            const oldLabel = objES.getLabel();
                            const newLabel = nameMaker.makeName(oldLabel);
                            objES.setLabel(newLabel);
                            for (const child of objES.getAppendedChildren()) {
                                this.updateGameObjectName(child, nameMaker);
                            }
                        }
                        setNewObjectId(data) {
                            data.id = Phaser.Utils.String.UUID();
                            if (data.list) {
                                for (const child of data.list) {
                                    this.setNewObjectId(child);
                                }
                            }
                            if (data.nestedPrefabs) {
                                for (const child of data.nestedPrefabs) {
                                    this.setNewObjectId(child);
                                }
                            }
                        }
                    }
                    undo.PasteOperation = PasteOperation;
                })(undo = editor_33.undo || (editor_33.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene_26.ui || (scene_26.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_34) {
                var undo;
                (function (undo) {
                    class PlainObjectOrderOperation extends undo.SceneSnapshotOperation {
                        _depthMove;
                        constructor(editor, depthMove) {
                            super(editor);
                            this._depthMove = depthMove;
                        }
                        static getSibling(editor, obj) {
                            const objES = obj.getEditorSupport();
                            const category = objES.getExtension().getCategory();
                            const siblings = editor.getScene().getPlainObjectsByCategory(category);
                            return siblings;
                        }
                        static allow(editor, move) {
                            // sort the selection and filter off non-game-objects
                            let sel = this.sortedSelection(editor);
                            // if the sorted selection contains all the selected objects
                            if (sel.length !== editor.getSelection().length) {
                                return false;
                            }
                            for (const obj of sel) {
                                const siblings = this.getSibling(editor, obj);
                                const index = siblings.indexOf(obj);
                                let bottomIndex = 0;
                                const len = siblings.length;
                                if (move === "Bottom" || move === "Down") {
                                    if (index === len - 1) {
                                        return false;
                                    }
                                }
                                else { // Top || Up
                                    if (index === bottomIndex) {
                                        return false;
                                    }
                                }
                            }
                            return true;
                        }
                        async performModification() {
                            const editor = this.getEditor();
                            const sel = PlainObjectOrderOperation.sortedSelection(editor);
                            const plainObjects = editor.getScene().getPlainObjects();
                            switch (this._depthMove) {
                                case "Bottom":
                                    for (const obj of sel) {
                                        const siblings = PlainObjectOrderOperation.getSibling(editor, obj);
                                        const start = plainObjects.indexOf(siblings[0]);
                                        Phaser.Utils.Array.BringToTop(siblings, obj);
                                        plainObjects.splice(start, siblings.length, ...siblings);
                                    }
                                    break;
                                case "Top":
                                    for (let i = 0; i < sel.length; i++) {
                                        const obj = sel[sel.length - i - 1];
                                        const siblings = PlainObjectOrderOperation.getSibling(editor, obj);
                                        const start = plainObjects.indexOf(siblings[0]);
                                        Phaser.Utils.Array.SendToBack(siblings, obj);
                                        plainObjects.splice(start, siblings.length, ...siblings);
                                    }
                                    break;
                                case "Down":
                                    for (let i = 0; i < sel.length; i++) {
                                        const obj = sel[sel.length - i - 1];
                                        Phaser.Utils.Array.MoveUp(plainObjects, obj);
                                    }
                                    break;
                                case "Up":
                                    for (const obj of sel) {
                                        Phaser.Utils.Array.MoveDown(plainObjects, obj);
                                    }
                                    break;
                            }
                            this.getEditor().repaint();
                        }
                        static sortedSelection(editor) {
                            const sel = editor.getSelectedPlainObjects();
                            const plainObjects = editor.getScene().getPlainObjects();
                            sel.sort((a, b) => {
                                const aa = plainObjects.indexOf(a);
                                const bb = plainObjects.indexOf(b);
                                return aa - bb;
                            });
                            return sel;
                        }
                    }
                    undo.PlainObjectOrderOperation = PlainObjectOrderOperation;
                })(undo = editor_34.undo || (editor_34.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_35) {
                var undo;
                (function (undo) {
                    class SimpleSceneSnapshotOperation extends undo.SceneSnapshotOperation {
                        _action;
                        constructor(editor, action) {
                            super(editor);
                            this._action = action;
                        }
                        async performModification() {
                            this._action();
                            delete this._action;
                        }
                    }
                    undo.SimpleSceneSnapshotOperation = SimpleSceneSnapshotOperation;
                })(undo = editor_35.undo || (editor_35.undo = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    var code = scene.core.code;
                    class UserComponentCodeDOMBuilder {
                        _component;
                        _model;
                        // TODO: will be used for the "import" syntax
                        _modelFile;
                        _unitDom;
                        _typeFileMap;
                        constructor(component, model, file) {
                            this._component = component;
                            this._model = model;
                            this._modelFile = file;
                        }
                        build() {
                            if (this._model.autoImport) {
                                this.buildFilesMap();
                            }
                            this._unitDom = new code.UnitCodeDOM([]);
                            const clsDom = this.createClass();
                            this._unitDom.getBody().push(clsDom);
                            return this._unitDom;
                        }
                        buildFilesMap() {
                            this._typeFileMap = new Map();
                            colibri.ui.ide.FileUtils.visitProject(file => {
                                if (file.getExtension() === "ts" || file.getExtension() === "js") {
                                    this._typeFileMap.set(file.getNameWithoutExtension(), file);
                                }
                            });
                        }
                        createClass() {
                            const clsDom = new code.ClassDeclCodeDOM(this._component.getName());
                            clsDom.setExportClass(this._model.exportClass);
                            clsDom.setSuperClass(this._component.getBaseClass());
                            this.addImportForType(clsDom.getSuperClass());
                            this.buildConstructor(clsDom);
                            this.buildFields(clsDom);
                            this.buildAccessorMethods(clsDom);
                            return clsDom;
                        }
                        buildConstructor(clsDom) {
                            const ctrDeclDom = new code.MethodDeclCodeDOM("constructor");
                            ctrDeclDom.arg("gameObject", this._component.getGameObjectType());
                            if (this.isTypeScriptOutput()) {
                                this.addImportForType(this._component.getGameObjectType());
                            }
                            const body = ctrDeclDom.getBody();
                            const superClass = this._component.getBaseClass();
                            if (superClass && superClass.trim() !== "") {
                                const superCall = new code.MethodCallCodeDOM("super");
                                superCall.arg("gameObject");
                                body.push(superCall);
                                body.push(new code.RawCodeDOM(""));
                            }
                            const initGameObjDom = new code.AssignPropertyCodeDOM("gameObject", "this");
                            initGameObjDom.value("gameObject");
                            body.push(initGameObjDom);
                            const setCompDom = new code.RawCodeDOM(this.isTypeScriptOutput() ?
                                `(gameObject as any)["__${clsDom.getName()}"] = this;`
                                : `gameObject["__${clsDom.getName()}"] = this;`);
                            body.push(setCompDom);
                            body.push(new code.RawCodeDOM(""));
                            body.push(new code.UserSectionCodeDOM("/* START-USER-CTR-CODE */", "/* END-USER-CTR-CODE */", "\n\t\t// Write your code here.\n\t\t"));
                            this.buildCustomPropertiesInit(body);
                            clsDom.getBody().push(new code.UserSectionCodeDOM("/* START-USER-CODE */", "/* END-USER-CODE */", "\n\n\t// Write your code here.\n\n\t"));
                            clsDom.getBody().push(ctrDeclDom);
                        }
                        buildCustomPropertiesInit(body) {
                            const userProps = this._component.getUserProperties();
                            const assignDomList = userProps.getProperties()
                                .filter(prop => prop.isCustomDefinition())
                                .map(prop => {
                                const fieldDecl = prop.buildFieldDeclarationCode();
                                const assignDom = new code.AssignPropertyCodeDOM(fieldDecl.getName(), "this");
                                assignDom.value(fieldDecl.getInitialValueExpr());
                                return assignDom;
                            });
                            if (assignDomList.length > 0) {
                                body.push(new code.RawCodeDOM("\n"));
                                body.push(new code.RawCodeDOM("// custom definition props"));
                            }
                            body.push(...assignDomList);
                        }
                        addImportForType(type) {
                            if (!this._model.autoImport) {
                                return;
                            }
                            if (type) {
                                if (type.startsWith("Phaser.")) {
                                    this._unitDom.addImport("Phaser", "phaser", true);
                                }
                                else if (this._typeFileMap.has(type)) {
                                    const importFile = this._typeFileMap.get(type);
                                    const { importPath, asDefault } = code.getImportPath(this._modelFile, importFile);
                                    this._unitDom.addImport(type, importPath, asDefault);
                                }
                            }
                        }
                        buildFields(clsDom) {
                            // gameObject field
                            const gameObjectFieldDecl = new code.FieldDeclCodeDOM("gameObject", this._component.getGameObjectType());
                            gameObjectFieldDecl.setAllowUndefined(false);
                            clsDom.getBody().push(gameObjectFieldDecl);
                            // props fields
                            const userProps = this._component.getUserProperties();
                            for (const prop of userProps.getProperties()) {
                                if (!prop.isCustomDefinition()) {
                                    const fieldDecl = prop.buildFieldDeclarationCode();
                                    clsDom.getBody().push(fieldDecl);
                                }
                            }
                            if (this.isTypeScriptOutput()) {
                                // add imports for field declarations
                                for (const elem of clsDom.getBody()) {
                                    if (elem instanceof code.FieldDeclCodeDOM) {
                                        this.addImportForType(elem.getType());
                                    }
                                }
                            }
                        }
                        isTypeScriptOutput() {
                            return this._model.outputLang === phasereditor2d.ide.core.code.SourceLang.TYPE_SCRIPT;
                        }
                        buildAccessorMethods(clsDom) {
                            {
                                // getComponent()
                                const declDom = new code.MethodDeclCodeDOM("getComponent");
                                declDom.getModifiers().push("static");
                                declDom.arg("gameObject", this._component.getGameObjectType());
                                declDom.setReturnType(clsDom.getName());
                                const returnDom = new code.RawCodeDOM(this.isTypeScriptOutput() ?
                                    `return (gameObject as any)["__${clsDom.getName()}"];`
                                    : `return gameObject["__${clsDom.getName()}"];`);
                                declDom.getBody().push(returnDom);
                                clsDom.getBody().push(declDom);
                            }
                        }
                    }
                    usercomponent.UserComponentCodeDOMBuilder = UserComponentCodeDOMBuilder;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
///<reference path="../../../core/code/CodeResources2.ts">
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    class UserComponentCodeResources extends scene.core.code.CodeResources2 {
                        static _instance = new UserComponentCodeResources();
                        static getInstance() {
                            return this._instance;
                        }
                        constructor() {
                            super("phasereditor2d.scene/code/usercomponent");
                            this.addCodeResource("UserComponent");
                        }
                    }
                    usercomponent.UserComponentCodeResources = UserComponentCodeResources;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    class UserComponentCompileAllExtension extends phasereditor2d.ide.core.CompileProjectExtension {
                        getTotal() {
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            return finder.getUserComponentsModels().length;
                        }
                        async compile(monitor) {
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            const infos = finder.getUserComponentsModels(false);
                            for (const info of infos) {
                                const compiler = new usercomponent.UserComponentCompiler(info.file, info.model);
                                await compiler.compile();
                                monitor.step();
                            }
                        }
                    }
                    usercomponent.UserComponentCompileAllExtension = UserComponentCompileAllExtension;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    var code = scene.core.code;
                    class UserComponentCompiler {
                        _componentsFile;
                        _model;
                        constructor(componentsFile, model) {
                            this._componentsFile = componentsFile;
                            this._model = model;
                        }
                        async compile() {
                            for (const userComp of this._model.getComponents()) {
                                const builder = new usercomponent.UserComponentCodeDOMBuilder(userComp, this._model, this._componentsFile);
                                const unitDom = builder.build();
                                const generator = this.isJavaScriptOutput() ?
                                    new code.JavaScriptUnitCodeGenerator(unitDom) :
                                    new code.TypeScriptUnitCodeGenerator(unitDom);
                                if (this.isJavaScriptOutput()) {
                                    generator.setInitFieldInConstructor(this._model.javaScriptInitFieldsInConstructor);
                                }
                                let replace = "";
                                const outFile = this.getOutputFile(userComp.getName());
                                if (outFile) {
                                    replace = await colibri.ui.ide.FileUtils.preloadAndGetFileString(outFile);
                                }
                                let output = generator.generate(replace);
                                if (this._model.insertSpaces) {
                                    const tabs = " ".repeat(Math.max(1, this._model.tabSize));
                                    output = output.replace(/\t/g, tabs);
                                }
                                const folder = this._componentsFile.getParent();
                                const fileName = this.getOutputFileName(userComp.getName());
                                await colibri.ui.ide.FileUtils.createFile_async(folder, fileName, output);
                            }
                        }
                        isJavaScriptOutput() {
                            return this._model.getOutputLang() === phasereditor2d.ide.core.code.SourceLang.JAVA_SCRIPT;
                        }
                        getOutputFile(userCompName) {
                            const file = this._componentsFile.getSibling(this.getOutputFileName(userCompName));
                            return file;
                        }
                        getOutputFileName(userCompName) {
                            return userCompName + "." + (this.isJavaScriptOutput() ? "js" : "ts");
                        }
                    }
                    usercomponent.UserComponentCompiler = UserComponentCompiler;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    class UserComponentEditorContentProvider {
                        getRoots(input) {
                            return input.getComponents();
                        }
                        getChildren(parent) {
                            if (parent instanceof usercomponent.UserComponent) {
                                return parent.getUserProperties().getProperties();
                            }
                            return [];
                        }
                    }
                    usercomponent.UserComponentEditorContentProvider = UserComponentEditorContentProvider;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class UserPropertiesManager {
                    _properties;
                    _componentPropertyBuilder;
                    constructor(componentPropertyBuilder) {
                        this._componentPropertyBuilder = componentPropertyBuilder;
                        this._properties = [];
                    }
                    findPropertyByName(name) {
                        return this._properties.find(p => p.getName() === name);
                    }
                    getProperties() {
                        return this._properties;
                    }
                    deleteProperty(propName) {
                        const prop = this._properties.find(p => p.getName() === propName);
                        const i = this._properties.indexOf(prop);
                        this._properties.splice(i, 1);
                    }
                    add(prop) {
                        this._properties.push(prop);
                    }
                    createProperty(propType) {
                        const { name, label } = this.createNewPropertyNameInfo("property", "Property");
                        const prop = new sceneobjects.UserProperty(this, this._componentPropertyBuilder, {
                            defValue: propType.getDefaultValue(),
                            name,
                            label,
                            tooltip: "",
                            customDefinition: false,
                            type: propType
                        });
                        return prop;
                    }
                    createNewPropertyNameInfo(baseName, baseLabel) {
                        const p = this._properties.find(p2 => p2.getInfo().name === baseName);
                        if (!p) {
                            return { name: baseName, label: baseLabel };
                        }
                        let i = 0;
                        while (true) {
                            i++;
                            const p = this._properties.find(p2 => p2.getInfo().name === `${baseName}_${i}`);
                            if (!p) {
                                break;
                            }
                        }
                        return {
                            name: `${baseName}_${i}`,
                            label: `${baseLabel} ${i}`
                        };
                    }
                    createPropertyFromData(data) {
                        const prop = new sceneobjects.UserProperty(this, this._componentPropertyBuilder);
                        prop.readJSON(data);
                        return prop;
                    }
                    readJSON(data) {
                        this._properties = [];
                        for (const propData of data) {
                            const prop = this.createPropertyFromData(propData);
                            this._properties.push(prop);
                        }
                    }
                    writeJSON(data) {
                        for (const prop of this._properties) {
                            const propData = {};
                            prop.writeJSON(propData);
                            data.push(propData);
                        }
                    }
                    toJSON() {
                        const data = [];
                        this.writeJSON(data);
                        return data;
                    }
                }
                sceneobjects.UserPropertiesManager = UserPropertiesManager;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class UserComponentPropertyWrapper {
                    _userProp;
                    _userComp;
                    constructor(userComp, userProp) {
                        this._userComp = userComp;
                        this._userProp = userProp;
                    }
                    getUserComponent() {
                        return this._userComp;
                    }
                    getUserProperty() {
                        return this._userProp;
                    }
                    getValue(obj) {
                        const comp = this.getComponent(obj);
                        if (comp.isPropertySet(this._userComp.getName(), this._userProp)) {
                            return comp.getPropertyValue(this._userComp.getName(), this._userProp);
                        }
                        return this._userProp.getDefaultValue();
                    }
                    setValue(obj, value) {
                        this.getComponent(obj).setPropertyValue(this._userComp.getName(), this._userProp, value);
                    }
                    getComponent(obj) {
                        return sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, sceneobjects.UserComponentsEditorComponent);
                    }
                    get name() {
                        return this._userComp.getName() + "." + this._userProp.getName();
                    }
                    get codeName() {
                        return this._userProp.getName();
                    }
                    get defValue() {
                        return this._userProp.getDefaultValue();
                    }
                    get local() {
                        return false;
                    }
                    get label() {
                        return this._userProp.getLabel();
                    }
                    get tooltip() {
                        return this._userProp.getTooltip();
                    }
                }
                sceneobjects.UserComponentPropertyWrapper = UserComponentPropertyWrapper;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PrefabUserPropertyWrapper {
                    _userProp;
                    constructor(userProp) {
                        this._userProp = userProp;
                    }
                    getUserProperty() {
                        return this._userProp;
                    }
                    getValue(obj) {
                        const comp = this.getComponent(obj);
                        if (comp.isPropertySet(this._userProp)) {
                            return this.getComponent(obj).getPropertyValue(this._userProp);
                        }
                        return this._userProp.getDefaultValue();
                    }
                    setValue(obj, value) {
                        this.getComponent(obj).setPropertyValue(this._userProp, value);
                    }
                    getComponent(obj) {
                        return sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, sceneobjects.PrefabUserPropertyComponent);
                    }
                    get name() {
                        return this._userProp.getName();
                    }
                    get defValue() {
                        return this._userProp.getDefaultValue();
                    }
                    get local() {
                        return false;
                    }
                    get label() {
                        return this._userProp.getLabel();
                    }
                    get tooltip() {
                        return this._userProp.getTooltip();
                    }
                }
                sceneobjects.PrefabUserPropertyWrapper = PrefabUserPropertyWrapper;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./PrefabUserPropertyWrapper.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class UserComponentOptionPropertyWrapper extends sceneobjects.UserComponentPropertyWrapper {
                    constructor(userComp, userProp) {
                        super(userComp, userProp);
                    }
                    get values() {
                        return this.getUserProperty().getType().getOptions();
                    }
                    getValueLabel(value) {
                        return value;
                    }
                }
                sceneobjects.UserComponentOptionPropertyWrapper = UserComponentOptionPropertyWrapper;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../sceneobjects/userProperties/UserPropertiesManager.ts" />
/// <reference path="../../sceneobjects/userProperties/UserComponentPropertyWrapper.ts" />
/// <reference path="../../sceneobjects/userProperties/UserComponentOptionPropertyWrapper.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    class UserComponentProperties extends ui.sceneobjects.UserPropertiesManager {
                        _userComponent;
                        constructor(userComponent) {
                            super((prop) => {
                                if (prop.getType() instanceof ui.sceneobjects.OptionPropertyType) {
                                    return new ui.sceneobjects.UserComponentOptionPropertyWrapper(userComponent, prop);
                                }
                                return new ui.sceneobjects.UserComponentPropertyWrapper(userComponent, prop);
                            });
                            this._userComponent = userComponent;
                        }
                        getUserComponent() {
                            return this._userComponent;
                        }
                    }
                    usercomponent.UserComponentProperties = UserComponentProperties;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../properties/UserPropertiesSection.ts" />
/// <reference path="../properties/SingleUserPropertySection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    class UserComponentPropertySection extends editor.properties.SingleUserPropertySection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.usercomponent.UserComponentPropertySection", "User Property", false, false);
                        }
                        getSectionHelpPath() {
                            return "scene-editor/user-components-editor-edit-component.html";
                        }
                        getEditor() {
                            return colibri.Platform.getWorkbench()
                                .getActiveWindow().getEditorArea()
                                .getSelectedEditor();
                        }
                        getUserProperties() {
                            return this.getSelectionFirstElement().getManager();
                        }
                        getProperty() {
                            return this.getSelectionFirstElement();
                        }
                        componentTitleUpdated() {
                            this.getEditor().refreshViewers();
                        }
                        runOperation(action, updateSelection) {
                            this.getEditor().runOperation(() => action(this.getUserProperties()));
                            if (updateSelection) {
                                this.updateWithSelection();
                            }
                        }
                        canEdit(obj, n) {
                            return obj instanceof ui.sceneobjects.UserProperty;
                        }
                        canEditNumber(n) {
                            return n === 1;
                        }
                    }
                    usercomponent.UserComponentPropertySection = UserComponentPropertySection;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_36) {
                var usercomponent;
                (function (usercomponent) {
                    var controls = colibri.ui.controls;
                    class UserComponentSection extends controls.properties.PropertySection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.usercomponent.UserComponentSection", "Component", false, false);
                        }
                        hasMenu() {
                            return true;
                        }
                        createMenu(menu) {
                            phasereditor2d.ide.IDEPlugin.getInstance().createHelpMenuItem(menu, "scene-editor/user-components-editor-edit-component.html");
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 3);
                            comp.style.gridTemplateColumns = "auto 1fr auto";
                            {
                                // Name
                                const text = this.stringProp(comp, "Name", "Name", "Name of the component. In the compiled code, it is used as file name and class name.");
                                this.addUpdater(() => {
                                    text.readOnly = this.getSelection().length > 1;
                                });
                            }
                            this.stringProp(comp, "GameObjectType", "Game Object Type", "Name of the type of the Game Object that this component can be added on.", () => this.createGameObjectTypeOptions());
                            this.stringProp(comp, "BaseClass", "Super Class", "Name of the super class of the component. It is optional.", () => this.createSuperClassOptions());
                            this.stringProp(comp, "DisplayName", "Display Name", "The display name of the component.");
                            this.stringProp(comp, "ObjectDisplayFormat", "Object Display Format", "The display name format to show in prefab instances.");
                            const op = (action) => {
                                const props = this.getSelectionFirstElement().getUserProperties();
                                this.getEditor().runOperation(() => action(props));
                            };
                            const selector = (obj) => {
                                const editor = this.getEditor();
                                const data = editor.getSelectionDataFromObjects([obj]);
                                const sel = editor.getSelectionFromData(data);
                                editor.getViewer().revealAndSelect(...sel);
                                editor.refreshViewers();
                            };
                            const { buttonElement } = editor.properties.SingleUserPropertySection
                                .createAddPropertyButton(comp, this, op, selector);
                            buttonElement.style.marginTop = "10px";
                            buttonElement.style.width = "100%";
                            buttonElement.style.gridColumn = "1 / span 3";
                        }
                        createSuperClassOptions() {
                            const options = new Set(scene.ScenePlugin.getInstance().getSceneFinder()
                                .getUserComponentsModels()
                                .flatMap(model => model.model.getComponents())
                                .map(comp => comp.getBaseClass())
                                .filter(name => name !== undefined && name !== null && name.trim().length > 0));
                            options.delete("UserComponent");
                            return ["UserComponent", ...([...options].sort())];
                        }
                        createGameObjectTypeOptions() {
                            const options = new Set(scene.ScenePlugin.getInstance().getSceneFinder()
                                .getUserComponentsModels()
                                .flatMap(model => model.model.getComponents())
                                .map(comp => comp.getGameObjectType()));
                            for (const option of scene.ScenePlugin.getInstance()
                                .getGameObjectExtensions()
                                .map(e => e.getPhaserTypeName())) {
                                options.add(option);
                            }
                            return [...options].sort();
                        }
                        stringProp(comp, prop, propName, propHelp, options) {
                            this.createLabel(comp, propName, propHelp);
                            const text = this.createText(comp);
                            text.addEventListener("change", e => {
                                this.getEditor().runOperation(() => {
                                    for (const comp1 of this.getSelection()) {
                                        comp1["set" + prop](text.value);
                                    }
                                });
                            });
                            this.addUpdater(() => {
                                text.value = this.flatValues_StringOneOrNothing(this.getSelection().map(c => c["get" + prop]() || ""));
                            });
                            if (options) {
                                const btn = new controls.IconControl(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_CONTROL_TREE_COLLAPSE), true);
                                btn.getCanvas().style.alignSelf = "center";
                                comp.appendChild(btn.getCanvas());
                                btn.getCanvas().addEventListener("click", e => {
                                    const menu = new controls.Menu();
                                    for (const option of options()) {
                                        menu.addAction({
                                            text: option,
                                            callback: () => {
                                                text.value = option;
                                                this.getEditor().runOperation(() => {
                                                    for (const comp1 of this.getSelection()) {
                                                        comp1["set" + prop](text.value);
                                                    }
                                                });
                                            }
                                        });
                                    }
                                    menu.createWithEvent(e, true);
                                });
                            }
                            else {
                                text.style.gridColumn = "2 / span 2";
                            }
                            return text;
                        }
                        booleanProp(comp, prop, propName, propHelp) {
                            const checkbox = this.createCheckbox(comp, this.createLabel(comp, propName, propHelp));
                            checkbox.style.gridColumn = "2 / span 2";
                            checkbox.addEventListener("change", e => {
                                this.getEditor().runOperation(() => {
                                    for (const comp1 of this.getSelection()) {
                                        comp1["set" + prop](checkbox.checked);
                                    }
                                });
                            });
                            this.addUpdater(() => {
                                checkbox.checked = this.flatValues_BooleanAnd(this.getSelection().map(c => c["is" + prop]()));
                            });
                            return checkbox;
                        }
                        getEditor() {
                            return colibri.Platform.getWorkbench()
                                .getActiveWindow().getEditorArea()
                                .getSelectedEditor();
                        }
                        canEdit(obj, n) {
                            return obj instanceof usercomponent.UserComponent;
                        }
                        canEditNumber(n) {
                            return n > 0;
                        }
                    }
                    usercomponent.UserComponentSection = UserComponentSection;
                })(usercomponent = editor_36.usercomponent || (editor_36.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    var controls = colibri.ui.controls;
                    class UserComponentsCompilerSection extends controls.properties.PropertySection {
                        constructor(page) {
                            super(page, "phasereditor2d.scene.ui.editor.usercomponent.UserComponentsCompilerSection", "Compiler Settings", false, false);
                        }
                        hasMenu() {
                            return true;
                        }
                        createMenu(menu) {
                            phasereditor2d.ide.IDEPlugin.getInstance().createHelpMenuItem(menu, "scene-editor/user-components-compiler.html");
                        }
                        createForm(parent) {
                            const comp = this.createGridElement(parent, 2);
                            {
                                // Output Lang
                                this.createLabel(comp, "Output Language", "The components code output language.");
                                const btn = this.createMenuButton(comp, "", () => [{
                                        name: "JavaScript",
                                        value: phasereditor2d.ide.core.code.SourceLang.JAVA_SCRIPT
                                    }, {
                                        name: "TypeScript",
                                        value: phasereditor2d.ide.core.code.SourceLang.TYPE_SCRIPT
                                    }], value => {
                                    this.getEditor().runOperation(model => {
                                        model.setOutputLang(value);
                                        this.updateWithSelection();
                                    });
                                });
                                this.addUpdater(() => {
                                    const lang = this.getSelectionFirstElement().getOutputLang();
                                    btn.textContent = lang === phasereditor2d.ide.core.code.SourceLang.JAVA_SCRIPT ?
                                        "JavaScript" : "TypeScript";
                                });
                            }
                            {
                                // Fields In Constructor
                                const checkbox = this.createCheckbox(comp, this.createLabel(comp, "Fields In Constructor (JS)", "Generate the initialization of the fields in the constructor. This is valid only when the output is JavaScript."));
                                checkbox.addEventListener("change", e => {
                                    this.getEditor().runOperation(model => {
                                        model.javaScriptInitFieldsInConstructor = checkbox.checked;
                                    });
                                });
                                this.addUpdater(() => {
                                    checkbox.checked = this.getSelectionFirstElement().javaScriptInitFieldsInConstructor;
                                });
                            }
                            {
                                // Export Class
                                const checkbox = this.createCheckbox(comp, this.createLabel(comp, "Export Class (ES Module)", "Export the class."));
                                checkbox.addEventListener("change", e => {
                                    this.getEditor().runOperation(model => {
                                        model.exportClass = checkbox.checked;
                                    });
                                });
                                this.addUpdater(() => {
                                    checkbox.checked = this.getSelectionFirstElement().exportClass;
                                });
                            }
                            {
                                // Auto Import
                                const checkbox = this.createCheckbox(comp, this.createLabel(comp, "Auto Import (ES Module)", "Auto import types used in the component."));
                                checkbox.addEventListener("change", e => {
                                    this.getEditor().runOperation(model => {
                                        model.autoImport = checkbox.checked;
                                    });
                                });
                                this.addUpdater(() => {
                                    checkbox.checked = this.getSelectionFirstElement().autoImport;
                                });
                            }
                            {
                                // Insert Spaces
                                const checkbox = this.createCheckbox(comp, this.createLabel(comp, "Insert Spaces", "Use spaces for indentation."));
                                checkbox.addEventListener("change", e => {
                                    this.getEditor().runOperation(model => {
                                        model.insertSpaces = checkbox.checked;
                                    });
                                });
                                this.addUpdater(() => {
                                    checkbox.checked = this.getSelectionFirstElement().insertSpaces;
                                });
                            }
                            {
                                // Tab Size
                                this.createLabel(comp, "Tab Size", "The number of spaces if the Insert Spaces option is checked.");
                                const text = this.createText(comp);
                                text.addEventListener("change", e => {
                                    const n = Number.parseInt(text.value, 10);
                                    if (isNaN(n)) {
                                        this.updateWithSelection();
                                    }
                                    else {
                                        this.getEditor().runOperation(model => {
                                            model.tabSize = n;
                                        });
                                    }
                                });
                                this.addUpdater(() => {
                                    text.value = this.getSelectionFirstElement().tabSize.toString();
                                });
                            }
                        }
                        canEdit(obj, n) {
                            return obj instanceof usercomponent.UserComponentsModel;
                        }
                        canEditNumber(n) {
                            return n === 1;
                        }
                        getEditor() {
                            return colibri.Platform.getWorkbench()
                                .getActiveWindow().getEditorArea()
                                .getSelectedEditor();
                        }
                    }
                    usercomponent.UserComponentsCompilerSection = UserComponentsCompilerSection;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_37) {
                var usercomponent;
                (function (usercomponent) {
                    var controls = colibri.ui.controls;
                    usercomponent.CMD_ADD_USER_COMPONENT = "phasereditor2d.scene.ui.editor.usercomponent.AddUserComponent";
                    usercomponent.CMD_COMPILE_FILE = "phasereditor2d.scene.ui.editor.usercomponent.CompileFile";
                    usercomponent.CMD_QUICK_EDIT_COMPONENT_FILE = "phasereditor2d.scene.ui.editor.usercomponent.QuickEditComponentFile";
                    usercomponent.CMD_OPEN_COMPONENT_OUTPUT_FILE_IN_VSCODE = "phasereditor2d.scene.ui.editor.usercomponent.OpenComponentOutputFileInVSCode";
                    usercomponent.CMD_OPEN_COMPONENT_OUTPUT_FILE = "phasereditor2d.scene.ui.editor.usercomponent.OpenComponentOutputFile";
                    usercomponent.CAT_USER_COMPONENTS_EDITOR = "phasereditor2d.scene.ui.editor.usercomponent.UserComponentsCategory";
                    class UserComponentsEditor extends colibri.ui.ide.ViewerFileEditor {
                        static _factory;
                        static ID;
                        _createdPart;
                        _revealCompName;
                        _outputFileEditorStateMap = {};
                        static getFactory() {
                            return this._factory || (this._factory = new colibri.ui.ide.ContentTypeEditorFactory("User Components Editor", scene.core.CONTENT_TYPE_USER_COMPONENTS, () => new UserComponentsEditor()));
                        }
                        static registerCommands(manager) {
                            const editorScope = (args) => {
                                return args.activePart instanceof UserComponentsEditor ||
                                    (args.activeEditor instanceof UserComponentsEditor &&
                                        (args.activePart instanceof phasereditor2d.outline.ui.views.OutlineView
                                            || args.activePart instanceof colibri.inspector.ui.views.InspectorView));
                            };
                            manager.addCategory({
                                id: usercomponent.CAT_USER_COMPONENTS_EDITOR,
                                name: "User Components Editor"
                            });
                            manager.add({
                                command: {
                                    id: usercomponent.CMD_ADD_USER_COMPONENT,
                                    name: "Add User Component",
                                    category: usercomponent.CAT_USER_COMPONENTS_EDITOR,
                                    tooltip: "Add a new User Component.",
                                    icon: colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_PLUS)
                                },
                                handler: {
                                    testFunc: editorScope,
                                    executeFunc: args => {
                                        args.activeEditor.addComponent();
                                    }
                                },
                                keys: {
                                    key: "KeyA"
                                }
                            });
                            manager.add({
                                command: {
                                    id: usercomponent.CMD_COMPILE_FILE,
                                    name: "Compile",
                                    tooltip: "Compile User Components file.",
                                    category: usercomponent.CAT_USER_COMPONENTS_EDITOR
                                },
                                handler: {
                                    testFunc: editorScope,
                                    executeFunc: args => args.activeEditor.compile()
                                }
                            });
                            manager.add({
                                handler: {
                                    testFunc: args => editorScope(args) && args.activeEditor.getSelection().length > 0,
                                    executeFunc: args => {
                                        args.activeEditor.deleteSelection();
                                    }
                                }
                            }, colibri.ui.ide.actions.CMD_DELETE);
                            manager.add({
                                command: {
                                    id: usercomponent.CMD_OPEN_COMPONENT_OUTPUT_FILE,
                                    icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_FILE_SCRIPT),
                                    name: "Open Component Output File",
                                    tooltip: "Open the output source file of the selected component.",
                                    category: usercomponent.CAT_USER_COMPONENTS_EDITOR
                                },
                                handler: {
                                    testFunc: args => {
                                        if (args.activeEditor instanceof UserComponentsEditor) {
                                            return args.activeEditor.getSelectedComponents().length === 1;
                                        }
                                        return false;
                                    },
                                    executeFunc: args => {
                                        const editor = args.activeEditor;
                                        const compiler = new usercomponent.UserComponentCompiler(editor.getInput(), editor.getModel());
                                        const component = editor.getSelectedComponents()[0];
                                        const file = compiler.getOutputFile(component.getName());
                                        colibri.Platform.getWorkbench().openEditor(file);
                                    }
                                }
                            });
                            manager.add({
                                command: {
                                    id: usercomponent.CMD_QUICK_EDIT_COMPONENT_FILE,
                                    name: "Quick Edit Component Source File",
                                    category: usercomponent.CAT_USER_COMPONENTS_EDITOR,
                                    tooltip: "Open output component file in a popup editor."
                                },
                                handler: {
                                    testFunc: args => editorScope(args) && args.activeEditor.getSelectedComponents().length === 1,
                                    executeFunc: args => {
                                        args.activeEditor.openOutputFileQuickEditorDialog();
                                    }
                                },
                                keys: {
                                    key: "KeyQ"
                                }
                            });
                            if (phasereditor2d.ide.IDEPlugin.getInstance().isDesktopMode()) {
                                const editorName = phasereditor2d.ide.IDEPlugin.getInstance().getExternalEditorName();
                                manager.add({
                                    command: {
                                        id: usercomponent.CMD_OPEN_COMPONENT_OUTPUT_FILE_IN_VSCODE,
                                        name: "Open Component Output File in " + editorName,
                                        category: usercomponent.CAT_USER_COMPONENTS_EDITOR,
                                        tooltip: "Open the compiler output file in the configured external editor (" + editorName + ")"
                                    },
                                    handler: {
                                        testFunc: args => {
                                            if (args.activeEditor instanceof UserComponentsEditor) {
                                                return args.activeEditor.getSelectedComponents().length === 1;
                                            }
                                            return false;
                                        },
                                        executeFunc: args => {
                                            const editor = args.activeEditor;
                                            const compiler = new usercomponent.UserComponentCompiler(editor.getInput(), editor.getModel());
                                            const component = editor.getSelectedComponents()[0];
                                            const file = compiler.getOutputFile(component.getName());
                                            if (file) {
                                                phasereditor2d.ide.IDEPlugin.getInstance().openFileExternalEditor(file);
                                            }
                                            else {
                                                alert(`Output from "${component.getName()}" not found.`);
                                            }
                                        }
                                    },
                                    keys: {
                                        control: true,
                                        alt: true,
                                        key: "KeyE"
                                    }
                                });
                            }
                        }
                        _model;
                        _outlineProvider;
                        _propertyProvider;
                        constructor() {
                            super(UserComponentsEditor.ID, UserComponentsEditor.getFactory());
                            this._model = new usercomponent.UserComponentsModel();
                            this._outlineProvider = new usercomponent.UserComponentsEditorOutlineProvider(this);
                            this._propertyProvider = new usercomponent.UserComponentsEditorPropertySectionProvider(this);
                        }
                        getSelectionDataFromObjects(selection) {
                            const result = selection.map(obj => {
                                if (obj instanceof usercomponent.UserComponent) {
                                    return { component: obj.getName() };
                                }
                                if (obj instanceof ui.sceneobjects.UserProperty) {
                                    const comp = obj.getManager().getUserComponent();
                                    return {
                                        component: comp.getName(),
                                        property: obj.getName()
                                    };
                                }
                            });
                            return result;
                        }
                        getSelectionFromData(selectionData) {
                            const selection = selectionData.map(item => {
                                const comp = this._model.getComponents().find(comp => comp.getName() === item.component);
                                if (comp && item.property) {
                                    return comp.getUserProperties().getProperties().find(prop => prop.getName() === item.property);
                                }
                                return comp;
                            }).filter(obj => obj !== undefined);
                            return selection;
                        }
                        getSelectedComponents() {
                            return this.getViewer().getSelection().filter(o => o instanceof usercomponent.UserComponent);
                        }
                        getModel() {
                            return this._model;
                        }
                        revealComponent(compName) {
                            if (!this._createdPart) {
                                this._revealCompName = compName;
                            }
                            else {
                                this.revealComponentNow(compName);
                            }
                        }
                        revealComponentNow(compName) {
                            const comp = this._model.getComponents().find(c => c.getName() === compName);
                            if (comp) {
                                this.getViewer().setSelection([comp]);
                                this.getViewer().reveal(comp);
                            }
                        }
                        async onEditorInputContentChangedByExternalEditor() {
                            const sel = new Set(this.getViewer().getSelection().map(c => c.getName()));
                            await this.updateContent();
                            this.getViewer().setSelection(this._model.getComponents().filter(c => sel.has(c.getName())));
                            this.getViewer().repaint();
                        }
                        async createPart() {
                            super.createPart();
                            await this.updateContent();
                            this._createdPart = true;
                            if (this._revealCompName) {
                                this.revealComponentNow(this._revealCompName);
                            }
                            else {
                                this.getViewer().setSelection([]);
                            }
                        }
                        fillContextMenu(menu) {
                            menu.addCommand(usercomponent.CMD_ADD_USER_COMPONENT, {
                                text: "Add Component"
                            });
                            menu.addCommand(colibri.ui.ide.actions.CMD_DELETE);
                            menu.addSeparator();
                            const resourceMenu = new controls.Menu("Resources");
                            for (const mod of [false, true]) {
                                for (const ext of ["js", "ts"]) {
                                    resourceMenu.addAction({
                                        text: `Create UserComponent.${ext}${mod ? " (ES Module)" : ""}`,
                                        icon: phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_FILE_SCRIPT),
                                        callback: async () => {
                                            const codeResources = usercomponent.UserComponentCodeResources.getInstance();
                                            // const id = "UserComponent" + (mod ? ".module" : "") + "." + ext;
                                            const id = `${ext}${mod ? "-module" : ""}/UserComponent.${ext}`;
                                            const parent = this.getInput().getParent();
                                            const name = "UserComponent." + ext;
                                            if (parent.getFile(name)) {
                                                if (!confirm("The file already exists, do you want to overwrite it?")) {
                                                    return;
                                                }
                                            }
                                            const file = await codeResources.createFile(id, parent, name);
                                            colibri.Platform.getWorkbench().openEditor(file);
                                        }
                                    });
                                }
                            }
                            menu.addMenu(resourceMenu);
                            const compilerMenu = new controls.Menu("Compiler");
                            compilerMenu.addCommand(usercomponent.CMD_COMPILE_FILE);
                            compilerMenu.addSeparator();
                            compilerMenu.addCommand(usercomponent.CMD_OPEN_COMPONENT_OUTPUT_FILE);
                            compilerMenu.addCommand(usercomponent.CMD_QUICK_EDIT_COMPONENT_FILE);
                            compilerMenu.addCommand(usercomponent.CMD_OPEN_COMPONENT_OUTPUT_FILE_IN_VSCODE);
                            menu.addMenu(compilerMenu);
                        }
                        async doSave() {
                            const content = JSON.stringify(this._model.toJSON(), null, 4);
                            try {
                                await colibri.ui.ide.FileUtils.setFileString_async(this.getInput(), content);
                                this.setDirty(false);
                                this.compile();
                            }
                            catch (e) {
                                console.error(e);
                            }
                        }
                        openOutputFileQuickEditorDialog() {
                            const component = this.getSelectedComponents()[0];
                            const fileName = component.getName() + "." + (this._model.getOutputLang() === phasereditor2d.ide.core.code.SourceLang.JAVA_SCRIPT ? "js" : "ts");
                            const file = this.getInput().getSibling(fileName);
                            if (!file) {
                                return;
                            }
                            const state = this._outputFileEditorStateMap[fileName] || {};
                            const dlg = new colibri.ui.ide.QuickEditorDialog(file, state);
                            dlg.create();
                            dlg.addButton("Play", () => {
                                colibri.Platform.getWorkbench().getCommandManager()
                                    .executeCommand(phasereditor2d.ide.ui.actions.CMD_PLAY_PROJECT);
                            });
                            dlg.eventDialogClose.addListener(() => {
                                this._outputFileEditorStateMap[fileName] = dlg.getEditorState();
                                colibri.Platform.getWorkbench().setActiveEditor(this);
                            });
                        }
                        async compile() {
                            const compiler = new usercomponent.UserComponentCompiler(this.getInput(), this._model);
                            await compiler.compile();
                        }
                        async updateContent() {
                            const content = await colibri.ui.ide.FileUtils.preloadAndGetFileString(this.getInput());
                            const data = JSON.parse(content);
                            this._model.readJSON(data);
                            if (this.getViewer()) {
                                this.refreshViewers();
                            }
                        }
                        refreshViewers() {
                            this.getViewer().repaint();
                            this._outlineProvider.repaint();
                        }
                        deleteSelection() {
                            const before = usercomponent.UserComponentsEditorSnapshotOperation.takeSnapshot(this);
                            const deleteComponentsSet = new Set();
                            for (const obj of this.getViewer().getSelection()) {
                                if (obj instanceof usercomponent.UserComponent) {
                                    deleteComponentsSet.add(obj);
                                }
                                else if (obj instanceof ui.sceneobjects.UserProperty) {
                                    obj.getManager().deleteProperty(obj.getName());
                                }
                                else if (typeof obj === "string") {
                                    for (const obj2 of this._model.getComponents()) {
                                        if (obj2.getGameObjectType() === obj) {
                                            deleteComponentsSet.add(obj2);
                                        }
                                    }
                                }
                            }
                            this._model.setComponents(this._model.getComponents().filter(comp => !deleteComponentsSet.has(comp)));
                            this.getViewer().setSelection([]);
                            this.setDirty(true);
                            const after = usercomponent.UserComponentsEditorSnapshotOperation.takeSnapshot(this);
                            this.getUndoManager().add(new usercomponent.UserComponentsEditorSnapshotOperation(this, before, after));
                        }
                        addComponent() {
                            const before = usercomponent.UserComponentsEditorSnapshotOperation.takeSnapshot(this);
                            const maker = new colibri.ui.ide.utils.NameMaker((comp) => comp.getName());
                            maker.update(this._model.getComponents());
                            const name = maker.makeName("Component");
                            const userComp = new usercomponent.UserComponent(name);
                            this._model.getComponents().push(userComp);
                            this.getViewer().setSelection([userComp]);
                            this.getViewer().reveal(userComp);
                            this.setDirty(true);
                            const after = usercomponent.UserComponentsEditorSnapshotOperation.takeSnapshot(this);
                            this.getUndoManager().add(new usercomponent.UserComponentsEditorSnapshotOperation(this, before, after));
                        }
                        createFilteredViewer(viewer) {
                            return new controls.viewers.FilteredViewer(viewer, false);
                        }
                        createViewer() {
                            const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.editor.usercomponent.UserComponentsEditor");
                            viewer.setLabelProvider(new UserComponentSignatureLabelProvider());
                            viewer.setStyledLabelProvider(new UserComponentSignatureStyledLabelProvider());
                            viewer.setContentProvider(new usercomponent.UserComponentEditorContentProvider());
                            viewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider(
                            // tslint:disable-next-line:new-parens
                            obj => {
                                if (obj instanceof usercomponent.UserComponent) {
                                    return new controls.viewers.IconImageCellRenderer(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_USER_COMPONENT));
                                }
                                return new controls.viewers.IconImageCellRenderer(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_USER_PROPERTY));
                            }));
                            // tslint:disable-next-line:new-parens
                            viewer.setTreeRenderer(new class extends controls.viewers.TreeViewerRenderer {
                                constructor() {
                                    super(viewer);
                                }
                                prepareContextForText(args) {
                                    super.prepareContextForText(args);
                                    args.canvasContext.font = controls.getCanvasFontHeight() + "px Monospace";
                                }
                            });
                            viewer.setInput(this._model);
                            viewer.eventSelectionChanged.addListener(() => {
                                this._outlineProvider.setSelection(viewer.getSelection(), true, false);
                                this._outlineProvider.repaint();
                            });
                            viewer.eventOpenItem.addListener((elem) => {
                                const compiler = new usercomponent.UserComponentCompiler(this.getInput(), this._model);
                                const file = compiler.getOutputFile(elem.getName());
                                colibri.Platform.getWorkbench().openEditor(file);
                            });
                            return viewer;
                        }
                        getEditorViewerProvider(key) {
                            switch (key) {
                                case phasereditor2d.outline.ui.views.OutlineView.EDITOR_VIEWER_PROVIDER_KEY:
                                    return this._outlineProvider;
                                default:
                                    break;
                            }
                        }
                        getPropertyProvider() {
                            return this._propertyProvider;
                        }
                        createEditorToolbar(parent) {
                            const manager = new controls.ToolbarManager(parent);
                            manager.addCommand(usercomponent.CMD_ADD_USER_COMPONENT, {
                                showText: true,
                                text: "Add Component"
                            });
                            return manager;
                        }
                        runOperation(action) {
                            const before = usercomponent.UserComponentsEditorSnapshotOperation.takeSnapshot(this);
                            action(this._model);
                            const after = usercomponent.UserComponentsEditorSnapshotOperation.takeSnapshot(this);
                            this.getUndoManager().add(new usercomponent.UserComponentsEditorSnapshotOperation(this, before, after));
                            this.setDirty(true);
                            this.refreshViewers();
                        }
                    }
                    usercomponent.UserComponentsEditor = UserComponentsEditor;
                    class UserComponentSignatureLabelProvider {
                        getLabel(obj) {
                            if (obj instanceof usercomponent.UserComponent) {
                                return `class ${obj.getName()} (gameObject: ${obj.getGameObjectType()})`;
                            }
                            if (obj instanceof ui.sceneobjects.UserProperty) {
                                return "property " + obj.getLabel() + ": " +
                                    (obj.getType() instanceof ui.sceneobjects.ExpressionPropertyType ?
                                        obj.getType().getExpressionType()
                                        : obj.getType().getName());
                            }
                            return "";
                        }
                    }
                    class UserComponentSignatureStyledLabelProvider {
                        static colorMap = {
                            light: {
                                keyword: "blue",
                                typeName: "#28809A",
                                default: "black"
                            },
                            dark: {
                                keyword: "#569CD6",
                                typeName: "#4BC1A9",
                                default: "white"
                            }
                        };
                        getStyledTexts(obj, dark) {
                            const colorMap = UserComponentSignatureStyledLabelProvider.colorMap;
                            const colors = dark ? colorMap.dark : colorMap.light;
                            if (obj instanceof usercomponent.UserComponent) {
                                return [{
                                        text: "class ",
                                        color: colors.keyword
                                    }, {
                                        text: obj.getName(),
                                        color: colors.typeName,
                                    }, {
                                        text: " (gameObject: ",
                                        color: colors.default
                                    }, {
                                        text: obj.getGameObjectType(),
                                        color: colors.typeName
                                    },
                                    {
                                        text: ")",
                                        color: colors.default
                                    }];
                            }
                            if (obj instanceof ui.sceneobjects.UserProperty) {
                                const typeName = obj.getType() instanceof ui.sceneobjects.ExpressionPropertyType ?
                                    obj.getType().getExpressionType()
                                    : obj.getType().getName();
                                return [{
                                        text: "property ",
                                        color: colors.keyword
                                    }, {
                                        text: obj.getLabel() + ": ",
                                        color: colors.default
                                    }, {
                                        text: typeName,
                                        color: colors.typeName
                                    }];
                            }
                            return [];
                        }
                    }
                })(usercomponent = editor_37.usercomponent || (editor_37.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_38) {
                var usercomponent;
                (function (usercomponent) {
                    var controls = colibri.ui.controls;
                    class OutlineContentProvider {
                        _editor;
                        constructor(editor) {
                            this._editor = editor;
                        }
                        getRoots(input) {
                            return [...new Set(input.getComponents().map(c => c.getGameObjectType()))];
                        }
                        getChildren(parent) {
                            return this._editor.getModel().getComponents().filter(c => c.getGameObjectType() === parent);
                        }
                    }
                    class UserComponentsEditorOutlineProvider extends colibri.ui.ide.EditorViewerProvider {
                        _editor;
                        constructor(editor) {
                            super();
                            this._editor = editor;
                        }
                        getContentProvider() {
                            return new OutlineContentProvider(this._editor);
                        }
                        getLabelProvider() {
                            return new controls.viewers.LabelProvider(obj => {
                                return obj instanceof usercomponent.UserComponent ? obj.getDisplayNameOrName() : obj;
                            });
                        }
                        getCellRendererProvider() {
                            return new controls.viewers.EmptyCellRendererProvider(obj => new controls.viewers.IconImageCellRenderer(phasereditor2d.resources.getIcon(obj instanceof usercomponent.UserComponent ?
                                phasereditor2d.resources.ICON_USER_COMPONENT : phasereditor2d.resources.ICON_GROUP)));
                        }
                        getTreeViewerRenderer(viewer) {
                            return new controls.viewers.TreeViewerRenderer(viewer);
                        }
                        getPropertySectionProvider() {
                            return this._editor.getPropertyProvider();
                        }
                        getInput() {
                            return this._editor.getModel();
                        }
                        preload(complete) {
                            return Promise.resolve();
                        }
                        getUndoManager() {
                            return this._editor.getUndoManager();
                        }
                        onViewerSelectionChanged(selection) {
                            const viewer = this._editor.getViewer();
                            viewer.setSelection(selection);
                            viewer.reveal(...selection);
                            viewer.repaint();
                        }
                        fillContextMenu(menu) {
                            this._editor.fillContextMenu(menu);
                        }
                    }
                    usercomponent.UserComponentsEditorOutlineProvider = UserComponentsEditorOutlineProvider;
                })(usercomponent = editor_38.usercomponent || (editor_38.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_39) {
                var usercomponent;
                (function (usercomponent) {
                    var controls = colibri.ui.controls;
                    class UserComponentsEditorPropertySectionProvider extends controls.properties.PropertySectionProvider {
                        _editor;
                        constructor(editor) {
                            super();
                            this._editor = editor;
                        }
                        addSections(page, sections) {
                            sections.push(new usercomponent.UserComponentsCompilerSection(page), new usercomponent.UserComponentSection(page), new usercomponent.UserComponentPropertySection(page));
                        }
                        getEmptySelectionObject() {
                            return this._editor.getModel();
                        }
                    }
                    usercomponent.UserComponentsEditorPropertySectionProvider = UserComponentsEditorPropertySectionProvider;
                })(usercomponent = editor_39.usercomponent || (editor_39.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor_40) {
                var usercomponent;
                (function (usercomponent) {
                    class UserComponentsEditorSnapshotOperation extends colibri.ui.ide.undo.Operation {
                        _editor;
                        _before;
                        _after;
                        constructor(editor, before, after) {
                            super();
                            this._editor = editor;
                            this._before = before;
                            this._after = after;
                        }
                        static takeSnapshot(editor) {
                            return {
                                selection: editor.getSelectionDataFromObjects(editor.getSelection()),
                                model: editor.getModel().toJSON()
                            };
                        }
                        loadSnapshot(data) {
                            this._editor.getModel().readJSON(data.model);
                            const sel = this._editor.getSelectionFromData(data.selection);
                            const viewer = this._editor.getViewer();
                            viewer.setSelection(sel);
                            viewer.reveal(...sel);
                            this._editor.refreshViewers();
                            this._editor.setDirty(true);
                        }
                        undo() {
                            this.loadSnapshot(this._before);
                        }
                        redo() {
                            this.loadSnapshot(this._after);
                        }
                    }
                    usercomponent.UserComponentsEditorSnapshotOperation = UserComponentsEditorSnapshotOperation;
                })(usercomponent = editor_40.usercomponent || (editor_40.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var editor;
            (function (editor) {
                var usercomponent;
                (function (usercomponent) {
                    var write = colibri.core.json.write;
                    var read = colibri.core.json.read;
                    class UserComponentsModel {
                        _components;
                        outputLang;
                        javaScriptInitFieldsInConstructor;
                        insertSpaces;
                        tabSize;
                        exportClass;
                        autoImport;
                        constructor() {
                            this._components = [];
                            this.outputLang = phasereditor2d.ide.core.code.SourceLang.JAVA_SCRIPT;
                            this.javaScriptInitFieldsInConstructor = false;
                            this.insertSpaces = false;
                            this.tabSize = 4;
                            this.exportClass = false;
                            this.autoImport = false;
                        }
                        toJSON() {
                            const data = {
                                components: this._components.map(comp => comp.toJSON()),
                                meta: {
                                    app: "Phaser Editor 2D - User Components Editor",
                                    url: "https://phasereditor2d.com",
                                    contentType: scene.core.CONTENT_TYPE_USER_COMPONENTS
                                }
                            };
                            write(data, "outputLang", this.outputLang, phasereditor2d.ide.core.code.SourceLang.JAVA_SCRIPT);
                            write(data, "javaScriptInitFieldsInConstructor", this.javaScriptInitFieldsInConstructor, false);
                            write(data, "insertSpaces", this.insertSpaces, false);
                            write(data, "tabSize", this.tabSize, 4);
                            write(data, "exportClass", this.exportClass, false);
                            write(data, "autoImport", this.autoImport, false);
                            return data;
                        }
                        readJSON(data) {
                            this.outputLang = read(data, "outputLang", phasereditor2d.ide.core.code.SourceLang.JAVA_SCRIPT);
                            this.javaScriptInitFieldsInConstructor = read(data, "javaScriptInitFieldsInConstructor", false);
                            this.insertSpaces = read(data, "insertSpaces", false);
                            this.tabSize = read(data, "tabSize", 4);
                            this.exportClass = read(data, "exportClass", false);
                            this.autoImport = read(data, "autoImport", false);
                            this._components = data.components.map(userCompData => {
                                const userComp = new usercomponent.UserComponent(userCompData.name);
                                userComp.readJSON(userCompData);
                                return userComp;
                            });
                        }
                        getOutputLang() {
                            return this.outputLang;
                        }
                        setOutputLang(outputLang) {
                            this.outputLang = outputLang;
                        }
                        getComponents() {
                            return this._components;
                        }
                        setComponents(components) {
                            this._components = components;
                        }
                    }
                    usercomponent.UserComponentsModel = UserComponentsModel;
                })(usercomponent = editor.usercomponent || (editor.usercomponent = {}));
            })(editor = ui.editor || (ui.editor = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                var read = colibri.core.json.read;
                var write = colibri.core.json.write;
                class Component {
                    _obj;
                    _properties;
                    _active;
                    _activeDefaultValue;
                    constructor(obj, properties, activeDefaultValue = true) {
                        this._obj = obj;
                        this._properties = new Set(properties);
                        this._active = activeDefaultValue;
                        this._activeDefaultValue = activeDefaultValue;
                    }
                    isActive() {
                        return this._active;
                    }
                    setActive(active) {
                        this._active = active;
                    }
                    getExplicitTypesForMethodFactory(baseType) {
                        return undefined;
                    }
                    getProperties() {
                        return this._properties;
                    }
                    getObject() {
                        return this._obj;
                    }
                    getEditorSupport() {
                        return this._obj.getEditorSupport();
                    }
                    getPropertyDefaultValue(prop) {
                        return this.getEditorSupport().getPropertyDefaultValue(prop);
                    }
                    write(ser, ...properties) {
                        for (const prop of properties) {
                            const value = prop.getValue(this._obj);
                            const defValue = this.getPropertyDefaultValue(prop);
                            ser.write(prop.name, value, defValue);
                        }
                    }
                    read(ser, ...properties) {
                        for (const prop of properties) {
                            const value = ser.read(prop.name, this.getPropertyDefaultValue(prop));
                            prop.setValue(this._obj, value);
                        }
                    }
                    writeLocal(ser, ...properties) {
                        for (const prop of properties) {
                            write(ser.getData(), prop.name, prop.getValue(this._obj), this.getPropertyDefaultValue(prop));
                        }
                    }
                    readLocal(ser, ...properties) {
                        for (const prop of properties) {
                            const value = read(ser.getData(), prop.name, this.getPropertyDefaultValue(prop));
                            prop.setValue(this._obj, value);
                        }
                    }
                    helperBuildSetObjectPropertyCodeDOM_StringProperty(args, properties, verbatim) {
                        this.buildSetObjectPropertyCodeDOM(properties, args2 => {
                            const dom = new code.AssignPropertyCodeDOM(args2.fieldCodeName, args.objectVarName);
                            if (verbatim) {
                                dom.value(args2.value);
                            }
                            else {
                                dom.valueLiteral(args2.value);
                            }
                            args.statements.push(dom);
                        });
                    }
                    buildSetObjectPropertyCodeDOM_StringProperty(args, ...properties) {
                        this.helperBuildSetObjectPropertyCodeDOM_StringProperty(args, properties, false);
                    }
                    buildSetObjectPropertyCodeDOM_StringVerbatimProperty(args, ...properties) {
                        this.helperBuildSetObjectPropertyCodeDOM_StringProperty(args, properties, true);
                    }
                    buildSetObjectPropertyCodeDOM_BooleanProperty(args, ...properties) {
                        this.buildSetObjectPropertyCodeDOM(properties, args2 => {
                            const dom = new code.AssignPropertyCodeDOM(args2.fieldCodeName, args.objectVarName);
                            dom.valueBool(args2.value);
                            args.statements.push(dom);
                        });
                    }
                    buildSetObjectPropertyCodeDOM(properties, codeDomBuilder, onPropertyIgnored) {
                        const objES = this.getEditorSupport();
                        for (const prop of properties) {
                            const fieldCodeName = prop.codeName ?? prop.name;
                            const value = prop.getValue(this.getObject());
                            const builderArgs = { prop, fieldCodeName, value };
                            let local = true;
                            let skip = true;
                            if (objES.isPrefabInstance()) {
                                local = false;
                                if (prop instanceof sceneobjects.UserComponentPropertyWrapper) {
                                    local = objES.isLocalUserProperty(prop);
                                }
                                if (!local) {
                                    if (objES.isUnlockedProperty(prop)) {
                                        skip = false;
                                        codeDomBuilder(builderArgs);
                                    }
                                }
                            }
                            if (local) {
                                const defValue = this.getPropertyDefaultValue(prop);
                                if (value !== defValue) {
                                    skip = false;
                                    codeDomBuilder(builderArgs);
                                }
                            }
                            if (skip && onPropertyIgnored) {
                                onPropertyIgnored(builderArgs);
                            }
                        }
                    }
                    buildSetObjectPropertyXYCodeDOM(propXY, codeDomBuilder) {
                        const obj = this.getObject();
                        const x = propXY.x.getValue(obj);
                        const y = propXY.y.getValue(obj);
                        let gen = false;
                        if (this.getEditorSupport().isPrefabInstance()) {
                            gen = this.getEditorSupport().isUnlockedPropertyXY(propXY);
                        }
                        else {
                            const defaultX = this.getPropertyDefaultValue(propXY.x);
                            const defaultY = this.getPropertyDefaultValue(propXY.y);
                            gen = x !== defaultX || y !== defaultY;
                        }
                        if (gen) {
                            codeDomBuilder({ propXY, x, y });
                        }
                    }
                    buildSetObjectPropertyXYCodeDOM_FloatXY(args, propXY) {
                        this.buildSetObjectPropertyXYCodeDOM(propXY, args2 => {
                            const dom = new code.MethodCallCodeDOM(propXY.setterName, args.objectVarName);
                            dom.argFloat(args2.x);
                            dom.argFloat(args2.y);
                            args.statements.push(dom);
                        });
                    }
                    buildSetObjectPropertyCodeDOM_FloatProperty(args, ...properties) {
                        this.buildSetObjectPropertyCodeDOM(properties, args2 => {
                            const dom = new code.AssignPropertyCodeDOM(args2.fieldCodeName, args.objectVarName);
                            const codeValue = args2.prop.valueToCodeConverter ? args2.prop.valueToCodeConverter(args2.value) : args2.value;
                            dom.valueFloat(codeValue);
                            args.statements.push(dom);
                        });
                    }
                    buildSetObjectPropertiesWithMethodCodeDOM_FloatProperty(args, methodName, ...properties) {
                        const values = [];
                        const generateCode = { yes: false };
                        this.buildSetObjectPropertyCodeDOM(properties, args2 => {
                            const codeValue = args2.prop.valueToCodeConverter ? args2.prop.valueToCodeConverter(args2.value) : args2.value;
                            values.push(codeValue);
                            generateCode.yes = true;
                        }, args2 => {
                            values.push(`${args.objectVarName}.${args2.fieldCodeName}`);
                        });
                        if (generateCode.yes) {
                            const dom = new code.MethodCallCodeDOM(methodName, args.objectVarName);
                            for (const value of values) {
                                dom.arg(value);
                            }
                            args.statements.push(dom);
                        }
                    }
                    /**
                    * Build extra typescript definitions at the top of the file.
                    *
                    * @param args This method args.
                    */
                    buildPrefabTypeScriptDefinitionsCodeDOM(args) {
                        // nothing by default
                    }
                    async buildDependenciesHash(args) {
                        // nothing by default
                    }
                    getComponentName() {
                        return this.constructor.name;
                    }
                    writeJSON(ser) {
                        ser.write(`${this.getComponentName()}.active`, this._active, this._activeDefaultValue);
                        if (this._active) {
                            for (const prop of this.getProperties()) {
                                this.writeProperty(ser, prop);
                            }
                        }
                    }
                    writeProperty(ser, prop, local) {
                        local = local ?? prop.local;
                        if (local) {
                            this.writeLocal(ser, prop);
                        }
                        else {
                            this.write(ser, prop);
                        }
                    }
                    readJSON(ser) {
                        this._active = ser.read(`${this.getComponentName()}.active`, this._activeDefaultValue);
                        if (this._active) {
                            for (const prop of this.getProperties()) {
                                if (prop.local) {
                                    this.readLocal(ser, prop);
                                }
                                else {
                                    this.read(ser, prop);
                                }
                            }
                        }
                    }
                }
                sceneobjects.Component = Component;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./Component.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ChildrenComponent extends sceneobjects.Component {
                    static allowPickChildren = {
                        name: "allowPickChildren",
                        label: "Allow Picking Children In Scene",
                        tooltip: "If this object's children can be pickable (mouse-selected) in the scene.",
                        defValue: true,
                        local: true,
                        getValue: obj => obj.getEditorSupport().isAllowPickChildren(),
                        setValue: (obj, value) => obj.getEditorSupport().setAllowPickChildren(value)
                    };
                    static showChildrenInOutline = {
                        name: "showChildrenInOutline",
                        label: "Show Children In Outline",
                        tooltip: "If showing the children in the Outline view.",
                        defValue: true,
                        local: true,
                        getValue: obj => obj.getEditorSupport().isShowChildrenInOutline(),
                        setValue: (obj, value) => obj.getEditorSupport().setShowChildrenInOutline(value)
                    };
                    static allowAppendChildren = {
                        name: "allowAppendChildren",
                        label: "Allow Append Children",
                        tooltip: "If allow appending children to the prefab instances of this object.",
                        defValue: false,
                        local: false,
                        getValue: obj => obj.getEditorSupport().isAllowAppendChildren(),
                        setValue: (obj, value) => obj.getEditorSupport().setAllowAppendChildren(value)
                    };
                    constructor(obj) {
                        super(obj, [
                            ChildrenComponent.allowPickChildren,
                            ChildrenComponent.showChildrenInOutline,
                            ChildrenComponent.allowAppendChildren
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        // nothing
                    }
                }
                sceneobjects.ChildrenComponent = ChildrenComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./object/properties/SceneGameObjectSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ChildrenSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ChildrenSection", "Children", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/container-object.html#container-properties";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr";
                        this.createPropertyBoolean(comp, sceneobjects.ChildrenComponent.allowPickChildren, false);
                        this.createPropertyBoolean(comp, sceneobjects.ChildrenComponent.showChildrenInOutline, false);
                        {
                            const label = this.createLabel(comp, "Prefab Instances:");
                            label.style.gridColumn = "2 / span 2";
                            label.style.opacity = "0.5";
                            label.style.fontWeight = "bold";
                            label.style.justifySelf = "left";
                        }
                        this.createPropertyBoolean(comp, sceneobjects.ChildrenComponent.allowAppendChildren, true);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.ChildrenComponent);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.ChildrenSection = ChildrenSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class DirtyObjectManager {
                    _object;
                    _properties;
                    _values;
                    constructor(obj) {
                        this._object = obj;
                        this._properties = [];
                        this._values = [];
                    }
                    start(redrawCallback) {
                        const updateListener = () => {
                            if (this.isDirty()) {
                                redrawCallback();
                            }
                        };
                        const awakeListener = () => {
                            this._values = this._properties.map(p => p.getValue(this._object));
                            redrawCallback();
                            this._object.scene.events.on("update", updateListener);
                        };
                        this._object.scene.events.once("update", awakeListener);
                        this._object.once("destroy", () => {
                            this._object.scene.events.off("update", awakeListener);
                            this._object.scene.events.off("update", updateListener);
                        });
                    }
                    addProperties(...properties) {
                        this._properties.push(...properties);
                    }
                    addComponents(...compCtrs) {
                        for (const ctr of compCtrs) {
                            const comp = this._object.getEditorSupport().getComponent(ctr);
                            this.addProperties(...comp.getProperties());
                        }
                    }
                    getKey() {
                        const name = this._object.getEditorSupport().getExtension().getTypeName();
                        return `${name}[${this._values.map(v => JSON.stringify(v)).join(",")}]`;
                    }
                    isDirty() {
                        let dirty = false;
                        for (let i = 0; i < this._properties.length; i++) {
                            const v = this._properties[i].getValue(this._object);
                            if (v !== this._values[i]) {
                                this._values[i] = v;
                                dirty = true;
                            }
                        }
                        return dirty;
                    }
                }
                sceneobjects.DirtyObjectManager = DirtyObjectManager;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_27) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EditorSupport {
                    _object;
                    _label;
                    _displayName;
                    _useGameObjectName;
                    _scope;
                    _scene;
                    constructor(obj, label, scene) {
                        this._object = obj;
                        this._scene = scene;
                        this._label = label;
                        this._displayName = "";
                        this._useGameObjectName = false;
                        this._scope = sceneobjects.ObjectScope.LOCAL;
                        this.setId(Phaser.Utils.String.UUID());
                    }
                    static getEditorSupport(obj) {
                        if (obj["getEditorSupport"]) {
                            const support = obj["getEditorSupport"]();
                            if (support instanceof EditorSupport) {
                                return support;
                            }
                        }
                        return null;
                    }
                    computeContentHash() {
                        return "";
                    }
                    isLocalScope() {
                        return sceneobjects.isLocalScope(this._scope);
                    }
                    isMethodScope() {
                        return sceneobjects.isMethodScope(this._scope);
                    }
                    isClassScope() {
                        return sceneobjects.isClassScope(this._scope);
                    }
                    isPublicScope() {
                        return sceneobjects.isPublicScope(this._scope);
                    }
                    isNestedPrefabScope() {
                        return sceneobjects.isNestedPrefabScope(this._scope);
                    }
                    isClassOrPublicScope() {
                        return sceneobjects.isClassOrPublicScope(this._scope);
                    }
                    getObject() {
                        return this._object;
                    }
                    getLabel() {
                        return this._label;
                    }
                    setLabel(label) {
                        this._label = label;
                    }
                    getDisplayName() {
                        return this._displayName;
                    }
                    setDisplayName(displayName) {
                        this._displayName = displayName;
                    }
                    isUseGameObjectName() {
                        return this._useGameObjectName;
                    }
                    setUseGameObjectName(useGameObjectName) {
                        this._useGameObjectName = useGameObjectName;
                    }
                    getScope() {
                        return this._scope;
                    }
                    setScope(scope) {
                        this._scope = scope;
                    }
                    getScene() {
                        return this._scene;
                    }
                    setScene(scene) {
                        this._scene = scene;
                    }
                    getPropertyDefaultValue(prop) {
                        return prop.defValue;
                    }
                    isUnlockedProperty(prop) {
                        return true;
                    }
                }
                sceneobjects.EditorSupport = EditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_27.ui || (scene_27.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./EditorSupport.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_28) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var json = scene_28.core.json;
                var controls = colibri.ui.controls;
                class GameObjectEditorSupport extends sceneobjects.EditorSupport {
                    _extension;
                    _prefabId;
                    _serializables;
                    // tslint:disable-next-line:ban-types
                    _componentMap;
                    _unlockedProperties;
                    _isNestedPrefabInstance;
                    _isPrivateNestedPrefabInstance;
                    _isPrefabInstancePart;
                    // a temporal variable used for serialization
                    _private_np;
                    unlockEvent;
                    // parent
                    _allowPickChildren;
                    _showChildrenInOutline;
                    _countPrefabChildren;
                    _allowAppendChildren;
                    _objectChildren;
                    constructor(extension, obj, scene) {
                        super(obj, extension.getTypeName().toLowerCase(), scene);
                        this._extension = extension;
                        this.unlockEvent = new controls.ListenerList();
                        this._unlockedProperties = new Set();
                        this._serializables = [];
                        this._componentMap = new Map();
                        this._isNestedPrefabInstance = false;
                        this._isPrivateNestedPrefabInstance = false;
                        this._isPrefabInstancePart = false;
                        this._private_np = false;
                        this._allowPickChildren = true;
                        this._showChildrenInOutline = true;
                        this._countPrefabChildren = 0;
                        this._allowAppendChildren = false;
                        this._objectChildren = [];
                        obj.setDataEnabled();
                        this.setId(Phaser.Utils.String.UUID());
                        this.addComponent(new sceneobjects.VariableComponent(obj));
                        this.addComponent(new sceneobjects.PrefabUserPropertyComponent(obj));
                        this.addComponent(new sceneobjects.UserComponentsEditorComponent(obj));
                        this.addComponent(new sceneobjects.EffectsComponent(obj));
                        if (this.isDisplayObject()) {
                            this.addComponent(new sceneobjects.HitAreaComponent(obj), new sceneobjects.RectangleHitAreaComponent(obj), new sceneobjects.CircleHitAreaComponent(obj), new sceneobjects.EllipseHitAreaComponent(obj), new sceneobjects.PolygonHitAreaComponent(obj), new sceneobjects.PixelPerfectHitAreaComponent(obj));
                        }
                        this.setInteractive();
                        scene.addGameObject(obj);
                    }
                    static isDisplayObjectType(type) {
                        return type !== sceneobjects.ScriptNodeExtension.getInstance().getTypeName();
                    }
                    isDisplayObject() {
                        return true;
                    }
                    addObjectChild(child) {
                        const obj = this.getObject();
                        if (obj instanceof sceneobjects.Layer || obj instanceof sceneobjects.Container) {
                            obj.add(child);
                        }
                        else {
                            this._objectChildren.push(child);
                        }
                        if (child instanceof sceneobjects.ScriptNode) {
                            child.removeFromParent();
                            child.setParent(obj);
                        }
                    }
                    removeObjectChild(child) {
                        const obj = this.getObject();
                        if (obj instanceof sceneobjects.Layer || obj instanceof sceneobjects.Container) {
                            obj.remove(child);
                        }
                        else {
                            const i = this._objectChildren.indexOf(child);
                            if (i >= 0) {
                                this._objectChildren.splice(i, 1);
                            }
                        }
                        if (child instanceof sceneobjects.ScriptNode) {
                            child.setParent(undefined);
                        }
                    }
                    removeAllObjectChildren() {
                        const obj = this.getObject();
                        if (obj instanceof sceneobjects.Layer || obj instanceof sceneobjects.Container) {
                            return obj.removeAll(true);
                        }
                        else {
                            this._objectChildren = [];
                        }
                    }
                    getDisplayObjectChildren() {
                        return this.getObjectChildren()
                            .filter(obj => obj.getEditorSupport().isDisplayObject());
                    }
                    getObjectScriptNodes() {
                        return this.getObjectChildren().filter(o => o instanceof sceneobjects.ScriptNode);
                    }
                    getEditableObjectChildren() {
                        if (this.isPrefabInstance()) {
                            return this.getAppendedChildren();
                        }
                        return this.getObjectChildren();
                    }
                    getObjectChildren() {
                        const obj = this.getObject();
                        if (obj instanceof sceneobjects.Layer) {
                            return obj.getChildren();
                        }
                        if (obj instanceof sceneobjects.Container) {
                            return obj.list;
                        }
                        return this._objectChildren;
                    }
                    getObjectSiblings() {
                        const parent = this.getObjectParent();
                        if (parent) {
                            return parent.getEditorSupport().getObjectChildren();
                        }
                        return this.getScene().getGameObjects();
                    }
                    sortObjectChildren() {
                        const children = this.getObjectChildren();
                        sceneobjects.sortObjectsAlgorithm(children, this._countPrefabChildren);
                    }
                    getObjectParent() {
                        const obj = this.getObject();
                        if (obj.parentContainer) {
                            return obj.parentContainer;
                        }
                        if (obj.displayList instanceof sceneobjects.Layer) {
                            return obj.displayList;
                        }
                        return undefined;
                    }
                    computeContentHashWithProperties(obj, ...properties) {
                        return properties.map(prop => prop.name + "=" + prop.getValue(obj)).join(";");
                    }
                    computeContentHashWithComponent(obj, ...compConstructors) {
                        const props = compConstructors.flatMap(ctr => [...obj.getEditorSupport().getComponent(ctr).getProperties()]);
                        return this.computeContentHashWithProperties(obj, ...props);
                    }
                    /**
                     * Destroy the object. Return `true` if it requires a complete refresh of the scene, to re-build all objects.
                     */
                    destroy() {
                        for (const obj of this.getObjectChildren()) {
                            obj.getEditorSupport().destroy();
                        }
                        if (this.isDisplayObject()) {
                            const obj = this.getObject();
                            obj.disableInteractive();
                            obj.destroy();
                            obj.active = false;
                            obj.visible = false;
                            // hack, to remove the object from the input list
                            const list = this.getScene().input["_list"];
                            const i = list.indexOf(obj);
                            if (i > 0) {
                                list.splice(i, 1);
                            }
                        }
                        else {
                            const obj = this.getObject();
                            const parent = this.getObjectParent();
                            if (parent) {
                                parent.getEditorSupport().removeObjectChild(obj);
                            }
                            else {
                                this.getScene().removeGameObject(obj);
                            }
                        }
                        return false;
                    }
                    hasProperty(property) {
                        for (const comp of this.getActiveComponents()) {
                            if (comp.getProperties().has(property)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    hasUnlockedProperties() {
                        return this._unlockedProperties.size > 0;
                    }
                    isLockedProperty(property) {
                        return !this.isUnlockedProperty(property);
                    }
                    isUnlockedPropertyXY(property) {
                        return this.isUnlockedProperty(property.x) && this.isUnlockedProperty(property.y);
                    }
                    isUnlockedProperty(property) {
                        if (this.isPrefabInstance()) {
                            if (property instanceof sceneobjects.UserComponentPropertyWrapper) {
                                if (this.isLocalUserProperty(property)) {
                                    return true;
                                }
                            }
                            return this._unlockedProperties.has(property.name);
                        }
                        return true;
                    }
                    isLocalUserProperty(property) {
                        const userComp = property.getUserComponent();
                        const editorUserComp = this.getUserComponentsComponent();
                        if (editorUserComp.hasLocalUserComponent(userComp.getName())) {
                            return true;
                        }
                        return false;
                    }
                    setUnlockedProperty(property, unlock) {
                        if (unlock) {
                            this._unlockedProperties.add(property.name);
                        }
                        else {
                            this._unlockedProperties.delete(property.name);
                        }
                        this.unlockEvent.fire({ property, unlock });
                    }
                    setUnlockedPropertyXY(property, unlock) {
                        this.setUnlockedProperty(property.x, unlock);
                        this.setUnlockedProperty(property.y, unlock);
                    }
                    _clearUnlockProperties() {
                        this._unlockedProperties.clear();
                    }
                    static async buildPrefabDependencyHash(builder, prefabId) {
                        if (!prefabId) {
                            return;
                        }
                        const finder = scene_28.ScenePlugin.getInstance().getSceneFinder();
                        const file = finder.getPrefabFile(prefabId);
                        if (!file) {
                            return;
                        }
                        const token = "prefab(" + prefabId + "," + file.getModTime() + ")";
                        builder.addPartialToken(token);
                        const sceneData = finder.getSceneData(file);
                        if (!sceneData) {
                            return;
                        }
                        for (const objData of sceneData.displayList) {
                            this.buildPrefabDependencyHash(builder, objData.prefabId);
                        }
                    }
                    async buildDependencyHash(args) {
                        GameObjectEditorSupport.buildPrefabDependencyHash(args.builder, this._prefabId);
                        for (const comp of this.getActiveComponents()) {
                            comp.buildDependenciesHash(args);
                        }
                        if (!this.isPrefabInstance()) {
                            for (const obj of this.getObjectChildren()) {
                                obj.getEditorSupport().buildDependencyHash(args);
                            }
                        }
                    }
                    getScreenBounds(camera) {
                        const sprite = this.getObject();
                        const points = [
                            new Phaser.Math.Vector2(0, 0),
                            new Phaser.Math.Vector2(0, 0),
                            new Phaser.Math.Vector2(0, 0),
                            new Phaser.Math.Vector2(0, 0)
                        ];
                        let w = sprite.width;
                        let h = sprite.height;
                        if (sprite instanceof Phaser.GameObjects.BitmapText) {
                            // the BitmapText.width is considered a displayWidth, it is already multiplied by the scale
                            w = w / sprite.scaleX;
                            h = h / sprite.scaleY;
                        }
                        const { originX, originY } = this.computeOrigin();
                        const x = -w * originX;
                        const y = -h * originY;
                        const tx = sprite.getWorldTransformMatrix();
                        tx.transformPoint(x, y, points[0]);
                        tx.transformPoint(x + w, y, points[1]);
                        tx.transformPoint(x + w, y + h, points[2]);
                        tx.transformPoint(x, y + h, points[3]);
                        return points.map(p => camera.getScreenPoint(p.x, p.y));
                    }
                    getOriginSectionId() {
                        return sceneobjects.OriginSection.SECTION_ID;
                    }
                    getOriginProperties() {
                        if (this.hasComponent(sceneobjects.OriginComponent)) {
                            return [sceneobjects.OriginComponent.originX, sceneobjects.OriginComponent.originY];
                        }
                        return [];
                    }
                    supportsOrigin() {
                        return this.getOriginProperties().length > 0;
                    }
                    computeOrigin() {
                        const { originX, originY } = this.getObject();
                        return { originX, originY };
                    }
                    computeDisplayOrigin() {
                        const { width, height } = this.computeSize();
                        const { originX, originY } = this.computeOrigin();
                        return {
                            displayOriginX: width * originX,
                            displayOriginY: height * originY
                        };
                    }
                    computeSize() {
                        const obj = this.getObject();
                        return { width: obj.width, height: obj.height };
                    }
                    setComponentActive(ctr, active) {
                        const comp = this._componentMap.get(ctr);
                        comp.setActive(active);
                    }
                    // tslint:disable-next-line:ban-types
                    getComponent(ctr) {
                        const comp = this._componentMap.get(ctr);
                        if (comp && comp.isActive()) {
                            return comp;
                        }
                        return undefined;
                    }
                    // tslint:disable-next-line:ban-types
                    hasComponent(ctr) {
                        const comp = this._componentMap.get(ctr);
                        if (comp) {
                            return comp.isActive();
                        }
                        return false;
                    }
                    getComponents() {
                        return this._componentMap.values();
                    }
                    getActiveComponents() {
                        return [...this._componentMap.values()].filter(comp => comp.isActive());
                    }
                    getUserComponentsComponent() {
                        return this.getComponent(sceneobjects.UserComponentsEditorComponent);
                    }
                    // tslint:disable-next-line:ban-types
                    static getObjectComponent(obj, ctr) {
                        if (this.hasEditorSupport(obj)) {
                            const support = obj.getEditorSupport();
                            return support.getComponent(ctr) ?? null;
                        }
                        return null;
                    }
                    static hasEditorSupport(obj) {
                        try {
                            // tslint:disable-next-line:ban-types
                            const support = obj["getEditorSupport"];
                            return support.apply(obj) instanceof GameObjectEditorSupport;
                        }
                        catch (e) {
                            // nothing
                        }
                        return false;
                    }
                    static getEditorSupport(obj) {
                        if (this.hasEditorSupport(obj)) {
                            return obj.getEditorSupport();
                        }
                        return null;
                    }
                    // tslint:disable-next-line:ban-types
                    static hasObjectComponent(obj, ctr) {
                        return this.getObjectComponent(obj, ctr) !== null;
                    }
                    addComponent(...components) {
                        for (const c of components) {
                            this._componentMap.set(c.constructor, c);
                        }
                        this._serializables.push(...components);
                    }
                    setNewId(sprite) {
                        this.setId(Phaser.Utils.String.UUID());
                    }
                    getExtension() {
                        return this._extension;
                    }
                    getId() {
                        return this.getObject().name;
                    }
                    setId(id) {
                        this.getObject().name = id;
                    }
                    getParentId() {
                        const parent = this.getObjectParent();
                        if (parent) {
                            return parent.getEditorSupport().getId();
                        }
                        return undefined;
                    }
                    /**
                     * Checks if it is a nested prefab instance that can be modified.
                     * It means, if there is a path from a root prefab
                     * walking thought nested prefabs until reach this object.
                     *
                     * @returns If it is reachable.
                     */
                    isMutableNestedPrefabInstance() {
                        // TODO: the next line is a better implementation we should test:
                        // return this.isNestedPrefabInstance() && !this.isPrivateNestedPrefabInstance();
                        if (this.isNestedPrefabInstance()) {
                            const parent = this.getObjectParent();
                            const parentES = parent.getEditorSupport();
                            return parentES.isMutableNestedPrefabInstance()
                                || parentES.isPrefabInstanceRoot();
                        }
                        return false;
                    }
                    /**
                     * If it's first definition as prefab is a nested prefab.
                     * It means, in any case, it isn't an instance of a root prefab.
                     *
                     * @returns Is it defined as nested prefab?
                     */
                    isNestedPrefabDefined() {
                        const finder = scene_28.ScenePlugin.getInstance().getSceneFinder();
                        if (this.isPrefabInstance()) {
                            const id = finder.getOriginalPrefabId(this.getPrefabId());
                            return finder.isNestedPrefab(id);
                        }
                        return false;
                    }
                    /**
                     * Checks if the object is a prefab instance and the parent isn't a prefab instance.
                     * It is a prefab instance added to the scene, it is not part of a bigger prefab.
                     * It is the bigger prefab.
                     * But ok, it is possible it is also a child appended to a prefab instance.
                     *
                     * @returns If it is the root.
                     */
                    isPrefabInstanceRoot() {
                        if (this.isPrefabInstance() && !this.isNestedPrefabInstance()) {
                            const parent = this.getObjectParent();
                            const parentES = parent?.getEditorSupport();
                            if (!parent
                                || !parentES.isPrefabInstance()
                                || this.isPrefeabInstanceAppendedChild()) {
                                return true;
                            }
                        }
                        return false;
                    }
                    isNestedPrefabInstanceParent() {
                        for (const obj of this.getObjectChildren()) {
                            const objES = obj.getEditorSupport();
                            if (objES.isNestedPrefabInstance() || objES.isNestedPrefabInstanceParent()) {
                                return true;
                            }
                        }
                        return false;
                    }
                    isNestedPrefabInstance() {
                        return this._isNestedPrefabInstance;
                    }
                    isPrivateNestedPrefabInstance() {
                        return this._isPrivateNestedPrefabInstance;
                    }
                    isPrefabInstancePart() {
                        return this._isPrefabInstancePart;
                    }
                    isPrefabInstance() {
                        return this._prefabId !== undefined && this._prefabId !== null;
                    }
                    isPrefeabInstanceAppendedChild() {
                        const parent = this.getObjectParent();
                        if (parent && parent.getEditorSupport().isPrefabInstance()) {
                            const parentES = parent.getEditorSupport();
                            const countPrefabChildren = parentES.getCountPrefabChildren();
                            const index = parentES.getObjectChildren().indexOf(this.getObject());
                            return index >= countPrefabChildren;
                        }
                        return false;
                    }
                    /**
                     * Checks if the object is a child or nested child of prefab instance.
                     *
                     * @returns If it is element.
                     */
                    isPrefabInstanceElement() {
                        const owner = this.getOwnerPrefabInstance();
                        if (owner) {
                            return owner !== this.getObject();
                        }
                        return false;
                    }
                    getAllParents() {
                        const list = [];
                        this.getAllParents2(this.getObject(), list);
                        return list;
                    }
                    /**
                    * If this object type has a custom method for setting the size of the object.
                    *
                    * @returns Generate a custom code for setting the size properties.
                    */
                    isCustom_SizeComponent_buildSetObjectPropertiesCodeDOM() {
                        return false;
                    }
                    /**
                     * Get the size properties for this object type. By default it uses the properties from the SizeComponent.
                     *
                     * @returns The size properties.
                     */
                    getSizeProperties() {
                        if (this.hasComponent(sceneobjects.SizeComponent)) {
                            return [sceneobjects.SizeComponent.width, sceneobjects.SizeComponent.height];
                        }
                        return [];
                    }
                    /**
                     * The section ID for the size properties of this object type. By default it retures the SizeSection ID.
                     *
                     * @returns The size section id.
                     */
                    getSizeSectionId() {
                        return sceneobjects.SizeSection.SECTION_ID;
                    }
                    /**
                     * If this object type requires to update the display origin after changing the size.
                     *
                     * @returns Generate updateDisplayOrigin()?
                     */
                    getSizeComponentGeneratesUpdateDisplayOrigin() {
                        return true;
                    }
                    /**
                     * This callback method is executed when the texture of this object is changed by TextureComponent.
                     */
                    onUpdateAfterSetTexture() {
                        // nothing by default
                    }
                    isDescendentOf(parent) {
                        const set = new Set(this.getAllParents());
                        return set.has(parent);
                    }
                    getAllParents2(obj, list) {
                        const objParent = obj.getEditorSupport().getObjectParent();
                        if (objParent) {
                            list.push(objParent);
                            this.getAllParents2(objParent, list);
                        }
                        return list;
                    }
                    isScenePrefabObject() {
                        return this.getScene().isPrefabSceneType() && this.getScene().getPrefabObject() === this.getObject();
                    }
                    getMutableNestedPrefabChildren() {
                        if (this.isPrefabInstance()) {
                            const children = this.getObjectChildren();
                            const result = [];
                            for (const obj of children) {
                                const objES = obj.getEditorSupport();
                                if (objES.isMutableNestedPrefabInstance()) {
                                    result.push(obj);
                                }
                            }
                            return result;
                        }
                        return [];
                    }
                    getOwnerPrefabInstance() {
                        const parents = this.getAllParents();
                        for (const parent of parents) {
                            if (parent.getEditorSupport().isPrefabInstance()) {
                                return parent;
                            }
                        }
                        if (this.isPrefabInstance()) {
                            return this.getObject();
                        }
                        return null;
                    }
                    getPrefabId() {
                        return this._prefabId;
                    }
                    setPrefabId(id) {
                        this._prefabId = id;
                    }
                    getPrefabName() {
                        const file = this.getPrefabFile();
                        if (file) {
                            return file.getNameWithoutExtension();
                        }
                        return null;
                    }
                    /**
                     * Get the display name of the prefab. The display name of a prefab is a composition of the prefab's name and the nested prefab's name.
                     * If this is a nested prefab, then it may be instance of another prefab file, so it returns two prefab names.
                     */
                    getDisplayPrefabName() {
                        if (!this.isPrefabInstance()) {
                            return undefined;
                        }
                        if (this.isNestedPrefabDefined()) {
                            return this.getPrefabName();
                        }
                        const name1 = this.getPrefabName();
                        const finder = scene_28.ScenePlugin.getInstance().getSceneFinder();
                        const data = finder.getPrefabData(this.getPrefabId());
                        if (data && data.prefabId) {
                            const file2 = finder.getPrefabFile(data.prefabId);
                            if (file2) {
                                return `${name1}#${file2.getNameWithoutExtension()}`;
                            }
                        }
                        return name1;
                    }
                    getPrefabFile() {
                        if (this._prefabId) {
                            const finder = scene_28.ScenePlugin.getInstance().getSceneFinder();
                            const file = finder.getPrefabFile(this._prefabId);
                            return file;
                        }
                        return null;
                    }
                    getPrefabData() {
                        if (this._prefabId) {
                            const finder = scene_28.ScenePlugin.getInstance().getSceneFinder();
                            const data = finder.getPrefabData(this._prefabId);
                            return data;
                        }
                        return null;
                    }
                    getPrefabSettings() {
                        if (this._prefabId) {
                            const finder = scene_28.ScenePlugin.getInstance().getSceneFinder();
                            const file = finder.getPrefabFile(this._prefabId);
                            if (file) {
                                return finder.getSceneSettings(file);
                            }
                        }
                        return null;
                    }
                    getPrefabSerializer() {
                        const data = this.getPrefabData();
                        if (data) {
                            return this.getScene().getMaker().getSerializer(data);
                        }
                        return null;
                    }
                    getObjectType() {
                        const ser = this.getScene().getMaker().getSerializer({
                            id: this.getId(),
                            type: this._extension.getTypeName(),
                            prefabId: this._prefabId,
                            label: "temporal"
                        });
                        return ser.getType();
                    }
                    getPhaserType() {
                        const ser = this.getScene().getMaker().getSerializer({
                            id: this.getId(),
                            type: this._extension.getTypeName(),
                            prefabId: this._prefabId,
                            label: "temporal",
                        });
                        return ser.getPhaserType();
                    }
                    getSerializer(data) {
                        return this.getScene().getMaker().getSerializer(data);
                    }
                    writeJSON(data) {
                        if (this.isPrefabInstance()) {
                            data.prefabId = this._prefabId;
                        }
                        else {
                            data.type = this._extension.getTypeName();
                        }
                        data.id = this.getId();
                        data.private_np = this._private_np ? true : undefined;
                        if (this._prefabId && this._unlockedProperties.size > 0) {
                            data["unlock"] = [...this._unlockedProperties];
                        }
                        const ser = this.getSerializer(data);
                        for (const s of this._serializables) {
                            s.writeJSON(ser);
                        }
                        this.writeJSON_children(this.getObject(), data);
                    }
                    readJSON(data) {
                        const ser = this.getSerializer(data);
                        this.setId(data.id);
                        this._prefabId = data.prefabId;
                        this._unlockedProperties = new Set(data["unlock"] ?? []);
                        for (const s of this._serializables) {
                            s.readJSON(ser);
                        }
                        this.readJSON_children(this.getObject(), data);
                    }
                    // parent methods
                    getCountPrefabChildren() {
                        return this._countPrefabChildren;
                    }
                    isAllowAppendChildren() {
                        return this._allowAppendChildren;
                    }
                    setAllowAppendChildren(allowAppendChild) {
                        this._allowAppendChildren = allowAppendChild;
                    }
                    isAllowPickChildren() {
                        return this._allowPickChildren;
                    }
                    setAllowPickChildren(childrenPickable) {
                        this._allowPickChildren = childrenPickable;
                    }
                    isShowChildrenInOutline() {
                        return this._showChildrenInOutline;
                    }
                    setShowChildrenInOutline(showChildrenInOutline) {
                        this._showChildrenInOutline = showChildrenInOutline;
                    }
                    getAppendedChildren() {
                        const children = this.getObjectChildren();
                        const appended = children.slice(this._countPrefabChildren);
                        return appended;
                    }
                    writeJSON_children(container, containerData) {
                        const finder = scene_28.ScenePlugin.getInstance().getSceneFinder();
                        const containerES = container.getEditorSupport();
                        if (containerES.isPrefabInstance()) {
                            // write nested prefabs
                            containerData.nestedPrefabs = containerES.getObjectChildren()
                                .filter(obj => obj.getEditorSupport().isMutableNestedPrefabInstance())
                                .filter(obj => finder.existsPrefab(obj.getEditorSupport().getPrefabId()))
                                .map(obj => {
                                const objData = {};
                                obj.getEditorSupport().writeJSON(objData);
                                return objData;
                            })
                                .filter(data => (data.nestedPrefabs ?? []).length > 0
                                || (data.unlock ?? []).length > 0
                                || (data.components ?? []).length > 0
                                || (data.list ?? []).length > 0);
                            // write appended objects
                            containerData.list = containerES.getAppendedChildren().map(obj => {
                                const objData = {};
                                obj.getEditorSupport().writeJSON(objData);
                                return objData;
                            });
                        }
                        else {
                            containerData.list = containerES.getObjectChildren().map(obj => {
                                const objData = {};
                                obj.getEditorSupport().writeJSON(objData);
                                return objData;
                            });
                        }
                        // if the container has an empty list, remove it from the file
                        if (containerData.list && containerData.list.length === 0) {
                            delete containerData.list;
                        }
                        // if the container has an empty nestedPrefabs array, remove it from the file
                        if (containerData.nestedPrefabs && containerData.nestedPrefabs.length === 0) {
                            delete containerData.nestedPrefabs;
                        }
                    }
                    static readPrefabChildren(serializer, list) {
                        if (serializer.isPrefabInstance()) {
                            this.readPrefabChildren(serializer.getPrefabSerializer(), list);
                        }
                        const localList = serializer.getData()["list"] || [];
                        list.push(...localList);
                    }
                    static buildRawChildrenData(containerData) {
                        const serializer = new json.Serializer(containerData);
                        const isPrefabContainer = serializer.isPrefabInstance();
                        /**
                         * The orginal children of the container's prefab.
                         * It means, it doesn't include the appended children.
                         */
                        let prefabChildren = [];
                        /**
                         * All the final children to be added to the container.
                         */
                        let children;
                        /**
                         * Just the children added explicity to this container (without looking to the prefab).
                         */
                        const localChildren = containerData.list || [];
                        if (isPrefabContainer) {
                            prefabChildren = [];
                            this.readPrefabChildren(serializer.getPrefabSerializer(), prefabChildren);
                            const updatedPrefabChildren = sceneobjects.DisplayParentGameObjectEditorSupport
                                .buildUpdatedPrefabChildrenDataWithNestedPrefab(containerData, prefabChildren);
                            children = [...updatedPrefabChildren, ...localChildren];
                        }
                        else {
                            // it is not a prefab, just get the local children
                            children = localChildren;
                        }
                        return { prefabChildren, children };
                    }
                    readJSON_children(parent, containerData) {
                        const parentES = parent.getEditorSupport();
                        const { children, prefabChildren } = sceneobjects.DisplayParentGameObjectEditorSupport
                            .buildRawChildrenData(containerData);
                        parentES._countPrefabChildren = prefabChildren.length;
                        const maker = parentES.getScene().getMaker();
                        parent.getEditorSupport().removeAllObjectChildren();
                        let i = 0;
                        for (const childData of children) {
                            const serializer = maker.getSerializer(childData);
                            const type = serializer.getType();
                            const ext = scene_28.ScenePlugin.getInstance().getGameObjectExtensionByObjectType(type);
                            if (!ext) {
                                alert(`Unknown type "${type}" of game object "${childData.id}".`);
                                continue;
                            }
                            const initObjData = ext.createInitObjectDataFromChild(childData);
                            // creates an empty object
                            const sprite = maker.createObject(initObjData, undefined, parent);
                            if (sprite) {
                                parentES.addObjectChild(sprite);
                                const spriteES = sprite.getEditorSupport();
                                // if it is not an appended child
                                if (i < prefabChildren.length) {
                                    const prefabData = prefabChildren[i];
                                    const { private_np, scope } = prefabData;
                                    if (private_np || ui.sceneobjects.isNestedPrefabScope(scope)) {
                                        spriteES._isNestedPrefabInstance = true;
                                        spriteES._isPrivateNestedPrefabInstance = private_np;
                                    }
                                    this._isPrefabInstancePart = true;
                                }
                                // updates the object with the final data
                                spriteES.readJSON(childData);
                            }
                            i++;
                        }
                    }
                    /**
                     * Build the children data but modified by the nested prefab info.
                     *
                     * @param objData The container data
                     * @param originalPrefabChildren The container's prefab children
                     * @returns The children but modified by the nested prefabs
                     */
                    static buildUpdatedPrefabChildrenDataWithNestedPrefab(objData, originalPrefabChildren) {
                        const result = [];
                        const localNestedPrefabs = objData.nestedPrefabs ?? [];
                        for (const originalChild of originalPrefabChildren) {
                            const isNestedPrefab = originalChild.private_np
                                || sceneobjects.isNestedPrefabScope(originalChild.scope);
                            if (isNestedPrefab) {
                                // find a local nested prefab
                                let localNestedPrefab;
                                for (const local of localNestedPrefabs) {
                                    const localOriginalIdOfNestedPrefab = this.findOriginalIdOfNestedPrefab(local);
                                    if (localOriginalIdOfNestedPrefab === originalChild.id) {
                                        const remoteNestedPrefab = this.findRemoteNestedPrefab(objData.prefabId, originalChild.id);
                                        if (remoteNestedPrefab) {
                                            localNestedPrefab = colibri.core.json.copy(local);
                                            localNestedPrefab.prefabId = remoteNestedPrefab.id;
                                        }
                                        else {
                                            localNestedPrefab = local;
                                        }
                                        break;
                                    }
                                }
                                let createFreshObject = true;
                                let newNestedPrefabs;
                                if (localNestedPrefab) {
                                    if (sceneobjects.isPublicScope(originalChild.scope)) {
                                        // it is ok, the original child is public
                                        // add the local nested prefab as final version of the object
                                        result.push(localNestedPrefab);
                                        createFreshObject = false;
                                    }
                                    else {
                                        // the original object is not public any more,
                                        // we will create a link-object, but keeping the same nested prefabs
                                        newNestedPrefabs = localNestedPrefab.nestedPrefabs;
                                    }
                                }
                                if (createFreshObject) {
                                    // we don't have a local nested prefab,
                                    // or the original nested prefab is not public any more
                                    // so find one remote and create a pointer to it
                                    const remoteNestedPrefab = this.findRemoteNestedPrefab(objData.prefabId, originalChild.id);
                                    if (remoteNestedPrefab) {
                                        // we found a remote nested prefab, create a link to it
                                        const nestedPrefab = {
                                            id: Phaser.Utils.String.UUID(),
                                            prefabId: remoteNestedPrefab.id,
                                            label: remoteNestedPrefab.label,
                                            nestedPrefabs: newNestedPrefabs
                                        };
                                        result.push(nestedPrefab);
                                    }
                                    else {
                                        // ok, just create a link with the original child
                                        const nestedPrefab = {
                                            id: Phaser.Utils.String.UUID(),
                                            prefabId: originalChild.id,
                                            label: originalChild.label,
                                            nestedPrefabs: newNestedPrefabs
                                        };
                                        result.push(nestedPrefab);
                                    }
                                }
                            }
                            else {
                                result.push(originalChild);
                            }
                        }
                        return result;
                    }
                    static findRemoteNestedPrefab(parentPrefabId, originalNestedPrefabId) {
                        const finder = scene_28.ScenePlugin.getInstance().getSceneFinder();
                        const prefabData = finder.getPrefabData(parentPrefabId);
                        if (!prefabData) {
                            return null;
                        }
                        const nestedPrefab = (prefabData.nestedPrefabs ?? []).find(obj => {
                            // const thisOriginalId = finder.getOriginalPrefabId(obj.prefabId);
                            const thisOriginalId = this.findOriginalIdOfNestedPrefab(obj);
                            return thisOriginalId === originalNestedPrefabId;
                        });
                        if (nestedPrefab) {
                            return nestedPrefab;
                        }
                        if (prefabData.prefabId) {
                            return this.findRemoteNestedPrefab(prefabData.prefabId, originalNestedPrefabId);
                        }
                        return null;
                    }
                    static findOriginalIdOfNestedPrefab(obj) {
                        const finder = scene_28.ScenePlugin.getInstance().getSceneFinder();
                        if (obj.prefabId && finder.isNestedPrefab(obj.prefabId)) {
                            const prefabData = finder.getPrefabData(obj.prefabId);
                            return this.findOriginalIdOfNestedPrefab(prefabData);
                        }
                        return obj.id;
                    }
                }
                sceneobjects.GameObjectEditorSupport = GameObjectEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_28.ui || (scene_28.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./GameObjectEditorSupport.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class DisplayParentGameObjectEditorSupport extends sceneobjects.GameObjectEditorSupport {
                    getCellRenderer() {
                        if (this.isPrefabInstance() && !this.isNestedPrefabInstance()) {
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            const file = finder.getPrefabFile(this.getPrefabId());
                            if (file) {
                                const image = ui.SceneThumbnailCache.getInstance().getContent(file);
                                if (image) {
                                    return new controls.viewers.ImageCellRenderer(image);
                                }
                            }
                        }
                        return new controls.viewers.IconImageCellRenderer(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_GROUP));
                    }
                    setInteractive() {
                        // nothing
                    }
                }
                sceneobjects.DisplayParentGameObjectEditorSupport = DisplayParentGameObjectEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                /**
                 * This class provides the methods to build the CodeDOM of the different aspects
                 * of the code generation associated to game objects.
                 *
                 * Each object extension provides an instance of this class, that is used by the Scene compiler.
                 */
                class GameObjectCodeDOMBuilder {
                    _chainToFactory;
                    /**
                     *
                     * @param chainToFactory The code chain to reach the factory of the object.
                     * It is in the context of a scene. It is `add` by default, like in `scene.add.sprite(...)`.
                     * But it could be `physics.add`, like in `scene.physics.add.spirte(...)`.
                     */
                    constructor(chainToFactory = "add") {
                        this._chainToFactory = chainToFactory;
                    }
                    getChainToFactory() {
                        return this._chainToFactory;
                    }
                    /**
                     * Adds the X and Y arguments to the prefab's instance creation.
                     *
                     * @param args This method args.
                     */
                    buildCreatePrefabInstanceCodeDOM_XY_Arguments(args) {
                        const obj = args.obj;
                        const objES = obj.getEditorSupport();
                        const call = args.methodCallDOM;
                        if (objES.isUnlockedPropertyXY(sceneobjects.TransformComponent.position)) {
                            call.argFloat(obj.x);
                            call.argFloat(obj.y);
                        }
                        else {
                            call.arg("undefined");
                            call.arg("undefined");
                        }
                    }
                    /**
                     * Adds the Width and Height arguments to the prefab's instance creation.
                     *
                     * @param args This method args.
                     */
                    buildCreatePrefabInstanceCodeDOM_Size_Arguments(args) {
                        const obj = args.obj;
                        const call = args.methodCallDOM;
                        if (obj.getEditorSupport().isUnlockedPropertyXY(sceneobjects.SizeComponent.size)) {
                            call.argFloat(obj.width);
                            call.argFloat(obj.height);
                        }
                        else {
                            call.arg("undefined");
                            call.arg("undefined");
                        }
                    }
                    /**
                     * Adds the X and Y parameters to the `super` statement of a prefab constructor.
                     *
                     * @param args Method args
                     */
                    buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args) {
                        const obj = args.prefabObj;
                        const objES = obj.getEditorSupport();
                        const call = args.superMethodCallCodeDOM;
                        if (objES.isUnlockedPropertyXY(sceneobjects.TransformComponent.position)) {
                            call.arg(`x ?? ${sceneobjects.TransformComponent.x.getValue(obj)}`);
                            call.arg(`y ?? ${sceneobjects.TransformComponent.y.getValue(obj)}`);
                        }
                        else {
                            call.arg("x");
                            call.arg("y");
                        }
                    }
                    /**
                     * Adds the Width and Height parameters to the `super` statement of a prefab constructor.
                     *
                     * @param args Method args
                     */
                    buildPrefabConstructorDeclarationSupperCallCodeDOM_SizeParameters(args) {
                        const obj = args.prefabObj;
                        const call = args.superMethodCallCodeDOM;
                        if (obj.getEditorSupport().isUnlockedProperty(sceneobjects.SizeComponent.width)) {
                            call.arg("width ?? " + obj.width);
                            call.arg("height ?? " + obj.height);
                        }
                        else {
                            call.arg("width");
                            call.arg("height");
                        }
                    }
                }
                sceneobjects.GameObjectCodeDOMBuilder = GameObjectCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                function ArrayValueToCodeConverter(value) {
                    return `[${value.map(val => JSON.stringify(val)).join(", ")}]`;
                }
                sceneobjects.ArrayValueToCodeConverter = ArrayValueToCodeConverter;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_29) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class LoaderUpdaterExtension extends colibri.Extension {
                    static POINT_ID = "phasereditor2d.scene.ui.sceneobjects.AssetLoaderExtension";
                    constructor() {
                        super(LoaderUpdaterExtension.POINT_ID);
                    }
                }
                sceneobjects.LoaderUpdaterExtension = LoaderUpdaterExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_29.ui || (scene_29.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./LoaderUpdaterExtension.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_30) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ImageLoaderExtension extends sceneobjects.LoaderUpdaterExtension {
                    clearCache(scene) {
                        const list = scene.textures.list;
                        for (const key of scene.textures.getTextureKeys()) {
                            const texture = list[key];
                            texture.destroy();
                            delete list[key];
                        }
                    }
                    acceptAsset(asset) {
                        return asset instanceof phasereditor2d.pack.core.ImageFrameContainerAssetPackItem
                            || asset instanceof phasereditor2d.pack.core.AsepriteAssetPackItem
                            || asset instanceof phasereditor2d.pack.core.AssetPackImageFrame
                            || asset instanceof phasereditor2d.pack.core.AnimationConfigInPackItem;
                    }
                    async updateLoader(scene, asset) {
                        if (asset instanceof phasereditor2d.pack.core.AnimationConfigInPackItem) {
                            for (const animFrame of asset.getFrames()) {
                                const textureFrame = animFrame.getTextureFrame();
                                if (textureFrame) {
                                    await this.updateLoader(scene, textureFrame);
                                }
                            }
                        }
                        let framesContainer = null;
                        if (asset instanceof phasereditor2d.pack.core.ImageFrameContainerAssetPackItem
                            || asset instanceof phasereditor2d.pack.core.AsepriteAssetPackItem) {
                            framesContainer = asset;
                        }
                        else if (asset instanceof phasereditor2d.pack.core.AssetPackImageFrame) {
                            framesContainer = asset.getPackItem();
                        }
                        if (framesContainer !== null) {
                            await framesContainer.preload();
                            await framesContainer.preloadImages();
                            framesContainer.addToPhaserCache(scene.game, scene.getPackCache());
                        }
                    }
                    async updateLoaderWithObjData(scene, data) {
                        const serializer = new scene_30.core.json.Serializer(data);
                        const textureKeys = serializer.read("texture");
                        if (textureKeys) {
                            const { key, frame } = textureKeys;
                            if (key) {
                                const finder = scene.getMaker().getPackFinder();
                                const asset = finder.getAssetPackItemImage(key, frame);
                                if (asset) {
                                    if (this.acceptAsset(asset)) {
                                        await this.updateLoader(scene, asset);
                                    }
                                }
                            }
                        }
                    }
                }
                sceneobjects.ImageLoaderExtension = ImageLoaderExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_30.ui || (scene_30.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_31) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                function interactive_shape(hitArea, x, y, obj) {
                    const sprite = obj;
                    return sprite.geom.contains(x, y);
                }
                sceneobjects.interactive_shape = interactive_shape;
                function interactive_getAlpha_SharedTexture(hitArea, x, y, obj) {
                    const sprite = obj;
                    const textureManager = obj.getEditorSupport().getScene().textures;
                    if (sprite.flipX) {
                        x = 2 * sprite.width * sprite.originX - x;
                    }
                    if (sprite.flipY) {
                        y = 2 * sprite.height * sprite.originY - y;
                    }
                    const alpha = textureManager.getPixelAlpha(x, y, sprite.texture.key, sprite.frame.name);
                    return alpha > 0;
                }
                sceneobjects.interactive_getAlpha_SharedTexture = interactive_getAlpha_SharedTexture;
                function interactive_getAlpha_RenderTexture(hitArea, x, y, obj) {
                    const sprite = obj;
                    // TODO: lets fix the bound checking.
                    // const hitBounds = x >= 0 && y >= 0 && x <= sprite.width && y <= sprite.height;
                    // if (!hitBounds) {
                    //     return false;
                    // }
                    const scene = obj.getEditorSupport().getScene();
                    const renderTexture = new Phaser.GameObjects.RenderTexture(scene, 0, 0, 5, 5);
                    const scaleX = sprite.scaleX;
                    const scaleY = sprite.scaleY;
                    const originX = sprite.originX;
                    const originY = sprite.originY;
                    const angle = sprite.angle;
                    sprite.setScale(1, 1);
                    sprite.setOrigin(0, 0);
                    sprite.setAngle(0);
                    renderTexture.draw([sprite], -x, -y);
                    sprite.setScale(scaleX, scaleY);
                    sprite.setOrigin(originX, originY);
                    sprite.setAngle(angle);
                    const colorArray = [];
                    // catches an error caused by a Phaser bug.
                    try {
                        renderTexture.snapshotPixel(0, 0, (c) => {
                            colorArray[0] = c;
                        });
                    }
                    catch (e) {
                        console.log(e);
                        return x >= 0 && y >= 0 && x <= sprite.width && y <= sprite.height;
                    }
                    renderTexture.destroy();
                    const color = colorArray[0];
                    const alpha = color ? color.alpha : 0;
                    return alpha > 0;
                }
                sceneobjects.interactive_getAlpha_RenderTexture = interactive_getAlpha_RenderTexture;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_31.ui || (scene_31.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                function parseColor(color, alpha = false) {
                    const rgba = controls.Colors.parseColor(color);
                    if (alpha) {
                        return Phaser.Display.Color.GetColor32(rgba.r, rgba.g, rgba.b, rgba.a);
                    }
                    return Phaser.Display.Color.GetColor(rgba.r, rgba.g, rgba.b);
                }
                function NumberColorProperty(name, defValue, label, tooltip) {
                    return {
                        name,
                        defValue: defValue,
                        label,
                        tooltip,
                        local: false,
                        getValue: obj => {
                            const val = obj["color__" + name];
                            return val === undefined ? defValue : val;
                        },
                        setValue: (obj, value) => {
                            if (typeof (value) === "string" && value.trim() === "") {
                                value = defValue;
                            }
                            // update the real object color property
                            try {
                                const color = parseColor(value);
                                obj[name] = color;
                                // store the original value in the object
                                obj["color__" + name] = value;
                            }
                            catch (e) {
                                // possible color syntax error.
                                console.log(e);
                            }
                        }
                    };
                }
                sceneobjects.NumberColorProperty = NumberColorProperty;
                function NumberColorPropertyCodeDomAdapter2(p) {
                    const name = p.name;
                    const defValue = parseColor(p.defValue);
                    return {
                        name: name,
                        defValue,
                        label: p.label,
                        tooltip: p.tooltip,
                        local: p.local,
                        getValue: obj => {
                            const val = p.getValue(obj);
                            const color = parseColor(val);
                            return color;
                        },
                        setValue: (obj, value) => {
                            throw new Error("Unreachable code!");
                        }
                    };
                }
                sceneobjects.NumberColorPropertyCodeDomAdapter2 = NumberColorPropertyCodeDomAdapter2;
                function NumberColorPropertyCodeDomAdapter(p) {
                    const name = p.name;
                    const defValue = parseColor(p.defValue);
                    return {
                        name: name,
                        defValue,
                        label: p.label,
                        tooltip: p.tooltip,
                        local: p.local,
                        getValue: obj => {
                            const val = obj["color__" + name];
                            if (val === undefined) {
                                return defValue;
                            }
                            const color = parseColor(val);
                            console.log("parseColor", val, color);
                            return color;
                        },
                        setValue: (obj, value) => {
                            throw new Error("Unreachable code!");
                        }
                    };
                }
                sceneobjects.NumberColorPropertyCodeDomAdapter = NumberColorPropertyCodeDomAdapter;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ObjectListDocSection extends ui.editor.properties.DocsSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ObjectListSection");
                    }
                    getHelp() {
                        // tslint:disable-next-line:no-trailing-whitespace
                        const help = `An array of objects. Like in:

\`\`\`
const itemList = [collectable1,
    collectable2,
    coin1,
    coin2];
\`\`\`

`;
                        return help;
                    }
                    canEdit(obj, n) {
                        return obj === sceneobjects.ObjectList;
                    }
                }
                sceneobjects.ObjectListDocSection = ObjectListDocSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                let ObjectScope;
                (function (ObjectScope) {
                    ObjectScope["LOCAL"] = "LOCAL";
                    ObjectScope["METHOD"] = "METHOD";
                    ObjectScope["CLASS"] = "CLASS";
                    ObjectScope["PUBLIC"] = "PUBLIC";
                    ObjectScope["NESTED_PREFAB"] = "NESTED_PREFAB";
                })(ObjectScope = sceneobjects.ObjectScope || (sceneobjects.ObjectScope = {}));
                sceneobjects.OBJECT_SCOPES = [
                    ObjectScope.LOCAL,
                    ObjectScope.METHOD,
                    ObjectScope.CLASS,
                    ObjectScope.PUBLIC,
                    ObjectScope.NESTED_PREFAB
                ];
                function isNestedPrefabScope(scope) {
                    return scope === ObjectScope.NESTED_PREFAB;
                }
                sceneobjects.isNestedPrefabScope = isNestedPrefabScope;
                function isClassOrPublicScope(scope) {
                    return isClassScope(scope) || isPublicScope(scope);
                }
                sceneobjects.isClassOrPublicScope = isClassOrPublicScope;
                function isPublicScope(scope) {
                    switch (scope) {
                        case ObjectScope.PUBLIC:
                        case ObjectScope.NESTED_PREFAB:
                            return true;
                    }
                    return false;
                }
                sceneobjects.isPublicScope = isPublicScope;
                function isLocalScope(scope) {
                    return scope === ObjectScope.LOCAL;
                }
                sceneobjects.isLocalScope = isLocalScope;
                function isMethodScope(scope) {
                    return scope === ObjectScope.METHOD;
                }
                sceneobjects.isMethodScope = isMethodScope;
                function isClassScope(scope) {
                    return scope === ObjectScope.CLASS;
                }
                sceneobjects.isClassScope = isClassScope;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../editor/properties/DocsSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ObjectTypeDocSection extends ui.editor.properties.DocsSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ObjectTypeDocSection");
                    }
                    getHelp() {
                        return this.getSelectionFirstElement().getHelp();
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.SceneObjectExtension;
                    }
                }
                sceneobjects.ObjectTypeDocSection = ObjectTypeDocSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PlainObjectComponent {
                    _obj;
                    _properties;
                    constructor(obj, ...properties) {
                        this._obj = obj;
                        this._properties = properties;
                    }
                    getProperties() {
                        return this._properties;
                    }
                    getObject() {
                        return this._obj;
                    }
                }
                sceneobjects.PlainObjectComponent = PlainObjectComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class SceneObjectExtension extends colibri.Extension {
                    _typeName;
                    _typeNameAlias;
                    _phaserTypeName;
                    _phaserTypeThirdPartyLib;
                    _phaserTypeThirdPartyLibModule;
                    _iconDescriptor;
                    _category;
                    constructor(config) {
                        super(config.extensionPoint);
                        this._typeName = config.typeName;
                        this._typeNameAlias = config.typeNameAlias || [];
                        this._phaserTypeName = config.phaserTypeName;
                        this._phaserTypeThirdPartyLib = config.phaserTypeThirdPartyLib;
                        this._phaserTypeThirdPartyLibModule = config.phaserTypeThirdPartyLibModule;
                        this._category = config.category;
                        this._iconDescriptor = config.icon;
                    }
                    /**
                     * Some types like TilemapLayer are too complex to be included in a prefab instance.
                     * For now, those types should be excluded from a prefab scene.
                     */
                    isAvailableAsPrefabElement() {
                        return true;
                    }
                    /**
                     * Collect the data used to create a new, empty object. For example, a BitmapText requires
                     * a BitmapFont key to be created, so this method opens a dialog to select the font.
                     */
                    async collectExtraDataForCreateDefaultObject(editor, inReplaceTypeContext = false) {
                        return {};
                    }
                    getIcon() {
                        return this._iconDescriptor.getIcon();
                    }
                    getBlockCellRenderer() {
                        return new controls.viewers.IconImageCellRenderer(this.getIcon());
                    }
                    getCategory() {
                        return this._category;
                    }
                    getTypeName() {
                        return this._typeName;
                    }
                    getTypeNameAlias() {
                        return this._typeNameAlias;
                    }
                    getPhaserTypeName() {
                        return this._phaserTypeName;
                    }
                    getPhaserTypeThirdPartyLib() {
                        return this._phaserTypeThirdPartyLib;
                    }
                    getPhaserTypeThirdPartyLibModule() {
                        return this._phaserTypeThirdPartyLibModule;
                    }
                    isThirdPartyLib() {
                        return Boolean(this._phaserTypeThirdPartyLib);
                    }
                    getHelp() {
                        let helpKey;
                        if (this.isThirdPartyLib()) {
                            helpKey = this.getPhaserTypeThirdPartyLib() + "." + this.getPhaserTypeName();
                        }
                        else {
                            helpKey = this.getPhaserTypeName();
                        }
                        return scene.ScenePlugin.getInstance().getPhaserDocs().getDoc(helpKey);
                    }
                }
                sceneobjects.SceneObjectExtension = SceneObjectExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneObjectExtension.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SceneGameObjectExtension extends sceneobjects.SceneObjectExtension {
                    static POINT_ID = "phasereditor2d.scene.ui.SceneGameObjectExtension";
                    constructor(config) {
                        super({
                            extensionPoint: SceneGameObjectExtension.POINT_ID,
                            ...config
                        });
                    }
                    /**
                     * Adapt the data taken from a type conversion.
                     *
                     * @param serializer Serializer of the data resulted by the type-conversion.
                     * @param originalObject The original object that was converted.
                     * @param extraData Sometimes, to create the object, some extra data is needed.
                     * For example, the bitmap font of a bitmap text.
                     */
                    adaptDataAfterTypeConversion(serializer, originalObject, extraData) {
                        // nothing by default
                    }
                    createInitObjectDataFromChild(childData) {
                        return {
                            id: childData.id,
                            prefabId: childData.prefabId,
                            type: childData.type,
                            label: childData.label,
                        };
                    }
                }
                sceneobjects.SceneGameObjectExtension = SceneGameObjectExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_32) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                var json = colibri.core.json;
                class ScenePlainObjectEditorSupport extends sceneobjects.EditorSupport {
                    _id;
                    _extension;
                    _components;
                    constructor(extension, obj, scene, ...components) {
                        super(obj, extension.getTypeName().toLowerCase(), scene);
                        this._extension = extension;
                        this._components = components;
                        this.setScope(sceneobjects.ObjectScope.CLASS);
                        this._id = Phaser.Utils.String.UUID();
                    }
                    writeJSON(objData) {
                        objData.id = this._id;
                        objData.type = this._extension.getTypeName();
                        objData.label = this.getLabel();
                        colibri.core.json.write(objData, "scope", this.getScope(), sceneobjects.ObjectScope.CLASS);
                        for (const comp of this._components) {
                            for (const prop of comp.getProperties()) {
                                const value = prop.getValue(this.getObject());
                                json.write(objData, prop.name, value, prop.defValue);
                            }
                        }
                    }
                    readJSON(objData) {
                        this._id = objData.id || Phaser.Utils.String.UUID();
                        this.setScope(colibri.core.json.read(objData, "scope", sceneobjects.ObjectScope.CLASS));
                        this.setLabel(objData.label);
                        for (const comp of this._components) {
                            for (const prop of comp.getProperties()) {
                                const value = json.read(objData, prop.name, prop.defValue);
                                prop.setValue(this.getObject(), value);
                            }
                        }
                    }
                    getExtension() {
                        return this._extension;
                    }
                    getCellRenderer() {
                        return new controls.viewers.IconImageCellRenderer(this._extension.getIcon());
                    }
                    getId() {
                        return this._id;
                    }
                    setId(id) {
                        this._id = id;
                    }
                    getPhaserType() {
                        return this._extension.getPhaserTypeName();
                    }
                    static hasEditorSupport(obj) {
                        if (typeof obj.getEditorSupport === "function") {
                            return obj.getEditorSupport() instanceof ScenePlainObjectEditorSupport;
                        }
                        return false;
                    }
                }
                sceneobjects.ScenePlainObjectEditorSupport = ScenePlainObjectEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_32.ui || (scene_32.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ScenePlainObjectExtension extends sceneobjects.SceneObjectExtension {
                    static POINT_ID = "phasereditor2d.scene.ui.sceneobjects.ScenePlainObjectExtension";
                    constructor(config) {
                        super({
                            extensionPoint: ScenePlainObjectExtension.POINT_ID,
                            ...config
                        });
                    }
                }
                sceneobjects.ScenePlainObjectExtension = ScenePlainObjectExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ScenePlainObjectVariableSection extends ui.editor.properties.BaseSceneSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ScenePlainObjectVariableSection", "Variable", false);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        {
                            // Name
                            this.createLabel(comp, "Name");
                            const text = this.createText(comp);
                            text.addEventListener("change", e => {
                                this.performChange(objects => {
                                    const obj = objects[0];
                                    obj.getEditorSupport().setLabel(text.value);
                                });
                            });
                            this.addUpdater(() => {
                                text.readOnly = this.getSelection().length !== 1;
                                text.value = this.flatValues_StringJoinDifferent(this.getSelection().map(obj => obj.getEditorSupport().getLabel()));
                            });
                        }
                        {
                            // Type
                            this.createLabel(comp, "Type");
                            const text = this.createText(comp, true);
                            this.addUpdater(() => {
                                text.value = this.flatValues_StringJoinDifferent(this.getSelection().map(obj => obj.getEditorSupport().getExtension().getTypeName()));
                            });
                        }
                        {
                            // Scope
                            this.createLabel(comp, "Scope", "The lexical scope of the object.");
                            const items = [
                                {
                                    name: "LOCAL",
                                    value: sceneobjects.ObjectScope.LOCAL
                                },
                                {
                                    name: "METHOD",
                                    value: sceneobjects.ObjectScope.METHOD
                                }, {
                                    name: "CLASS",
                                    value: sceneobjects.ObjectScope.CLASS
                                }, {
                                    name: "PUBLIC",
                                    value: sceneobjects.ObjectScope.PUBLIC
                                }
                            ];
                            const btn = this.createMenuButton(comp, "", () => items, scope => {
                                this.performChange(objects => {
                                    for (const obj of objects) {
                                        const objES = obj.getEditorSupport();
                                        objES.setScope(scope);
                                    }
                                });
                            });
                            this.addUpdater(() => {
                                btn.textContent = this.flatValues_StringJoinDifferent(this.getSelection().map(obj => {
                                    const scope = obj.getEditorSupport().getScope();
                                    return items.find(i => i.value === scope).name;
                                }));
                            });
                        }
                    }
                    performChange(performChange) {
                        this.getUndoManager().add(new ui.editor.undo.SceneSnapshotOperation(this.getEditor(), async () => {
                            performChange(this.getSelection());
                        }));
                    }
                    canEdit(obj, n) {
                        return sceneobjects.ScenePlainObjectEditorSupport.hasEditorSupport(obj);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.ScenePlainObjectVariableSection = ScenePlainObjectVariableSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                function SimpleEnumProperty(nameConfig, defValue, enumValues, enumLabels, label, tooltip, local = false, afterSetValue, valueToCodeConverter) {
                    let codeName;
                    let name;
                    if (typeof nameConfig === "object") {
                        codeName = nameConfig.codeName;
                        name = nameConfig.name;
                    }
                    else {
                        name = nameConfig;
                    }
                    return {
                        name,
                        codeName,
                        defValue,
                        label,
                        tooltip: tooltip,
                        local,
                        valueToCodeConverter,
                        getValue: obj => obj[name],
                        setValue: (obj, value) => {
                            obj[name] = value;
                            if (afterSetValue) {
                                afterSetValue(obj);
                            }
                        },
                        values: enumValues,
                        getEnumValues: (object) => enumValues,
                        getValueLabel: (value) => {
                            if (Array.isArray(value)) {
                                const enumValues2 = enumValues.map(val => JSON.stringify(val));
                                const value2 = JSON.stringify(value);
                                return enumLabels[enumValues2.indexOf(value2)];
                            }
                            return enumLabels[enumValues.indexOf(value)];
                        }
                    };
                }
                sceneobjects.SimpleEnumProperty = SimpleEnumProperty;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                function SimpleProperty(nameConfig, defValue, label, tooltip, local = false, afterSetValue, increment, incrementMin, incrementMax) {
                    let codeName;
                    let name;
                    if (typeof nameConfig === "object") {
                        codeName = nameConfig.codeName;
                        name = nameConfig.name;
                    }
                    else {
                        name = nameConfig;
                    }
                    return {
                        name,
                        codeName,
                        defValue,
                        label,
                        tooltip: tooltip,
                        local,
                        increment,
                        incrementMin,
                        incrementMax,
                        getValue: obj => obj[name],
                        setValue: (obj, value) => {
                            obj[name] = value;
                            if (afterSetValue) {
                                afterSetValue(obj);
                            }
                        }
                    };
                }
                sceneobjects.SimpleProperty = SimpleProperty;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SizeComponent extends sceneobjects.Component {
                    static FLAG_DISABLE_GENERATE_UPDATE_DISPALY_ORIGIN = "updateDispyOrigin";
                    // static width = SimpleProperty("width", 0, "Width", "The object's width.", false, updateDisplayOrigin);
                    // static height = SimpleProperty("height", 0, "Height", "The object's height.", false, updateDisplayOrigin);
                    static width = {
                        name: "width",
                        defValue: 0,
                        label: "W",
                        tooltip: "The object's width.",
                        local: false,
                        getValue: obj => obj.width,
                        setValue: (obj, value) => {
                            obj.setSize(value, obj.height);
                            obj.updateDisplayOrigin();
                        }
                    };
                    static height = {
                        name: "height",
                        label: "H",
                        defValue: 0,
                        tooltip: "The object's height.",
                        local: false,
                        getValue: obj => obj.height,
                        setValue: (obj, value) => {
                            obj.setSize(obj.width, value);
                            obj.updateDisplayOrigin();
                        }
                    };
                    static size = {
                        label: "Size",
                        x: SizeComponent.width,
                        y: SizeComponent.height
                    };
                    constructor(obj) {
                        super(obj, [SizeComponent.width, SizeComponent.height]);
                    }
                    buildSetObjectPropertiesCodeDOM(args, checkCustom = true) {
                        const obj = this.getObject();
                        const objES = obj.getEditorSupport();
                        if (checkCustom && objES.isCustom_SizeComponent_buildSetObjectPropertiesCodeDOM()) {
                            return;
                        }
                        const prop = SizeComponent.size;
                        if (objES.isNestedPrefabInstance()
                            && objES.isUnlockedPropertyXY(prop)) {
                            const dom = new scene.core.code.MethodCallCodeDOM("setSize", args.objectVarName);
                            dom.argFloat(prop.x.getValue(obj));
                            dom.argFloat(prop.y.getValue(obj));
                            args.statements.push(dom);
                            if (objES.getSizeComponentGeneratesUpdateDisplayOrigin()) {
                                args.statements.push(new scene.core.code.MethodCallCodeDOM("updateDisplayOrigin", args.objectVarName));
                            }
                        }
                    }
                }
                sceneobjects.SizeComponent = SizeComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./object/properties/SceneGameObjectSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SizeSection extends sceneobjects.SceneGameObjectSection {
                    static SECTION_ID = "phasereditor2d.scene.ui.sceneobjects.SizeSection";
                    constructor(page) {
                        super(page, SizeSection.SECTION_ID, "Size", false, true);
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createPropertyXYRow(comp, sceneobjects.SizeComponent.size);
                    }
                    canEdit(obj, n) {
                        if (sceneobjects.isGameObject(obj)) {
                            const support = obj.getEditorSupport();
                            return support.hasComponent(sceneobjects.SizeComponent);
                        }
                        return false;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.SizeSection = SizeSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TextContentComponent extends sceneobjects.Component {
                    static text = sceneobjects.SimpleProperty("text", "", "Text", "The text content.");
                    constructor(obj) {
                        super(obj, [TextContentComponent.text]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_StringProperty(args, TextContentComponent.text);
                    }
                }
                sceneobjects.TextContentComponent = TextContentComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./object/properties/SceneGameObjectSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TextContentSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor.scene.ui.sceneobjects.TextContentSection", "Text Content", false, false);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/text-property.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr";
                        this.createLock(comp, sceneobjects.TextContentComponent.text);
                        this.createLabel(comp, sceneobjects.TextContentComponent.text.label, scene.PhaserHelp(sceneobjects.TextContentComponent.text.tooltip));
                        this.createStringField(comp, sceneobjects.TextContentComponent.text, true, false, true);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.TextContentComponent);
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.TextContentSection = TextContentSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_33) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                function getSceneDisplayName(file) {
                    const finder = scene_33.ScenePlugin.getInstance().getSceneFinder();
                    const settings = finder.getSceneSettings(file);
                    if (settings && settings.displayName && settings.displayName.trim() !== "") {
                        return settings.displayName;
                    }
                    return file.getNameWithoutExtension();
                }
                sceneobjects.getSceneDisplayName = getSceneDisplayName;
                function findObjectDisplayFormat(obj) {
                    const objES = obj.getEditorSupport();
                    const finder = scene_33.ScenePlugin.getInstance().getSceneFinder();
                    if (objES.isPrefabInstance()) {
                        let hierarchy = finder.getPrefabHierarchy(objES.getPrefabId());
                        for (const prefabFile of hierarchy) {
                            const { prefabObjDisplayFmt } = finder.getSceneSettings(prefabFile);
                            if (prefabObjDisplayFmt !== undefined && prefabObjDisplayFmt.trim().length > 0) {
                                return prefabObjDisplayFmt;
                            }
                        }
                    }
                    return undefined;
                }
                sceneobjects.findObjectDisplayFormat = findObjectDisplayFormat;
                function getNestedPrefabDisplayName(prefabId) {
                    const finder = scene_33.ScenePlugin.getInstance().getSceneFinder();
                    const data = finder.getPrefabData(prefabId);
                    if (data) {
                        if (data.displayName) {
                            return data.displayName;
                        }
                        if (finder.isNestedPrefab(data.prefabId)) {
                            return getNestedPrefabDisplayName(data.prefabId);
                        }
                    }
                    return undefined;
                }
                function formatObjectDisplayText(obj) {
                    const objES = obj.getEditorSupport();
                    if (objES.getDisplayName()) {
                        return objES.getDisplayName();
                    }
                    if (objES.isNestedPrefabInstance()) {
                        const displayName = getNestedPrefabDisplayName(objES.getPrefabId());
                        if (displayName) {
                            return displayName;
                        }
                    }
                    const displayFormat = findObjectDisplayFormat(obj);
                    if (displayFormat) {
                        let prefix = getTargetActionDisplayNamePrefix(objES, obj);
                        return prefix + applyFormat(obj, displayFormat);
                    }
                    return objES.getLabel();
                }
                sceneobjects.formatObjectDisplayText = formatObjectDisplayText;
                function getTargetActionDisplayNamePrefix(objES, obj) {
                    let prefix = "";
                    const targetActionComp = objES.getUserComponentsComponent()
                        .getUserComponentNodes()
                        .find(n => n.getComponentName() === "ActionTargetComp");
                    if (targetActionComp) {
                        const props = targetActionComp.getUserComponent()
                            .getUserProperties();
                        const targetProp = props.findPropertyByName("target");
                        const targetNameProp = props.findPropertyByName("targetName");
                        let value = "";
                        if (targetProp) {
                            const target = targetProp.getComponentProperty().getValue(obj);
                            if (target) {
                                value = target;
                            }
                        }
                        if (targetNameProp) {
                            const name = targetNameProp.getComponentProperty().getValue(obj);
                            if (name) {
                                value += " " + name;
                            }
                        }
                        if (value) {
                            prefix = value + " → ";
                        }
                    }
                    return prefix;
                }
                function applyFormat(obj, displayFormat) {
                    const objES = obj.getEditorSupport();
                    const data = {
                        label: objES.getLabel()
                    };
                    // from prefabs
                    {
                        const comp = objES.getComponent(sceneobjects.PrefabUserPropertyComponent);
                        const props = comp.getProperties();
                        for (const prop of props) {
                            data[prop.name] = prop.getValue(obj);
                        }
                    }
                    // from user components
                    let componentsSuffix = "";
                    {
                        const components = objES.getUserComponentsComponent();
                        const props = components.getProperties();
                        for (const prop of props) {
                            data[prop.codeName] = prop.getValue(obj);
                        }
                        for (const node of components.getUserComponentNodes()) {
                            const comp = node.getUserComponent();
                            const format = comp.getObjectDisplayFormat();
                            if (format) {
                                const compData = {};
                                for (const userProp of comp.getUserProperties().getProperties()) {
                                    const prop = userProp.getComponentProperty();
                                    const value = prop.getValue(obj);
                                    compData[prop.codeName] = value;
                                }
                                componentsSuffix += ", " + formatString(format, compData);
                            }
                        }
                    }
                    const output = formatString(displayFormat, data) + componentsSuffix;
                    return output;
                }
                function formatString(displayFormat, data) {
                    let output = displayFormat.replace(/\${(.*?)}/g, (match, p1) => {
                        const variableValue = data[p1.trim()];
                        return variableValue !== undefined ? variableValue : match;
                    });
                    output = output.replace(/\#{(.*?)}/g, (match, p1) => {
                        const k = p1.trim();
                        const variableValue = data[k];
                        return Boolean(variableValue) ? `"${k}"` : "";
                    });
                    output = output.replace(/ +/g, " ").trim();
                    return output;
                }
                function sortGameObjects(objects) {
                    const sorted = new Set();
                    for (const obj of objects) {
                        const objES = obj.getEditorSupport();
                        const scene = objES.getScene();
                        const parent = objES.getObjectParent();
                        if (parent && !sorted.has(parent)) {
                            parent.getEditorSupport().sortObjectChildren();
                            sorted.add(parent);
                        }
                        else if (!sorted.has(scene)) {
                            scene.sortGameObjects();
                            sorted.add(scene);
                        }
                    }
                }
                sceneobjects.sortGameObjects = sortGameObjects;
                function sortObjectsAlgorithm(children, countPrefabChildren) {
                    const start = countPrefabChildren;
                    const len = children.length;
                    for (let i = start; i < len - 1; i++) {
                        for (let j = i + 1; j < len; j++) {
                            const a = children[i];
                            const b = children[j];
                            if (gameObjectSortingWeight(b) < gameObjectSortingWeight(a)) {
                                children[i] = b;
                                children[j] = a;
                            }
                        }
                    }
                }
                sceneobjects.sortObjectsAlgorithm = sortObjectsAlgorithm;
                function gameObjectSortingWeight(obj) {
                    if (obj instanceof sceneobjects.ScriptNode) {
                        return 1;
                    }
                    return 0;
                }
                sceneobjects.gameObjectSortingWeight = gameObjectSortingWeight;
                function isNestedPrefabInstance(obj) {
                    const support = sceneobjects.GameObjectEditorSupport.getEditorSupport(obj);
                    if (support) {
                        return support.isNestedPrefabInstance();
                    }
                    return false;
                }
                sceneobjects.isNestedPrefabInstance = isNestedPrefabInstance;
                function isGameObject(obj) {
                    return sceneobjects.GameObjectEditorSupport.hasEditorSupport(obj);
                }
                sceneobjects.isGameObject = isGameObject;
                function isPlainObject(obj) {
                    return sceneobjects.ScenePlainObjectEditorSupport.hasEditorSupport(obj);
                }
                sceneobjects.isPlainObject = isPlainObject;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_33.ui || (scene_33.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_34) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BitmapFontLoaderUpdater extends sceneobjects.LoaderUpdaterExtension {
                    clearCache(scene) {
                        const fontCache = scene.cache.bitmapFont;
                        const keys = fontCache.getKeys();
                        for (const key of keys) {
                            fontCache.remove(key);
                        }
                    }
                    acceptAsset(asset) {
                        return asset instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem;
                    }
                    async updateLoader(scene, asset) {
                        const font = asset;
                        await font.preload();
                        await font.preloadImages();
                        font.addToPhaserCache(scene.game, scene.getPackCache());
                    }
                    async updateLoaderWithObjData(scene, data) {
                        const serializer = new scene_34.core.json.Serializer(data);
                        const type = serializer.getType();
                        if (type === sceneobjects.BitmapTextExtension.getInstance().getTypeName()) {
                            const font = serializer.read("font");
                            if (font) {
                                const finder = scene.getMaker().getPackFinder();
                                const asset = finder.findAssetPackItem(font);
                                if (asset && asset instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem) {
                                    await this.updateLoader(scene, asset);
                                }
                            }
                        }
                    }
                }
                sceneobjects.BitmapFontLoaderUpdater = BitmapFontLoaderUpdater;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_34.ui || (scene_34.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_35) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BitmapText extends Phaser.GameObjects.BitmapText {
                    _editorSupport;
                    static getFont(scene, font) {
                        let entry = scene.sys.cache.bitmapFont.get(font);
                        if (!entry) {
                            font = "__missing__";
                            entry = scene.sys.cache.bitmapFont.get(font);
                            if (!entry) {
                                const data = {
                                    chars: {},
                                    font,
                                    lineHeight: 10,
                                    retroFont: false,
                                    size: 10
                                };
                                entry = { data };
                                scene.sys.cache.bitmapFont.add(font, entry);
                            }
                        }
                        return font;
                    }
                    constructor(scene, x, y, font, text) {
                        super(scene, x, y, BitmapText.getFont(scene, font), "New BitmapText");
                        this._editorSupport = new sceneobjects.BitmapTextEditorSupport(this, scene);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.BitmapText = BitmapText;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_35.ui || (scene_35.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class BitmapTextCodeDOMBuilder extends sceneobjects.GameObjectCodeDOMBuilder {
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const call = new code.MethodCallCodeDOM("bitmapText", args.gameObjectFactoryExpr);
                        const obj = args.obj;
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        call.argLiteral(obj.font);
                        call.argLiteral(obj.text);
                        return call;
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const call = args.methodCallDOM;
                        const obj = args.obj;
                        const support = args.obj.getEditorSupport();
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        if (support.isUnlockedProperty(sceneobjects.BitmapTextComponent.font)) {
                            call.argLiteral(obj.font);
                        }
                        else {
                            call.arg("undefined");
                        }
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                        ctr.arg("font", "string", true);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        const obj = args.prefabObj;
                        const support = obj.getEditorSupport();
                        const call = args.superMethodCallCodeDOM;
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        if (support.isLockedProperty(sceneobjects.BitmapTextComponent.font)) {
                            call.arg("font");
                        }
                        else {
                            call.arg("font ?? " + code.CodeDOM.quote(obj.font));
                        }
                    }
                }
                sceneobjects.BitmapTextCodeDOMBuilder = BitmapTextCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BitmapTextComponent extends sceneobjects.Component {
                    static font = {
                        name: "font",
                        label: "Font",
                        tooltip: "phaser:Phaser.GameObjects.BitmapText.setFont",
                        defValue: undefined,
                        getValue: obj => obj.font,
                        setValue: (obj, value) => obj.setFont(value)
                    };
                    static align = {
                        name: "align",
                        label: "Align",
                        tooltip: "phaser:Phaser.GameObjects.BitmapText.align",
                        defValue: Phaser.GameObjects.BitmapText.ALIGN_LEFT,
                        getValue: obj => obj.align,
                        setValue: (obj, value) => obj.align = value,
                        getValueLabel: value => {
                            return {
                                [Phaser.GameObjects.BitmapText.ALIGN_LEFT]: "LEFT",
                                [Phaser.GameObjects.BitmapText.ALIGN_CENTER]: "CENTER",
                                [Phaser.GameObjects.BitmapText.ALIGN_RIGHT]: "RIGHT"
                            }[value];
                        },
                        values: [
                            Phaser.GameObjects.BitmapText.ALIGN_LEFT,
                            Phaser.GameObjects.BitmapText.ALIGN_CENTER,
                            Phaser.GameObjects.BitmapText.ALIGN_RIGHT
                        ]
                    };
                    static fontSize = {
                        name: "fontSize",
                        label: "Font Size",
                        tooltip: "phaser:Phaser.GameObjects.BitmapText.setFontSize",
                        defValue: 0,
                        increment: 1,
                        incrementMin: 1,
                        getValue: obj => obj.fontSize,
                        setValue: (obj, value) => obj.setFontSize(value)
                    };
                    static letterSpacing = {
                        name: "letterSpacing",
                        label: "Letter Spacing",
                        tooltip: "phaser:Phaser.GameObjects.BitmapText.setLetterSpacing",
                        defValue: 0,
                        increment: 1,
                        incrementMin: 1,
                        getValue: obj => obj.letterSpacing,
                        setValue: (obj, value) => obj.setLetterSpacing(value)
                    };
                    static maxWidth = {
                        name: "maxWidth",
                        label: "Max Width",
                        tooltip: "phaser:Phaser.GameObjects.BitmapText.maxWidth",
                        defValue: 0,
                        increment: 1,
                        incrementMin: 0,
                        getValue: obj => obj.maxWidth,
                        setValue: (obj, value) => obj.setMaxWidth(value)
                    };
                    static dropShadowX = sceneobjects.SimpleProperty("dropShadowX", 0, "Drop Shadow X", "phaser:Phaser.GameObjects.BitmapText.dropShadowX", false, null, 1, 0);
                    static dropShadowY = sceneobjects.SimpleProperty("dropShadowY", 0, "Drop Shadow Y", "phaser:Phaser.GameObjects.BitmapText.dropShadowY", false, null, 1, 0);
                    static dropShadowAlpha = sceneobjects.SimpleProperty("dropShadowAlpha", 0.5, "Drop Shadow Alpha", "phaser:Phaser.GameObjects.BitmapText.dropShadowAlpha", false, null, 0.05, 0);
                    static dropShadowColor = sceneobjects.NumberColorProperty("dropShadowColor", "#000000", "Drop Shadow Color", "phaser:Phaser.GameObjects.BitmapText.dropShadowColor");
                    constructor(obj) {
                        super(obj, [
                            BitmapTextComponent.font,
                            BitmapTextComponent.align,
                            BitmapTextComponent.fontSize,
                            BitmapTextComponent.letterSpacing,
                            BitmapTextComponent.maxWidth,
                            BitmapTextComponent.dropShadowX,
                            BitmapTextComponent.dropShadowY,
                            BitmapTextComponent.dropShadowAlpha,
                            BitmapTextComponent.dropShadowColor
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const support = this.getObject().getEditorSupport();
                        if (support.isUnlockedProperty(BitmapTextComponent.font) && support.isNestedPrefabInstance()) {
                            const dom = new scene.core.code.MethodCallCodeDOM("setFont", args.objectVarName);
                            dom.argLiteral(this.getObject().font);
                            args.statements.push(dom);
                        }
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, BitmapTextComponent.fontSize, BitmapTextComponent.align, BitmapTextComponent.letterSpacing, BitmapTextComponent.maxWidth, BitmapTextComponent.dropShadowX, BitmapTextComponent.dropShadowY, BitmapTextComponent.dropShadowAlpha, sceneobjects.NumberColorPropertyCodeDomAdapter2(BitmapTextComponent.dropShadowColor));
                    }
                }
                sceneobjects.BitmapTextComponent = BitmapTextComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_36) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BitmapTextEditorSupport extends sceneobjects.GameObjectEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.BitmapTextExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.TransformComponent(obj), new sceneobjects.OriginComponent(obj), new sceneobjects.VisibleComponent(obj), new sceneobjects.AlphaComponent(obj), new sceneobjects.TintComponent(obj), new sceneobjects.TextContentComponent(obj), new sceneobjects.ArcadeComponent(obj, false), new sceneobjects.BitmapTextComponent(obj));
                    }
                    computeContentHash() {
                        const obj = this.getObject();
                        return this.computeContentHashWithComponent(obj, sceneobjects.TintComponent, sceneobjects.TextContentComponent, sceneobjects.BitmapTextComponent);
                    }
                    getCellRenderer() {
                        return new sceneobjects.ObjectCellRenderer();
                    }
                    setInteractive() {
                        this.getObject().setInteractive(sceneobjects.interactive_getAlpha_RenderTexture);
                    }
                    getPropertyDefaultValue(prop) {
                        if (prop === sceneobjects.OriginComponent.originX || prop === sceneobjects.OriginComponent.originY) {
                            return 0;
                        }
                        return super.getPropertyDefaultValue(prop);
                    }
                }
                sceneobjects.BitmapTextEditorSupport = BitmapTextEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_36.ui || (scene_36.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BitmapTextExtension extends sceneobjects.SceneGameObjectExtension {
                    static _instance = new BitmapTextExtension();
                    static getInstance() {
                        return this._instance;
                    }
                    constructor() {
                        super({
                            phaserTypeName: "Phaser.GameObjects.BitmapText",
                            typeName: "BitmapText",
                            category: scene.SCENE_OBJECT_TEXT_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_BITMAP_FONT_TYPE)
                        });
                    }
                    acceptsDropData(data) {
                        return data instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem;
                    }
                    createSceneObjectWithAsset(args) {
                        const font = args.asset;
                        return new sceneobjects.BitmapText(args.scene, args.x, args.y, font.getKey(), "New BitmapText");
                    }
                    adaptDataAfterTypeConversion(serializer, originalObject, extraData) {
                        const bitmapFont = extraData;
                        if (bitmapFont && bitmapFont instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem) {
                            let size = 64;
                            const newData = serializer.getData();
                            if ("height" in originalObject) {
                                size = originalObject["height"];
                            }
                            if (typeof originalObject["text"] !== "string") {
                                newData["text"] = "New Bitmap Text";
                            }
                            newData["fontSize"] = size;
                            newData["font"] = bitmapFont.getKey();
                        }
                    }
                    async collectExtraDataForCreateDefaultObject(editor) {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        const dlg = new phasereditor2d.pack.ui.dialogs.AssetSelectionDialog();
                        dlg.create();
                        dlg.getViewer().setInput(finder.getPacks()
                            .flatMap(pack => pack.getItems())
                            .filter(item => item instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem));
                        dlg.getViewer().setCellSize(128, true);
                        dlg.setTitle("Select Bitmap Font");
                        const promise = new Promise((resolver, reject) => {
                            dlg.setSelectionCallback(async (sel) => {
                                const item = sel[0];
                                await item.preload();
                                await item.preloadImages();
                                const result = {
                                    data: item
                                };
                                resolver(result);
                            });
                            dlg.setCancelCallback(() => {
                                const result = {
                                    abort: true
                                };
                                resolver(result);
                            });
                        });
                        return promise;
                    }
                    createDefaultSceneObject(args) {
                        const fontAsset = args.extraData;
                        fontAsset.addToPhaserCache(args.scene.game, args.scene.getPackCache());
                        return [new sceneobjects.BitmapText(args.scene, args.x, args.y, fontAsset.getKey(), "New BitmapText")];
                    }
                    createGameObjectWithData(args) {
                        const serializer = new scene.core.json.Serializer(args.data);
                        const font = serializer.read(sceneobjects.BitmapTextComponent.font.name);
                        const obj = new sceneobjects.BitmapText(args.scene, 0, 0, font, "");
                        obj.getEditorSupport().readJSON(args.data);
                        return obj;
                    }
                    async getAssetsFromObjectData(args) {
                        let result = [];
                        const font = args.serializer.read(sceneobjects.BitmapTextComponent.font.name);
                        const asset = args.finder.findAssetPackItem(font);
                        if (asset instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem) {
                            result = [asset];
                        }
                        // Maybe it contains FX objects depending on textures
                        const childrenAssets = await sceneobjects.ContainerExtension.getAssetsFromNestedData(args);
                        return [...result, ...childrenAssets];
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.BitmapTextCodeDOMBuilder();
                    }
                }
                sceneobjects.BitmapTextExtension = BitmapTextExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BitmapTextSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor.scene.ui.sceneobjects.BitmapTextSection", "Bitmap Text");
                    }
                    getSectionHelpPath() {
                        return "scene-editor/bitmap-text-object.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr";
                        {
                            // font
                            this.createLock(comp, sceneobjects.BitmapTextComponent.font);
                            this.createLabel(comp, sceneobjects.BitmapTextComponent.font.label, scene.PhaserHelp(sceneobjects.BitmapTextComponent.font.tooltip));
                            const btn = this.createButton(comp, "", async () => {
                                const input = this.getEditor().getPackFinder().getPacks()
                                    .flatMap(pack => pack.getItems())
                                    .filter(item => item instanceof phasereditor2d.pack.core.BitmapFontAssetPackItem);
                                const dlg = new phasereditor2d.pack.ui.dialogs.AssetSelectionDialog();
                                dlg.create();
                                dlg.setTitle("Select Bitmap Font");
                                dlg.getViewer().setCellSize(128, true);
                                dlg.getViewer().setInput(input);
                                dlg.getViewer().repaint();
                                dlg.setSelectionCallback(async (sel) => {
                                    const item = sel[0];
                                    await item.preload();
                                    await item.preloadImages();
                                    item.addToPhaserCache(this.getEditor().getGame(), this.getEditor().getScene().getPackCache());
                                    this.getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), sceneobjects.BitmapTextComponent.font, item.getKey()));
                                });
                            });
                            this.addUpdater(() => {
                                if (this.getSelection().length !== 1) {
                                    btn.textContent = this.getSelection().length + " selected";
                                }
                                else {
                                    btn.textContent = this.getSelectionFirstElement().font;
                                }
                            });
                        }
                        this.createPropertyFloatRow(comp, sceneobjects.BitmapTextComponent.fontSize);
                        this.createPropertyEnumRow(comp, sceneobjects.BitmapTextComponent.align);
                        this.createPropertyFloatRow(comp, sceneobjects.BitmapTextComponent.letterSpacing);
                        this.createPropertyFloatRow(comp, sceneobjects.BitmapTextComponent.maxWidth);
                        this.createPropertyFloatRow(comp, sceneobjects.BitmapTextComponent.dropShadowX);
                        this.createPropertyFloatRow(comp, sceneobjects.BitmapTextComponent.dropShadowY);
                        this.createPropertyFloatRow(comp, sceneobjects.BitmapTextComponent.dropShadowAlpha);
                        this.createPropertyColorRow(comp, sceneobjects.BitmapTextComponent.dropShadowColor);
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.BitmapText;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.BitmapTextSection = BitmapTextSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../editor/undo/SceneSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_37) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BreakParentOperation extends ui.editor.undo.SceneSnapshotOperation {
                    async performModification() {
                        const editor = this.getEditor();
                        const scene = editor.getScene();
                        const selectedObjects = editor.getSelectedGameObjects();
                        const sel = BreakParentOperation.breakParent(scene, selectedObjects);
                        this.getEditor().setSelection(sel);
                    }
                    static breakParent(scene, selectedObjects) {
                        const sel = [];
                        for (const obj of selectedObjects) {
                            const parent = obj;
                            const children = [...parent.getEditorSupport().getObjectChildren()];
                            for (const childObj of children) {
                                const pos = new Phaser.Math.Vector2(0, 0);
                                let childAsSprite;
                                if (childObj.getEditorSupport().hasComponent(sceneobjects.TransformComponent)) {
                                    childAsSprite = childObj;
                                    childAsSprite.getWorldTransformMatrix().transformPoint(0, 0, pos);
                                }
                                sel.push(childObj);
                                parent.getEditorSupport().removeObjectChild(childObj);
                                scene.removeGameObject(childObj);
                                childObj.displayList = null;
                                if (parent.parentContainer) {
                                    parent.parentContainer.getWorldTransformMatrix().applyInverse(pos.x, pos.y, pos);
                                    parent.parentContainer.getEditorSupport().addObjectChild(childObj);
                                }
                                else {
                                    if (parent.displayList instanceof sceneobjects.Layer) {
                                        parent.displayList.getEditorSupport().addObjectChild(childObj);
                                    }
                                    else {
                                        const i = scene.getGameObjectIndex(parent);
                                        scene.addGameObjectAt(childObj, i, true);
                                    }
                                }
                                if (childAsSprite) {
                                    childAsSprite.x = pos.x;
                                    childAsSprite.y = pos.y;
                                }
                            }
                            parent.getEditorSupport().destroy();
                        }
                        return sel;
                    }
                }
                sceneobjects.BreakParentOperation = BreakParentOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_37.ui || (scene_37.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_38) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Container extends Phaser.GameObjects.Container {
                    _editorSupport;
                    constructor(scene, x, y, children) {
                        super(scene, x, y, children);
                        this._editorSupport = new sceneobjects.ContainerEditorSupport(this, scene);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.Container = Container;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_38.ui || (scene_38.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class ContainerCodeDOMBuilder extends sceneobjects.GameObjectCodeDOMBuilder {
                    static _instance = new ContainerCodeDOMBuilder();
                    static getInstance() {
                        return this._instance;
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("container", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        return call;
                    }
                }
                sceneobjects.ContainerCodeDOMBuilder = ContainerCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../DisplayParentGameObjectEditorSupport.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_39) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ContainerEditorSupport extends sceneobjects.DisplayParentGameObjectEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.ContainerExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.TransformComponent(obj), new sceneobjects.VisibleComponent(obj), new sceneobjects.AlphaSingleComponent(obj), new sceneobjects.ChildrenComponent(obj), new sceneobjects.ArcadeComponent(obj, false));
                    }
                    computeSize() {
                        const obj = this.getObject();
                        const b = obj.getBounds();
                        return {
                            width: b.width / obj.scaleX,
                            height: b.height / obj.scaleY
                        };
                    }
                    computeOrigin() {
                        const obj = this.getObject();
                        const bounds = obj.getBounds();
                        let { x, y } = obj;
                        if (obj.parentContainer) {
                            const p = obj.parentContainer
                                .getBoundsTransformMatrix()
                                .transformPoint(obj.x, obj.y);
                            x = p.x;
                            y = p.y;
                        }
                        const originX = (x - bounds.x) / bounds.width;
                        const originY = (y - bounds.y) / bounds.height;
                        return { originX, originY };
                    }
                    getScreenBounds(camera) {
                        const container = this.getObject();
                        const children = this.getDisplayObjectChildren();
                        if (children.length === 0) {
                            return [];
                        }
                        const minPoint = new Phaser.Math.Vector2(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
                        const maxPoint = new Phaser.Math.Vector2(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
                        const points = [];
                        for (const obj of children) {
                            const bounds = obj.getEditorSupport().getScreenBounds(camera);
                            points.push(...bounds);
                        }
                        const worldPoint = new Phaser.Math.Vector2(0, 0);
                        container.getWorldTransformMatrix().transformPoint(0, 0, worldPoint);
                        const p = camera.getScreenPoint(worldPoint.x, worldPoint.y);
                        points.push(p);
                        for (const point of points) {
                            minPoint.x = Math.min(minPoint.x, point.x);
                            minPoint.y = Math.min(minPoint.y, point.y);
                            maxPoint.x = Math.max(maxPoint.x, point.x);
                            maxPoint.y = Math.max(maxPoint.y, point.y);
                        }
                        return [
                            new Phaser.Math.Vector2(minPoint.x, minPoint.y),
                            new Phaser.Math.Vector2(maxPoint.x, minPoint.y),
                            new Phaser.Math.Vector2(maxPoint.x, maxPoint.y),
                            new Phaser.Math.Vector2(minPoint.x, maxPoint.y)
                        ];
                    }
                    trim() {
                        const container = this.getObject();
                        if (container.length === 0) {
                            return;
                        }
                        let minX = Number.MAX_SAFE_INTEGER;
                        let minY = Number.MAX_SAFE_INTEGER;
                        for (const child of container.list) {
                            const sprite = child;
                            minX = Math.min(sprite.x, minX);
                            minY = Math.min(sprite.y, minY);
                        }
                        for (const child of container.list) {
                            const sprite = child;
                            sprite.x -= minX;
                            sprite.y -= minY;
                        }
                        const p = new Phaser.Math.Vector2(0, 0);
                        container.getWorldTransformMatrix().transformPoint(minX, minY, p);
                        if (container.parentContainer) {
                            container.parentContainer.getWorldTransformMatrix().applyInverse(p.x, p.y, p);
                        }
                        container.x = p.x;
                        container.y = p.y;
                    }
                }
                sceneobjects.ContainerEditorSupport = ContainerEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_39.ui || (scene_39.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_40) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ContainerExtension extends sceneobjects.SceneGameObjectExtension {
                    static _instance;
                    static getInstance() {
                        return this._instance || (this._instance = new ContainerExtension());
                    }
                    constructor() {
                        super({
                            typeName: "Container",
                            phaserTypeName: "Phaser.GameObjects.Container",
                            category: scene_40.SCENE_OBJECT_GROUPING_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_GROUP)
                        });
                    }
                    getCodeDOMBuilder() {
                        return sceneobjects.ContainerCodeDOMBuilder.getInstance();
                    }
                    static async getAssetsFromNestedData(args) {
                        const list = [];
                        const { children } = sceneobjects.GameObjectEditorSupport.buildRawChildrenData(args.serializer.getData());
                        for (const objData of children) {
                            const ser = args.serializer.getSerializer(objData);
                            const type = ser.getType();
                            const ext = scene_40.ScenePlugin.getInstance().getGameObjectExtensionByObjectType(type);
                            if (ext) {
                                const list2 = await ext.getAssetsFromObjectData({
                                    serializer: ser,
                                    scene: args.scene,
                                    finder: args.finder
                                });
                                list.push(...list2);
                            }
                        }
                        return list;
                    }
                    async getAssetsFromObjectData(args) {
                        return ContainerExtension.getAssetsFromNestedData(args);
                    }
                    createDefaultSceneObject(args) {
                        return [this.createContainerObject(args.scene, 0, 0, [])];
                    }
                    createGameObjectWithData(args) {
                        const container = this.createContainerObject(args.scene, 0, 0, []);
                        container.getEditorSupport().readJSON(args.data);
                        return container;
                    }
                    createContainerObject(scene, x, y, list) {
                        const container = new sceneobjects.Container(scene, x, y, list);
                        container.getEditorSupport().setScene(scene);
                        scene.addGameObject(container);
                        return container;
                    }
                    createContainerObjectWithChildren(scene, objectList) {
                        const container = this.createContainerObject(scene, 0, 0, objectList);
                        const name = scene.makeNewName("container");
                        container.getEditorSupport().setLabel(name);
                        return container;
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        return null;
                    }
                }
                sceneobjects.ContainerExtension = ContainerExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_40.ui || (scene_40.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../editor/undo/SceneSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_41) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class CreateContainerWithObjectsOperation extends ui.editor.undo.SceneSnapshotOperation {
                    async performModification() {
                        const scene = this.getScene();
                        const [container] = sceneobjects.ContainerExtension.getInstance().createDefaultSceneObject({
                            scene,
                            x: 0,
                            y: 0
                        });
                        container.getEditorSupport().setLabel(this.getScene().makeNewName("container"));
                        const list = [...this._editor.getSelectedGameObjects()];
                        scene.sortObjectsByRenderingOrder(list);
                        let newParent;
                        for (const obj of list) {
                            const objParent = obj.getEditorSupport().getObjectParent();
                            if (objParent && (objParent instanceof sceneobjects.Layer || objParent instanceof sceneobjects.Container)) {
                                if (newParent) {
                                    if (newParent.getEditorSupport().isDescendentOf(objParent)) {
                                        newParent = objParent;
                                    }
                                }
                                else {
                                    newParent = objParent;
                                }
                            }
                        }
                        if (newParent) {
                            scene.removeGameObject(container);
                            const newParentES = newParent.getEditorSupport();
                            newParentES.addObjectChild(container);
                            newParentES.sortObjectChildren();
                        }
                        else {
                            scene.sortGameObjects();
                        }
                        for (const obj of list) {
                            const sprite = obj;
                            const worldPoint = new Phaser.Math.Vector2(0, 0);
                            sprite.getWorldTransformMatrix().transformPoint(0, 0, worldPoint);
                            const objParent = obj.getEditorSupport().getObjectParent();
                            if (objParent) {
                                objParent.getEditorSupport().removeObjectChild(sprite);
                            }
                            container.getEditorSupport().addObjectChild(sprite);
                            const localPoint = new Phaser.Math.Vector2(0, 0);
                            container.getWorldTransformMatrix().applyInverse(worldPoint.x, worldPoint.y, localPoint);
                            sprite.x = localPoint.x;
                            sprite.y = localPoint.y;
                        }
                        container.getEditorSupport().trim();
                        this.getEditor().setSelection([container]);
                    }
                }
                sceneobjects.CreateContainerWithObjectsOperation = CreateContainerWithObjectsOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_41.ui || (scene_41.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TrimContainerOperation extends ui.editor.undo.SceneSnapshotOperation {
                    async performModification() {
                        for (const obj of this._editor.getSelectedGameObjects()) {
                            const container = obj;
                            container.getEditorSupport().trim();
                        }
                        this.getEditor().dispatchSelectionChanged();
                    }
                }
                sceneobjects.TrimContainerOperation = TrimContainerOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class EffectsComponent extends sceneobjects.Component {
                    static padding = {
                        name: "padding",
                        label: "Padding",
                        tooltip: scene.PhaserHelp("Phaser.GameObjects.Components.FX.padding"),
                        defValue: 0,
                        increment: 1,
                        incrementMin: 0,
                        getValue: (obj) => {
                            if (obj.preFX) {
                                return obj.preFX.padding;
                            }
                            return 0;
                        },
                        setValue: (obj, value) => {
                            if (obj.preFX) {
                                obj.preFX.padding = value;
                            }
                        }
                    };
                    constructor(obj) {
                        super(obj, [
                            EffectsComponent.padding
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM([EffectsComponent.padding], args2 => {
                            const dom = new code.AssignPropertyCodeDOM(args2.fieldCodeName, args.objectVarName + ".preFX");
                            dom.setOptionalContext(true);
                            dom.valueFloat(args2.value);
                            args.statements.push(dom);
                        });
                    }
                }
                sceneobjects.EffectsComponent = EffectsComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_42) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FXObject extends Phaser.GameObjects.GameObject {
                    _parent;
                    _phaserFX;
                    _preFX;
                    constructor(scene, type, parent, preFX) {
                        super(scene, type);
                        this._parent = parent;
                        this._preFX = preFX;
                    }
                    removeFX() {
                        const pipeline = this.getPipeline();
                        pipeline.remove(this._phaserFX);
                        this._phaserFX = undefined;
                    }
                    getPhaserFX() {
                        return this._phaserFX;
                    }
                    getPipeline() {
                        const obj = this._parent;
                        return this._preFX ? obj.preFX : obj.postFX;
                    }
                    isPreFX() {
                        return this._preFX;
                    }
                    setPreFX(preFX) {
                        this._preFX = preFX;
                    }
                    getParent() {
                        return this._parent;
                    }
                    setParent(parent) {
                        this._parent = parent;
                    }
                    getParentDisplayObject() {
                        return this._parent;
                    }
                    removeFromParent() {
                        this._parent.getEditorSupport().removeObjectChild(this);
                        this._parent = undefined;
                    }
                    willRender(camera) {
                        return false;
                    }
                }
                sceneobjects.FXObject = FXObject;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_42.ui || (scene_42.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class FXObjectCodeDOMBuilder extends sceneobjects.GameObjectCodeDOMBuilder {
                    _fxName;
                    constructor(fxName) {
                        super();
                        this._fxName = fxName;
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const pipeline = obj.isPreFX() ? "preFX" : "postFX";
                        const varname = `${args.parentVarName}.${pipeline}`;
                        const call = new code.MethodCallCodeDOM("add" + this._fxName, varname);
                        call.setOptionalContext(true);
                        const fx = obj.getPhaserFX();
                        this.buildAddFXMethodArgs(call, fx, args);
                        return call;
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        throw new Error("FX prefab not supported.");
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        throw new Error("FX prefab not supported.");
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        throw new Error("FX prefab not supported.");
                    }
                }
                sceneobjects.FXObjectCodeDOMBuilder = FXObjectCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_43) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class FXObjectEditorSupport extends sceneobjects.GameObjectEditorSupport {
                    _cellRenderer;
                    constructor(extension, obj, scene) {
                        super(extension, obj, scene);
                    }
                    static syncEffectsOrder(obj) {
                        const sprite = obj;
                        const objES = obj.getEditorSupport();
                        const data = {};
                        objES.writeJSON(data);
                        objES.readJSON(data);
                        // const preFXs = objES.getObjectChildren()
                        //     .filter(obj => obj instanceof FXObject && obj.isPreFX())
                        //     .map((obj: FXObject) => obj.getPhaserFX());
                        // const postFXs = objES.getObjectChildren()
                        //     .filter(obj => obj instanceof FXObject && !obj.isPreFX())
                        //     .map((obj: FXObject) => obj.getPhaserFX());
                        // if (sprite.preFX) {
                        //     sprite.preFX.clear();
                        //     for (const fx of preFXs) {
                        //         sprite.preFX.add(fx);
                        //     }
                        // }
                        // sprite.postFX.clear();
                        // for (const fx of postFXs) {
                        //     sprite.postFX.add(fx);
                        // }
                    }
                    destroy() {
                        const obj = this.getObject();
                        obj.removeFX();
                        obj.removeFromParent();
                        super.destroy();
                    }
                    isDisplayObject() {
                        return false;
                    }
                    setInteractive() {
                        // nothing
                    }
                    getCellRenderer() {
                        if (!this._cellRenderer) {
                            this._cellRenderer = new controls.viewers.IconImageCellRenderer(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_FX));
                        }
                        return this._cellRenderer;
                    }
                    getObjectParent() {
                        const parent = this.getObject().getParent();
                        return parent;
                    }
                    writeJSON(data) {
                        super.writeJSON(data);
                        data.preFX = this.getObject().isPreFX() || undefined;
                    }
                }
                sceneobjects.FXObjectEditorSupport = FXObjectEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_43.ui || (scene_43.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_44) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FXObjectExtension extends sceneobjects.SceneGameObjectExtension {
                    static allowGameObject(obj) {
                        if (!obj.getEditorSupport().isDisplayObject()
                            || obj instanceof sceneobjects.SpineObject) {
                            return false;
                        }
                        return true;
                    }
                    static isDefaultPipelinePreFX(parent) {
                        return parent instanceof Phaser.GameObjects.Sprite
                            || parent instanceof Phaser.GameObjects.Image
                            || parent instanceof Phaser.GameObjects.Text
                            || parent instanceof Phaser.GameObjects.TileSprite
                            || parent instanceof Phaser.GameObjects.RenderTexture
                            || parent instanceof Phaser.GameObjects.Video;
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        // not supported
                        return null;
                    }
                    async getAssetsFromObjectData(args) {
                        return [];
                    }
                    createInitObjectDataFromChild(childData) {
                        const data = super.createInitObjectDataFromChild(childData);
                        data.preFX = childData.preFX;
                        return data;
                    }
                    getFXObjectFactories() {
                        return [];
                    }
                }
                sceneobjects.FXObjectExtension = FXObjectExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_44.ui || (scene_44.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FXObjectSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.FXObjectSection", "FX", false, true);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        this.createLabel(comp, "Change Pipeline", "Change the FX to a different pipeline.");
                        const btn = this.createMenuButton(comp, "", () => [
                            {
                                name: "Pre FX",
                                value: "preFX"
                            },
                            {
                                name: "Post FX",
                                value: "postFX"
                            }
                        ], value => {
                            const op = new ui.editor.undo.SceneSnapshotOperation(this.getEditor(), async () => {
                                const ids = this.getSelection()
                                    .map(obj => obj.getEditorSupport().getId());
                                const isPreFX = value === "preFX";
                                const syncObjects = new Set();
                                for (const obj of this.getSelection()) {
                                    obj.setPreFX(isPreFX);
                                    syncObjects.add(obj.getParent());
                                }
                                for (const obj of syncObjects) {
                                    this.recreateEffects(obj);
                                }
                                this.getEditor().getSelectionManager().setSelectionByIds(ids);
                            });
                            this.getEditor().getUndoManager().add(op);
                        });
                        this.addUpdater(() => {
                            const preFX = this.flatValues_BooleanAnd(this.getSelection().map(obj => obj.isPreFX()));
                            btn.textContent = preFX ? "Pre FX" : "Post FX";
                        });
                    }
                    recreateEffects(obj) {
                        const objES = obj.getEditorSupport();
                        const data = {};
                        objES.writeJSON(data);
                        const img = obj;
                        if (img.preFX) {
                            img.preFX.clear();
                        }
                        if (img.postFX) {
                            img.postFX.clear();
                        }
                        objES.readJSON(data);
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.FXObject;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.FXObjectSection = FXObjectSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                function FXProperty(prop) {
                    return {
                        ...prop,
                        getValue: obj => {
                            return prop.getValue(obj.getPhaserFX());
                        },
                        setValue: (obj, value) => {
                            prop.setValue(obj.getPhaserFX(), value);
                        },
                    };
                }
                sceneobjects.FXProperty = FXProperty;
                ;
                function FXEnumProperty(prop) {
                    return {
                        name: prop.name,
                        defValue: prop.defValue,
                        label: prop.label,
                        tooltip: prop.tooltip,
                        local: prop.local,
                        codeName: prop.codeName,
                        valueToCodeConverter: prop.valueToCodeConverter,
                        getValue: obj => {
                            return prop.getValue(obj.getPhaserFX());
                        },
                        setValue: (obj, value) => {
                            prop.setValue(obj.getPhaserFX(), value);
                        },
                        values: prop.values,
                        getEnumValues: object => prop.getEnumValues(object.getPhaserFX()),
                        getValueLabel: value => prop.getValueLabel(value)
                    };
                }
                sceneobjects.FXEnumProperty = FXEnumProperty;
                ;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ShadersSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ShadersSection", "FX Shaders", false, true);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 3);
                        this.createNumberProperty(comp, sceneobjects.EffectsComponent.padding);
                        const items = () => {
                            return scene.ScenePlugin.getInstance().getFXExtensions().map(e => ({
                                name: e.getTypeName(),
                                value: e,
                                icon: e.getIcon()
                            }));
                        };
                        {
                            const btn = this.createButton(comp, "Add", () => {
                                const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.EffectsSection");
                                viewer.setLabelProvider(new controls.viewers.LabelProvider((obj) => {
                                    return obj instanceof sceneobjects.FXObjectExtension ? obj.getTypeName() : obj.extension.getTypeName() + " - " + obj.factoryName;
                                }));
                                viewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider(e => new controls.viewers.IconImageCellRenderer(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_FX))));
                                viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                                const input = scene.ScenePlugin.getInstance()
                                    .getFXExtensions()
                                    .flatMap(e => {
                                    const factories = e.getFXObjectFactories();
                                    if (factories.length === 0) {
                                        return [e];
                                    }
                                    return factories;
                                });
                                viewer.setInput(input);
                                const dlg = new controls.dialogs.ViewerDialog(viewer, false);
                                dlg.create();
                                dlg.setTitle("Shader Effects");
                                dlg.enableButtonOnlyWhenOneElementIsSelected(dlg.addOpenButton("Add", (sel) => {
                                    this.getEditor()
                                        .getDropManager()
                                        .addFXObjects(sel[0]);
                                }));
                                dlg.addCancelButton();
                            });
                            btn.style.gridColumn = "1 / span 3";
                        }
                    }
                    canEdit(obj, n) {
                        return sceneobjects.isGameObject(obj) && sceneobjects.FXObjectExtension.allowGameObject(obj);
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.ShadersSection = ShadersSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../FXObject.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_45) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FXGlow extends sceneobjects.FXObject {
                    _editorSupport;
                    constructor(scene, parent, preFX) {
                        super(scene, sceneobjects.FXGlowExtension.getInstance().getTypeName(), parent, preFX);
                        const pipeline = this.getPipeline();
                        this._phaserFX = pipeline.addGlow();
                        this._editorSupport = new sceneobjects.FXGlowEditorSupport(this, scene);
                    }
                    getPhaserFX() {
                        return super.getPhaserFX();
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.FXGlow = FXGlow;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_45.ui || (scene_45.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FXGlowCodeDOMBuilder extends sceneobjects.FXObjectCodeDOMBuilder {
                    constructor() {
                        super("Glow");
                    }
                    buildAddFXMethodArgs(call, fx) {
                        call.argFloat(fx.color);
                        call.argFloat(fx.outerStrength);
                        call.argFloat(fx.innerStrength);
                        call.argBool(fx.knockout);
                    }
                }
                sceneobjects.FXGlowCodeDOMBuilder = FXGlowCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../FXProperty.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FXGlowComponent extends sceneobjects.Component {
                    static color = sceneobjects.FXProperty(sceneobjects.NumberColorProperty("color", "#ffffff", "Color", "phaser:Phaser.FX.Glow.color"));
                    static outerStrength = sceneobjects.FXProperty(sceneobjects.SimpleProperty("outerStrength", 4, "Outer Strength", "phaser:Phaser.FX.Glow.outerStrength", false, undefined, 1, 0));
                    static innerStrength = sceneobjects.FXProperty(sceneobjects.SimpleProperty("innerStrength", 0, "Inner Strength", "phaser:Phaser.FX.Glow.innerStrength", false, undefined, 1, 0));
                    static knockout = sceneobjects.FXProperty(sceneobjects.SimpleProperty("knockout", false, "Knockout", "phaser:Phaser.FX.Glow.knockout"));
                    constructor(obj) {
                        super(obj, [
                            FXGlowComponent.color,
                            FXGlowComponent.outerStrength,
                            FXGlowComponent.innerStrength,
                            FXGlowComponent.knockout
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const obj = this.getObject();
                        const objES = obj.getEditorSupport();
                        if (objES.isNestedPrefabInstance()) {
                            sceneobjects.NumberColorPropertyCodeDomAdapter;
                            this.buildSetObjectPropertyCodeDOM_FloatProperty(args, sceneobjects.NumberColorPropertyCodeDomAdapter2(FXGlowComponent.color), FXGlowComponent.outerStrength, FXGlowComponent.innerStrength);
                            this.buildSetObjectPropertyCodeDOM_BooleanProperty(args, FXGlowComponent.knockout);
                        }
                    }
                }
                sceneobjects.FXGlowComponent = FXGlowComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../FXObjectEditorSupport.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_46) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FXGlowEditorSupport extends sceneobjects.FXObjectEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.FXGlowExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.FXGlowComponent(obj));
                    }
                }
                sceneobjects.FXGlowEditorSupport = FXGlowEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_46.ui || (scene_46.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../FXObjectExtension.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_47) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FXGlowExtension extends sceneobjects.FXObjectExtension {
                    static _instance = new FXGlowExtension();
                    static getInstance() {
                        return this._instance;
                    }
                    constructor() {
                        super({
                            typeName: "Glow",
                            phaserTypeName: "Phaser.FX.Glow",
                            category: scene_47.SCENE_OBJECT_FX_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_FX)
                        });
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.FXGlowCodeDOMBuilder();
                    }
                    createFXObject(scene, parent, preFX) {
                        const obj = new sceneobjects.FXGlow(scene, parent, preFX);
                        scene.removeGameObject(obj);
                        return obj;
                    }
                    createGameObjectWithData(args) {
                        const data = args.data;
                        const obj = new sceneobjects.FXGlow(args.scene, args.parent, data.preFX ?? false);
                        args.scene.removeGameObject(obj);
                        obj.getEditorSupport().readJSON(args.data);
                        return obj;
                    }
                    createDefaultSceneObject(args) {
                        throw new Error("Method not supported.");
                    }
                }
                sceneobjects.FXGlowExtension = FXGlowExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_47.ui || (scene_47.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FXGlowSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.FXGlowSection", "Glow", false, false);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 3);
                        this.createPropertyColorRow(comp, sceneobjects.FXGlowComponent.color, false);
                        this.createNumberProperty(comp, sceneobjects.FXGlowComponent.outerStrength);
                        this.createNumberProperty(comp, sceneobjects.FXGlowComponent.innerStrength);
                        this.createPropertyBoolean(comp, sceneobjects.FXGlowComponent.knockout);
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.FXGlow;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.FXGlowSection = FXGlowSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../FXObject.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_48) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FXShadow extends sceneobjects.FXObject {
                    _editorSupport;
                    constructor(scene, parent, preFX) {
                        super(scene, sceneobjects.FXShadowExtension.getInstance().getTypeName(), parent, preFX);
                        const pipeline = this.getPipeline();
                        this._phaserFX = pipeline.addShadow();
                        this._editorSupport = new sceneobjects.FXShadowEditorSupport(this, scene);
                    }
                    getPhaserFX() {
                        return super.getPhaserFX();
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.FXShadow = FXShadow;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_48.ui || (scene_48.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FXShadowCodeDOMBuilder extends sceneobjects.FXObjectCodeDOMBuilder {
                    constructor() {
                        super("Shadow");
                    }
                    buildAddFXMethodArgs(call, fx) {
                        call.argFloat(fx.x);
                        call.argFloat(fx.y);
                        call.argFloat(fx.decay);
                        call.argFloat(fx.power);
                        call.argFloat(fx.color);
                        call.argFloat(fx.samples);
                        call.argFloat(fx.intensity);
                    }
                }
                sceneobjects.FXShadowCodeDOMBuilder = FXShadowCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../FXProperty.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FXShadowComponent extends sceneobjects.Component {
                    static x = sceneobjects.FXProperty(sceneobjects.SimpleProperty("x", 0, "X", "phaser:Phaser.FX.Shadow.x", false, undefined, 0.25));
                    static y = sceneobjects.FXProperty(sceneobjects.SimpleProperty("y", 0, "Y", "phaser:Phaser.FX.Shadow.y", false, undefined, 0.25));
                    static decay = sceneobjects.FXProperty(sceneobjects.SimpleProperty("decay", 0.1, "Decay", "phaser:Phaser.FX.Shadow.decay", false, undefined, 0.01));
                    static power = sceneobjects.FXProperty(sceneobjects.SimpleProperty("power", 1, "Power", "phaser:Phaser.FX.Shadow.power", false, undefined, 0.01, 0));
                    static color = sceneobjects.FXProperty(sceneobjects.NumberColorProperty("color", "#000000", "Color", "phaser:Phaser.FX.Shadow.color"));
                    static samples = sceneobjects.FXProperty(sceneobjects.SimpleProperty("samples", 6, "Samples", "phaser:Phaser.FX.Shadow.samples", false, undefined, 1, 0));
                    static intensity = sceneobjects.FXProperty(sceneobjects.SimpleProperty("intensity", 1, "Intensity", "phaser:Phaser.FX.Shadow.intensity", false, undefined, 0.01, 0));
                    constructor(obj) {
                        super(obj, [
                            FXShadowComponent.x,
                            FXShadowComponent.y,
                            FXShadowComponent.decay,
                            FXShadowComponent.power,
                            FXShadowComponent.color,
                            FXShadowComponent.samples,
                            FXShadowComponent.intensity
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const obj = this.getObject();
                        const objES = obj.getEditorSupport();
                        if (objES.isNestedPrefabInstance()) {
                            this.buildSetObjectPropertyCodeDOM_FloatProperty(args, FXShadowComponent.x, FXShadowComponent.y, FXShadowComponent.decay, FXShadowComponent.power, sceneobjects.NumberColorPropertyCodeDomAdapter2(FXShadowComponent.color), FXShadowComponent.samples, FXShadowComponent.intensity);
                        }
                    }
                }
                sceneobjects.FXShadowComponent = FXShadowComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_49) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FXShadowEditorSupport extends sceneobjects.FXObjectEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.FXShadowExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.FXShadowComponent(obj));
                    }
                }
                sceneobjects.FXShadowEditorSupport = FXShadowEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_49.ui || (scene_49.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../FXObjectExtension.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_50) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FXShadowExtension extends sceneobjects.FXObjectExtension {
                    static _instance = new FXShadowExtension();
                    static getInstance() {
                        return this._instance;
                    }
                    constructor() {
                        super({
                            typeName: "Shadow",
                            phaserTypeName: "Phaser.FX.Shadow",
                            category: scene_50.SCENE_OBJECT_FX_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_FX)
                        });
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.FXShadowCodeDOMBuilder();
                    }
                    createFXObject(scene, parent, preFX) {
                        const obj = new sceneobjects.FXShadow(scene, parent, preFX);
                        scene.removeGameObject(obj);
                        return obj;
                    }
                    createGameObjectWithData(args) {
                        const data = args.data;
                        const obj = new sceneobjects.FXShadow(args.scene, args.parent, data.preFX ?? false);
                        args.scene.removeGameObject(obj);
                        obj.getEditorSupport().readJSON(args.data);
                        return obj;
                    }
                    createDefaultSceneObject(args) {
                        throw new Error("Method not supported.");
                    }
                }
                sceneobjects.FXShadowExtension = FXShadowExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_50.ui || (scene_50.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FXShadowSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.FXShadowSection", "Shadow", false, false);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 3);
                        this.createNumberProperty(comp, sceneobjects.FXShadowComponent.x);
                        this.createNumberProperty(comp, sceneobjects.FXShadowComponent.y);
                        this.createNumberProperty(comp, sceneobjects.FXShadowComponent.decay);
                        this.createNumberProperty(comp, sceneobjects.FXShadowComponent.power);
                        this.createPropertyColorRow(comp, sceneobjects.FXShadowComponent.color, false);
                        this.createNumberProperty(comp, sceneobjects.FXShadowComponent.samples);
                        this.createNumberProperty(comp, sceneobjects.FXShadowComponent.intensity);
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.FXShadow;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.FXShadowSection = FXShadowSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BaseHitAreaComponent extends sceneobjects.Component {
                    _shape;
                    constructor(obj, shape, properties) {
                        super(obj, properties);
                        this._shape = shape;
                    }
                    initUnlockListener() {
                        const objES = this.getEditorSupport();
                        const unlockEvent = objES.unlockEvent;
                        unlockEvent.addListener(args => {
                            if (args.property.name === sceneobjects.HitAreaComponent.hitAreaShape.name) {
                                for (const prop of this.getProperties()) {
                                    objES.setUnlockedProperty(prop, args.unlock);
                                }
                            }
                        });
                    }
                    readJSON(ser) {
                        this.initUnlockListener();
                        super.readJSON(ser);
                    }
                    writeJSON(ser) {
                        // only writes this component data if its shape is selected
                        const shape = sceneobjects.HitAreaComponent.hitAreaShape.getValue(this.getObject());
                        if (shape === this._shape) {
                            super.writeJSON(ser);
                        }
                    }
                    setDefaultValues() {
                        const obj = this.getObject();
                        const objES = this.getEditorSupport();
                        let width = 0, height = 0;
                        let x = 0, y = 0;
                        let [widthProp, heightProp] = objES.getSizeProperties();
                        if (widthProp && heightProp) {
                            width = widthProp.getValue(obj);
                            height = heightProp.getValue(obj);
                        }
                        else if (obj instanceof sceneobjects.Container) {
                            const c = obj;
                            const b = c.getBounds();
                            width = b.width;
                            height = b.height;
                            const origin = c.getEditorSupport().computeDisplayOrigin();
                            x = -origin.displayOriginX;
                            y = -origin.displayOriginY;
                        }
                        else if (obj.width && obj.height) {
                            width = obj.width;
                            height = obj.height;
                        }
                        this._setDefaultValues(x, y, width, height);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const obj = this.getObject();
                        const objES = obj.getEditorSupport();
                        if (objES.getComponent(sceneobjects.HitAreaComponent)) {
                            if (objES.isUnlockedProperty(sceneobjects.HitAreaComponent.hitAreaShape)) {
                                if (sceneobjects.HitAreaComponent.hitAreaShape.getValue(obj) === this._shape) {
                                    const code = new scene.core.code.MethodCallCodeDOM("setInteractive", args.objectVarName);
                                    this.buildSetInteractiveCodeCOM(args, obj, code);
                                    args.statements.push(code);
                                }
                            }
                        }
                    }
                }
                sceneobjects.BaseHitAreaComponent = BaseHitAreaComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BaseHitAreaToolItem extends ui.editor.tools.SceneToolItem {
                    _shape;
                    constructor(shape) {
                        super();
                        this._shape = shape;
                    }
                    isValidFor(objects) {
                        if (sceneobjects.EditHitAreaTool.isValidFor(...objects)) {
                            for (const obj of objects) {
                                if (sceneobjects.HitAreaComponent.getShape(obj) === this._shape) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                }
                sceneobjects.BaseHitAreaToolItem = BaseHitAreaToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseHitAreaToolItem.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BaseHitAreaOffsetToolItem extends sceneobjects.BaseHitAreaToolItem {
                    _x;
                    _y;
                    _dragging;
                    constructor(shape, x, y) {
                        super(shape);
                        this._x = x;
                        this._y = y;
                    }
                    getPoint(args) {
                        return this.getAvgScreenPointOfObjects(args, (sprite) => this._x - this.getToolOrigin(sprite).originX, (sprite) => this._y - this.getToolOrigin(sprite).originY);
                    }
                    getScreenPointOfObject(args, sprite, fx, fy) {
                        const worldPoint = new Phaser.Geom.Point(0, 0);
                        let { displayOriginX, displayOriginY } = sprite.getEditorSupport().computeDisplayOrigin();
                        if (sprite instanceof sceneobjects.Container) {
                            displayOriginX = 0;
                            displayOriginY = 0;
                        }
                        const offset = this.getOffsetProperties(sprite);
                        const size = this.getSizeProperties(sprite);
                        let x = offset.x.getValue(sprite);
                        let y = offset.y.getValue(sprite);
                        let width = size.width.getValue(sprite);
                        let height = size.height.getValue(sprite);
                        x = x - displayOriginX + fx * width;
                        y = y - displayOriginY + fy * height;
                        const tx = sprite.getWorldTransformMatrix();
                        tx.transformPoint(x, y, worldPoint);
                        return args.camera.getScreenPoint(worldPoint.x, worldPoint.y);
                    }
                    computeSize(obj) {
                        const size = this.getSizeProperties(obj);
                        return {
                            width: size.width.getValue(obj),
                            height: size.height.getValue(obj)
                        };
                    }
                    computeOffset(obj) {
                        const offset = this.getOffsetProperties(obj);
                        return {
                            x: offset.x.getValue(obj),
                            y: offset.y.getValue(obj)
                        };
                    }
                    ;
                    render(args) {
                        const point = this.getPoint(args);
                        const ctx = args.canvasContext;
                        ctx.save();
                        ctx.translate(point.x, point.y);
                        const angle = this.globalAngle(args.objects[0]);
                        ctx.rotate(Phaser.Math.DegToRad(angle));
                        this.drawRect(ctx, args.canEdit ?
                            sceneobjects.EditHitAreaTool.TOOL_COLOR : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                        ctx.restore();
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        return Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y) < 20;
                    }
                    onStartDrag(args) {
                        if (!this.containsPoint(args)) {
                            return;
                        }
                        this._dragging = true;
                        const point = this.getPoint(args);
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const worldTx = new Phaser.GameObjects.Components.TransformMatrix();
                            const initLocalPos = new Phaser.Math.Vector2();
                            sprite.getWorldTransformMatrix(worldTx);
                            worldTx.applyInverse(point.x, point.y, initLocalPos);
                            const offset = this.computeOffset(sprite);
                            sprite.setData(this.getKeyData(), {
                                initLocalPos: initLocalPos,
                                initLocalOffset: offset,
                                initWorldTx: worldTx
                            });
                        }
                    }
                    getInitialValue(obj) {
                        const { initLocalOffset } = obj.getData(this.getKeyData());
                        return initLocalOffset;
                    }
                    onDrag(args) {
                        if (!this._dragging) {
                            return;
                        }
                        const camera = args.camera;
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const data = sprite.data.get(this.getKeyData());
                            const initLocalPos = data.initLocalPos;
                            const worldTx = data.initWorldTx;
                            const localPos = new Phaser.Math.Vector2();
                            worldTx.applyInverse(args.x, args.y, localPos);
                            const flipX = sprite.flipX ? -1 : 1;
                            const flipY = sprite.flipY ? -1 : 1;
                            const dx = (localPos.x - initLocalPos.x) * flipX / camera.zoom;
                            const dy = (localPos.y - initLocalPos.y) * flipY / camera.zoom;
                            const x = data.initLocalOffset.x + dx;
                            const y = data.initLocalOffset.y + dy;
                            const changeAll = this._x === 0 && this._y === 0 || this._x === 0.5 && this._y === 0.5;
                            const changeX = this._x === 0 && this._y === 0.5 || changeAll;
                            const changeY = this._x === 0.5 && this._y === 0 || changeAll;
                            const offset = this.getOffsetProperties(obj);
                            if (changeX) {
                                offset.x.setValue(sprite, Math.floor(x));
                            }
                            if (changeY) {
                                offset.y.setValue(sprite, Math.floor(y));
                            }
                            args.editor.updateInspectorViewSection(this.getOffsetSectionId());
                        }
                    }
                    onStopDrag(args) {
                        if (this._dragging) {
                            args.editor.getUndoManager().add(this.createStopDragOperation(args));
                            this._dragging = false;
                        }
                    }
                }
                sceneobjects.BaseHitAreaOffsetToolItem = BaseHitAreaOffsetToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseHitAreaToolItem.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BaseHitAreaSizeToolItem extends sceneobjects.BaseHitAreaToolItem {
                    _x;
                    _y;
                    _dragging;
                    constructor(shape, x, y) {
                        super(shape);
                        this._x = x;
                        this._y = y;
                    }
                    getPoint(args) {
                        return this.getAvgScreenPointOfObjects(args, (sprite) => this._x - this.getToolOrigin(sprite).originX, (sprite) => this._y - this.getToolOrigin(sprite).originY);
                    }
                    getScreenPointOfObject(args, sprite, fx, fy) {
                        const worldPoint = new Phaser.Geom.Point(0, 0);
                        const { width, height } = this.computeSize(sprite);
                        let { displayOriginX, displayOriginY } = sprite.getEditorSupport().computeDisplayOrigin();
                        if (sprite instanceof sceneobjects.Container) {
                            displayOriginX = 0;
                            displayOriginY = 0;
                        }
                        const offset = this.getHitAreaOffset(sprite);
                        const x = offset.x - displayOriginX + fx * width;
                        const y = offset.y - displayOriginY + fy * height;
                        const tx = sprite.getWorldTransformMatrix();
                        tx.transformPoint(x, y, worldPoint);
                        return args.camera.getScreenPoint(worldPoint.x, worldPoint.y);
                    }
                    render(args) {
                        const point = this.getPoint(args);
                        const ctx = args.canvasContext;
                        ctx.save();
                        ctx.translate(point.x, point.y);
                        const angle = this.globalAngle(args.objects[0]);
                        ctx.rotate(Phaser.Math.DegToRad(angle));
                        this.drawRect(ctx, args.canEdit ?
                            sceneobjects.EditHitAreaTool.TOOL_COLOR : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                        ctx.restore();
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        return Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y) < 20;
                    }
                    onStartDrag(args) {
                        if (!this.containsPoint(args)) {
                            return;
                        }
                        this._dragging = true;
                        const point = this.getPoint(args);
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const worldTx = new Phaser.GameObjects.Components.TransformMatrix();
                            const initLocalPos = new Phaser.Math.Vector2();
                            sprite.getWorldTransformMatrix(worldTx);
                            worldTx.applyInverse(point.x, point.y, initLocalPos);
                            const { width, height } = this.computeSize(sprite);
                            sprite.setData(this.getDataKey(), {
                                initWidth: width,
                                initHeight: height,
                                initLocalPos: initLocalPos,
                                initWorldTx: worldTx
                            });
                        }
                    }
                    getInitialSize(obj) {
                        const data = obj.getData(this.getDataKey());
                        return { x: data.initWidth, y: data.initHeight };
                    }
                    onDrag(args) {
                        if (!this._dragging) {
                            return;
                        }
                        const camera = args.camera;
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const data = sprite.data.get(this.getDataKey());
                            const initLocalPos = data.initLocalPos;
                            const worldTx = data.initWorldTx;
                            const localPos = new Phaser.Math.Vector2();
                            worldTx.applyInverse(args.x, args.y, localPos);
                            const flipX = sprite.flipX ? -1 : 1;
                            const flipY = sprite.flipY ? -1 : 1;
                            const { originX, originY } = this.getToolOrigin(obj);
                            const dx = (localPos.x - initLocalPos.x) * flipX / camera.zoom;
                            const dy = (localPos.y - initLocalPos.y) * flipY / camera.zoom;
                            const dw = dx / (1 - (originX === 1 ? 0 : originX));
                            const dh = dy / (1 - (originY === 1 ? 0 : originY));
                            const { x: width, y: height } = args.editor.getScene().snapPoint(data.initWidth + dw, data.initHeight + dh);
                            const changeAll = this._x === 1 && this._y === 1;
                            const changeX = this._x === 1 && this._y === 0.5 || changeAll;
                            const changeY = this._x === 0.5 && this._y === 1 || changeAll;
                            this.onDragValues(sprite, changeX, changeY, width, height);
                            args.editor.updateInspectorViewSection(this.getHitAreaSectionId());
                        }
                    }
                    onStopDrag(args) {
                        if (this._dragging) {
                            args.editor.getUndoManager().add(this.createStopDragOperation(args));
                            this._dragging = false;
                        }
                    }
                }
                sceneobjects.BaseHitAreaSizeToolItem = BaseHitAreaSizeToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                function HitAreaProperty(component, name, label, tooltip, defValue) {
                    return {
                        name: `hitArea.${name}`,
                        label,
                        tooltip,
                        defValue,
                        getValue: (obj) => {
                            const objES = obj.getEditorSupport();
                            const comp = objES.getComponent(component);
                            if (comp) {
                                return comp[name];
                            }
                            return undefined;
                        },
                        setValue: (obj, value) => {
                            const objES = obj.getEditorSupport();
                            const comp = objES.getComponent(component);
                            if (comp) {
                                comp[name] = value;
                            }
                        },
                    };
                }
                sceneobjects.HitAreaProperty = HitAreaProperty;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseHitAreaComponent.ts" />
/// <reference path="./HitAreaProperty.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class CircleHitAreaComponent extends sceneobjects.BaseHitAreaComponent {
                    static x = sceneobjects.HitAreaProperty(CircleHitAreaComponent, "x", "X", "phaser:Phaser.Geom.Circle.x", 0);
                    static y = sceneobjects.HitAreaProperty(CircleHitAreaComponent, "y", "Y", "phaser:Phaser.Geom.Circle.y", 0);
                    static radius = sceneobjects.HitAreaProperty(CircleHitAreaComponent, "radius", "Radius", "phaser:Phaser.Geom.Circle.radius", 0);
                    static position = {
                        label: "Offset",
                        x: this.x,
                        y: this.y
                    };
                    x = 0;
                    y = 0;
                    radius = 0;
                    constructor(obj) {
                        super(obj, sceneobjects.HitAreaShape.CIRCLE, [
                            CircleHitAreaComponent.x,
                            CircleHitAreaComponent.y,
                            CircleHitAreaComponent.radius,
                        ]);
                    }
                    static getCircleComponent(obj) {
                        const objES = obj.getEditorSupport();
                        const comp = objES.getComponent(CircleHitAreaComponent);
                        return comp;
                    }
                    _setDefaultValues(x, y, width, height) {
                        this.x = x + width / 2;
                        this.y = y + height / 2;
                        this.radius = Math.min(width, height) / 2;
                    }
                    buildSetInteractiveCodeCOM(args, obj, code) {
                        const { x, y, radius } = this;
                        code.arg(`new Phaser.Geom.Circle(${x}, ${y}, ${radius})`);
                        code.arg("Phaser.Geom.Circle.Contains");
                    }
                }
                sceneobjects.CircleHitAreaComponent = CircleHitAreaComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class CircleHitAreaOffsetToolItem extends sceneobjects.BaseHitAreaOffsetToolItem {
                    constructor() {
                        super(sceneobjects.HitAreaShape.CIRCLE, 0.5, 0.5);
                    }
                    getToolOrigin(obj) {
                        return { originX: 0.5, originY: 0.5 };
                    }
                    getOffsetProperties(obj) {
                        const { x, y } = sceneobjects.CircleHitAreaComponent;
                        return { x, y };
                    }
                    getSizeProperties(obj) {
                        const { radius } = sceneobjects.CircleHitAreaComponent;
                        const prop = { ...radius };
                        prop.getValue = obj => radius.getValue(obj) * 2;
                        return { width: prop, height: prop };
                    }
                    getKeyData() {
                        return "CircleHitAreaOffsetToolItem";
                    }
                    getOffsetSectionId() {
                        return sceneobjects.CircleHitAreaSection.ID;
                    }
                    createStopDragOperation(args) {
                        return new sceneobjects.CircleOffsetOperation(args, obj => this.getInitialValue(obj));
                    }
                }
                sceneobjects.CircleHitAreaOffsetToolItem = CircleHitAreaOffsetToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class CircleHitAreaSection extends sceneobjects.SceneGameObjectSection {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.CircleHitAreaSection";
                    constructor(page) {
                        super(page, CircleHitAreaSection.ID, "Hit Area (Circle)");
                    }
                    createMenu(menu) {
                        this.createToolMenuItem(menu, sceneobjects.EditHitAreaTool.ID);
                        super.createMenu(menu);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/input-hit-area-circle.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createPropertyXYRow(comp, sceneobjects.CircleHitAreaComponent.position, false);
                        this.createPropertyFloatRow(comp, sceneobjects.CircleHitAreaComponent.radius, false)
                            .style.gridColumn = "span 4";
                    }
                    canEdit(obj, n) {
                        return sceneobjects.HitAreaComponent.hasHitAreaShape(obj, sceneobjects.HitAreaShape.CIRCLE);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.CircleHitAreaSection = CircleHitAreaSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class CircleHitAreaSizeOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialSize;
                    constructor(toolArgs, getInitialSize) {
                        super(toolArgs);
                        this.getInitialSize = getInitialSize;
                    }
                    getInitialValue(obj) {
                        return this.getInitialSize(obj);
                    }
                    getFinalValue(obj) {
                        return {
                            x: sceneobjects.CircleHitAreaComponent.radius.getValue(obj),
                            y: sceneobjects.CircleHitAreaComponent.radius.getValue(obj)
                        };
                    }
                    setValue(obj, value) {
                        sceneobjects.CircleHitAreaComponent.radius.setValue(obj, value.x / 2);
                    }
                }
                sceneobjects.CircleHitAreaSizeOperation = CircleHitAreaSizeOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseHitAreaSizeToolItem.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class CircleHitAreaSizeToolItem extends sceneobjects.BaseHitAreaSizeToolItem {
                    constructor() {
                        super(sceneobjects.HitAreaShape.CIRCLE, 1, 0.5);
                    }
                    getToolOrigin(obj) {
                        return { originX: 0.5, originY: 0.5 };
                    }
                    computeSize(obj) {
                        const { radius } = sceneobjects.CircleHitAreaComponent.getCircleComponent(obj);
                        return { width: radius * 2, height: radius * 2 };
                    }
                    getHitAreaOffset(obj) {
                        const { x, y } = sceneobjects.CircleHitAreaComponent.getCircleComponent(obj);
                        return { x, y };
                    }
                    getDataKey() {
                        return "CircleHitAreaSizeToolItem";
                    }
                    getHitAreaSectionId() {
                        return sceneobjects.CircleHitAreaSection.ID;
                    }
                    onDragValues(obj, changeX, changeY, width, height) {
                        const comp = sceneobjects.CircleHitAreaComponent.getCircleComponent(obj);
                        if (changeX) {
                            comp.radius = width / 2;
                        }
                        if (changeY) {
                            comp.radius = height / 2;
                        }
                    }
                    createStopDragOperation(args) {
                        return new sceneobjects.CircleHitAreaSizeOperation(args, obj => this.getInitialSize(obj));
                    }
                }
                sceneobjects.CircleHitAreaSizeToolItem = CircleHitAreaSizeToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class CircleOffsetOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialOffset;
                    constructor(toolArgs, getInitialOffset) {
                        super(toolArgs);
                        this.getInitialOffset = getInitialOffset;
                    }
                    getInitialValue(obj) {
                        return this.getInitialOffset(obj);
                    }
                    getFinalValue(obj) {
                        return {
                            x: sceneobjects.CircleHitAreaComponent.x.getValue(obj),
                            y: sceneobjects.CircleHitAreaComponent.y.getValue(obj)
                        };
                    }
                    setValue(obj, value) {
                        sceneobjects.CircleHitAreaComponent.x.setValue(obj, value.x);
                        sceneobjects.CircleHitAreaComponent.y.setValue(obj, value.y);
                    }
                }
                sceneobjects.CircleOffsetOperation = CircleOffsetOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BaseObjectTool extends ui.editor.tools.SceneTool {
                    _properties;
                    constructor(config, ...properties) {
                        super(config);
                        this._properties = properties;
                    }
                    getProperties(obj) {
                        return this._properties;
                    }
                    canEdit(obj) {
                        if (sceneobjects.isGameObject(obj)) {
                            const support = obj.getEditorSupport();
                            const props = this.getProperties(obj);
                            for (const prop of props) {
                                if (!support.hasProperty(prop)) {
                                    return false;
                                }
                                if (!support.isUnlockedProperty(prop)) {
                                    return false;
                                }
                            }
                            return props.length > 0;
                        }
                        return false;
                    }
                    canRender(obj) {
                        if (sceneobjects.isGameObject(obj)) {
                            const support = obj.getEditorSupport();
                            const props = this.getProperties(obj);
                            for (const prop of props) {
                                if (support.hasProperty(prop)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                    async confirmUnlockProperty(args, props, propLabel, ...sectionId) {
                        await args.editor.confirmUnlockProperty(props, propLabel, ...sectionId);
                    }
                }
                sceneobjects.BaseObjectTool = BaseObjectTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../object/tools/BaseObjectTool.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EditHitAreaTool extends sceneobjects.BaseObjectTool {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.EditHitAreaTool";
                    static TOOL_COLOR = "orange";
                    _polygonToolItem;
                    constructor() {
                        super({
                            id: EditHitAreaTool.ID,
                            command: ui.editor.commands.CMD_EDIT_HIT_AREA,
                        }, sceneobjects.RectangleHitAreaComponent.x, sceneobjects.RectangleHitAreaComponent.y, sceneobjects.RectangleHitAreaComponent.width, sceneobjects.RectangleHitAreaComponent.height, sceneobjects.EllipseHitAreaComponent.x, sceneobjects.EllipseHitAreaComponent.y, sceneobjects.EllipseHitAreaComponent.width, sceneobjects.EllipseHitAreaComponent.height, sceneobjects.CircleHitAreaComponent.x, sceneobjects.CircleHitAreaComponent.y, sceneobjects.CircleHitAreaComponent.radius);
                        this.addItems(new sceneobjects.RectangleHitAreaSizeToolItem(1, 0.5), new sceneobjects.RectangleHitAreaSizeToolItem(1, 1), new sceneobjects.RectangleHitAreaSizeToolItem(0.5, 1), new sceneobjects.RectangleHitAreaOffsetToolItem(0, 0), new sceneobjects.RectangleHitAreaOffsetToolItem(0.5, 0), new sceneobjects.RectangleHitAreaOffsetToolItem(0, 0.5), new sceneobjects.EllipseHitAreaSizeToolItem(1, 0.5), new sceneobjects.EllipseHitAreaSizeToolItem(1, 1), new sceneobjects.EllipseHitAreaSizeToolItem(0.5, 1), new sceneobjects.EllipseHitAreaOffsetToolItem(0, 0), new sceneobjects.EllipseHitAreaOffsetToolItem(0.5, 0), new sceneobjects.EllipseHitAreaOffsetToolItem(0, 0.5), new sceneobjects.CircleHitAreaSizeToolItem(), new sceneobjects.CircleHitAreaOffsetToolItem(), this._polygonToolItem = new sceneobjects.PolygonHitAreaToolItem());
                    }
                    handleDoubleClick(args) {
                        if (this._polygonToolItem.isValidFor(args.objects)) {
                            return this._polygonToolItem.handleDoubleClick(args);
                        }
                        return super.handleDoubleClick(args);
                    }
                    handleDeleteCommand(args) {
                        if (this._polygonToolItem.isValidFor(args.objects)) {
                            return this._polygonToolItem.handleDeleteCommand(args);
                        }
                        return super.handleDeleteCommand(args);
                    }
                    requiresRepaintOnMouseMove() {
                        return true;
                    }
                    getProperties(obj) {
                        if (sceneobjects.HitAreaComponent.hasHitArea(obj)) {
                            return [
                                sceneobjects.RectangleHitAreaComponent.x,
                                sceneobjects.RectangleHitAreaComponent.x,
                                sceneobjects.RectangleHitAreaComponent.width,
                                sceneobjects.RectangleHitAreaComponent.height
                            ];
                        }
                        return [];
                    }
                    async onActivated(args) {
                        super.onActivated(args);
                        for (const obj of args.objects) {
                            if (!sceneobjects.HitAreaComponent.hasHitArea(obj)) {
                                return;
                            }
                        }
                        const sections = [sceneobjects.RectangleHitAreaSection.ID];
                        const props = new Set();
                        for (const obj of args.objects) {
                            const objProps = this.getProperties(obj);
                            for (const prop of objProps) {
                                props.add(prop);
                            }
                        }
                        await this.confirmUnlockProperty(args, [...props], "hit area", ...sections);
                    }
                    render(args) {
                        for (const obj of args.objects) {
                            if (EditHitAreaTool.isValidFor(obj)) {
                                this.renderObj(args, obj);
                            }
                        }
                        super.render(args);
                    }
                    static isValidFor(...objects) {
                        for (const obj of objects) {
                            if (!sceneobjects.HitAreaComponent.hasHitArea(obj)
                                || sceneobjects.HitAreaComponent.getShape(obj) === sceneobjects.HitAreaShape.NONE) {
                                return false;
                            }
                        }
                        return true;
                    }
                    renderObj(args, obj) {
                        const objES = obj.getEditorSupport();
                        const comp = objES.getComponent(sceneobjects.HitAreaComponent);
                        const shape = comp.getHitAreaShape();
                        if (shape === sceneobjects.HitAreaShape.PIXEL_PERFECT) {
                            // pixel perfect doesn't have any tool item
                            return;
                        }
                        const ctx = args.canvasContext;
                        ctx.save();
                        if (shape === sceneobjects.HitAreaShape.ELLIPSE) {
                            this.renderEllipse(obj, args, ctx);
                        }
                        else if (shape === sceneobjects.HitAreaShape.CIRCLE) {
                            this.renderCircle(obj, args, ctx);
                        }
                        else if (shape === sceneobjects.HitAreaShape.POLYGON) {
                            this.renderPolygon(obj, args, ctx);
                        }
                        else {
                            this.renderRect(obj, args, ctx);
                        }
                        ctx.restore();
                    }
                    renderPolygon(obj, args, ctx) {
                        const origin = obj.getEditorSupport().computeDisplayOrigin();
                        if (obj instanceof sceneobjects.Container) {
                            origin.displayOriginX = 0;
                            origin.displayOriginY = 0;
                        }
                        const comp = sceneobjects.PolygonHitAreaComponent.getPolygonComponent(obj);
                        const tx = obj.getWorldTransformMatrix();
                        const points = comp.vectors
                            .map(p => new Phaser.Math.Vector2(p.x - origin.displayOriginX, p.y - origin.displayOriginY))
                            .map(p => tx.transformPoint(p.x, p.y))
                            .map(p => args.camera.getScreenPoint(p.x, p.y));
                        // close the path
                        points.push(points[0]);
                        ctx.save();
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 3;
                        this.drawPath(ctx, points);
                        ctx.strokeStyle = EditHitAreaTool.TOOL_COLOR;
                        ctx.lineWidth = 1;
                        this.drawPath(ctx, points);
                        ctx.restore();
                    }
                    renderRect(obj, args, ctx) {
                        const origin = obj.getEditorSupport().computeDisplayOrigin();
                        if (obj instanceof sceneobjects.Container) {
                            origin.displayOriginX = 0;
                            origin.displayOriginY = 0;
                        }
                        const comp = sceneobjects.RectangleHitAreaComponent.getRectangleComponent(obj);
                        const { x, y, width, height } = comp;
                        let x1 = x - origin.displayOriginX;
                        let y1 = y - origin.displayOriginY;
                        let x2 = x1 + width;
                        let y2 = y1 + height;
                        const tx = obj.getWorldTransformMatrix();
                        const points = [
                            [x1, y1],
                            [x2, y1],
                            [x2, y2],
                            [x1, y2],
                            [x1, y1]
                        ].map(([x, y]) => {
                            return tx.transformPoint(x, y);
                        }).map(p => {
                            return args.camera.getScreenPoint(p.x, p.y);
                        });
                        ctx.save();
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 3;
                        this.drawPath(ctx, points);
                        ctx.strokeStyle = EditHitAreaTool.TOOL_COLOR;
                        ctx.lineWidth = 1;
                        this.drawPath(ctx, points);
                        ctx.restore();
                    }
                    drawPath(ctx, points) {
                        ctx.beginPath();
                        ctx.moveTo(points[0].x, points[0].y);
                        for (const p of points) {
                            ctx.lineTo(p.x, p.y);
                        }
                        ctx.stroke();
                        ctx.closePath();
                    }
                    renderEllipse(obj, args, ctx) {
                        const comp = sceneobjects.EllipseHitAreaComponent.getEllipseComponent(obj);
                        const { x, y, width, height } = comp;
                        this.renderEllipseHelper(args, ctx, obj, x, y, width, height, true);
                    }
                    drawEllipse(ctx, x, y, w, h, angle) {
                        const rx = w / 2;
                        const ry = h / 2;
                        ctx.ellipse(x, y, rx, ry, Phaser.Math.DegToRad(angle), 0, Math.PI * 2);
                    }
                    renderCircle(obj, args, ctx) {
                        const comp = sceneobjects.CircleHitAreaComponent.getCircleComponent(obj);
                        const { x, y, radius } = comp;
                        const width = radius * 2;
                        const height = width;
                        this.renderEllipseHelper(args, ctx, obj, x, y, width, height, false);
                    }
                    renderEllipseHelper(args, ctx, obj, x, y, width, height, dashedRect) {
                        const origin = obj.getEditorSupport().computeDisplayOrigin();
                        if (obj instanceof sceneobjects.Container) {
                            origin.displayOriginX = 0;
                            origin.displayOriginY = 0;
                        }
                        let x1 = x - origin.displayOriginX;
                        let y1 = y - origin.displayOriginY;
                        let x2 = x1 + width;
                        let y2 = y1 + height;
                        const tx = obj.getWorldTransformMatrix();
                        let points = [
                            [x1, y1],
                            [x2, y1],
                            [x2, y2],
                        ]
                            .map(([x, y]) => tx.transformPoint(x, y))
                            .map(p => args.camera.getScreenPoint(p.x, p.y));
                        const [p1, p2, p3] = points;
                        const screenWidth = Phaser.Math.Distance.BetweenPoints(p1, p2);
                        const screenHeight = Phaser.Math.Distance.BetweenPoints(p2, p3);
                        const angle = ui.editor.tools.SceneToolItem.getGlobalAngle(obj);
                        ctx.save();
                        ctx.beginPath();
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 3;
                        this.drawEllipse(ctx, p1.x, p1.y, screenWidth, screenHeight, angle);
                        ctx.stroke();
                        ctx.closePath();
                        ctx.beginPath();
                        ctx.strokeStyle = EditHitAreaTool.TOOL_COLOR;
                        ctx.lineWidth = 1;
                        this.drawEllipse(ctx, p1.x, p1.y, screenWidth, screenHeight, angle);
                        ctx.stroke();
                        ctx.closePath();
                        if (dashedRect) {
                            // dashed rect
                            x1 = x - origin.displayOriginX - width / 2;
                            y1 = y - origin.displayOriginY - height / 2;
                            x2 = x1 + width;
                            y2 = y1 + height;
                            points = [
                                [x1, y1],
                                [x2, y1],
                                [x2, y2],
                                [x1, y2],
                                [x1, y1]
                            ]
                                .map(([x, y]) => tx.transformPoint(x, y))
                                .map(p => args.camera.getScreenPoint(p.x, p.y));
                            ctx.setLineDash([1, 1]);
                            this.drawPath(ctx, points);
                            ctx.restore();
                        }
                    }
                }
                sceneobjects.EditHitAreaTool = EditHitAreaTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseHitAreaComponent.ts" />
/// <reference path="./HitAreaProperty.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseHitAreaComponent extends sceneobjects.BaseHitAreaComponent {
                    static x = sceneobjects.HitAreaProperty(EllipseHitAreaComponent, "x", "X", "phaser:Phaser.Geom.Ellipse.x", 0);
                    static y = sceneobjects.HitAreaProperty(EllipseHitAreaComponent, "y", "Y", "phaser:Phaser.Geom.Ellipse.y", 0);
                    static width = sceneobjects.HitAreaProperty(EllipseHitAreaComponent, "width", "W", "phaser:Phaser.Geom.Ellipse.width", 0);
                    static height = sceneobjects.HitAreaProperty(EllipseHitAreaComponent, "height", "H", "phaser:Phaser.Geom.Ellipse.height", 0);
                    static position = {
                        label: "Offset",
                        x: this.x,
                        y: this.y
                    };
                    static size = {
                        label: "Size",
                        x: this.width,
                        y: this.height
                    };
                    x = 0;
                    y = 0;
                    width = 0;
                    height = 0;
                    constructor(obj) {
                        super(obj, sceneobjects.HitAreaShape.ELLIPSE, [
                            EllipseHitAreaComponent.x,
                            EllipseHitAreaComponent.y,
                            EllipseHitAreaComponent.width,
                            EllipseHitAreaComponent.height,
                        ]);
                    }
                    static getEllipseComponent(obj) {
                        const objES = obj.getEditorSupport();
                        const comp = objES.getComponent(EllipseHitAreaComponent);
                        return comp;
                    }
                    _setDefaultValues(x, y, width, height) {
                        this.x = x + width / 2;
                        this.y = y + height / 2;
                        this.width = width;
                        this.height = height;
                    }
                    buildSetInteractiveCodeCOM(args, obj, code) {
                        const { x, y, width, height } = this;
                        code.arg(`new Phaser.Geom.Ellipse(${x}, ${y}, ${width}, ${height})`);
                        code.arg("Phaser.Geom.Ellipse.Contains");
                    }
                }
                sceneobjects.EllipseHitAreaComponent = EllipseHitAreaComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseHitAreaOffsetToolItem extends sceneobjects.BaseHitAreaOffsetToolItem {
                    constructor(x, y) {
                        super(sceneobjects.HitAreaShape.ELLIPSE, x, y);
                    }
                    getToolOrigin(obj) {
                        return { originX: 0.5, originY: 0.5 };
                    }
                    getOffsetProperties(obj) {
                        const { x, y } = sceneobjects.EllipseHitAreaComponent;
                        return { x, y };
                    }
                    getSizeProperties(obj) {
                        const { width, height } = sceneobjects.EllipseHitAreaComponent;
                        return { width, height };
                    }
                    getKeyData() {
                        return "EllipseHitAreaOffsetToolItem";
                    }
                    getOffsetSectionId() {
                        return sceneobjects.EllipseHitAreaSection.ID;
                    }
                    createStopDragOperation(args) {
                        return new sceneobjects.EllipseOffsetOperation(args, obj => this.getInitialValue(obj));
                    }
                }
                sceneobjects.EllipseHitAreaOffsetToolItem = EllipseHitAreaOffsetToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseHitAreaSection extends sceneobjects.SceneGameObjectSection {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.EllipseHitAreaSection";
                    constructor(page) {
                        super(page, EllipseHitAreaSection.ID, "Hit Area (Ellipse)");
                    }
                    createMenu(menu) {
                        this.createToolMenuItem(menu, sceneobjects.EditHitAreaTool.ID);
                        super.createMenu(menu);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/input-hit-area-ellipse.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createPropertyXYRow(comp, sceneobjects.EllipseHitAreaComponent.position, false);
                        this.createPropertyXYRow(comp, sceneobjects.EllipseHitAreaComponent.size, false);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.HitAreaComponent.hasHitAreaShape(obj, sceneobjects.HitAreaShape.ELLIPSE);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.EllipseHitAreaSection = EllipseHitAreaSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseHitAreaSizeOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialSize;
                    constructor(toolArgs, getInitialSize) {
                        super(toolArgs);
                        this.getInitialSize = getInitialSize;
                    }
                    getInitialValue(obj) {
                        return this.getInitialSize(obj);
                    }
                    getFinalValue(obj) {
                        return {
                            x: sceneobjects.EllipseHitAreaComponent.width.getValue(obj),
                            y: sceneobjects.EllipseHitAreaComponent.height.getValue(obj)
                        };
                    }
                    setValue(obj, value) {
                        sceneobjects.EllipseHitAreaComponent.width.setValue(obj, value.x);
                        sceneobjects.EllipseHitAreaComponent.height.setValue(obj, value.y);
                    }
                }
                sceneobjects.EllipseHitAreaSizeOperation = EllipseHitAreaSizeOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseHitAreaSizeToolItem.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseHitAreaSizeToolItem extends sceneobjects.BaseHitAreaSizeToolItem {
                    constructor(x, y) {
                        super(sceneobjects.HitAreaShape.ELLIPSE, x, y);
                    }
                    getToolOrigin(obj) {
                        return { originX: 0.5, originY: 0.5 };
                    }
                    getHitAreaComp(obj) {
                        const objEs = obj.getEditorSupport();
                        const comp = objEs.getComponent(sceneobjects.EllipseHitAreaComponent);
                        return comp;
                    }
                    computeSize(obj) {
                        const { width, height } = this.getHitAreaComp(obj);
                        return { width, height };
                    }
                    getHitAreaOffset(obj) {
                        const { x, y } = this.getHitAreaComp(obj);
                        return { x, y };
                    }
                    getDataKey() {
                        return "EllipseHitAreaSizeToolItem";
                    }
                    getHitAreaSectionId() {
                        return sceneobjects.EllipseHitAreaSection.ID;
                    }
                    onDragValues(obj, changeX, changeY, width, height) {
                        const comp = this.getHitAreaComp(obj);
                        if (changeX) {
                            comp.width = width;
                        }
                        if (changeY) {
                            comp.height = height;
                        }
                    }
                    createStopDragOperation(args) {
                        return new sceneobjects.EllipseHitAreaSizeOperation(args, obj => this.getInitialSize(obj));
                    }
                }
                sceneobjects.EllipseHitAreaSizeToolItem = EllipseHitAreaSizeToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseOffsetOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialOffset;
                    constructor(toolArgs, getInitialOffset) {
                        super(toolArgs);
                        this.getInitialOffset = getInitialOffset;
                    }
                    getInitialValue(obj) {
                        return this.getInitialOffset(obj);
                    }
                    getFinalValue(obj) {
                        return {
                            x: sceneobjects.EllipseHitAreaComponent.x.getValue(obj),
                            y: sceneobjects.EllipseHitAreaComponent.y.getValue(obj)
                        };
                    }
                    setValue(obj, value) {
                        sceneobjects.EllipseHitAreaComponent.x.setValue(obj, value.x);
                        sceneobjects.EllipseHitAreaComponent.y.setValue(obj, value.y);
                    }
                }
                sceneobjects.EllipseOffsetOperation = EllipseOffsetOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                let HitAreaShape;
                (function (HitAreaShape) {
                    HitAreaShape["NONE"] = "NONE";
                    HitAreaShape["RECTANGLE"] = "RECTANGLE";
                    HitAreaShape["CIRCLE"] = "CIRCLE";
                    HitAreaShape["ELLIPSE"] = "ELLIPSE";
                    HitAreaShape["POLYGON"] = "POLYGON";
                    HitAreaShape["PIXEL_PERFECT"] = "PIXEL_PERFECT";
                })(HitAreaShape = sceneobjects.HitAreaShape || (sceneobjects.HitAreaShape = {}));
                function getComp(obj) {
                    return obj.getEditorSupport().getComponent(HitAreaComponent);
                }
                class HitAreaComponent extends sceneobjects.Component {
                    static hitAreaShape = {
                        name: "hitArea.shape",
                        label: "Shape",
                        defValue: HitAreaShape.NONE,
                        getValue: obj => getComp(obj).getHitAreaShape(),
                        setValue: (obj, value) => getComp(obj).setHitAreaShape(value),
                        getValueLabel: value => value.toString(),
                        values: [
                            HitAreaShape.NONE,
                            HitAreaShape.RECTANGLE,
                            HitAreaShape.CIRCLE,
                            HitAreaShape.ELLIPSE,
                            HitAreaShape.POLYGON,
                            HitAreaShape.PIXEL_PERFECT
                        ]
                    };
                    _hitAreaShape;
                    constructor(obj) {
                        super(obj, [
                            HitAreaComponent.hitAreaShape
                        ]);
                        this._hitAreaShape = HitAreaShape.NONE;
                    }
                    static getShapeComponent(obj) {
                        const shape = this.getShape(obj);
                        switch (shape) {
                            case HitAreaShape.RECTANGLE:
                                return sceneobjects.RectangleHitAreaComponent.getRectangleComponent(obj);
                            case HitAreaShape.CIRCLE:
                                return sceneobjects.CircleHitAreaComponent.getCircleComponent(obj);
                            case HitAreaShape.ELLIPSE:
                                return sceneobjects.EllipseHitAreaComponent.getEllipseComponent(obj);
                            case HitAreaShape.POLYGON:
                                return sceneobjects.PolygonHitAreaComponent.getPolygonComponent(obj);
                            case HitAreaShape.PIXEL_PERFECT:
                                return sceneobjects.PixelPerfectHitAreaComponent.getPixelPerfectComponent(obj);
                        }
                        return undefined;
                    }
                    static hasHitAreaShape(obj, shape) {
                        if (this.hasHitArea(obj)) {
                            return this.getShape(obj) === shape;
                        }
                        return false;
                    }
                    static hasHitArea(obj) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, HitAreaComponent);
                    }
                    static getShape(obj) {
                        return this.hitAreaShape.getValue(obj);
                    }
                    getHitAreaShape() {
                        return this._hitAreaShape;
                    }
                    setHitAreaShape(hitAreaShape) {
                        this._hitAreaShape = hitAreaShape;
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const objES = this.getEditorSupport();
                        if (objES.isPrefabInstance()) {
                            if (objES.isUnlockedProperty(HitAreaComponent.hitAreaShape)) {
                                const code = new scene.core.code.MethodCallCodeDOM("removeInteractive", args.objectVarName);
                                args.statements.push(code);
                            }
                        }
                    }
                }
                sceneobjects.HitAreaComponent = HitAreaComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class HitAreaSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.HitAreaSection", "Hit Area");
                    }
                    getSectionHelpPath() {
                        return "scene-editor/input-hit-area.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 3);
                        const { hitAreaShape } = sceneobjects.HitAreaComponent;
                        const prop = { ...hitAreaShape };
                        prop.setValue = (obj, value) => {
                            hitAreaShape.setValue(obj, value);
                            if (value !== sceneobjects.HitAreaShape.NONE) {
                                const comp = sceneobjects.HitAreaComponent.getShapeComponent(obj);
                                comp.setDefaultValues();
                            }
                        };
                        this.createPropertyEnumRow(comp, prop, undefined, value => {
                            if (value === sceneobjects.HitAreaShape.PIXEL_PERFECT) {
                                for (const obj of this.getSelection()) {
                                    if (!(obj instanceof sceneobjects.Sprite) && !(obj instanceof sceneobjects.Image)) {
                                        return false;
                                    }
                                }
                            }
                            return true;
                        });
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.HitAreaComponent);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.HitAreaSection = HitAreaSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseHitAreaComponent.ts" />
/// <reference path="./HitAreaProperty.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_51) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PixelPerfectHitAreaComponent extends sceneobjects.BaseHitAreaComponent {
                    static alphaTolerance = sceneobjects.HitAreaProperty(PixelPerfectHitAreaComponent, "alphaTolerance", "Alpha Tolerance", "phaser:Phaser.Input.InputPlugin.makePixelPerfect(alphaTolerance)", 1);
                    alphaTolerance = 1;
                    constructor(obj) {
                        super(obj, sceneobjects.HitAreaShape.PIXEL_PERFECT, [
                            PixelPerfectHitAreaComponent.alphaTolerance
                        ]);
                    }
                    static getPixelPerfectComponent(obj) {
                        const objES = obj.getEditorSupport();
                        const comp = objES.getComponent(PixelPerfectHitAreaComponent);
                        return comp;
                    }
                    _setDefaultValues(x, y, width, height) {
                        // nothing
                    }
                    buildSetInteractiveCodeCOM(args, obj, code) {
                        const objES = this.getEditorSupport();
                        const scene = objES.getScene();
                        const sceneVar = scene.isPrefabSceneType() ?
                            "this.scene" : "this";
                        const alpha = this.alphaTolerance === 1 ? "" : this.alphaTolerance;
                        code.arg(`${sceneVar}.input.makePixelPerfect(${alpha})`);
                    }
                }
                sceneobjects.PixelPerfectHitAreaComponent = PixelPerfectHitAreaComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_51.ui || (scene_51.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PixelPerfectHitAreaSection extends sceneobjects.SceneGameObjectSection {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.PixelPerfectHitAreaSection";
                    constructor(page) {
                        super(page, PixelPerfectHitAreaSection.ID, "Hit Area (Pixel Perfect)");
                    }
                    createMenu(menu) {
                        this.createToolMenuItem(menu, sceneobjects.EditHitAreaTool.ID);
                        super.createMenu(menu);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/input-hit-area-pixel-perfect.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 3);
                        this.createPropertyFloatRow(comp, sceneobjects.PixelPerfectHitAreaComponent.alphaTolerance, false);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.HitAreaComponent.hasHitAreaShape(obj, sceneobjects.HitAreaShape.PIXEL_PERFECT);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.PixelPerfectHitAreaSection = PixelPerfectHitAreaSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseHitAreaComponent.ts" />
/// <reference path="./HitAreaProperty.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PolygonHitAreaComponent extends sceneobjects.BaseHitAreaComponent {
                    static points = sceneobjects.HitAreaProperty(PolygonHitAreaComponent, "points", "Points", "The polygon's points, in a string format `X1 Y1 Y2 X2...`", "");
                    points;
                    constructor(obj) {
                        super(obj, sceneobjects.HitAreaShape.POLYGON, [
                            PolygonHitAreaComponent.points
                        ]);
                        this.points = "";
                    }
                    get vectors() {
                        const vectors = [];
                        const chunks = this.points.split(" ").map(s => s.trim()).filter(s => s.length > 0);
                        for (let i = 0; i < chunks.length - 1; i += 2) {
                            const x = Number.parseFloat(chunks[i]);
                            const y = Number.parseFloat(chunks[i + 1]);
                            vectors.push(new Phaser.Math.Vector2(x, y));
                        }
                        return vectors;
                    }
                    static getPolygonComponent(obj) {
                        const objES = obj.getEditorSupport();
                        const comp = objES.getComponent(PolygonHitAreaComponent);
                        return comp;
                    }
                    _setDefaultValues(x, y, w, h) {
                        this.points = `${x} ${y + h * 0.25} ${x + w / 2} ${y} ${x + w} ${y + h * 0.25} ${x + w} ${y + h} ${x} ${y + h}`;
                    }
                    buildSetInteractiveCodeCOM(args, obj, code) {
                        code.arg(`new Phaser.Geom.Polygon("${this.points}")`);
                        code.arg("Phaser.Geom.Polygon.Contains");
                    }
                }
                sceneobjects.PolygonHitAreaComponent = PolygonHitAreaComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PolygonHitAreaSection extends sceneobjects.SceneGameObjectSection {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.PolygonHitAreaSection";
                    constructor(page) {
                        super(page, PolygonHitAreaSection.ID, "Hit Area (Polygon)");
                    }
                    createMenu(menu) {
                        this.createToolMenuItem(menu, sceneobjects.EditHitAreaTool.ID);
                        super.createMenu(menu);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/input-hit-area.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 3);
                        this.createPropertyStringDialogRow(comp, sceneobjects.PolygonHitAreaComponent.points, false);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.HitAreaComponent.hasHitAreaShape(obj, sceneobjects.HitAreaShape.POLYGON);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.PolygonHitAreaSection = PolygonHitAreaSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PolygonHitAreaToolItem extends ui.editor.tools.SceneToolItem {
                    _dragging;
                    _draggingIndex;
                    _newPoint;
                    _newPointIndex;
                    _highlightPointIndex = -1;
                    constructor() {
                        super();
                    }
                    handleDoubleClick(args) {
                        if (this._highlightPointIndex >= 0) {
                            const op = new ui.editor.undo.SceneSnapshotOperation(args.editor, async () => {
                                this.handleDeleteCommand(args);
                            });
                            args.editor.getUndoManager().add(op);
                            return true;
                        }
                        return false;
                    }
                    handleDeleteCommand(args) {
                        if (this._highlightPointIndex >= 0) {
                            const comp = sceneobjects.PolygonHitAreaComponent.getPolygonComponent(args.objects[0]);
                            const points = comp.vectors;
                            if (points.length <= 3) {
                                return true;
                            }
                            const newPoints = [];
                            for (let i = 0; i < points.length; i++) {
                                if (i !== this._highlightPointIndex) {
                                    newPoints.push(points[i]);
                                }
                            }
                            comp.points = newPoints.map(p => `${p.x} ${p.y}`).join(" ");
                            return true;
                        }
                        return false;
                    }
                    getPoint(args) {
                        return { x: 0, y: 0 };
                    }
                    render(args) {
                        if (args.objects.length !== 1) {
                            return;
                        }
                        let nearPoint;
                        let nearPointIndex;
                        const comp = sceneobjects.PolygonHitAreaComponent.getPolygonComponent(args.objects[0]);
                        const sprite = comp.getObject();
                        const points = this.getPolygonScreenPoints(comp);
                        const ctx = args.canvasContext;
                        const cursor = args.editor.getMouseManager().getMousePosition();
                        // find highlihting point
                        let highlightPoint;
                        let highlightPointIndex = -1;
                        for (let i = 0; i < points.length; i++) {
                            const point = points[i];
                            if (this.isCursorOnPoint(cursor.x, cursor.y, point)) {
                                highlightPoint = point;
                                highlightPointIndex = i;
                                break;
                            }
                        }
                        if (!highlightPoint) {
                            // paint near line
                            let nearLine;
                            let nearLineDistance = Number.MAX_VALUE;
                            const line = new Phaser.Geom.Line();
                            const tempPoint = new Phaser.Geom.Point();
                            for (let i = 0; i < points.length; i++) {
                                const p1 = points[i];
                                const p2 = points[(i + 1) % points.length];
                                line.setTo(p1.x, p1.y, p2.x, p2.y);
                                Phaser.Geom.Line.GetNearestPoint(line, new Phaser.Geom.Point(cursor.x, cursor.y), tempPoint);
                                const d = Phaser.Math.Distance.BetweenPoints(cursor, tempPoint);
                                if (d < 10 && d < nearLineDistance) {
                                    const lineLength = Phaser.Geom.Line.Length(line);
                                    const length1 = Phaser.Math.Distance.BetweenPoints(p1, tempPoint);
                                    const length2 = Phaser.Math.Distance.BetweenPoints(p2, tempPoint);
                                    // check the point is inside the segment
                                    if (length1 <= lineLength && length2 <= lineLength) {
                                        nearLineDistance = d;
                                        nearPointIndex = i;
                                        if (nearLine) {
                                            nearLine.setTo(line.x1, line.y1, line.x2, line.y2);
                                            nearPoint.setTo(tempPoint.x, tempPoint.y);
                                        }
                                        else {
                                            nearLine = new Phaser.Geom.Line(line.x1, line.y1, line.x2, line.y2);
                                            nearPoint = new Phaser.Geom.Point(tempPoint.x, tempPoint.y);
                                        }
                                    }
                                }
                            }
                            if (nearLine) {
                                const color = args.canEdit ? "#fff" : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT;
                                // draw near line
                                ctx.save();
                                ctx.translate(nearLine.x1, nearLine.y1);
                                const angle = this.globalAngle(sprite);
                                ctx.rotate(Phaser.Math.DegToRad(angle));
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(nearLine.x2 - nearLine.x1, nearLine.y2 - nearLine.y1);
                                ctx.strokeStyle = color;
                                ctx.lineWidth = 3;
                                ctx.stroke();
                                ctx.restore();
                                // draw near point
                                ctx.save();
                                ctx.translate(nearPoint.x, nearPoint.y);
                                ctx.rotate(Phaser.Math.DegToRad(this.globalAngle(sprite)));
                                this.drawRect(ctx, args.canEdit ? "#faa" : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                                ctx.restore();
                            }
                        }
                        // paint highlight point
                        for (const point of points) {
                            ctx.save();
                            ctx.translate(point.x, point.y);
                            const angle = this.globalAngle(sprite);
                            ctx.rotate(Phaser.Math.DegToRad(angle));
                            const color = point === highlightPoint ? "#f00" : sceneobjects.EditHitAreaTool.TOOL_COLOR;
                            this.drawRect(ctx, args.canEdit ? color : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                            ctx.restore();
                        }
                        this._newPoint = nearPoint ? this.getPolygonLocalPoint(sprite, nearPoint) : undefined;
                        this._newPointIndex = nearPointIndex;
                        this._highlightPointIndex = highlightPointIndex;
                    }
                    getPolygonScreenPoints(comp) {
                        const points = [];
                        const worldPoint = new Phaser.Math.Vector2(0, 0);
                        const obj = comp.getObject();
                        const { displayOriginX, displayOriginY } = this.getDisplayOrigin(obj);
                        const tx = obj.getWorldTransformMatrix();
                        for (const point of comp.vectors) {
                            tx.transformPoint(point.x - displayOriginX, point.y - displayOriginY, worldPoint);
                            const screenPoint = obj.scene.cameras.main.getScreenPoint(worldPoint.x, worldPoint.y);
                            points.push(screenPoint);
                        }
                        return points;
                    }
                    getPolygonLocalPoint(polygon, point) {
                        const camera = polygon.scene.cameras.main;
                        point = camera.getWorldPoint2(point.x, point.y);
                        const localPoint = polygon.getWorldTransformMatrix().applyInverse(point.x, point.y);
                        localPoint.x += polygon.displayOriginX;
                        localPoint.y += polygon.displayOriginY;
                        return localPoint;
                    }
                    containsPoint(args) {
                        if (this._newPoint) {
                            return true;
                        }
                        const points = this.getPolygonScreenPoints(sceneobjects.PolygonHitAreaComponent.getPolygonComponent(args.objects[0]));
                        for (const point of points) {
                            if (this.isCursorOnPoint(args.x, args.y, point)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    isCursorOnPoint(cursorX, cursorY, point) {
                        return cursorX >= point.x - 5 && cursorX <= point.x + 5
                            && cursorY >= point.y - 5 && cursorY <= point.y + 5;
                    }
                    _startDragTime = 0;
                    onStartDrag(args) {
                        this._startDragTime = Date.now();
                        const comp = sceneobjects.PolygonHitAreaComponent.getPolygonComponent(args.objects[0]);
                        if (this._newPoint) {
                            const points = comp.vectors;
                            let newPoints = [];
                            for (let i = 0; i < points.length; i++) {
                                const point = points[i];
                                newPoints.push(point);
                                if (this._newPointIndex === i) {
                                    newPoints.push(this._newPoint);
                                }
                            }
                            comp.points = newPoints.map(p => `${p.x} ${p.y}`).join(" ");
                        }
                        const cursor = args.editor.getMouseManager().getMousePosition();
                        const points = this.getPolygonScreenPoints(comp);
                        for (let i = 0; i < points.length; i++) {
                            const point = points[i];
                            if (this.isCursorOnPoint(cursor.x, cursor.y, point)) {
                                comp.getObject().setData("PolygonHitAreaToolItem", {
                                    initPoints: comp.points
                                });
                                this._draggingIndex = i;
                                this._dragging = true;
                                break;
                            }
                        }
                    }
                    static getInitialPoints(obj) {
                        return obj.getData("PolygonHitAreaToolItem").initPoints;
                    }
                    isValidFor(objects) {
                        const obj = objects[0];
                        if (obj) {
                            if (sceneobjects.HitAreaComponent.hasHitArea(obj) && sceneobjects.HitAreaComponent.hasHitAreaShape(obj, sceneobjects.HitAreaShape.POLYGON)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    onDrag(args) {
                        if (!this._dragging) {
                            return;
                        }
                        const comp = sceneobjects.PolygonHitAreaComponent.getPolygonComponent(args.objects[0]);
                        const points = comp.vectors;
                        const point = points[this._draggingIndex];
                        const newPoint = args.editor.getScene().getCamera().getWorldPoint(args.x, args.y);
                        const sprite = comp.getObject();
                        sprite.getWorldTransformMatrix().applyInverse(newPoint.x, newPoint.y, newPoint);
                        let { displayOriginX, displayOriginY } = this.getDisplayOrigin(sprite);
                        point.x = newPoint.x + displayOriginX;
                        point.y = newPoint.y + displayOriginY;
                        comp.points = points.map(p => `${p.x} ${p.y}`).join(" ");
                        args.editor.updateInspectorViewSection(sceneobjects.PolygonHitAreaSection.ID);
                    }
                    getDisplayOrigin(sprite) {
                        if (sprite instanceof sceneobjects.Container) {
                            return { displayOriginX: 0, displayOriginY: 0 };
                        }
                        return sprite.getEditorSupport().computeDisplayOrigin();
                    }
                    onStopDrag(args) {
                        this._newPoint = undefined;
                        if (this._dragging) {
                            if (Date.now() - this._startDragTime > 300) {
                                args.editor.getUndoManager().add(new sceneobjects.PolygonHitAreaOperation(args));
                            }
                            this._dragging = false;
                        }
                    }
                }
                sceneobjects.PolygonHitAreaToolItem = PolygonHitAreaToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseHitAreaComponent.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RectangleHitAreaComponent extends sceneobjects.BaseHitAreaComponent {
                    static x = sceneobjects.HitAreaProperty(RectangleHitAreaComponent, "x", "X", "phaser:Phaser.Geom.Rectangle.x", 0);
                    static y = sceneobjects.HitAreaProperty(RectangleHitAreaComponent, "y", "Y", "phaser:Phaser.Geom.Rectangle.y", 0);
                    static width = sceneobjects.HitAreaProperty(RectangleHitAreaComponent, "width", "W", "phaser:Phaser.Geom.Rectangle.width", 0);
                    static height = sceneobjects.HitAreaProperty(RectangleHitAreaComponent, "height", "H", "phaser:Phaser.Geom.Rectangle.height", 0);
                    static position = {
                        label: "Offset",
                        x: this.x,
                        y: this.y
                    };
                    static size = {
                        label: "Size",
                        x: this.width,
                        y: this.height
                    };
                    x = 0;
                    y = 0;
                    width = 0;
                    height = 0;
                    constructor(obj) {
                        super(obj, sceneobjects.HitAreaShape.RECTANGLE, [
                            RectangleHitAreaComponent.x,
                            RectangleHitAreaComponent.y,
                            RectangleHitAreaComponent.width,
                            RectangleHitAreaComponent.height,
                        ]);
                    }
                    static getRectangleComponent(obj) {
                        const objES = obj.getEditorSupport();
                        const comp = objES.getComponent(RectangleHitAreaComponent);
                        return comp;
                    }
                    _setDefaultValues(x, y, width, height) {
                        this.x = x;
                        this.y = y;
                        this.width = width;
                        this.height = height;
                    }
                    buildSetInteractiveCodeCOM(args, obj, code) {
                        const { x, y, width, height } = this;
                        code.arg(`new Phaser.Geom.Rectangle(${x}, ${y}, ${width}, ${height})`);
                        code.arg("Phaser.Geom.Rectangle.Contains");
                    }
                }
                sceneobjects.RectangleHitAreaComponent = RectangleHitAreaComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RectangleHitAreaOffsetToolItem extends sceneobjects.BaseHitAreaOffsetToolItem {
                    constructor(x, y) {
                        super(sceneobjects.HitAreaShape.RECTANGLE, x, y);
                    }
                    getToolOrigin(obj) {
                        return { originX: 0, originY: 0 };
                    }
                    getOffsetProperties(obj) {
                        const { x, y } = sceneobjects.RectangleHitAreaComponent;
                        return { x, y };
                    }
                    getSizeProperties(obj) {
                        const { width, height } = sceneobjects.RectangleHitAreaComponent;
                        return { width, height };
                    }
                    getKeyData() {
                        return "RectangleHitAreaOffsetToolItem";
                    }
                    getOffsetSectionId() {
                        return sceneobjects.RectangleHitAreaSection.ID;
                    }
                    createStopDragOperation(args) {
                        return new sceneobjects.RectangleOffsetOperation(args, obj => this.getInitialValue(obj));
                    }
                }
                sceneobjects.RectangleHitAreaOffsetToolItem = RectangleHitAreaOffsetToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RectangleHitAreaSection extends sceneobjects.SceneGameObjectSection {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.RectangleHitAreaSection";
                    constructor(page) {
                        super(page, RectangleHitAreaSection.ID, "Hit Area (Rectangle)");
                    }
                    createMenu(menu) {
                        this.createToolMenuItem(menu, sceneobjects.EditHitAreaTool.ID);
                        super.createMenu(menu);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/input-hit-area-rectangle.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createPropertyXYRow(comp, sceneobjects.RectangleHitAreaComponent.position, false);
                        this.createPropertyXYRow(comp, sceneobjects.RectangleHitAreaComponent.size, false);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.HitAreaComponent.hasHitAreaShape(obj, sceneobjects.HitAreaShape.RECTANGLE);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.RectangleHitAreaSection = RectangleHitAreaSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RectangleHitAreaSizeOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialSize;
                    constructor(toolArgs, getInitialSize) {
                        super(toolArgs);
                        this.getInitialSize = getInitialSize;
                    }
                    getInitialValue(obj) {
                        return this.getInitialSize(obj);
                    }
                    getFinalValue(obj) {
                        return {
                            x: sceneobjects.RectangleHitAreaComponent.width.getValue(obj),
                            y: sceneobjects.RectangleHitAreaComponent.height.getValue(obj)
                        };
                    }
                    setValue(obj, value) {
                        sceneobjects.RectangleHitAreaComponent.width.setValue(obj, value.x);
                        sceneobjects.RectangleHitAreaComponent.height.setValue(obj, value.y);
                    }
                }
                sceneobjects.RectangleHitAreaSizeOperation = RectangleHitAreaSizeOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseHitAreaSizeToolItem.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RectangleHitAreaSizeToolItem extends sceneobjects.BaseHitAreaSizeToolItem {
                    constructor(x, y) {
                        super(sceneobjects.HitAreaShape.RECTANGLE, x, y);
                    }
                    getToolOrigin() {
                        return { originX: 0, originY: 0 };
                    }
                    getHitAreaComp(obj) {
                        const objEs = obj.getEditorSupport();
                        const comp = objEs.getComponent(sceneobjects.RectangleHitAreaComponent);
                        return comp;
                    }
                    computeSize(obj) {
                        const { width, height } = this.getHitAreaComp(obj);
                        return { width, height };
                    }
                    getHitAreaOffset(obj) {
                        const { x, y } = this.getHitAreaComp(obj);
                        return { x, y };
                    }
                    getDataKey() {
                        return "RectangleHitAreaSizeToolItem";
                    }
                    getHitAreaSectionId() {
                        return sceneobjects.RectangleHitAreaSection.ID;
                    }
                    onDragValues(obj, changeX, changeY, width, height) {
                        const comp = this.getHitAreaComp(obj);
                        if (changeX) {
                            comp.width = width;
                        }
                        if (changeY) {
                            comp.height = height;
                        }
                    }
                    createStopDragOperation(args) {
                        return new sceneobjects.RectangleHitAreaSizeOperation(args, obj => this.getInitialSize(obj));
                    }
                }
                sceneobjects.RectangleHitAreaSizeToolItem = RectangleHitAreaSizeToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RectangleOffsetOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialOffset;
                    constructor(toolArgs, getInitialOffset) {
                        super(toolArgs);
                        this.getInitialOffset = getInitialOffset;
                    }
                    getInitialValue(obj) {
                        return this.getInitialOffset(obj);
                    }
                    getFinalValue(obj) {
                        return {
                            x: sceneobjects.RectangleHitAreaComponent.x.getValue(obj),
                            y: sceneobjects.RectangleHitAreaComponent.y.getValue(obj)
                        };
                    }
                    setValue(obj, value) {
                        sceneobjects.RectangleHitAreaComponent.x.setValue(obj, value.x);
                        sceneobjects.RectangleHitAreaComponent.y.setValue(obj, value.y);
                    }
                }
                sceneobjects.RectangleOffsetOperation = RectangleOffsetOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../GameObjectCodeDOMBuilder.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class BaseImageCodeDOMBuilder extends sceneobjects.GameObjectCodeDOMBuilder {
                    _factoryMethodName;
                    constructor(factoryMethodName, chainToFactory) {
                        super(chainToFactory);
                        this._factoryMethodName = factoryMethodName;
                    }
                    getFactoryMethodName(obj) {
                        return this._factoryMethodName;
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        const call = args.superMethodCallCodeDOM;
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_TextureParameters(args, call);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM_TextureParameters(args, call) {
                        const obj = args.prefabObj;
                        const support = obj.getEditorSupport();
                        if (support.isLockedProperty(sceneobjects.TextureComponent.texture)) {
                            call.arg("texture");
                            call.arg("frame");
                        }
                        else {
                            const texture = sceneobjects.TextureComponent.texture.getValue(obj);
                            const key = texture.key || "__DEFAULT";
                            const frame = texture.frame;
                            call.arg("texture || " + code.CodeDOM.quote(key));
                            let frameCode;
                            if (typeof frame === "string") {
                                frameCode = code.CodeDOM.quote(frame);
                            }
                            else if (typeof frame === "number") {
                                frameCode = frame.toString();
                            }
                            if (frameCode) {
                                call.arg("frame ?? " + frameCode);
                            }
                            else {
                                call.arg("frame");
                            }
                        }
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                        ctr.arg("texture", "string", true);
                        ctr.arg("frame", "number | string", true);
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const obj = args.obj;
                        const support = obj.getEditorSupport();
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        if (support.isUnlockedProperty(sceneobjects.TextureComponent.texture)) {
                            this.addTextureFrameArgsToObjectFactoryMethodCallDOM(args.methodCallDOM, args.obj);
                        }
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM(this.getFactoryMethodName(obj), args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        this.addTextureFrameArgsToObjectFactoryMethodCallDOM(call, args.obj);
                        return call;
                    }
                    addTextureFrameArgsToObjectFactoryMethodCallDOM(call, obj) {
                        const texture = sceneobjects.TextureComponent.texture.getValue(obj);
                        if (texture.key) {
                            call.argLiteral(texture.key);
                            call.argStringOrInt(texture.frame);
                        }
                        else {
                            call.argLiteral("_MISSING");
                        }
                    }
                }
                sceneobjects.BaseImageCodeDOMBuilder = BaseImageCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_52) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BaseImageEditorSupport extends sceneobjects.GameObjectEditorSupport {
                    constructor(extension, obj, scene, includeTextureComponent = true, includeAlphaComponent = true, includeFlipComponent = true, includeTint = true) {
                        super(extension, obj, scene);
                        // texture
                        if (includeTextureComponent) {
                            this.addComponent(new sceneobjects.TextureComponent(obj));
                        }
                        // transform
                        // origin
                        this.addComponent(new sceneobjects.TransformComponent(obj), new sceneobjects.OriginComponent(obj));
                        // flip
                        if (includeFlipComponent) {
                            this.addComponent(new sceneobjects.FlipComponent(obj));
                        }
                        // visible
                        this.addComponent(new sceneobjects.VisibleComponent(obj));
                        // alpha
                        if (includeAlphaComponent) {
                            this.addComponent(new sceneobjects.AlphaComponent(obj));
                        }
                        // tint
                        if (includeTint) {
                            this.addComponent(new sceneobjects.TintComponent(obj));
                        }
                        // arcade
                        this.addComponent(new sceneobjects.ArcadeComponent(obj, false));
                    }
                    getCellRenderer() {
                        return new sceneobjects.TextureCellRenderer();
                    }
                    getTextureComponent() {
                        return this.getComponent(sceneobjects.TextureComponent);
                    }
                    setInteractive() {
                        this.getObject().setInteractive(undefined, sceneobjects.interactive_getAlpha_SharedTexture);
                    }
                }
                sceneobjects.BaseImageEditorSupport = BaseImageEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_52.ui || (scene_52.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_53) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BaseImageExtension extends sceneobjects.SceneGameObjectExtension {
                    static async getAssetsFromObjectWithTextureData(args) {
                        const { key } = args.serializer.read(sceneobjects.TextureComponent.texture.name, {});
                        const finder = args.finder;
                        const item = finder.findAssetPackItem(key);
                        if (item) {
                            return [item];
                        }
                        return [];
                    }
                    async getAssetsFromObjectData(args) {
                        const assets1 = await BaseImageExtension.getAssetsFromObjectWithTextureData(args);
                        // Maybe it contains FX objects depending on textures
                        const assets2 = await sceneobjects.ContainerExtension.getAssetsFromNestedData(args);
                        return [...assets1, ...assets2];
                    }
                    static isImageOrImageFrameAsset(data) {
                        return data instanceof phasereditor2d.pack.core.AssetPackImageFrame || data instanceof phasereditor2d.pack.core.ImageAssetPackItem;
                    }
                    acceptsDropData(data) {
                        return sceneobjects.ImageExtension.isImageOrImageFrameAsset(data);
                    }
                    createDefaultSceneObject(args) {
                        let key;
                        let frame;
                        if (args.extraData) {
                            const result = this.getKeyFrameFromAsset(args.extraData);
                            key = result.key;
                            frame = result.frame;
                        }
                        const obj = this.createImageObject(args.scene, args.x, args.y, key, frame);
                        if (key) {
                            const textureComponent = obj.getEditorSupport().getComponent(sceneobjects.TextureComponent);
                            textureComponent.setTextureKeys({ key, frame });
                        }
                        return [obj];
                    }
                    getKeyFrameFromAsset(data) {
                        let key;
                        let frame;
                        let baseLabel;
                        if (data instanceof phasereditor2d.pack.core.AssetPackImageFrame) {
                            const packItem = data.getPackItem();
                            key = packItem.getKey();
                            frame = data.getName();
                            baseLabel = frame.toString();
                            if (packItem instanceof phasereditor2d.pack.core.SpritesheetAssetPackItem) {
                                baseLabel = key + frame.toString();
                            }
                        }
                        else if (data instanceof phasereditor2d.pack.core.ImageAssetPackItem) {
                            key = data.getKey();
                            frame = undefined;
                            baseLabel = key;
                        }
                        return { key, frame, baseLabel };
                    }
                    createSceneObjectWithAsset(args) {
                        const { key, frame, baseLabel } = this.getKeyFrameFromAsset(args.asset);
                        const obj = this.createImageObject(args.scene, args.x, args.y, key, frame);
                        const objES = obj.getEditorSupport();
                        objES.setLabel(baseLabel);
                        const textureComponent = objES.getComponent(sceneobjects.TextureComponent);
                        textureComponent.setTextureKeys({ key, frame });
                        return obj;
                    }
                    createGameObjectWithData(args) {
                        let key;
                        let frame;
                        const textureData = args.data;
                        if (textureData.texture) {
                            key = textureData.texture.key;
                            frame = textureData.texture.frame;
                        }
                        const sprite = this.createImageObject(args.scene, 0, 0, key, frame);
                        sprite.getEditorSupport().readJSON(args.data);
                        return sprite;
                    }
                    async collectTextureDataCreateDefaultObject(editor) {
                        const selected = await sceneobjects.TextureSelectionDialog.selectOneTexture(editor, [], "No Texture");
                        const ext = scene_53.ScenePlugin.getInstance().getLoaderUpdaterForAsset(selected);
                        if (ext) {
                            await ext.updateLoader(editor.getScene(), selected);
                        }
                        return {
                            data: selected
                        };
                    }
                    createImageObject(scene, x, y, key, frame) {
                        const sprite = this.newObject(scene, x, y, key, frame);
                        return sprite;
                    }
                    adaptDataAfterTypeConversion(serializer, originalObject, extraData) {
                        const support = originalObject.getEditorSupport();
                        if (support.isPrefabInstance()) {
                            const textureComponent = support.getComponent(sceneobjects.TextureComponent);
                            if (extraData.keepOriginalTexture) {
                                // create a new serializer with the original prefab
                                // so we can find the real texture, and keep it.
                                const data2 = JSON.parse(JSON.stringify(serializer.getData()));
                                data2.prefabId = support.getPrefabId();
                                const serializer2 = serializer.getSerializer(data2);
                                const keys = serializer2.read(sceneobjects.TextureComponent.texture.name, {});
                                // we write the texture directly into the data, bypassing unlocking validation of the serializer
                                colibri.core.json.write(serializer.getData(), sceneobjects.TextureComponent.texture.name, keys);
                            }
                            else {
                                const keys = textureComponent.getTextureKeys();
                                serializer.write(sceneobjects.TextureComponent.texture.name, keys, {});
                            }
                        }
                        if (extraData.keepOriginalTexture) {
                            serializer.setUnlocked(sceneobjects.TextureComponent.texture.name, true);
                        }
                    }
                }
                sceneobjects.BaseImageExtension = BaseImageExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_53.ui || (scene_53.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_54) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Image extends Phaser.GameObjects.Image {
                    _editorSupport;
                    constructor(scene, x, y, texture, frame) {
                        super(scene, x, y, texture, frame);
                        this._editorSupport = new sceneobjects.ImageEditorSupport(this, scene);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.Image = Image;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_54.ui || (scene_54.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_55) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ImageEditorSupport extends sceneobjects.BaseImageEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.ImageExtension.getInstance(), obj, scene);
                    }
                }
                sceneobjects.ImageEditorSupport = ImageEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_55.ui || (scene_55.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseImageExtension.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_56) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ImageExtension extends sceneobjects.BaseImageExtension {
                    static _instance;
                    static getInstance() {
                        return this._instance ?? (this._instance = new ImageExtension());
                    }
                    constructor() {
                        super({
                            typeName: "Image",
                            phaserTypeName: "Phaser.GameObjects.Image",
                            category: scene_56.SCENE_OBJECT_IMAGE_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_IMAGE_TYPE)
                        });
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.BaseImageCodeDOMBuilder("image");
                    }
                    newObject(scene, x, y, key, frame) {
                        return new sceneobjects.Image(scene, x, y, key || null, frame);
                    }
                }
                sceneobjects.ImageExtension = ImageExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_56.ui || (scene_56.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_57) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class KeyboardKey {
                    keyCode;
                    _editorSupport;
                    constructor(scene, keyCode = "SPACE") {
                        this.keyCode = keyCode;
                        this._editorSupport = new sceneobjects.KeyboardKeyEditorSupport(scene, this);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.KeyboardKey = KeyboardKey;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_57.ui || (scene_57.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class KeyboardKeyComponent extends sceneobjects.PlainObjectComponent {
                    static keyCode = sceneobjects.SimpleProperty("keyCode", "SPACE", "Key Code", "The keycode of this key.", true);
                    constructor(obj) {
                        super(obj, KeyboardKeyComponent.keyCode);
                    }
                }
                sceneobjects.KeyboardKeyComponent = KeyboardKeyComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_58) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class KeyboardKeyEditorSupport extends sceneobjects.ScenePlainObjectEditorSupport {
                    constructor(scene, obj) {
                        super(sceneobjects.KeyboardKeyExtension.getInstance(), obj, scene, new sceneobjects.KeyboardKeyComponent(obj));
                    }
                    destroy() {
                        // nothing
                    }
                    async buildDependencyHash(args) {
                        // nothing
                    }
                }
                sceneobjects.KeyboardKeyEditorSupport = KeyboardKeyEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_58.ui || (scene_58.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class KeyboardKeyExtension extends sceneobjects.ScenePlainObjectExtension {
                    static _instance = new KeyboardKeyExtension();
                    static getInstance() {
                        return this._instance;
                    }
                    constructor() {
                        super({
                            category: scene.SCENE_OBJECT_INPUT_CATEGORY,
                            phaserTypeName: "Phaser.Input.Keyboard.Key",
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_KEYBOARD_KEY),
                            typeName: "Keyboard.Key",
                        });
                    }
                    createPlainObjectWithData(args) {
                        const key = new sceneobjects.KeyboardKey(args.scene);
                        key.getEditorSupport().readJSON(args.data);
                        return key;
                    }
                    async getAssetsFromObjectData(args) {
                        return [];
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const sceneCtx = obj.getEditorSupport().getScene().isPrefabSceneType() ? "this.scene" : "this";
                        const call = new scene.core.code.MethodCallCodeDOM("addKey", `${sceneCtx}.input.keyboard`);
                        call.setOptionalContext(true);
                        call.arg(`Phaser.Input.Keyboard.KeyCodes.${obj.keyCode}`);
                        return {
                            firstStatements: [call],
                            objectFactoryMethodCall: call,
                        };
                    }
                    createDefaultSceneObject(args) {
                        return [new sceneobjects.KeyboardKey(args.scene)];
                    }
                    _keyCodes;
                    getKeyCodes() {
                        if (!this._keyCodes) {
                            this._keyCodes = [];
                            for (const k in Phaser.Input.Keyboard.KeyCodes) {
                                this._keyCodes.push(k);
                            }
                        }
                        return this._keyCodes;
                    }
                }
                sceneobjects.KeyboardKeyExtension = KeyboardKeyExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PlainObjectSection extends sceneobjects.SceneObjectSection {
                    createDefaultGridElement(parent) {
                        const comp = this.createGridElement(parent, 2);
                        comp.style.gridTemplateColumns = "auto 1fr";
                        return comp;
                    }
                    createPropertyObjectVar(parent, prop) {
                        const labelElement = this.createLabel(parent, prop.label, scene.PhaserHelp(prop.tooltip));
                        const { textElement } = this.createObjectVarField(parent, prop);
                        return { labelElement, textElement };
                    }
                    createPropertyString(parent, prop) {
                        const labelElement = this.createLabel(parent, prop.label, scene.PhaserHelp(prop.tooltip));
                        const textElement = this.createStringField(parent, prop);
                        return { labelElement, textElement };
                    }
                    createPropertyBoolean(parent, prop) {
                        const elements = this.createBooleanField(parent, prop);
                        return elements;
                    }
                }
                sceneobjects.PlainObjectSection = PlainObjectSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../object/properties/PlainObjectSection.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class KeyboardKeySection extends sceneobjects.PlainObjectSection {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.KeybardKeySection";
                    constructor(page) {
                        super(page, KeyboardKeySection.ID, "Keyboard Key", false, false);
                    }
                    createForm(parent) {
                        const comp = this.createDefaultGridElement(parent);
                        this.createLabel(comp, "Key Code", "The keycode of this key");
                        this.createKeyCodeField(comp, sceneobjects.KeyboardKeyComponent.keyCode);
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.KeyboardKey;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.KeyboardKeySection = KeyboardKeySection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class KeyboardKeysViewer extends controls.viewers.TreeViewer {
                    constructor() {
                        super("KeyboardKeysViewer");
                        this.setLabelProvider(new controls.viewers.LabelProvider(obj => obj));
                        this.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        this.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider());
                        this.setInput(sceneobjects.KeyboardKeyExtension.getInstance().getKeyCodes());
                    }
                }
                sceneobjects.KeyboardKeysViewer = KeyboardKeysViewer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../editor/undo/SceneSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_59) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class CreateLayerWithObjectsOperation extends ui.editor.undo.SceneSnapshotOperation {
                    findParentLayer(obj) {
                        const parent = obj.getEditorSupport().getObjectParent();
                        if (parent) {
                            if (parent instanceof sceneobjects.Layer) {
                                return parent;
                            }
                            return this.findParentLayer(parent);
                        }
                        return null;
                    }
                    async performModification() {
                        const scene = this.getScene();
                        const [layer] = sceneobjects.LayerExtension.getInstance().createDefaultSceneObject({
                            scene: this.getScene(),
                            x: 0,
                            y: 0
                        });
                        layer.getEditorSupport().setLabel(scene.makeNewName("layer"));
                        const list = [...this._editor.getSelectedGameObjects()];
                        scene.sortObjectsByRenderingOrder(list);
                        let newParent;
                        for (const obj of list) {
                            const objParent = this.findParentLayer(obj);
                            if (objParent && objParent instanceof sceneobjects.Layer) {
                                if (newParent) {
                                    if (newParent.getEditorSupport().isDescendentOf(objParent)) {
                                        newParent = objParent;
                                    }
                                }
                                else {
                                    newParent = objParent;
                                }
                            }
                        }
                        if (newParent) {
                            scene.removeGameObject(layer);
                            const newParentES = newParent.getEditorSupport();
                            newParentES.addObjectChild(layer);
                            newParentES.sortObjectChildren();
                        }
                        else {
                            scene.sortGameObjects();
                        }
                        for (const obj of list) {
                            const sprite = obj;
                            const worldPoint = new Phaser.Math.Vector2(0, 0);
                            sprite.getWorldTransformMatrix().transformPoint(0, 0, worldPoint);
                            const objParent = obj.getEditorSupport().getObjectParent();
                            if (objParent) {
                                objParent.getEditorSupport().removeObjectChild(sprite);
                            }
                            else {
                                scene.removeGameObject(sprite);
                            }
                            layer.getEditorSupport().addObjectChild(sprite);
                            sprite.x = worldPoint.x;
                            sprite.y = worldPoint.y;
                        }
                        this.getEditor().setSelection([layer]);
                    }
                }
                sceneobjects.CreateLayerWithObjectsOperation = CreateLayerWithObjectsOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_59.ui || (scene_59.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_60) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Layer extends Phaser.GameObjects.Layer {
                    _editorSupport;
                    constructor(scene, list) {
                        super(scene, list);
                        this._editorSupport = new sceneobjects.LayerEditorSupport(this, scene);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                    // polyfill GameObject methods
                    setData(key, data) {
                        return super.setData(key, data);
                    }
                    incData(key, data) {
                        return super.incData(key, data);
                    }
                    toggleData(key) {
                        return super.toggleData(key);
                    }
                    replace(oldChild, newChild) {
                        newChild.displayList = this;
                        return super.replace(oldChild, newChild);
                    }
                    setInteractive(hitArea, callback, dropZone) {
                        return this;
                    }
                    disableInteractive() {
                        return this;
                    }
                    removeInteractive() {
                        return this;
                    }
                    getIndexList() {
                        return [];
                    }
                    eventNames() {
                        return super["evenNames"]();
                    }
                    // tslint:disable-next-line:ban-types
                    listeners(event) {
                        return super["listeners"](event);
                    }
                    listenerCount(event) {
                        return super["listenerCount"](event);
                    }
                    emit(event, ...args) {
                        return super["emit"](event, ...args);
                    }
                    // tslint:disable-next-line:ban-types
                    on(event, fn, context) {
                        return super["on"](event, fn, context);
                    }
                    // tslint:disable-next-line:ban-types
                    addListener(event, fn, context) {
                        return super["addListener"](event, fn, context);
                    }
                    // tslint:disable-next-line:ban-types
                    once(event, fn, context) {
                        return super["once"](event, fn, context);
                    }
                    // tslint:disable-next-line:ban-types
                    removeListener(event, fn, context, once) {
                        return super["removeListener"](event, fn, context, once);
                    }
                    // tslint:disable-next-line:ban-types
                    off(event, fn, context, once) {
                        return super["off"](event, fn, context, once);
                    }
                    // tslint:disable-next-line:ban-types
                    removeAllListeners(event) {
                        return super["removeAllListeners"](event);
                    }
                    // tslint:disable-next-line:ban-types
                    addToDisplayList(displayList) {
                        return super["addToDisplayList"](displayList);
                    }
                    // tslint:disable-next-line:ban-types
                    addToUpdateList() {
                        return super["addToUpdateList"]();
                    }
                    // tslint:disable-next-line:ban-types
                    removeFromDisplayList() {
                        return Phaser.GameObjects.GameObject.prototype.removeFromDisplayList.call(this);
                    }
                    // tslint:disable-next-line:ban-types
                    removeFromUpdateList() {
                        return Phaser.GameObjects.GameObject.prototype.removeFromUpdateList.call(this);
                    }
                }
                sceneobjects.Layer = Layer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_60.ui || (scene_60.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class LayerCodeDOMBuilder extends sceneobjects.GameObjectCodeDOMBuilder {
                    static _instance = new LayerCodeDOMBuilder();
                    static getInstance() {
                        return this._instance;
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        // nothing
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        // nothing
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const call = new code.MethodCallCodeDOM("layer", args.gameObjectFactoryExpr);
                        return call;
                    }
                }
                sceneobjects.LayerCodeDOMBuilder = LayerCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_61) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class LayerEditorSupport extends sceneobjects.DisplayParentGameObjectEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.LayerExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.VisibleComponent(obj), new sceneobjects.AlphaSingleComponent(obj), new sceneobjects.ChildrenComponent(obj));
                    }
                    getScreenBounds(camera) {
                        const children = this.getObjectChildren();
                        if (children.length === 0) {
                            return [];
                        }
                        const minPoint = new Phaser.Math.Vector2(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
                        const maxPoint = new Phaser.Math.Vector2(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
                        const points = [];
                        for (const obj of children) {
                            const bounds = obj.getEditorSupport().getScreenBounds(camera);
                            points.push(...bounds);
                        }
                        for (const point of points) {
                            minPoint.x = Math.min(minPoint.x, point.x);
                            minPoint.y = Math.min(minPoint.y, point.y);
                            maxPoint.x = Math.max(maxPoint.x, point.x);
                            maxPoint.y = Math.max(maxPoint.y, point.y);
                        }
                        return [
                            new Phaser.Math.Vector2(minPoint.x, minPoint.y),
                            new Phaser.Math.Vector2(maxPoint.x, minPoint.y),
                            new Phaser.Math.Vector2(maxPoint.x, maxPoint.y),
                            new Phaser.Math.Vector2(minPoint.x, maxPoint.y)
                        ];
                    }
                }
                sceneobjects.LayerEditorSupport = LayerEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_61.ui || (scene_61.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_62) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class LayerExtension extends sceneobjects.SceneGameObjectExtension {
                    static _instance;
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new LayerExtension());
                    }
                    constructor() {
                        super({
                            category: scene_62.SCENE_OBJECT_GROUPING_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_LAYER),
                            phaserTypeName: "Phaser.GameObjects.Layer",
                            typeName: "Layer"
                        });
                    }
                    adaptDataAfterTypeConversion(serializer, originalObject, extraData) {
                        if (originalObject instanceof sceneobjects.Container) {
                            const containerData = serializer.getData();
                            const children = originalObject.getEditorSupport().getObjectChildren();
                            // tslint:disable-next-line:prefer-for-of
                            for (let i = 0; i < children.length; i++) {
                                const child = children[i];
                                if (child.getEditorSupport().hasComponent(sceneobjects.TransformComponent)) {
                                    const sprite = child;
                                    const p = new Phaser.Math.Vector2();
                                    sprite.getWorldTransformMatrix().transformPoint(0, 0, p);
                                    const spriteData = containerData.list[i];
                                    if (spriteData) {
                                        spriteData["x"] = p.x;
                                        spriteData["y"] = p.y;
                                    }
                                }
                            }
                        }
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        return null;
                    }
                    createGameObjectWithData(args) {
                        const container = this.createLayerObject(args.scene, []);
                        container.getEditorSupport().readJSON(args.data);
                        return container;
                    }
                    createLayerObject(scene, list) {
                        const layer = new sceneobjects.Layer(scene, list);
                        layer.getEditorSupport().setScene(scene);
                        scene.addGameObject(layer);
                        return layer;
                    }
                    async getAssetsFromObjectData(args) {
                        return sceneobjects.ContainerExtension.getAssetsFromNestedData(args);
                    }
                    createDefaultSceneObject(args) {
                        return [this.createLayerObject(args.scene, [])];
                    }
                    getCodeDOMBuilder() {
                        return sceneobjects.LayerCodeDOMBuilder.getInstance();
                    }
                }
                sceneobjects.LayerExtension = LayerExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_62.ui || (scene_62.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ListVariableSection extends ui.editor.properties.BaseSceneSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ListVariableSection", "Variable", false);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        {
                            // Name
                            this.createLabel(comp, "Name");
                            const text = this.createText(comp);
                            text.addEventListener("change", e => {
                                this.performChange(list => {
                                    list.setLabel(text.value);
                                });
                            });
                            this.addUpdater(() => {
                                text.value = this.getSelectionFirstElement().getLabel();
                            });
                        }
                        {
                            // Type
                            this.createLabel(comp, "Type");
                            const text = this.createText(comp, true);
                            this.addUpdater(() => {
                                const map = this.getEditor().getScene().buildObjectIdMap();
                                text.value = this.getSelectionFirstElement().inferType(map);
                            });
                        }
                        {
                            // Scope
                            this.createLabel(comp, "Scope", "The lexical scope of the object.");
                            // I skip the LOCAL scope here because a List without a variable
                            // has no sense
                            const items = [{
                                    name: "METHOD",
                                    value: sceneobjects.ObjectScope.METHOD
                                }, {
                                    name: "CLASS",
                                    value: sceneobjects.ObjectScope.CLASS
                                }, {
                                    name: "PUBLIC",
                                    value: sceneobjects.ObjectScope.PUBLIC
                                }];
                            const btn = this.createMenuButton(comp, "", () => items, scope => {
                                this.performChange(list => {
                                    list.setScope(scope);
                                });
                            });
                            this.addUpdater(() => {
                                btn.textContent = items
                                    .find(item => item.value === this.getSelectionFirstElement().getScope())
                                    .name;
                            });
                        }
                    }
                    performChange(performChange) {
                        this.getUndoManager().add(new sceneobjects.ChangeListOperation(this.getEditor(), this.getSelectionFirstElement(), performChange));
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.ObjectList;
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.ListVariableSection = ListVariableSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_63) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ObjectList {
                    _id;
                    _label;
                    _scope;
                    _objectIds;
                    _items;
                    constructor() {
                        this._id = Phaser.Utils.String.UUID();
                        this._label = "list";
                        this._scope = sceneobjects.ObjectScope.CLASS;
                        this._objectIds = [];
                        this._items = [];
                    }
                    getItemsWithObjects(scene) {
                        const map = scene.buildObjectIdMap();
                        for (const item of this._items) {
                            item.setObject(map.get(item.getObjectId()));
                        }
                        return this._items.filter(item => Boolean(item.getObject()));
                    }
                    updateOrderIdsFromItems() {
                        this._objectIds = this._items.map(i => i.getObjectId());
                    }
                    removeItem(id) {
                        this._items = this._items.filter(i => i.getId() !== id);
                        this._objectIds = this._items.map(i => i.getObjectId());
                    }
                    getItems() {
                        return this._items;
                    }
                    getObjectIds() {
                        return this._objectIds;
                    }
                    setObjectsIds(ids) {
                        this._objectIds = ids;
                        this._items = this._objectIds.map(id => new sceneobjects.ObjectListItem(this, id));
                    }
                    getId() {
                        return this._id;
                    }
                    setId(id) {
                        this._id = id;
                    }
                    getLabel() {
                        return this._label;
                    }
                    setLabel(label) {
                        this._label = label;
                    }
                    getScope() {
                        return this._scope;
                    }
                    setScope(scope) {
                        this._scope = scope;
                    }
                    inferType(objMap) {
                        const types = new Set(this.getObjectIds()
                            .map(id => objMap.get(id))
                            .filter(obj => obj !== undefined)
                            .map(obj => {
                            const support = obj.getEditorSupport();
                            if (support.isPrefabInstance()) {
                                return support.getPrefabName();
                            }
                            return support.getPhaserType();
                        }));
                        let listType = [...types].join("|");
                        if (types.size === 0) {
                            listType = "Array<any>";
                        }
                        else if (types.size === 1) {
                            listType = listType + "[]";
                        }
                        else {
                            listType = "Array<" + listType + ">";
                        }
                        return listType;
                    }
                    readJSON(data) {
                        this._id = data.id;
                        this._label = data.label;
                        this._scope = data.scope || sceneobjects.ObjectScope.CLASS;
                        this.setObjectsIds(data.objectIds || []);
                    }
                    writeJSON(data) {
                        data.id = this._id;
                        data.label = this._label;
                        data.objectIds = this._objectIds.length === 0 ? undefined : [...this._objectIds];
                        data.scope = this._scope === sceneobjects.ObjectScope.CLASS ? undefined : this._scope;
                    }
                }
                sceneobjects.ObjectList = ObjectList;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_63.ui || (scene_63.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ObjectListItem {
                    _parent;
                    _objectId;
                    _obj;
                    constructor(parent, objectId) {
                        this._parent = parent;
                        this._objectId = objectId;
                    }
                    getParent() {
                        return this._parent;
                    }
                    getId() {
                        return `ListItem#${this._objectId}`;
                    }
                    getObjectId() {
                        return this._objectId;
                    }
                    getObject() {
                        return this._obj;
                    }
                    setObject(obj) {
                        this._obj = obj;
                    }
                }
                sceneobjects.ObjectListItem = ObjectListItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ObjectListItemCellRenderer {
                    _objRenderer;
                    constructor(objRenderer) {
                        this._objRenderer = objRenderer;
                    }
                    adaptArgs(args) {
                        const args2 = args.clone();
                        args2.obj = args2.obj.getObject();
                        return args2;
                    }
                    renderCell(args) {
                        this._objRenderer.renderCell(this.adaptArgs(args));
                    }
                    cellHeight(args) {
                        return this._objRenderer.cellHeight(this.adaptArgs(args));
                    }
                    preload(args) {
                        const clone = args.clone();
                        clone.obj = clone.obj.getObject();
                        return this._objRenderer.preload(clone);
                    }
                    get layout() {
                        return this._objRenderer.layout;
                    }
                }
                sceneobjects.ObjectListItemCellRenderer = ObjectListItemCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ObjectListItemSection extends ui.editor.properties.BaseSceneSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ObjectListItemSection", "List Item");
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        {
                            this.createLabel(comp, "Name", "The object's name.");
                            const field = this.createText(comp, true);
                            this.addUpdater(() => {
                                const labels = this.getSelectedGameObjects()
                                    .map(obj => obj.getEditorSupport().getLabel());
                                field.value = this.flatValues_StringOneOrNothing(labels);
                            });
                        }
                        {
                            const btn = this.createButton(comp, "Select Game Object", () => {
                                this.getEditor().setSelection(this.getSelectedGameObjects());
                            });
                            btn.style.gridColumn = "1 / span 2";
                        }
                    }
                    getSelectedGameObjects() {
                        const map = this.getEditor().getScene().buildObjectIdMap();
                        return this.getSelection()
                            .map(item => item.getObjectId())
                            .map(id => map.get(id))
                            .filter(obj => Boolean(obj));
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.ObjectListItem;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.ObjectListItemSection = ObjectListItemSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ObjectLists {
                    _lists;
                    constructor() {
                        this._lists = [];
                    }
                    getLists() {
                        return this._lists;
                    }
                    getListById(id) {
                        return this._lists.find(list => list.getId() === id);
                    }
                    getListsByObjectId(objectId) {
                        const result = this._lists
                            .filter(list => list.getObjectIds().findIndex(id => id === objectId) >= 0);
                        return result;
                    }
                    readJSON_lists(listsArray) {
                        this._lists = [];
                        for (const listData of listsArray) {
                            const list = new sceneobjects.ObjectList();
                            list.readJSON(listData);
                            this._lists.push(list);
                        }
                    }
                    readJSON(sceneData) {
                        const lists = sceneData.lists;
                        if (Array.isArray(lists)) {
                            this.readJSON_lists(lists);
                        }
                        else {
                            this._lists = [];
                        }
                    }
                    writeJSON(sceneData) {
                        sceneData.lists = undefined;
                        if (this._lists.length > 0) {
                            sceneData.lists = this.toJSON_lists();
                        }
                    }
                    toJSON_lists() {
                        const listsData = [];
                        for (const list of this._lists) {
                            const listData = {};
                            list.writeJSON(listData);
                            listsData.push(listData);
                        }
                        return listsData;
                    }
                    removeListById(id) {
                        const i = this._lists.findIndex(l => l.getId() === id);
                        if (i >= 0) {
                            this._lists.splice(i, 1);
                        }
                    }
                    removeObjectById(objId) {
                        for (const list of this._lists) {
                            const i = list.getObjectIds().findIndex(id => id === objId);
                            if (i >= 0) {
                                list.getObjectIds().splice(i, 1);
                            }
                        }
                    }
                }
                sceneobjects.ObjectLists = ObjectLists;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_64) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ListsSnapshotOperation extends ui.editor.undo.SceneEditorOperation {
                    _before;
                    _after;
                    _selection;
                    constructor(editor) {
                        super(editor);
                    }
                    async execute() {
                        const scene = this._editor.getScene();
                        const lists = scene.getObjectLists();
                        this._before = lists.toJSON_lists();
                        this._selection = this._editor.getSelectionManager().getSelectionIds();
                        this.performChange(lists);
                        this._after = lists.toJSON_lists();
                        this.loadData(this._after);
                    }
                    loadData(data) {
                        const lists = this._editor.getScene().getObjectLists();
                        lists.readJSON_lists(data);
                        this._editor.setDirty(true);
                        this._editor.refreshOutline();
                        this._editor.getSelectionManager().setSelectionByIds(this._selection);
                    }
                    undo() {
                        this.loadData(this._before);
                    }
                    redo() {
                        this.loadData(this._after);
                    }
                }
                sceneobjects.ListsSnapshotOperation = ListsSnapshotOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_64.ui || (scene_64.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./ListsSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AddObjectListOperation extends sceneobjects.ListsSnapshotOperation {
                    _list;
                    constructor(editor, list) {
                        super(editor);
                        this._list = list;
                    }
                    performChange(lists) {
                        lists.getLists().push(this._list);
                        this._editor.refreshOutline();
                        this._editor.setSelection([this._list]);
                    }
                }
                sceneobjects.AddObjectListOperation = AddObjectListOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AddObjectsToListOperation extends sceneobjects.ListsSnapshotOperation {
                    _objects;
                    _list;
                    constructor(editor, list, objects) {
                        super(editor);
                        this._list = list;
                        this._objects = objects;
                    }
                    performChange(lists) {
                        this._list.getObjectIds().push(...this._objects.map(obj => obj.getEditorSupport().getId()));
                        delete this._list;
                        delete this._objects;
                    }
                }
                sceneobjects.AddObjectsToListOperation = AddObjectsToListOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AddObjectsToNewListOperation extends sceneobjects.ListsSnapshotOperation {
                    _objects;
                    _label;
                    constructor(editor, label, objects) {
                        super(editor);
                        this._label = label;
                        this._objects = objects;
                    }
                    performChange(lists) {
                        const list = new sceneobjects.ObjectList();
                        list.setLabel(this._label);
                        list.getObjectIds().push(...this._objects.map(obj => obj.getEditorSupport().getId()));
                        lists.getLists().push(list);
                    }
                }
                sceneobjects.AddObjectsToNewListOperation = AddObjectsToNewListOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ChangeListOperation extends ui.editor.undo.SceneEditorOperation {
                    _performChange;
                    _list;
                    _before;
                    _after;
                    constructor(editor, list, performChange) {
                        super(editor);
                        this._list = list;
                        this._performChange = performChange;
                    }
                    async execute() {
                        this._before = {};
                        this._list.writeJSON(this._before);
                        this._performChange(this._list);
                        this._after = {};
                        this._list.writeJSON(this._after);
                        delete this._list;
                        this.loadData(this._after);
                    }
                    loadData(listData) {
                        const list = this._editor.getScene().getObjectLists().getListById(listData.id);
                        list.readJSON(listData);
                        this._editor.setDirty(true);
                        this._editor.refreshOutline();
                        this._editor.dispatchSelectionChanged();
                    }
                    undo() {
                        this.loadData(this._before);
                    }
                    redo() {
                        this.loadData(this._after);
                    }
                }
                sceneobjects.ChangeListOperation = ChangeListOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ListOrderOperation extends sceneobjects.ListsSnapshotOperation {
                    _depthMove;
                    constructor(editor, depthMove) {
                        super(editor);
                        this._depthMove = depthMove;
                    }
                    static allow(editor, move) {
                        // sort the selection and filter off non-game-objects
                        let sel = this.sortedSelection(editor);
                        // if the sorted selection contains all the selected objects
                        if (sel.length !== editor.getSelection().length) {
                            return false;
                        }
                        for (const obj of sel) {
                            //const parent = obj.getEditorSupport().getObjectParent();
                            const siblings = obj.getParent().getItems();
                            const index = siblings.indexOf(obj);
                            const len = siblings.length;
                            if (move === "Bottom" || move === "Down") {
                                if (index === len - 1) {
                                    return false;
                                }
                            }
                            else { // Top || Up
                                if (index === 0) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    static sortedSelection(editor) {
                        const sel = editor.getSelectedListItems();
                        sel.sort((a, b) => {
                            const aa = a.getParent().getItems().indexOf(a);
                            const bb = a.getParent().getItems().indexOf(b);
                            return aa - bb;
                        });
                        return sel;
                    }
                    performChange(lists) {
                        const editor = this.getEditor();
                        const sel = ListOrderOperation.sortedSelection(editor);
                        switch (this._depthMove) {
                            case "Bottom":
                                for (const obj of sel) {
                                    const siblings = obj.getParent().getItems();
                                    Phaser.Utils.Array.BringToTop(siblings, obj);
                                    obj.getParent().updateOrderIdsFromItems();
                                }
                                break;
                            case "Top":
                                for (let i = 0; i < sel.length; i++) {
                                    const obj = sel[sel.length - i - 1];
                                    const siblings = obj.getParent().getItems();
                                    Phaser.Utils.Array.SendToBack(siblings, obj);
                                    obj.getParent().updateOrderIdsFromItems();
                                }
                                break;
                            case "Down":
                                for (let i = 0; i < sel.length; i++) {
                                    const obj = sel[sel.length - i - 1];
                                    const siblings = obj.getParent().getItems();
                                    Phaser.Utils.Array.MoveUp(siblings, obj);
                                    obj.getParent().updateOrderIdsFromItems();
                                }
                                break;
                            case "Up":
                                for (const obj of sel) {
                                    const siblings = obj.getParent().getItems();
                                    Phaser.Utils.Array.MoveDown(siblings, obj);
                                    obj.getParent().updateOrderIdsFromItems();
                                }
                                break;
                        }
                    }
                }
                sceneobjects.ListOrderOperation = ListOrderOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class NewListOperation extends sceneobjects.ListsSnapshotOperation {
                    performChange(lists) {
                        const list = new sceneobjects.ObjectList();
                        list.setLabel(this.getEditor().getScene().makeNewName("list"));
                        lists.getLists().push(list);
                        this.getEditor().setSelection([list]);
                    }
                }
                sceneobjects.NewListOperation = NewListOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./ListsSnapshotOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RemoveObjectListOperation extends sceneobjects.ListsSnapshotOperation {
                    _toDeleteArray;
                    constructor(editor, toDeleteArray) {
                        super(editor);
                        this._toDeleteArray = toDeleteArray;
                    }
                    performChange(sceneLists) {
                        for (const list of this._toDeleteArray) {
                            const i = sceneLists.getLists().indexOf(list);
                            sceneLists.getLists().splice(i, 1);
                        }
                        this._editor.refreshOutline();
                        this._editor.setSelection([]);
                    }
                }
                sceneobjects.RemoveObjectListOperation = RemoveObjectListOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RemoveObjectsFromListOperation extends sceneobjects.ListsSnapshotOperation {
                    _objects;
                    _list;
                    constructor(editor, list, objects) {
                        super(editor);
                        this._list = list;
                        this._objects = objects;
                    }
                    performChange(lists) {
                        const objectsInListIds = this._list.getObjectIds();
                        const objectsIds = new Set(this._objects.map(obj => obj.getEditorSupport().getId()));
                        this._list.setObjectsIds(objectsInListIds.filter(id => !objectsIds.has(id)));
                        delete this._list;
                        delete this._objects;
                    }
                }
                sceneobjects.RemoveObjectsFromListOperation = RemoveObjectsFromListOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_65) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class NineSlice extends Phaser.GameObjects.NineSlice {
                    _editorSupport;
                    constructor(scene, x, y, texture, frame, width, height, leftWidth, rightWidth, topHeight, bottomHeight) {
                        super(scene, x, y, texture || "__MISSING", frame, width, height, leftWidth, rightWidth, topHeight, bottomHeight);
                        this._editorSupport = new sceneobjects.NineSliceEditorSupport(this, scene);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                    setTexture(key, frame) {
                        super.setTexture(key, frame);
                        if (this.is3Slice) {
                            this.setSizeToFrame();
                        }
                        return this;
                    }
                    setSize(width, height) {
                        if (this.is3Slice) {
                            super.setSize(width, this.height);
                        }
                        else {
                            super.setSize(width, height);
                        }
                        return this;
                    }
                }
                sceneobjects.NineSlice = NineSlice;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_65.ui || (scene_65.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class NineSliceCodeDOMBuilder extends sceneobjects.BaseImageCodeDOMBuilder {
                    constructor() {
                        super("nineslice");
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const obj = args.obj;
                        const objES = obj.getEditorSupport();
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        if (objES.isUnlockedProperty(sceneobjects.TextureComponent.texture)) {
                            this.addTextureFrameArgsToObjectFactoryMethodCallDOM(args.methodCallDOM, args.obj);
                        }
                        else {
                            call.argUndefined();
                            call.argUndefined();
                        }
                        if (obj.getEditorSupport().isUnlockedPropertyXY(sceneobjects.SizeComponent.size)) {
                            call.argFloat(obj.width);
                            call.argFloat(obj.height);
                        }
                        else {
                            call.argUndefined();
                            call.argUndefined();
                        }
                        for (const prop of [
                            sceneobjects.NineSliceComponent.leftWidth,
                            sceneobjects.NineSliceComponent.rightWidth,
                            sceneobjects.NineSliceComponent.topHeight,
                            sceneobjects.NineSliceComponent.bottomHeight
                        ]) {
                            if (objES.isUnlockedProperty(prop)) {
                                call.argFloat(prop.getValue(obj));
                            }
                            else {
                                call.arg("undefined");
                            }
                        }
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                        ctr.arg("texture", "string", true);
                        ctr.arg("frame", "number | string", true);
                        ctr.arg("width", "number", true);
                        ctr.arg("height", "number", true);
                        ctr.arg("leftWidth", "number", true);
                        ctr.arg("rightWidth", "number", true);
                        ctr.arg("topHeight", "number", true);
                        ctr.arg("bottomHeight", "number", true);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        const obj = args.prefabObj;
                        const objES = obj.getEditorSupport();
                        const call = args.superMethodCallCodeDOM;
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_TextureParameters(args, call);
                        if (objES.isUnlockedPropertyXY(sceneobjects.SizeComponent.size)) {
                            call.arg("width ?? " + obj.width);
                            call.arg("height ?? " + obj.height);
                        }
                        else {
                            call.arg("width");
                            call.arg("height");
                        }
                        for (const prop of [
                            sceneobjects.NineSliceComponent.leftWidth,
                            sceneobjects.NineSliceComponent.rightWidth,
                            sceneobjects.NineSliceComponent.topHeight,
                            sceneobjects.NineSliceComponent.bottomHeight
                        ]) {
                            if (objES.isUnlockedProperty(prop)) {
                                call.arg(prop.name + " ?? " + prop.getValue(obj));
                            }
                            else {
                                call.arg(prop.name);
                            }
                        }
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("nineslice", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        this.addTextureFrameArgsToObjectFactoryMethodCallDOM(call, obj);
                        call.argFloat(obj.width);
                        call.argFloat(obj.height);
                        call.argFloat(obj.leftWidth);
                        call.argFloat(obj.rightWidth);
                        call.argFloat(obj.topHeight);
                        call.argFloat(obj.bottomHeight);
                        return call;
                    }
                }
                sceneobjects.NineSliceCodeDOMBuilder = NineSliceCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                sceneobjects.updateVertices = (obj) => {
                    obj.updateVertices();
                    obj.updateUVs();
                };
                function sliceProperty(name, defValue, label) {
                    return {
                        name,
                        defValue,
                        label,
                        tooltip: `phaser:Phaser.GameObjects.NineSlice.${name}`,
                        local: false,
                        getValue: obj => obj[name],
                        setValue: (obj, value) => {
                            const data = {
                                leftWidth: obj.leftWidth,
                                rightWidth: obj.rightWidth,
                                topHeight: obj.topHeight,
                                bottomHeight: obj.bottomHeight
                            };
                            data[name] = value;
                            obj.setSlices(obj.width, obj.height, data.leftWidth, data.rightWidth, data.topHeight, data.bottomHeight);
                        }
                    };
                }
                class NineSliceComponent extends sceneobjects.Component {
                    static leftWidth = sliceProperty("leftWidth", 10, "L");
                    static rightWidth = sliceProperty("rightWidth", 10, "R");
                    static topHeight = sliceProperty("topHeight", 10, "T");
                    static bottomHeight = sliceProperty("bottomHeight", 10, "B");
                    static horizontalWidth = {
                        label: "Slice Width",
                        x: NineSliceComponent.leftWidth,
                        y: NineSliceComponent.rightWidth,
                    };
                    static verticalWidth = {
                        label: "Slice Height",
                        x: NineSliceComponent.topHeight,
                        y: NineSliceComponent.bottomHeight,
                    };
                    static sliceProperties = [
                        NineSliceComponent.leftWidth,
                        NineSliceComponent.rightWidth,
                        NineSliceComponent.topHeight,
                        NineSliceComponent.bottomHeight
                    ];
                    constructor(obj) {
                        super(obj, NineSliceComponent.sliceProperties);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const objES = this.getEditorSupport();
                        if (objES.isNestedPrefabInstance()) {
                            let onlySizeChanged = true;
                            for (const prop of NineSliceComponent.sliceProperties) {
                                if (objES.isUnlockedProperty(prop)) {
                                    onlySizeChanged = false;
                                }
                            }
                            if (onlySizeChanged) {
                                const sizeComponent = objES.getComponent(sceneobjects.SizeComponent);
                                sizeComponent.buildSetObjectPropertiesCodeDOM(args, false);
                            }
                            else {
                                this.buildSetObjectPropertiesWithMethodCodeDOM_FloatProperty(args, "setSlices", sceneobjects.SizeComponent.width, sceneobjects.SizeComponent.height, ...NineSliceComponent.sliceProperties);
                            }
                        }
                    }
                }
                sceneobjects.NineSliceComponent = NineSliceComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_66) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class NineSliceEditorSupport extends sceneobjects.BaseImageEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.NineSliceExtension.getInstance(), obj, scene, true, false, false, false);
                        this.addComponent(new sceneobjects.AlphaSingleComponent(obj), new sceneobjects.TintSingleComponent(obj), new sceneobjects.SizeComponent(obj), new sceneobjects.NineSliceComponent(obj));
                    }
                    setInteractive() {
                        this.getObject().setInteractive(sceneobjects.interactive_getAlpha_RenderTexture);
                    }
                    getSizeComponentGeneratesUpdateDisplayOrigin() {
                        return false;
                    }
                    isCustom_SizeComponent_buildSetObjectPropertiesCodeDOM() {
                        return true;
                    }
                    onUpdateAfterSetTexture() {
                        const obj = this.getObject();
                        obj.updateVertices();
                        obj.updateUVs();
                    }
                }
                sceneobjects.NineSliceEditorSupport = NineSliceEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_66.ui || (scene_66.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_67) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class NineSliceExtension extends sceneobjects.BaseImageExtension {
                    static _instance = new NineSliceExtension();
                    static getInstance() {
                        return this._instance;
                    }
                    constructor() {
                        super({
                            phaserTypeName: "Phaser.GameObjects.NineSlice",
                            typeName: "NineSlice",
                            category: scene_67.SCENE_OBJECT_IMAGE_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_9_SLICE)
                        });
                    }
                    adaptDataAfterTypeConversion(serializer, originalObject, extraData) {
                        super.adaptDataAfterTypeConversion(serializer, originalObject, extraData);
                        const obj = originalObject;
                        const width = obj.width === undefined ? 20 : obj.width;
                        const height = obj.height === undefined ? 20 : obj.height;
                        serializer.getData()[sceneobjects.SizeComponent.width.name] = width;
                        serializer.getData()[sceneobjects.SizeComponent.height.name] = height;
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.NineSliceCodeDOMBuilder();
                    }
                    newObject(scene, x, y, key, frame) {
                        if (key) {
                            return new sceneobjects.NineSlice(scene, x, y, key, frame, 256, 256, 10, 10, 10, 10);
                        }
                        return new sceneobjects.NineSlice(scene, x, y, undefined, undefined, 256, 256, 10, 10, 10, 10);
                    }
                }
                sceneobjects.NineSliceExtension = NineSliceExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_67.ui || (scene_67.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class NineSliceSection extends sceneobjects.SceneGameObjectSection {
                    static SECTION_ID = "phasereditor2d.scene.ui.sceneobjects.NineSliceSection";
                    constructor(page) {
                        super(page, NineSliceSection.SECTION_ID, "Nine Slice", false, false);
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createPropertyXYRow(comp, sceneobjects.NineSliceComponent.horizontalWidth);
                        this.createPropertyXYRow(comp, sceneobjects.NineSliceComponent.verticalWidth);
                        const btn = this.createButton(comp, "Edit Slices", () => {
                            this.getEditor().getToolsManager().activateTool(sceneobjects.SliceTool.ID);
                        });
                        btn.style.gridColumn = "1 / span 6";
                    }
                    createMenu(menu) {
                        super.createMenu(menu);
                        menu.addCommand(ui.editor.commands.CMD_EDIT_SLICE_SCENE_OBJECT);
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.NineSlice;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                    getSectionHelpPath() {
                        // return "scene-editor/tile-sprite-object.html#tile-sprite-properties";
                        // TODO
                        return "";
                    }
                }
                sceneobjects.NineSliceSection = NineSliceSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_68) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ThreeSlice extends Phaser.GameObjects.NineSlice {
                    _editorSupport;
                    constructor(scene, x, y, texture, frame, width, leftWidth, rightWidth) {
                        super(scene, x, y, texture || "__MISSING", frame, width, 0, leftWidth, rightWidth, 0, 0);
                        this._editorSupport = new sceneobjects.ThreeSliceEditorSupport(this, scene);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                    setTexture(key, frame) {
                        super.setTexture(key, frame);
                        if (this.is3Slice) {
                            this.setSizeToFrame();
                        }
                        return this;
                    }
                    setSize(width, height) {
                        if (this.is3Slice) {
                            super.setSize(width, this.height);
                        }
                        else {
                            super.setSize(width, height);
                        }
                        return this;
                    }
                }
                sceneobjects.ThreeSlice = ThreeSlice;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_68.ui || (scene_68.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class ThreeSliceCodeDOMBuilder extends sceneobjects.BaseImageCodeDOMBuilder {
                    constructor() {
                        super("nineslice");
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const obj = args.obj;
                        const objES = obj.getEditorSupport();
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        // texture
                        if (objES.isUnlockedProperty(sceneobjects.TextureComponent.texture)) {
                            this.addTextureFrameArgsToObjectFactoryMethodCallDOM(args.methodCallDOM, args.obj);
                        }
                        else {
                            call.argUndefined();
                            call.argUndefined();
                        }
                        // size (only the "width" argument matters)
                        if (obj.getEditorSupport().isUnlockedPropertyXY(sceneobjects.SizeComponent.size)) {
                            call.argFloat(obj.width);
                        }
                        else {
                            call.argUndefined();
                        }
                        // 3-slice
                        for (const prop of [
                            sceneobjects.NineSliceComponent.leftWidth,
                            sceneobjects.NineSliceComponent.rightWidth
                        ]) {
                            if (objES.isUnlockedProperty(prop)) {
                                call.argFloat(prop.getValue(obj));
                            }
                            else {
                                call.arg("undefined");
                            }
                        }
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                        ctr.arg("texture", "string", true);
                        ctr.arg("frame", "number | string", true);
                        ctr.arg("width", "number", true);
                        ctr.arg("leftWidth", "number", true);
                        ctr.arg("rightWidth", "number", true);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        const obj = args.prefabObj;
                        const objES = obj.getEditorSupport();
                        const call = args.superMethodCallCodeDOM;
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_TextureParameters(args, call);
                        if (objES.isUnlockedPropertyXY(sceneobjects.SizeComponent.size)) {
                            call.arg("width ?? " + obj.width);
                            call.argFloat(0); // height
                        }
                        else {
                            call.arg("width");
                            call.argFloat(0); // height
                        }
                        for (const prop of [
                            sceneobjects.ThreeSliceComponent.leftWidth,
                            sceneobjects.ThreeSliceComponent.rightWidth
                        ]) {
                            if (objES.isUnlockedProperty(prop)) {
                                call.arg(prop.name + " ?? " + prop.getValue(obj));
                            }
                            else {
                                call.arg(prop.name);
                            }
                        }
                        call.argFloat(0); // topHeight
                        call.argFloat(0); // bottomHeight
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("nineslice", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        this.addTextureFrameArgsToObjectFactoryMethodCallDOM(call, obj);
                        call.argFloat(obj.width);
                        call.argFloat(0);
                        call.argFloat(obj.leftWidth);
                        call.argFloat(obj.rightWidth);
                        call.argFloat(0);
                        call.argFloat(0);
                        return call;
                    }
                }
                sceneobjects.ThreeSliceCodeDOMBuilder = ThreeSliceCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                function sliceProperty(name, defValue, label) {
                    return {
                        name,
                        defValue,
                        label,
                        tooltip: `phaser:Phaser.GameObjects.NineSlice.${name}`,
                        local: false,
                        getValue: obj => obj[name],
                        setValue: (obj, value) => {
                            const data = {
                                leftWidth: obj.leftWidth,
                                rightWidth: obj.rightWidth
                            };
                            data[name] = value;
                            obj.setSlices(obj.width, 0, data.leftWidth, data.rightWidth, 0, 0);
                        }
                    };
                }
                class ThreeSliceComponent extends sceneobjects.Component {
                    static leftWidth = sliceProperty("leftWidth", 10, "L");
                    static rightWidth = sliceProperty("rightWidth", 10, "R");
                    static sliceProperties = [
                        ThreeSliceComponent.leftWidth,
                        ThreeSliceComponent.rightWidth
                    ];
                    static horizontalWidth = {
                        label: "Slice Width",
                        x: ThreeSliceComponent.leftWidth,
                        y: ThreeSliceComponent.rightWidth,
                    };
                    constructor(obj) {
                        super(obj, ThreeSliceComponent.sliceProperties);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const objES = this.getEditorSupport();
                        if (objES.isNestedPrefabInstance()) {
                            let onlySizeChanged = true;
                            for (const prop of ThreeSliceComponent.sliceProperties) {
                                if (objES.isUnlockedProperty(prop)) {
                                    onlySizeChanged = false;
                                }
                            }
                            if (onlySizeChanged) {
                                const sizeComponent = objES.getComponent(sceneobjects.SizeComponent);
                                sizeComponent.buildSetObjectPropertiesCodeDOM(args, false);
                            }
                            else {
                                this.buildSetObjectPropertiesWithMethodCodeDOM_FloatProperty(args, "setSlices", sceneobjects.SizeComponent.width, sceneobjects.SizeComponent.height, ...ThreeSliceComponent.sliceProperties);
                            }
                        }
                    }
                }
                sceneobjects.ThreeSliceComponent = ThreeSliceComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_69) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ThreeSliceEditorSupport extends sceneobjects.BaseImageEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.ThreeSliceExtension.getInstance(), obj, scene, true, false, false, false);
                        this.addComponent(new sceneobjects.AlphaSingleComponent(obj), new sceneobjects.TintSingleComponent(obj), new sceneobjects.SizeComponent(obj), new sceneobjects.ThreeSliceComponent(obj));
                    }
                    setInteractive() {
                        this.getObject().setInteractive(sceneobjects.interactive_getAlpha_RenderTexture);
                    }
                    isCustom_SizeComponent_buildSetObjectPropertiesCodeDOM() {
                        return true;
                    }
                    getSizeComponentGeneratesUpdateDisplayOrigin() {
                        return false;
                    }
                    onUpdateAfterSetTexture() {
                        const obj = this.getObject();
                        obj.updateVertices();
                        obj.updateUVs();
                    }
                }
                sceneobjects.ThreeSliceEditorSupport = ThreeSliceEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_69.ui || (scene_69.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_70) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ThreeSliceExtension extends sceneobjects.BaseImageExtension {
                    static _instance = new ThreeSliceExtension();
                    static getInstance() {
                        return this._instance;
                    }
                    constructor() {
                        super({
                            phaserTypeName: "Phaser.GameObjects.NineSlice",
                            typeName: "ThreeSlice",
                            category: scene_70.SCENE_OBJECT_IMAGE_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_3_SLICE)
                        });
                    }
                    adaptDataAfterTypeConversion(serializer, originalObject, extraData) {
                        super.adaptDataAfterTypeConversion(serializer, originalObject, extraData);
                        const obj = originalObject;
                        const width = obj.width === undefined ? 20 : obj.width;
                        const height = obj.height === undefined ? 20 : obj.height;
                        serializer.getData()[sceneobjects.SizeComponent.width.name] = width;
                        serializer.getData()[sceneobjects.SizeComponent.height.name] = height;
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.ThreeSliceCodeDOMBuilder();
                    }
                    newObject(scene, x, y, key, frame) {
                        if (key) {
                            return new sceneobjects.ThreeSlice(scene, x, y, key, frame, 256, 10, 10);
                        }
                        return new sceneobjects.ThreeSlice(scene, x, y, undefined, undefined, 256, 10, 10);
                    }
                }
                sceneobjects.ThreeSliceExtension = ThreeSliceExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_70.ui || (scene_70.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ThreeSliceSection extends sceneobjects.SceneGameObjectSection {
                    static SECTION_ID = "phasereditor2d.scene.ui.sceneobjects.ThreeSliceSection";
                    constructor(page) {
                        super(page, ThreeSliceSection.SECTION_ID, "Three Slice", false, false);
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createPropertyXYRow(comp, sceneobjects.ThreeSliceComponent.horizontalWidth);
                        const btn = this.createButton(comp, "Edit Slices", () => {
                            this.getEditor().getToolsManager().activateTool(sceneobjects.SliceTool.ID);
                        });
                        btn.style.gridColumn = "1 / span 6";
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.ThreeSlice;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                    getSectionHelpPath() {
                        // return "scene-editor/tile-sprite-object.html#tile-sprite-properties";
                        // TODO
                        return "";
                    }
                }
                sceneobjects.ThreeSliceSection = ThreeSliceSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AlphaComponent extends sceneobjects.Component {
                    static alpha = {
                        name: "alpha",
                        label: "Alpha",
                        tooltip: "phaser:Phaser.GameObjects.Components.Alpha.alpha",
                        defValue: 1,
                        increment: 0.01,
                        incrementMin: 0,
                        incrementMax: 1,
                        getValue: obj => obj.alpha,
                        setValue: (obj, value) => obj.alpha = Phaser.Math.Clamp(value, 0, 1)
                    };
                    static alphaTopLeft = {
                        name: "alphaTopLeft",
                        label: "Left",
                        tooltip: "phaser:Phaser.GameObjects.Components.Alpha.alphaTopLeft",
                        defValue: 1,
                        increment: 0.01,
                        incrementMin: 0,
                        incrementMax: 1,
                        getValue: obj => obj.alphaTopLeft,
                        setValue: (obj, value) => obj.alphaTopLeft = Phaser.Math.Clamp(value, 0, 1)
                    };
                    static alphaTopRight = {
                        name: "alphaTopRight",
                        label: "Right",
                        tooltip: "phaser:Phaser.GameObjects.Components.Alpha.alphaTopRight",
                        defValue: 1,
                        increment: 0.01,
                        incrementMin: 0,
                        incrementMax: 1,
                        getValue: obj => obj.alphaTopRight,
                        setValue: (obj, value) => obj.alphaTopRight = Phaser.Math.Clamp(value, 0, 1)
                    };
                    static alphaBottomLeft = {
                        name: "alphaBottomLeft",
                        label: "Left",
                        tooltip: "phaser:Phaser.GameObjects.Components.Alpha.alphaBottomLeft",
                        defValue: 1,
                        increment: 0.01,
                        incrementMin: 0,
                        incrementMax: 1,
                        getValue: obj => obj.alphaBottomLeft,
                        setValue: (obj, value) => obj.alphaBottomLeft = Phaser.Math.Clamp(value, 0, 1)
                    };
                    static alphaBottomRight = {
                        name: "alphaBottomRight",
                        label: "Right",
                        tooltip: "phaser:Phaser.GameObjects.Components.Alpha.alphaBottomRight",
                        defValue: 1,
                        increment: 0.01,
                        incrementMin: 0,
                        incrementMax: 1,
                        getValue: obj => obj.alphaBottomRight,
                        setValue: (obj, value) => obj.alphaBottomRight = Phaser.Math.Clamp(value, 0, 1)
                    };
                    static alphaTop = {
                        label: "Alpha Top",
                        x: AlphaComponent.alphaTopLeft,
                        y: AlphaComponent.alphaTopRight
                    };
                    static alphaBottom = {
                        label: "Alpha Bottom",
                        x: AlphaComponent.alphaBottomLeft,
                        y: AlphaComponent.alphaBottomRight
                    };
                    constructor(obj) {
                        super(obj, [
                            AlphaComponent.alpha,
                            AlphaComponent.alphaTopLeft,
                            AlphaComponent.alphaTopRight,
                            AlphaComponent.alphaBottomLeft,
                            AlphaComponent.alphaBottomRight
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, ...this.getProperties());
                    }
                }
                sceneobjects.AlphaComponent = AlphaComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AlphaSingleComponent extends sceneobjects.Component {
                    static alpha = sceneobjects.SimpleProperty("alpha", 1, "Alpha", "phaser:Phaser.GameObjects.Components.Alpha.alpha");
                    constructor(obj) {
                        super(obj, [
                            AlphaSingleComponent.alpha,
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, AlphaSingleComponent.alpha);
                    }
                }
                sceneobjects.AlphaSingleComponent = AlphaSingleComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class BrowseUserComponentsDialog extends controls.dialogs.ViewerDialog {
                    static createViewer(editor) {
                        const viewer = new controls.viewers.TreeViewer("BrowseScriptsDialog");
                        viewer.setLabelProvider(new ui.editor.outline.SceneEditorOutlineLabelProvider());
                        viewer.setStyledLabelProvider(new ui.editor.outline.SceneEditorOutlineStyledLabelProvider());
                        viewer.setCellRendererProvider(new ui.editor.outline.SceneEditorOutlineRendererProvider());
                        viewer.setContentProvider(new UserCompponentsDialogContentProvider(editor));
                        viewer.setInput([]);
                        viewer.expandRoots();
                        return viewer;
                    }
                    _editor;
                    constructor(editor) {
                        super(BrowseUserComponentsDialog.createViewer(editor), true);
                        this._editor = editor;
                    }
                    create() {
                        super.create();
                        this.setTitle("Browse User Components");
                        this.addOpenButton("Select", sel => {
                            const selSet = new Set(sel.map(obj => {
                                if (obj instanceof sceneobjects.UserComponentNode) {
                                    return obj.getObject();
                                }
                                return obj;
                            }));
                            this._editor.setSelection([...selSet]);
                        });
                        this.addCancelButton();
                    }
                }
                sceneobjects.BrowseUserComponentsDialog = BrowseUserComponentsDialog;
                class UserCompponentsDialogContentProvider extends ui.editor.outline.SceneEditorOutlineContentProvider {
                    constructor(editor) {
                        super(editor, true);
                    }
                    getRoots(input) {
                        return [this._editor.getScene().sys.displayList];
                    }
                    getChildren(parent) {
                        const children = super.getChildren(parent);
                        let result = [];
                        for (const obj of children) {
                            if (obj instanceof sceneobjects.UserComponentNode) {
                                result.push(obj);
                            }
                            else if (sceneobjects.isGameObject(obj)) {
                                if (this.hasUserComponents(obj)) {
                                    result.push(obj);
                                }
                            }
                        }
                        return result;
                    }
                    hasUserComponents(obj) {
                        let result = obj.getEditorSupport().getUserComponentsComponent()
                            .getUserComponentNodes().length > 0;
                        if (!result) {
                            const children = super.getChildren(obj);
                            for (const child of children) {
                                if (sceneobjects.isGameObject(child)) {
                                    result = this.hasUserComponents(child);
                                    if (result) {
                                        return true;
                                    }
                                }
                            }
                        }
                        return result;
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FlipComponent extends sceneobjects.Component {
                    static flipX = sceneobjects.SimpleProperty("flipX", false, "Flip X", "phaser:Phaser.GameObjects.Components.Flip.flipX");
                    static flipY = sceneobjects.SimpleProperty("flipY", false, "Flip Y", "phaser:Phaser.GameObjects.Components.Flip.flipY");
                    constructor(obj) {
                        super(obj, [FlipComponent.flipX, FlipComponent.flipY]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_BooleanProperty(args, ...this.getProperties());
                    }
                }
                sceneobjects.FlipComponent = FlipComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ObjectCellRenderer {
                    constructor() {
                    }
                    renderCell(args) {
                        const obj = args.obj;
                        const cache = obj.getEditorSupport().getScene().getEditor().getCellRendererCache();
                        const cached = cache.getImage(obj);
                        if (cached) {
                            cached.paint(args.canvasContext, args.x, args.y, args.w, args.h, false);
                        }
                    }
                    cellHeight(args) {
                        return args.viewer.getCellSize();
                    }
                    async preload(args) {
                        const obj = args.obj;
                        if (!obj.scene) {
                            return controls.PreloadResult.NOTHING_LOADED;
                        }
                        const cache = obj.getEditorSupport().getScene().getEditor().getCellRendererCache();
                        return cache.preloadImage(obj);
                    }
                }
                sceneobjects.ObjectCellRenderer = ObjectCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../Component.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class OriginComponent extends sceneobjects.Component {
                    static originX = {
                        name: "originX",
                        label: "X",
                        tooltip: "phaser:Phaser.GameObjects.Components.Origin.originX",
                        defValue: 0.5,
                        increment: 0.025,
                        getValue: obj => obj.originX,
                        setValue: (obj, value) => obj.setOrigin(value, obj.originY)
                    };
                    static originY = {
                        name: "originY",
                        label: "Y",
                        increment: 0.025,
                        tooltip: "phaser:Phaser.GameObjects.Components.Origin.originY",
                        defValue: 0.5,
                        getValue: obj => obj.originY,
                        setValue: (obj, value) => obj.setOrigin(obj.originX, value)
                    };
                    static origin = {
                        label: "Origin",
                        setterName: "setOrigin",
                        tooltip: "phaser:Phaser.GameObjects.Components.Origin.setOrigin",
                        x: OriginComponent.originX,
                        y: OriginComponent.originY
                    };
                    constructor(obj) {
                        super(obj, [
                            OriginComponent.originX,
                            OriginComponent.originY
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const obj = this.getObject();
                        this.buildSetObjectPropertyXYCodeDOM_FloatXY(args, OriginComponent.origin);
                        // let add = false;
                        // if (this.getEditorSupport().isPrefabInstance()) {
                        //     if (this.getEditorSupport().isUnlockedPropertyXY(OriginComponent.origin)) {
                        //         add = true;
                        //     }
                        // } else {
                        //     const defaultOriginX = this.getPropertyDefaultValue(OriginComponent.originX);
                        //     const defaultOriginY = this.getPropertyDefaultValue(OriginComponent.originY);
                        //     if (defaultOriginX !== obj.originX || defaultOriginY !== obj.originY) {
                        //         add = true;
                        //     }
                        // }
                        // if (add) {
                        //     const dom = new code.MethodCallCodeDOM("setOrigin", args.objectVarName);
                        //     dom.argFloat(obj.originX);
                        //     dom.argFloat(obj.originY);
                        //     args.statements.push(dom);
                        // }
                    }
                }
                sceneobjects.OriginComponent = OriginComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PrefabUserPropertyComponent extends sceneobjects.Component {
                    _data;
                    constructor(obj) {
                        super(obj, []);
                        this._data = {};
                    }
                    setPropertyValue(prop, value) {
                        this._data[prop.getName()] = value;
                    }
                    getPropertyValue(prop) {
                        return this._data[prop.getName()];
                    }
                    isPropertySet(prop) {
                        return prop.getName() in this._data;
                    }
                    getPropertiesByPrefab() {
                        const propertiesInObject = [];
                        const objES = this.getObject().getEditorSupport();
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        if (objES.isPrefabInstance()) {
                            // get all from the nested prefabs chain
                            if (objES.isNestedPrefabInstance()) {
                                this.getNestedPrefabProperties(propertiesInObject, objES.getPrefabId());
                            }
                            // get all from non-nested prefab hierarchy
                            const nextPrefabId = finder.getFirstNonNestedPrefabId(objES.getPrefabId());
                            if (nextPrefabId) {
                                const prefabFile = finder.getPrefabFile(nextPrefabId);
                                if (prefabFile) {
                                    this.getPrefabProperties(propertiesInObject, prefabFile);
                                }
                            }
                        }
                        return propertiesInObject;
                    }
                    getNestedPrefabProperties(propertiesInObject, nestedPrefabId) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const prefabFile = finder.getPrefabFile(nestedPrefabId);
                        propertiesInObject.push({
                            prefabFile,
                            properties: []
                        });
                        const data = finder.getPrefabData(nestedPrefabId);
                        nestedPrefabId = data.prefabId;
                        if (nestedPrefabId && finder.isNestedPrefab(nestedPrefabId)) {
                            this.getNestedPrefabProperties(propertiesInObject, data.prefabId);
                        }
                    }
                    getPrefabProperties(propertiesInObject, prefabFile) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const sceneData = finder.getSceneData(prefabFile);
                        if (sceneData.sceneType === scene.core.json.SceneType.PREFAB) {
                            if (sceneData.displayList.length > 0) {
                                const objData = sceneData.displayList[sceneData.displayList.length - 1];
                                if (objData.prefabId) {
                                    const prefabFile2 = finder.getPrefabFile(objData.prefabId);
                                    if (prefabFile2) {
                                        this.getPrefabProperties(propertiesInObject, prefabFile2);
                                    }
                                }
                            }
                        }
                        const userProps = new sceneobjects.PrefabUserProperties();
                        userProps.readJSON(sceneData.prefabProperties || []);
                        const properties = userProps.getProperties();
                        propertiesInObject.push({
                            prefabFile,
                            properties
                        });
                    }
                    getProperties() {
                        const properties = this.getPropertiesByPrefab()
                            .flatMap(data => data.properties)
                            .map(userProp => userProp.getComponentProperty());
                        return new Set(properties);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const mark = args.lazyStatements.length;
                        const temp = args.statements;
                        args.statements = args.lazyStatements;
                        for (const prop of this.getProperties()) {
                            const userProp = prop.getUserProperty();
                            userProp.getType().buildSetObjectPropertyCodeDOM(this, args, userProp);
                        }
                        args.statements = temp;
                        if (args.lazyStatements.length > mark) {
                            args.lazyStatements.splice(mark, 0, new scene.core.code.RawCodeDOM(""), new scene.core.code.RawCodeDOM(`// ${args.objectVarName} (prefab fields)`));
                        }
                    }
                }
                sceneobjects.PrefabUserPropertyComponent = PrefabUserPropertyComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_71) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SceneGameObjectOperation extends ui.editor.undo.SceneEditorOperation {
                    _objIdList;
                    _value;
                    _afterValues;
                    _beforeValues;
                    _objects;
                    constructor(editor, objects, value) {
                        super(editor);
                        this._objects = objects;
                        this._value = value;
                    }
                    transformValue(obj) {
                        return this._value;
                    }
                    async execute() {
                        this._objIdList = this._objects.map(obj => obj.getEditorSupport().getId());
                        this._beforeValues = this._objects.map(obj => this.getValue(obj));
                        this._afterValues = this._objects.map(obj => this.transformValue(obj));
                        // don't keep the objects reference, we have the ids.
                        this._objects = null;
                        this.update(this._afterValues);
                    }
                    undo() {
                        this.update(this._beforeValues);
                    }
                    redo() {
                        this.update(this._afterValues);
                    }
                    update(values) {
                        const scene = this._editor.getScene();
                        for (let i = 0; i < this._objIdList.length; i++) {
                            const id = this._objIdList[i];
                            const obj = scene.getPlainObjectById(id) || scene.getByEditorId(id);
                            const value = values[i];
                            if (obj) {
                                this.setValue(obj, value);
                            }
                        }
                        this._editor.setSelection(this._editor.getSelection());
                        this._editor.setDirty(true);
                    }
                }
                sceneobjects.SceneGameObjectOperation = SceneGameObjectOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_71.ui || (scene_71.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneGameObjectOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SimpleOperation extends sceneobjects.SceneGameObjectOperation {
                    _property;
                    constructor(editor, objects, property, value) {
                        super(editor, objects, value);
                        this._property = property;
                    }
                    getValue(obj) {
                        return this._property.getValue(obj);
                    }
                    setValue(obj, value) {
                        this._property.setValue(obj, value);
                    }
                }
                sceneobjects.SimpleOperation = SimpleOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                function colorStringToColorNumberConverter(value) {
                    if (typeof (value) === "string" && value.trim() === "") {
                        value = "#ffffff";
                    }
                    // update the real object tint property
                    try {
                        const rgba = controls.Colors.parseColor(value);
                        const color = Phaser.Display.Color.GetColor(rgba.r, rgba.g, rgba.b);
                        return color;
                    }
                    catch (e) {
                        // possible color syntax error.
                        console.log(e);
                    }
                    return 0;
                }
                sceneobjects.colorStringToColorNumberConverter = colorStringToColorNumberConverter;
                function TintProperty(name, label, tooltip) {
                    return {
                        name,
                        defValue: "#ffffff",
                        label,
                        tooltip: tooltip ?? "phaser:Phaser.GameObjects.Components.Tint." + name,
                        local: false,
                        getValue: obj => {
                            const val = obj["tint_" + name];
                            return val === undefined ? "#ffffff" : val;
                        },
                        setValue: (obj, value) => {
                            const validColor = colorStringToColorNumberConverter(value);
                            obj[name] = validColor;
                            // store the original, string color value in the object
                            obj["tint_" + name] = value;
                        },
                        valueToCodeConverter: colorStringToColorNumberConverter
                    };
                }
                sceneobjects.TintProperty = TintProperty;
                class TintComponent extends sceneobjects.Component {
                    static tintFill = sceneobjects.SimpleProperty("tintFill", false, "Tint Fill", "phaser:Phaser.GameObjects.Components.Tint.tintFill");
                    static tintTopLeft = TintProperty("tintTopLeft", "Tint Top Left");
                    static tintTopRight = TintProperty("tintTopRight", "Tint Top Right");
                    static tintBottomLeft = TintProperty("tintBottomLeft", "Tint Bottom Left");
                    static tintBottomRight = TintProperty("tintBottomRight", "Tint Bottom Right");
                    constructor(obj) {
                        super(obj, [
                            TintComponent.tintTopLeft,
                            TintComponent.tintTopRight,
                            TintComponent.tintBottomLeft,
                            TintComponent.tintBottomRight,
                            TintComponent.tintFill
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_BooleanProperty(args, TintComponent.tintFill);
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, TintComponent.tintTopLeft);
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, TintComponent.tintTopRight);
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, TintComponent.tintBottomLeft);
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, TintComponent.tintBottomRight);
                    }
                }
                sceneobjects.TintComponent = TintComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TintSingleComponent extends sceneobjects.Component {
                    static tintFill = sceneobjects.SimpleProperty("tintFill", false, "Tint Fill", "Fill the tint?");
                    static tint = sceneobjects.TintProperty("tint", "Tint", "The tint.");
                    constructor(obj) {
                        super(obj, [
                            TintSingleComponent.tintFill,
                            TintSingleComponent.tint,
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_BooleanProperty(args, TintSingleComponent.tintFill);
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, TintSingleComponent.tint);
                    }
                }
                sceneobjects.TintSingleComponent = TintSingleComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../Component.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TransformComponent extends sceneobjects.Component {
                    static x = sceneobjects.SimpleProperty("x", 0, "X", "phaser:Phaser.GameObjects.Components.Transform.x", false, null, 1);
                    static y = sceneobjects.SimpleProperty("y", 0, "Y", "phaser:Phaser.GameObjects.Components.Transform.y", false, null, 1);
                    static position = {
                        label: "Position",
                        tooltip: "phaser:Phaser.GameObjects.Components.Transform.setPosition",
                        x: TransformComponent.x,
                        y: TransformComponent.y
                    };
                    static scaleX = sceneobjects.SimpleProperty("scaleX", 1, "X", "phaser:Phaser.GameObjects.Components.Transform.scaleX", false, null, 0.05);
                    static scaleY = sceneobjects.SimpleProperty("scaleY", 1, "Y", "phaser:Phaser.GameObjects.Components.Transform.scaleY", false, null, 0.05);
                    static scale = {
                        label: "Scale",
                        x: TransformComponent.scaleX,
                        y: TransformComponent.scaleY
                    };
                    static angle = sceneobjects.SimpleProperty("angle", 0, "Angle", "phaser:Phaser.GameObjects.Components.Transform.angle", false, null, 1);
                    constructor(obj) {
                        super(obj, [
                            TransformComponent.x,
                            TransformComponent.y,
                            TransformComponent.scaleX,
                            TransformComponent.scaleY,
                            TransformComponent.angle
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const obj = this.getObject();
                        const support = obj.getEditorSupport();
                        const prop = TransformComponent.position;
                        if (support.isNestedPrefabInstance()
                            && support.isUnlockedPropertyXY(prop)) {
                            const dom = new scene.core.code.MethodCallCodeDOM("setPosition", args.objectVarName);
                            dom.argFloat(prop.x.getValue(obj));
                            dom.argFloat(prop.y.getValue(obj));
                            args.statements.push(dom);
                        }
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, TransformComponent.scaleX, TransformComponent.scaleY, TransformComponent.angle);
                    }
                }
                sceneobjects.TransformComponent = TransformComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class UserComponentNode {
                    _obj;
                    _userComponent;
                    _prefabFile;
                    static computeKey(obj, userComponent, prefabFile) {
                        const prefabFileKey = prefabFile ? prefabFile.getFullName() : "";
                        const compKey = userComponent.getName();
                        const objKey = obj.getEditorSupport().getId();
                        const key = `${prefabFileKey}${compKey}#${objKey}`;
                        return key;
                    }
                    constructor(obj, userComponent, prefabFile) {
                        this._obj = obj;
                        this._userComponent = userComponent;
                        this._prefabFile = prefabFile;
                    }
                    getId() {
                        return `${this._obj.getEditorSupport().getId()}#${this._userComponent.getName()}`;
                    }
                    getObject() {
                        return this._obj;
                    }
                    isPublished() {
                        return this.getUserComponentsComponent().isComponentPublished(this.getComponentName());
                    }
                    getUserComponent() {
                        return this._userComponent;
                    }
                    getComponentName() {
                        return this._userComponent.getName();
                    }
                    getUserComponentsComponent() {
                        return this._obj.getEditorSupport().getUserComponentsComponent();
                    }
                    getPrefabFile() {
                        return this._prefabFile;
                    }
                    isPrefabDefined() {
                        return this._prefabFile !== undefined;
                    }
                }
                sceneobjects.UserComponentNode = UserComponentNode;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                var io = colibri.core.io;
                class UserComponentsEditorComponent extends sceneobjects.Component {
                    _propData;
                    _compNames;
                    constructor(obj) {
                        super(obj, []);
                        this._propData = {};
                        this._compNames = [];
                    }
                    writeJSON(ser) {
                        const data = ser.getData();
                        data.components = [...this._compNames];
                        // we don't want to serialize an empty components array,
                        // if it is the case, we exclude it from the file
                        if (data.components.length === 0) {
                            delete data.components;
                        }
                        for (const compName of this._compNames) {
                            const key = this.getPropertyKey(compName, "export");
                            const exported = this.isExportComponent(compName);
                            colibri.core.json.write(ser.getData(), key, exported, true);
                        }
                        super.writeJSON(ser);
                    }
                    readJSON(ser) {
                        const data = ser.getData();
                        this._compNames = data.components || [];
                        for (const compName of this._compNames) {
                            const key = this.getPropertyKey(compName, "export");
                            const exported = colibri.core.json.read(ser.getData(), key, true);
                            this.setExportComponent(compName, exported);
                        }
                        super.readJSON(ser);
                    }
                    writeProperty(ser, prop) {
                        if (prop instanceof sceneobjects.UserComponentPropertyWrapper) {
                            // This may happen when you add a user component to a prefab instance.
                            // in that case, the properties are local.
                            // But if the user property is inherited from the prefab, then it is not local.
                            const local = this.getEditorSupport().isLocalUserProperty(prop);
                            super.writeProperty(ser, prop, local);
                            return;
                        }
                        super.writeProperty(ser, prop);
                    }
                    setExportComponent(compName, isExport) {
                        this._propData[this.getPropertyKey(compName, "export")] = isExport;
                    }
                    isExportComponent(compName) {
                        const val = this._propData[this.getPropertyKey(compName, "export")] ?? true;
                        return val;
                    }
                    isComponentPublished(compName) {
                        const objES = this.getEditorSupport();
                        if (objES.isPrefabInstance()) {
                            return this.isComponentAvailabeInPrefab(compName, objES.getPrefabId());
                        }
                        return this.hasLocalUserComponent(compName);
                    }
                    isComponentAvailabeInPrefab(compName, prefabId) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const data = finder.getPrefabData(prefabId);
                        const key = this.getPropertyKey(compName, "export");
                        if (key in data) {
                            return data[key];
                        }
                        if (data.prefabId) {
                            return this.isComponentAvailabeInPrefab(compName, data.prefabId);
                        }
                        return true;
                    }
                    setPropertyValue(compName, prop, value) {
                        this._propData[this.getPropertyKey(compName, prop.getName())] = value;
                    }
                    getPropertyValue(compName, prop) {
                        return this._propData[this.getPropertyKey(compName, prop.getName())];
                    }
                    isPropertySet(compName, prop) {
                        return this.getPropertyKey(compName, prop.getName()) in this._propData;
                    }
                    hasLocalUserComponent(compName) {
                        return this._compNames.indexOf(compName) >= 0;
                    }
                    hasUserComponent(compName) {
                        if (this.hasLocalUserComponent(compName)) {
                            return true;
                        }
                        const find = this.getPrefabUserComponents()
                            .flatMap(info => info.components)
                            .find(c => c.getName() === compName);
                        return find !== undefined;
                    }
                    addUserComponent(compName) {
                        this._compNames.push(compName);
                    }
                    removeUserComponent(compName) {
                        this._compNames = this._compNames.filter(name => name !== compName);
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const compInfo = finder.getUserComponentByName(compName);
                        if (compInfo) {
                            for (const prop of compInfo.component.getUserProperties().getProperties()) {
                                delete this._propData[this.getPropertyKey(compName, prop.getName())];
                            }
                            delete this._propData[this.getPropertyKey(compName, "export")];
                        }
                    }
                    moveUpUserComponent(compName) {
                        const i = this._compNames.indexOf(compName);
                        if (i > 0) {
                            const temp = this._compNames[i - 1];
                            this._compNames[i - 1] = compName;
                            this._compNames[i] = temp;
                        }
                    }
                    moveDownUserComponent(compName) {
                        const i = this._compNames.indexOf(compName);
                        const lastIndex = this._compNames.length - 1;
                        if (i >= 0 && i < lastIndex) {
                            const temp = this._compNames[i + 1];
                            this._compNames[i + 1] = compName;
                            this._compNames[i] = temp;
                        }
                    }
                    getPropertyKey(compName, propName) {
                        return `${compName}.${propName}`;
                    }
                    _userCompMap = new Map();
                    getUserComponentNodes() {
                        const obj = this.getObject();
                        const result = [];
                        // build local components
                        const localComponents = this.getLocalUserComponents();
                        for (const findCompResult of localComponents) {
                            const node = this.getUserComponentNodeFor(obj, findCompResult.component);
                            result.push(node);
                        }
                        // build prefab components
                        const compAndPrefabList = this.getPrefabUserComponents();
                        for (const compAndPrefab of compAndPrefabList) {
                            for (const comp of compAndPrefab.components) {
                                const node = this.getUserComponentNodeFor(obj, comp, compAndPrefab.prefabFile);
                                result.push(node);
                            }
                        }
                        return result;
                    }
                    getUserComponentNodeFor(obj, userComponent, prefabFile) {
                        const key = sceneobjects.UserComponentNode.computeKey(obj, userComponent, prefabFile);
                        if (this._userCompMap.has(key)) {
                            return this._userCompMap.get(key);
                        }
                        const node = new sceneobjects.UserComponentNode(obj, userComponent, prefabFile);
                        this._userCompMap.set(key, node);
                        return node;
                    }
                    getLocalUserComponents() {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        return this._compNames
                            .map(compName => finder.getUserComponentByName(compName))
                            .filter(c => c !== undefined);
                    }
                    getPrefabUserComponents() {
                        const result = [];
                        const objES = this.getObject().getEditorSupport();
                        if (objES.isPrefabInstance()) {
                            this.getUserComponentsOfPrefab(objES.getPrefabId(), result);
                        }
                        return result;
                    }
                    getUserComponentsOfPrefab(prefabId, result) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const prefabFile = finder.getPrefabFile(prefabId);
                        const objData = finder.getPrefabData(prefabId);
                        if (objData) {
                            if (objData.components) {
                                const components = objData.components
                                    .map(compName => finder.getUserComponentByName(compName))
                                    .filter(info => info !== undefined)
                                    .map(info => info.component);
                                if (components.length > 0) {
                                    result.push({ prefabFile, components });
                                }
                            }
                            if (objData.prefabId) {
                                this.getUserComponentsOfPrefab(objData.prefabId, result);
                            }
                        }
                    }
                    getProperties() {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const compNames = [...this._compNames];
                        compNames.push(...this.getPrefabUserComponents()
                            .flatMap(info => info.components)
                            .map(c => c.getName()));
                        const properties = compNames
                            .map(compName => finder.getUserComponentByName(compName))
                            .filter(c => c !== undefined)
                            .flatMap(c => c.component.getUserProperties().getProperties())
                            .flatMap(p => p.getComponentProperty());
                        return new Set(properties);
                    }
                    formatComponentVarName(name) {
                        return name.replaceAll(".", "_");
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const allPropsStart = args.lazyStatements.length;
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        for (const compName of this._compNames) {
                            const compInfo = finder.getUserComponentByName(compName);
                            if (compInfo) {
                                const compVarName = this.formatComponentVarName(args.objectVarName + compName);
                                const compPropsStart = args.lazyStatements.length;
                                this.buildSetObjectPropertiesCodeDOM2(compInfo.component, compName, compVarName, args);
                                args.lazyStatements.splice(compPropsStart, 0, new code.RawCodeDOM(compPropsStart === args.lazyStatements.length ?
                                    `new ${compName}(${args.objectVarName});`
                                    : `const ${compVarName} = new ${compName}(${args.objectVarName});`));
                                const { importPath, asDefault } = code.getImportPath(args.sceneFile, new io.FilePath(compInfo.file.getParent(), {
                                    isFile: true,
                                    modTime: 0,
                                    name: compName,
                                    size: 0,
                                    children: []
                                }));
                                args.unit.addImport(compName, importPath, asDefault);
                            }
                        }
                        const prefabUserComponents = this.getPrefabUserComponents();
                        for (const prefabUserComps of prefabUserComponents) {
                            for (const comp of prefabUserComps.components) {
                                const compName = comp.getName();
                                const compVarName = this.formatComponentVarName(args.objectVarName + compName);
                                const prefabPropsStart = args.lazyStatements.length;
                                this.buildSetObjectPropertiesCodeDOM2(comp, compName, compVarName, args);
                                if (prefabPropsStart !== args.lazyStatements.length) {
                                    args.lazyStatements.splice(prefabPropsStart, 0, new code.RawCodeDOM(`const ${compVarName} = ${compName}.getComponent(${args.objectVarName});`));
                                    const compInfo = finder.getUserComponentByName(compName);
                                    const importData = code.getImportPath(args.sceneFile, new io.FilePath(compInfo.file.getParent(), {
                                        isFile: true,
                                        modTime: 0,
                                        name: compName,
                                        size: 0,
                                        children: []
                                    }));
                                    args.unit.addImport(compName, importData.importPath, importData.asDefault);
                                }
                            }
                        }
                        if (allPropsStart !== args.lazyStatements.length) {
                            args.lazyStatements.splice(allPropsStart, 0, new code.RawCodeDOM(""), new code.RawCodeDOM(`// ${args.objectVarName} (components)`));
                        }
                    }
                    buildSetObjectPropertiesCodeDOM2(comp, compName, compVarName, args) {
                        const temp = args.statements;
                        args.statements = args.lazyStatements;
                        const props = comp.getUserProperties().getProperties();
                        if (props.length > 0) {
                            const objVarName = args.objectVarName;
                            for (const userProp of props) {
                                args.objectVarName = compVarName;
                                userProp.getType().buildSetObjectPropertyCodeDOM(this, args, userProp);
                            }
                            args.objectVarName = objVarName;
                        }
                        args.statements = temp;
                    }
                }
                sceneobjects.UserComponentsEditorComponent = UserComponentsEditorComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../sceneobjects/ObjectScope.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class VariableComponent extends sceneobjects.Component {
                    static label = {
                        name: "label",
                        tooltip: "The variable name of the object.",
                        defValue: undefined,
                        local: true,
                        getValue: obj => obj.getEditorSupport().getLabel(),
                        setValue: (obj, value) => obj.getEditorSupport().setLabel(value)
                    };
                    static displayName = {
                        name: "displayName",
                        tooltip: "The name to show in the UI.",
                        defValue: "",
                        local: true,
                        getValue: obj => obj.getEditorSupport().getDisplayName(),
                        setValue: (obj, value) => obj.getEditorSupport().setDisplayName(value)
                    };
                    static useGameObjectName = {
                        name: "useGameObjectName",
                        label: "GO Name",
                        tooltip: "Also set the Game Object's name",
                        defValue: false,
                        local: true,
                        getValue: obj => obj.getEditorSupport().isUseGameObjectName(),
                        setValue: (obj, value) => obj.getEditorSupport().setUseGameObjectName(value)
                    };
                    static scope = {
                        name: "scope",
                        tooltip: "The variable lexical scope.",
                        defValue: sceneobjects.ObjectScope.LOCAL,
                        local: true,
                        getValue: obj => obj.getEditorSupport().getScope(),
                        setValue: (obj, value) => obj.getEditorSupport().setScope(value),
                        values: sceneobjects.OBJECT_SCOPES,
                        getValueLabel: value => value.replaceAll("_", " ") // value.split("_").map(v => v[0] + v.substring(1).toLowerCase()).join(" ")
                    };
                    constructor(obj) {
                        super(obj, [
                            VariableComponent.label,
                            VariableComponent.displayName,
                            VariableComponent.useGameObjectName,
                            VariableComponent.scope
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        if (this.getEditorSupport().isUseGameObjectName()) {
                            const dom = new code.AssignPropertyCodeDOM("name", args.objectVarName);
                            dom.valueLiteral(this.getEditorSupport().getLabel());
                            args.statements.push(dom);
                        }
                    }
                }
                sceneobjects.VariableComponent = VariableComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class VisibleComponent extends sceneobjects.Component {
                    static visible = {
                        name: "visible",
                        label: "Visible",
                        tooltip: "phaser:Phaser.GameObjects.Components.Visible.visible",
                        defValue: true,
                        getValue: obj => obj.visible,
                        setValue: (obj, value) => obj.visible = value
                    };
                    constructor(obj) {
                        super(obj, [VisibleComponent.visible]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_BooleanProperty(args, VisibleComponent.visible);
                    }
                }
                sceneobjects.VisibleComponent = VisibleComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AlphaSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.AlphaSection", "Alpha", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/alpha-properties.html";
                        ;
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createNumberPropertyRow(comp, sceneobjects.AlphaComponent.alpha, true);
                        this.createPropertyXYRow(comp, sceneobjects.AlphaComponent.alphaTop, true, false);
                        this.createPropertyXYRow(comp, sceneobjects.AlphaComponent.alphaBottom, true, false);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.AlphaComponent) && n > 0;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.AlphaSection = AlphaSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AlphaSingleSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.AlphaSingleSection", "Alpha", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/alpha-properties.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr";
                        this.createNumberProperty(comp, sceneobjects.AlphaComponent.alpha);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.AlphaSingleComponent) && n > 0;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.AlphaSingleSection = AlphaSingleSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class DynamicPrefabInstanceSection extends sceneobjects.SceneGameObjectSection {
                    _prefabFile;
                    _properties;
                    constructor(page, prefabFile, properties) {
                        super(page, DynamicPrefabInstanceSection.computeId(prefabFile), sceneobjects.getSceneDisplayName(prefabFile), false, true, phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_GROUP), DynamicPrefabInstanceSection.computeTypeHash(prefabFile));
                        this._prefabFile = prefabFile;
                        this._properties = properties;
                    }
                    static computeTypeHash(prefabFile) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const prefabId = finder.getPrefabId(prefabFile);
                        return `DynamicPrefabInstanceSection_${prefabFile.getNameWithoutExtension()}_${prefabId}`;
                    }
                    static computeId(prefabFile) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const id = finder.getPrefabId(prefabFile);
                        const hash = prefabFile.getModTime();
                        return `phasereditor2d.scene.ui.sceneobjects.DynamicPrefabInstanceSection_${id}_${hash}`;
                    }
                    getSectionHelpPath() {
                        return "scene-editor/prefab-user-properties.html#user-properties-in-a-prefab-instance";
                    }
                    createMenu(menu) {
                        menu.addCommand(ui.editor.commands.CMD_OPEN_PREFAB);
                        const prefabName = this._prefabFile.getNameWithoutExtension();
                        menu.addAction({
                            text: `Select All ${prefabName}`,
                            callback: () => {
                                const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                                const sel = [];
                                this.getEditor().getScene().visitAll(obj2 => {
                                    if (sceneobjects.GameObjectEditorSupport.hasEditorSupport(obj2)) {
                                        const objES = sceneobjects.GameObjectEditorSupport.getEditorSupport(obj2);
                                        if (objES.isPrefabInstance()) {
                                            const prefabFiles = finder.getPrefabHierarchy(objES.getPrefabId());
                                            if (prefabFiles.indexOf(this._prefabFile) >= 0) {
                                                sel.push(obj2);
                                            }
                                        }
                                    }
                                });
                                this.getEditor().setSelection(sel);
                            }
                        });
                        menu.addSeparator();
                        super.createMenu(menu);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr";
                        for (const prop of this._properties) {
                            prop.getType().createInspectorPropertyEditor(this, comp, prop, true);
                        }
                    }
                    canEdit(obj, n) {
                        if (sceneobjects.isGameObject(obj)) {
                            const objES = obj.getEditorSupport();
                            if (objES.isPrefabInstance()) {
                                const objPrefabFile = objES.getPrefabFile();
                                const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                                if (objES.isNestedPrefabInstance()) {
                                    const objPrefabId = finder.getFirstNonNestedPrefabId(objES.getPrefabId());
                                    if (objPrefabId) {
                                        const sectionPrefabId = finder.getPrefabId(this._prefabFile);
                                        return objPrefabId === sectionPrefabId;
                                    }
                                }
                                else {
                                    if (finder.isPrefabVariant(objPrefabFile, this._prefabFile)) {
                                        return true;
                                    }
                                }
                            }
                        }
                        return false;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.DynamicPrefabInstanceSection = DynamicPrefabInstanceSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneGameObjectSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class FlipSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.FlipSection", "Flip", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/flip-properties.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto auto auto 1fr";
                        this.createLock(comp, sceneobjects.FlipComponent.flipX, sceneobjects.FlipComponent.flipY);
                        this.createBooleanField(comp, sceneobjects.FlipComponent.flipX).checkElement.style.marginRight = "10px";
                        this.createBooleanField(comp, sceneobjects.FlipComponent.flipY);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.FlipComponent);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.FlipSection = FlipSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneGameObjectSection.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_72) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class GameObjectListSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.GameObjectListSection", "Lists", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/lists-properties.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        this.createLabel(comp, "Lists", "The lists where this object belongs to.");
                        const btn = this.createButton(comp, "", e => {
                            const listsRoot = this.getEditor().getScene().getObjectLists();
                            const menu = new controls.Menu();
                            const selObjIds = this.getSelection().map(obj => obj.getEditorSupport().getId());
                            const usedLists = new Set(selObjIds.flatMap(objId => listsRoot.getListsByObjectId(objId)));
                            const notUsedLists = listsRoot.getLists().filter(list => !usedLists.has(list));
                            for (const list of notUsedLists) {
                                menu.add(new controls.Action({
                                    icon: colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_PLUS),
                                    text: list.getLabel(),
                                    callback: () => {
                                        this.getUndoManager().add(new sceneobjects.AddObjectsToListOperation(this.getEditor(), list, this.getEditor().getSelectedGameObjects()));
                                    }
                                }));
                            }
                            menu.addSeparator();
                            for (const list of usedLists) {
                                menu.add(new controls.Action({
                                    icon: colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_MINUS),
                                    text: list.getLabel(),
                                    callback: () => {
                                        this.getUndoManager().add(new sceneobjects.RemoveObjectsFromListOperation(this.getEditor(), list, this.getEditor().getSelectedGameObjects()));
                                    }
                                }));
                            }
                            menu.addSeparator();
                            menu.add(new controls.Action({
                                text: "Add To New List",
                                callback: () => {
                                    const dlg = new controls.dialogs.InputDialog();
                                    dlg.create();
                                    dlg.setTitle("New List");
                                    dlg.setMessage("Enter the name of the new list");
                                    dlg.setInitialValue("list");
                                    dlg.setInputValidator(name => {
                                        return this.getEditor().getScene().getObjectLists().getLists().findIndex(list => list.getLabel() === name) < 0;
                                    });
                                    dlg.setResultCallback(name => {
                                        this.getUndoManager().add(new sceneobjects.AddObjectsToNewListOperation(this.getEditor(), name, this.getEditor().getSelectedGameObjects()));
                                    });
                                    dlg.validate();
                                }
                            }));
                            menu.createWithEvent(e);
                        });
                        controls.Tooltip.tooltip(btn, "Change the lists containing this object.");
                        this.addUpdater(() => {
                            const scene = this.getEditor().getScene();
                            if (!scene) {
                                return;
                            }
                            const listsRoot = scene.getObjectLists();
                            const lists = new Set(this.getSelection()
                                .map(obj => obj.getEditorSupport().getId())
                                .flatMap(objId => listsRoot.getListsByObjectId(objId))
                                .map(list => list.getLabel()));
                            btn.textContent = "[" + [...lists].join(",") + "]";
                        });
                    }
                    canEdit(obj, n) {
                        return sceneobjects.isGameObject(obj) && !this.isPrefabSceneObject(obj);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.GameObjectListSection = GameObjectListSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_72.ui || (scene_72.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneGameObjectSection.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class GameObjectVariableSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.GameObjectVariableSection", "Variable", false);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/variable-properties.html";
                    }
                    createMenu(menu) {
                        const creator = this.getEditor().getMenuCreator();
                        creator.createTypeMenuItems(menu);
                        menu.addSeparator();
                        menu.addCommand(ui.editor.commands.CMD_CREATE_PREFAB_WITH_OBJECT);
                        menu.addSeparator();
                        super.createMenu(menu);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        {
                            // Name
                            this.createLabel(comp, "Name", "The name of the variable associated to this object. This name is used by the compiler.");
                            this.createStringField(comp, sceneobjects.VariableComponent.label, false, true);
                        }
                        {
                            // Display Name
                            this.createLabel(comp, "Display Name", "The name to display in the UI.");
                            this.createStringField(comp, sceneobjects.VariableComponent.displayName, false, true);
                        }
                        {
                            // GameObject name
                            this.createBooleanField(comp, sceneobjects.VariableComponent.useGameObjectName, false);
                        }
                        GameObjectVariableSection.createTypeEditor(this, comp);
                        {
                            // Scope
                            this.createLabel(comp, "Scope", "The lexical scope of this object's variable, in code.");
                            this.createEnumField(comp, sceneobjects.VariableComponent.scope, false, scope => {
                                if (this.getEditor().getScene().isPrefabSceneType()) {
                                    return true;
                                }
                                return !sceneobjects.isNestedPrefabScope(scope);
                            });
                        }
                    }
                    static createTypeEditor(section, parentElement) {
                        const label = section.createLabel(parentElement, "Type", "The type of the object.");
                        const btn = section.createButton(parentElement, "", e => {
                            const dlg = new ui.editor.ConvertTypeDialog(section.getEditor());
                            dlg.create();
                        });
                        section.addUpdater(() => {
                            btn.disabled = !ui.editor.ConvertTypeDialog
                                .canConvert(section.getEditor());
                            btn.textContent = section.flatValues_StringJoinDifferent(section.getSelection().map(obj => {
                                const objES = obj.getEditorSupport();
                                let typename = objES.getObjectType();
                                if (objES.isPrefabInstance()) {
                                    typename = `prefab ${objES.getDisplayPrefabName()} (${typename})`;
                                }
                                return typename;
                            }));
                        });
                        return { label, btn };
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.VariableComponent)
                            && !this.isPrefabSceneObject(obj)
                            && !sceneobjects.isNestedPrefabInstance(obj);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.GameObjectVariableSection = GameObjectVariableSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_73) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class MoveToParentOperation extends ui.editor.undo.SceneSnapshotOperation {
                    _parentId;
                    constructor(editor, parentId) {
                        super(editor);
                        this._parentId = parentId;
                    }
                    async performModification() {
                        const scene = this.getScene();
                        const map = scene.buildObjectIdMap();
                        const objects = this.getEditor().getSelectedGameObjects();
                        scene.sortObjectsByIndex(objects);
                        for (const obj of objects) {
                            const sprite = obj;
                            const objES = obj.getEditorSupport();
                            const canTranslate = objES.hasComponent(sceneobjects.TransformComponent)
                                && objES.isUnlockedProperty(sceneobjects.TransformComponent.x);
                            const currentParent = objES.getObjectParent();
                            if (objES.getParentId() === this._parentId) {
                                continue;
                            }
                            const worldPoint = new Phaser.Math.Vector2(0, 0);
                            if (canTranslate) {
                                sprite.getWorldTransformMatrix().transformPoint(0, 0, worldPoint);
                            }
                            if (currentParent) {
                                currentParent.getEditorSupport().removeObjectChild(obj);
                            }
                            else {
                                scene.removeGameObject(obj);
                            }
                            if (this._parentId) {
                                const newParent = map.get(this._parentId);
                                if (canTranslate) {
                                    const p = new Phaser.Math.Vector2(0, 0);
                                    if (newParent instanceof sceneobjects.Container) {
                                        newParent.getWorldTransformMatrix().applyInverse(worldPoint.x, worldPoint.y, p);
                                    }
                                    else {
                                        p.set(worldPoint.x, worldPoint.y);
                                    }
                                    sprite.x = p.x;
                                    sprite.y = p.y;
                                }
                                newParent.getEditorSupport().addObjectChild(sprite);
                            }
                            else {
                                if (canTranslate) {
                                    sprite.x = worldPoint.x;
                                    sprite.y = worldPoint.y;
                                }
                                scene.addGameObject(sprite, true);
                            }
                        }
                    }
                }
                sceneobjects.MoveToParentOperation = MoveToParentOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_73.ui || (scene_73.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneGameObjectSection.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class NestedPrefabObjectVariableSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.NestedPrefabObjectVariableSection", "Variable", false);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/variable-properties.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        {
                            // Name
                            this.createLabel(comp, "Name", "The name of the variable associated to this object. This name is used by the compiler.");
                            const text = this.createText(comp, true);
                            this.addUpdater(() => {
                                text.value = this.flatValues_StringOneOrNothing(this.getSelection()
                                    .map(obj => this.getVarName(obj)));
                            });
                        }
                        {
                            // Type
                            const { btn } = sceneobjects.GameObjectVariableSection.createTypeEditor(this, comp);
                            btn.disabled = true;
                        }
                    }
                    getVarName(obj) {
                        const varName = scene.core.code.SceneCodeDOMBuilder.getPrefabInstanceVarName(obj);
                        return varName;
                    }
                    canEdit(obj, n) {
                        if (sceneobjects.isGameObject(obj)) {
                            const objES = obj.getEditorSupport();
                            return objES.isNestedPrefabInstance();
                        }
                        return false;
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.NestedPrefabObjectVariableSection = NestedPrefabObjectVariableSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneGameObjectSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class OriginSection extends sceneobjects.SceneGameObjectSection {
                    static SECTION_ID = "phasereditor2d.scene.ui.sceneobjects.OriginSection";
                    constructor(page) {
                        super(page, OriginSection.SECTION_ID, "Origin", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/origin-properties.html";
                    }
                    createMenu(menu) {
                        this.createToolMenuItem(menu, sceneobjects.OriginTool.ID);
                        menu.addSeparator();
                        this.getEditor().getMenuCreator().createOriginMenuItems(menu);
                        menu.addSeparator();
                        super.createMenu(menu);
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createPropertyXYRow(comp, sceneobjects.OriginComponent.origin);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.OriginComponent);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.OriginSection = OriginSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ParentDialog extends controls.dialogs.ViewerDialog {
                    _editor;
                    constructor(editor) {
                        super(new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.ParentDialog"), false);
                        this._editor = editor;
                    }
                    create() {
                        const viewer = this.getViewer();
                        viewer.setLabelProvider(new ui.editor.outline.SceneEditorOutlineLabelProvider());
                        viewer.setStyledLabelProvider(new ui.editor.outline.SceneEditorOutlineStyledLabelProvider());
                        viewer.setCellRendererProvider(new ui.editor.outline.SceneEditorOutlineRendererProvider());
                        viewer.setContentProvider(new ParentContentProvider(this._editor));
                        if (this._editor.getScene().isPrefabSceneType()) {
                            const obj = this._editor.getScene().getPrefabObject();
                            if (obj instanceof Phaser.GameObjects.Container || obj instanceof Phaser.GameObjects.Layer) {
                                viewer.setInput(obj);
                            }
                            else {
                                viewer.setInput([]);
                            }
                        }
                        else {
                            viewer.setInput(this._editor.getScene().sys.displayList);
                        }
                        viewer.setExpanded(viewer.getInput(), true);
                        super.create();
                        this.setTitle("Parent");
                        const btn = this.addOpenButton("Move", sel => {
                            const parent = sel[0];
                            if (parent instanceof Phaser.GameObjects.DisplayList) {
                                this._editor.getUndoManager().add(new sceneobjects.MoveToParentOperation(this._editor));
                            }
                            else {
                                this._editor.getUndoManager().add(new sceneobjects.MoveToParentOperation(this._editor, parent.getEditorSupport().getId()));
                            }
                        });
                        this.enableButtonOnlyWhenOneElementIsSelected(btn, dstObj => {
                            const editorSelection = this._editor.getSelectedGameObjects();
                            for (const selObj of editorSelection) {
                                // cannot move a root obj to the display list
                                if (dstObj instanceof Phaser.GameObjects.DisplayList) {
                                    if (dstObj.exists(selObj)) {
                                        return false;
                                    }
                                    return true;
                                }
                                const selObjParent = selObj.getEditorSupport().getObjectParent();
                                if (dstObj === selObjParent) {
                                    // cannot move the obj to its own parent
                                    return false;
                                }
                                if (selObj instanceof sceneobjects.ScriptNode) {
                                    // you can move a script node to any object in the dialog
                                    return true;
                                }
                                if (sceneobjects.isGameObject(dstObj)) {
                                    const dstObjES = dstObj.getEditorSupport();
                                    if (dstObjES.isPrefabInstance() && !dstObjES.isAllowAppendChildren()) {
                                        // you cannot move an object to a parent
                                        // who is not allowing adding more children
                                        return false;
                                    }
                                }
                            }
                            return true;
                        });
                        this.addCancelButton();
                    }
                }
                sceneobjects.ParentDialog = ParentDialog;
                class ParentContentProvider extends ui.editor.outline.SceneEditorOutlineContentProvider {
                    _selection;
                    constructor(editor) {
                        super(editor);
                        this._selection = editor.getSelectedGameObjects();
                    }
                    getRoots(input) {
                        return [this._editor.getScene().children];
                    }
                    getChildren(parent) {
                        let children = super.getChildren(parent);
                        children = children.filter(dstObj => {
                            // cannot add anything different to an scene or a game object
                            if (!sceneobjects.isGameObject(dstObj) && !(dstObj instanceof Phaser.GameObjects.DisplayList)) {
                                return false;
                            }
                            for (const selObj of this._selection) {
                                // cannot move a layer to a container
                                if (selObj instanceof sceneobjects.Layer && dstObj instanceof sceneobjects.Container) {
                                    return false;
                                }
                                // cannot add to itself or any's childlren
                                if (selObj === dstObj) {
                                    return false;
                                }
                                // cannot add a non-script-node to a script node
                                if (dstObj instanceof sceneobjects.ScriptNode && !(selObj instanceof sceneobjects.ScriptNode)) {
                                    return false;
                                }
                                // cannot add a non-script-node to a non-layer-or-container
                                if (!(dstObj instanceof sceneobjects.Layer || dstObj instanceof sceneobjects.Container) && !(selObj instanceof sceneobjects.ScriptNode)) {
                                    return false;
                                }
                                return true;
                            }
                        });
                        return children;
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SceneGameObjectSection.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PrefabObjectVariableSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.PrefabObjectVariableSection", "Variable", false);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/variable-properties.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        sceneobjects.GameObjectVariableSection.createTypeEditor(this, comp);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.VariableComponent)
                            && this.isPrefabSceneObject(obj);
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.PrefabObjectVariableSection = PrefabObjectVariableSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../SceneGameObjectOperation.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PropertyUnlockOperation extends sceneobjects.SceneGameObjectOperation {
                    _properties;
                    constructor(editor, objects, properties, unlocked) {
                        super(editor, objects, unlocked);
                        this._properties = properties;
                    }
                    getValue(obj) {
                        for (const prop of this._properties) {
                            const locked = !obj.getEditorSupport().isUnlockedProperty(prop);
                            if (locked) {
                                return false;
                            }
                        }
                        return true;
                    }
                    setValue(obj, unlocked) {
                        for (const prop of this._properties) {
                            const support = obj.getEditorSupport();
                            if (support.isPrefabInstance()) {
                                if (!unlocked) {
                                    const prefabSer = support.getPrefabSerializer();
                                    const propValue = prefabSer.read(prop.name, support.getPropertyDefaultValue(prop));
                                    prop.setValue(obj, propValue);
                                }
                                obj.getEditorSupport().setUnlockedProperty(prop, unlocked);
                            }
                        }
                    }
                }
                sceneobjects.PropertyUnlockOperation = PropertyUnlockOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TintSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.TintSection", "Tint", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/tint-properties.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr";
                        this.createPropertyBoolean(comp, sceneobjects.TintComponent.tintFill);
                        this.createPropertyColorRow(comp, sceneobjects.TintComponent.tintTopLeft, false);
                        this.createPropertyColorRow(comp, sceneobjects.TintComponent.tintTopRight, false);
                        this.createPropertyColorRow(comp, sceneobjects.TintComponent.tintBottomLeft, false);
                        this.createPropertyColorRow(comp, sceneobjects.TintComponent.tintBottomRight, false);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.TintComponent);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.TintSection = TintSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TintSingleSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.TintSingleSection", "Tint", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/tint-properties.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr";
                        this.createPropertyBoolean(comp, sceneobjects.TintSingleComponent.tintFill);
                        this.createPropertyColorRow(comp, sceneobjects.TintSingleComponent.tint, false);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.TintSingleComponent);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.TintSingleSection = TintSingleSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../../editor/properties/BaseSceneSection.ts"/>
/// <reference path="./SceneGameObjectSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TransformSection extends sceneobjects.SceneGameObjectSection {
                    static SECTION_ID = "phasereditor2d.scene.ui.sceneobjects.TransformSection";
                    constructor(page) {
                        super(page, TransformSection.SECTION_ID, "Transform", false);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/transform-properties.html";
                    }
                    createMenu(menu) {
                        this.createToolMenuItem(menu, sceneobjects.TranslateTool.ID);
                        this.createToolMenuItem(menu, sceneobjects.ScaleTool.ID);
                        this.createToolMenuItem(menu, sceneobjects.RotateTool.ID);
                        menu.addSeparator();
                        this.getEditor().getMenuCreator().createCoordsMenuItems(menu);
                        menu.addSeparator();
                        super.createMenu(menu);
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createPropertyXYRow(comp, sceneobjects.TransformComponent.position);
                        this.createPropertyXYRow(comp, sceneobjects.TransformComponent.scale);
                        this.createNumberPropertyRow(comp, sceneobjects.TransformComponent.angle, false);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.TransformComponent) && n > 0;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.TransformSection = TransformSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class VisibleSection extends sceneobjects.SceneGameObjectSection {
                    static SECTION_ID = "phasereditor2d.scene.ui.sceneobjects.VisibleSection";
                    constructor(page) {
                        super(page, VisibleSection.SECTION_ID, "Visible", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/visible-property.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr";
                        this.createPropertyBoolean(comp, sceneobjects.VisibleComponent.visible);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.VisibleComponent) && n > 0;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.VisibleSection = VisibleSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                const containerOriginProperty = {
                    defValue: undefined,
                    setValue: (obj, value) => {
                        obj.setPosition(value.x, value.y);
                        let i = 0;
                        for (const child of obj.list) {
                            child.setPosition(value.children[i].x, value.children[i].y);
                            i++;
                        }
                    },
                    getValue: obj => {
                        return {
                            x: obj.x,
                            y: obj.y,
                            children: obj.list.map((child) => ({
                                x: child.x,
                                y: child.y
                            }))
                        };
                    },
                    name: "containerOrigin"
                };
                class ContainerOriginToolItem extends ui.editor.tools.SceneToolItem {
                    _axis;
                    _initCursorPos;
                    _worldPosition_1;
                    _position_1;
                    _localTx;
                    _worldTx;
                    _initValue;
                    constructor(axis) {
                        super();
                        this._axis = axis;
                    }
                    isValidFor(objects) {
                        return objects.length === 1 && objects[0] instanceof sceneobjects.Container;
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        const d = Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y);
                        return d < 20;
                    }
                    onStartDrag(args) {
                        if (this.containsPoint(args)) {
                            const container = this.getContainer(args);
                            this._initCursorPos = { x: args.x, y: args.y };
                            this._position_1 = new Phaser.Math.Vector2(container.x, container.y);
                            this._localTx = container.getLocalTransformMatrix();
                            this._worldTx = container.getWorldTransformMatrix();
                            this._worldPosition_1 = new Phaser.Math.Vector2();
                            container.getWorldTransformMatrix().transformPoint(0, 0, this._worldPosition_1);
                            for (const obj of container.list) {
                                const sprite = obj;
                                sprite.setData("ContainerOriginTool.position", { x: sprite.x, y: sprite.y });
                            }
                            this._initValue = containerOriginProperty.getValue(container);
                        }
                    }
                    getContainer(args) {
                        return args.objects[0];
                    }
                    onDrag(args) {
                        if (!this._initCursorPos) {
                            return;
                        }
                        const cursorDx = args.x - this._initCursorPos.x;
                        const cursorDy = args.y - this._initCursorPos.y;
                        const xAxis = this._axis === "x" || this._axis === "xy" ? 1 : 0;
                        const yAxis = this._axis === "y" || this._axis === "xy" ? 1 : 0;
                        const worldDx = cursorDx / args.camera.zoom * xAxis;
                        const worldDy = cursorDy / args.camera.zoom * yAxis;
                        const worldPoint = new Phaser.Math.Vector2(this._worldPosition_1.x + worldDx, this._worldPosition_1.y + worldDy);
                        const container = this.getContainer(args);
                        const localPoint = new Phaser.Math.Vector2();
                        this._worldTx.applyInverse(worldPoint.x, worldPoint.y, localPoint);
                        for (const child of container.list) {
                            const sprite = child;
                            const { x, y } = sprite.getData("ContainerOriginTool.position");
                            sprite.x = x - localPoint.x;
                            sprite.y = y - localPoint.y;
                        }
                        const delta = new Phaser.Math.Vector2();
                        this._localTx.transformPoint(localPoint.x, localPoint.y, delta);
                        delta.x -= this._position_1.x;
                        delta.y -= this._position_1.y;
                        container.setPosition(this._position_1.x + delta.x, this._position_1.y + delta.y);
                        args.editor.dispatchSelectionChanged();
                    }
                    onStopDrag(args) {
                        if (this._initCursorPos) {
                            const editor = args.editor;
                            const container = this.getContainer(args);
                            const value = containerOriginProperty.getValue(container);
                            containerOriginProperty.setValue(container, this._initValue);
                            editor.getUndoManager().add(new sceneobjects.SimpleOperation(editor, [container], containerOriginProperty, value));
                        }
                        this._initCursorPos = null;
                    }
                    getPoint(args) {
                        return this.getSimpleTranslationPoint(this._axis, args);
                    }
                    render(args) {
                        const { x, y } = this.getPoint(args);
                        this.renderSimpleAxis(this._axis, x, y, "#fff", args);
                    }
                }
                sceneobjects.ContainerOriginToolItem = ContainerOriginToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../../editor/tools/SceneToolOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class OriginOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialValue(obj) {
                        return sceneobjects.OriginToolItem.getInitObjectOriginAndPosition(obj);
                    }
                    getFinalValue(obj) {
                        return sceneobjects.OriginToolItem.createFinalData(obj);
                    }
                    setValue(obj, value) {
                        const sprite = obj;
                        sprite.x = value.x;
                        sprite.y = value.y;
                        sprite.setOrigin(value.originX, value.originY);
                    }
                }
                sceneobjects.OriginOperation = OriginOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class OriginTool extends sceneobjects.BaseObjectTool {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.OriginTool";
                    constructor() {
                        super({
                            id: OriginTool.ID,
                            command: ui.editor.commands.CMD_SET_ORIGIN_SCENE_OBJECT,
                        });
                        const x = new sceneobjects.OriginToolItem("x");
                        const y = new sceneobjects.OriginToolItem("y");
                        const xy = new sceneobjects.OriginToolItem("xy");
                        const containerX = new sceneobjects.ContainerOriginToolItem("x");
                        const containerY = new sceneobjects.ContainerOriginToolItem("y");
                        const containerXY = new sceneobjects.ContainerOriginToolItem("xy");
                        this.addItems(new ui.editor.tools.LineToolItem("#f00", xy, x), new ui.editor.tools.LineToolItem("#0f0", xy, y), xy, x, y, new ui.editor.tools.LineToolItem("#f00", containerXY, containerX), new ui.editor.tools.LineToolItem("#0f0", containerXY, containerY), containerXY, containerX, containerY);
                    }
                    getProperties(obj) {
                        return obj.getEditorSupport().getOriginProperties();
                    }
                    canEdit(obj) {
                        if (obj instanceof sceneobjects.Container) {
                            const objES = obj.getEditorSupport();
                            if (objES.isPrefabInstance()) {
                                for (const test of [obj, ...objES.getObjectChildren()]) {
                                    if (!test.getEditorSupport().isUnlockedPropertyXY(sceneobjects.TransformComponent.position)) {
                                        return false;
                                    }
                                }
                            }
                            return true;
                        }
                        return super.canEdit(obj);
                    }
                    canRender(obj) {
                        if (obj instanceof sceneobjects.Container) {
                            return true;
                        }
                        return super.canRender(obj);
                    }
                    onActivated(args) {
                        super.onActivated(args);
                        const props = args.objects.flatMap(obj => obj.getEditorSupport().getOriginProperties());
                        const sections = args.objects.flatMap(obj => obj.getEditorSupport().getOriginSectionId());
                        this.confirmUnlockProperty(args, props, "origin", ...sections);
                    }
                }
                sceneobjects.OriginTool = OriginTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class OriginToolItem extends ui.editor.tools.SceneToolItem {
                    _axis;
                    _initCursorPos;
                    _displayOrigin_1;
                    _spriteWorldPosition_1;
                    _spriteWorldTx_1;
                    _position_1;
                    _localTx_1;
                    _origin_1;
                    constructor(axis) {
                        super();
                        this._axis = axis;
                    }
                    isValidFor(objects) {
                        return objects.length === 1
                            && objects[0].getEditorSupport().supportsOrigin();
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        const d = Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y);
                        return d < 20;
                    }
                    onStartDrag(args) {
                        if (this.containsPoint(args)) {
                            this._initCursorPos = { x: args.x, y: args.y };
                            const sprite = this.getSprite(args);
                            const worldPoint = new Phaser.Math.Vector2();
                            const tx = sprite.getWorldTransformMatrix();
                            tx.transformPoint(0, 0, worldPoint);
                            const { originX, originY } = sprite.getEditorSupport().computeOrigin();
                            const { displayOriginX, displayOriginY } = sprite.getEditorSupport().computeDisplayOrigin();
                            this._spriteWorldPosition_1 = worldPoint;
                            this._spriteWorldTx_1 = tx;
                            this._localTx_1 = sprite.getLocalTransformMatrix();
                            this._displayOrigin_1 = new Phaser.Math.Vector2(displayOriginX, displayOriginY);
                            this._origin_1 = new Phaser.Math.Vector2(originX, originY);
                            this._position_1 = new Phaser.Math.Vector2(sprite.x, sprite.y);
                        }
                    }
                    getSprite(args) {
                        return args.objects[0];
                    }
                    onDrag(args) {
                        if (!this._initCursorPos) {
                            return;
                        }
                        const sprite = this.getSprite(args);
                        const worldDelta = this.getTranslationInAxisWorldDelta(this._axis, this._initCursorPos.x, this._initCursorPos.y, args);
                        const worldPoint2 = this._spriteWorldPosition_1.clone().add(worldDelta);
                        const displayOriginPoint_2 = new Phaser.Math.Vector2();
                        this._spriteWorldTx_1.applyInverse(worldPoint2.x, worldPoint2.y, displayOriginPoint_2);
                        // when get the display point, it uses the initial origin,
                        // so we have to add it to the result, to get a 0,0 based display origin.
                        const originX_2 = (this._displayOrigin_1.x + displayOriginPoint_2.x) / sprite.width;
                        const originY_2 = (this._displayOrigin_1.y + displayOriginPoint_2.y) / sprite.height;
                        OriginToolItem.changeOriginKeepPosition(sprite, this._displayOrigin_1.x, this._displayOrigin_1.y, originX_2, originY_2, this._localTx_1, this._position_1.x, this._position_1.y);
                        args.editor.updateInspectorViewSection(sprite.getEditorSupport().getOriginSectionId());
                    }
                    static simpleChangeOriginKeepPosition(sprite, newOriginX, newOriginY) {
                        const { displayOriginX, displayOriginY } = sprite.getEditorSupport().computeDisplayOrigin();
                        this.changeOriginKeepPosition(sprite, displayOriginX, displayOriginY, newOriginX, newOriginY, sprite.getLocalTransformMatrix(), sprite.x, sprite.y);
                    }
                    static changeOriginKeepPosition(sprite, displayOriginX_1, displayOriginY_1, originX_2, originY_2, localTx_1, x_1, y_1) {
                        sprite.setOrigin(originX_2, originY_2);
                        const { displayOriginX, displayOriginY } = sprite.getEditorSupport().computeDisplayOrigin();
                        const displayOriginDx = displayOriginX - displayOriginX_1;
                        const displayOriginDy = displayOriginY - displayOriginY_1;
                        const displayOriginDelta = new Phaser.Math.Vector2(displayOriginDx, displayOriginDy);
                        localTx_1.transformPoint(displayOriginDelta.x, displayOriginDelta.y, displayOriginDelta);
                        displayOriginDelta.add(new Phaser.Math.Vector2(-x_1, -y_1));
                        sprite.setPosition(x_1 + displayOriginDelta.x, y_1 + displayOriginDelta.y);
                    }
                    static getInitObjectOriginAndPosition(obj) {
                        return obj.getData("OriginTool.initData");
                    }
                    static createFinalData(sprite) {
                        const { originX, originY } = sprite.getEditorSupport().computeOrigin();
                        return {
                            x: sprite.x,
                            y: sprite.y,
                            originX: originX,
                            originY: originY
                        };
                    }
                    onStopDrag(args) {
                        if (this._initCursorPos) {
                            const editor = args.editor;
                            const sprite = this.getSprite(args);
                            const data = {
                                x: this._position_1.x,
                                y: this._position_1.y,
                                originX: this._origin_1.x,
                                originY: this._origin_1.y
                            };
                            sprite.setData("OriginTool.initData", data);
                            editor.getUndoManager().add(new sceneobjects.OriginOperation(args));
                        }
                        this._initCursorPos = null;
                    }
                    getPoint(args) {
                        return this.getSimpleTranslationPoint(this._axis, args);
                    }
                    render(args) {
                        const { x, y } = this.getPoint(args);
                        this.renderSimpleAxis(this._axis, x, y, "#fff", args);
                    }
                }
                sceneobjects.OriginToolItem = OriginToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PanTool extends ui.editor.tools.SceneTool {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.PanTool";
                    _dragStartPoint;
                    _dragStartCameraScroll;
                    constructor() {
                        super({
                            command: ui.editor.commands.CMD_PAN_SCENE,
                            id: PanTool.ID
                        });
                    }
                    onActivated(args) {
                        this.setCursor(args.editor, "grab");
                    }
                    onDeactivated(args) {
                        this.setCursor(args.editor, "auto");
                    }
                    setCursor(editor, style) {
                        editor.getOverlayLayer().getCanvas().style.cursor = style;
                    }
                    onStartDrag(args) {
                        const camera = args.camera;
                        const e = args.event;
                        this._dragStartPoint = new Phaser.Math.Vector2(e.offsetX, e.offsetY);
                        this._dragStartCameraScroll = new Phaser.Math.Vector2(camera.scrollX, camera.scrollY);
                        args.event.preventDefault();
                    }
                    onDrag(args) {
                        this.setCursor(args.editor, "grabbing");
                        const e = args.event;
                        const dx = this._dragStartPoint.x - e.offsetX;
                        const dy = this._dragStartPoint.y - e.offsetY;
                        const camera = args.camera;
                        camera.scrollX = this._dragStartCameraScroll.x + dx / camera.zoom;
                        camera.scrollY = this._dragStartCameraScroll.y + dy / camera.zoom;
                        e.preventDefault();
                        args.editor.repaint();
                    }
                    onStopDrag(args) {
                        this.setCursor(args.editor, "grab");
                    }
                    render(args) {
                        // nothing
                    }
                    canEdit(obj) {
                        return false;
                    }
                    canRender(obj) {
                        return false;
                    }
                    isObjectTool() {
                        return false;
                    }
                }
                sceneobjects.PanTool = PanTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PolygonHitAreaOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialValue(obj) {
                        return sceneobjects.PolygonHitAreaToolItem.getInitialPoints(obj);
                    }
                    getFinalValue(obj) {
                        const comp = sceneobjects.PolygonHitAreaComponent.getPolygonComponent(obj);
                        return comp.points;
                    }
                    setValue(obj, value) {
                        const comp = sceneobjects.PolygonHitAreaComponent.getPolygonComponent(obj);
                        comp.points = value;
                    }
                }
                sceneobjects.PolygonHitAreaOperation = PolygonHitAreaOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PolygonOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialValue(obj) {
                        return sceneobjects.PolygonToolItem.getInitialPoints(obj);
                    }
                    getFinalValue(obj) {
                        return obj.points;
                    }
                    setValue(obj, value) {
                        const polygon = obj;
                        polygon.points = value;
                    }
                }
                sceneobjects.PolygonOperation = PolygonOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseObjectTool.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PolygonTool extends sceneobjects.BaseObjectTool {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.PolygonTool";
                    _toolItem;
                    constructor() {
                        super({
                            id: PolygonTool.ID,
                            command: ui.editor.commands.CMD_EDIT_POLYGON_OBJECT,
                        }, sceneobjects.PolygonComponent.points);
                        this._toolItem = new sceneobjects.PolygonToolItem();
                        this.addItems(this._toolItem);
                    }
                    handleDoubleClick(args) {
                        return this._toolItem.handleDoubleClick(args);
                    }
                    handleDeleteCommand(args) {
                        return this._toolItem.handleDeleteCommand(args);
                    }
                    requiresRepaintOnMouseMove() {
                        return true;
                    }
                    onActivated(args) {
                        this.confirmUnlockProperty(args, [sceneobjects.PolygonComponent.points], "points", sceneobjects.PolygonSection.SECTION_ID);
                    }
                    isValidForAll(objects) {
                        return objects.length === 1;
                    }
                    canRender(obj) {
                        return obj instanceof sceneobjects.Polygon;
                    }
                }
                sceneobjects.PolygonTool = PolygonTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PolygonToolItem extends ui.editor.tools.SceneToolItem {
                    _dragging;
                    _draggingIndex;
                    _newPoint;
                    _newPointIndex;
                    _highlightPointIndex = -1;
                    constructor() {
                        super();
                    }
                    handleDoubleClick(args) {
                        if (this._highlightPointIndex >= 0) {
                            const op = new ui.editor.undo.SceneSnapshotOperation(args.editor, async () => {
                                this.handleDeleteCommand(args);
                            });
                            args.editor.getUndoManager().add(op);
                            return true;
                        }
                        return false;
                    }
                    handleDeleteCommand(args) {
                        if (this._highlightPointIndex >= 0) {
                            const polygon = args.objects[0];
                            const points = polygon.getPolygonGeom().points;
                            if (points.length <= 3) {
                                return true;
                            }
                            const newPoints = [];
                            for (let i = 0; i < points.length; i++) {
                                if (i !== this._highlightPointIndex) {
                                    newPoints.push(points[i]);
                                }
                            }
                            polygon.points = newPoints.map(p => `${p.x} ${p.y}`).join(" ");
                            return true;
                        }
                        return false;
                    }
                    getPoint(args) {
                        return { x: 0, y: 0 };
                    }
                    render(args) {
                        if (args.objects.length !== 1) {
                            return;
                        }
                        let nearPoint;
                        let nearPointIndex;
                        const polygon = args.objects[0];
                        const points = this.getPolygonScreenPoints(polygon);
                        const ctx = args.canvasContext;
                        const cursor = args.editor.getMouseManager().getMousePosition();
                        // find highlihting point
                        let highlightPoint;
                        let highlightPointIndex = -1;
                        for (let i = 0; i < points.length; i++) {
                            const point = points[i];
                            if (this.isCursorOnPoint(cursor.x, cursor.y, point)) {
                                highlightPoint = point;
                                highlightPointIndex = i;
                                break;
                            }
                        }
                        if (!highlightPoint) {
                            // paint near line
                            let nearLine;
                            let nearLineDistance = Number.MAX_VALUE;
                            const line = new Phaser.Geom.Line();
                            const tempPoint = new Phaser.Geom.Point();
                            for (let i = 0; i < points.length; i++) {
                                const p1 = points[i];
                                const p2 = points[(i + 1) % points.length];
                                line.setTo(p1.x, p1.y, p2.x, p2.y);
                                Phaser.Geom.Line.GetNearestPoint(line, new Phaser.Geom.Point(cursor.x, cursor.y), tempPoint);
                                const d = Phaser.Math.Distance.BetweenPoints(cursor, tempPoint);
                                if (d < 10 && d < nearLineDistance) {
                                    const lineLength = Phaser.Geom.Line.Length(line);
                                    const length1 = Phaser.Math.Distance.BetweenPoints(p1, tempPoint);
                                    const length2 = Phaser.Math.Distance.BetweenPoints(p2, tempPoint);
                                    // check the point is inside the segment
                                    if (length1 <= lineLength && length2 <= lineLength) {
                                        nearLineDistance = d;
                                        nearPointIndex = i;
                                        if (nearLine) {
                                            nearLine.setTo(line.x1, line.y1, line.x2, line.y2);
                                            nearPoint.setTo(tempPoint.x, tempPoint.y);
                                        }
                                        else {
                                            nearLine = new Phaser.Geom.Line(line.x1, line.y1, line.x2, line.y2);
                                            nearPoint = new Phaser.Geom.Point(tempPoint.x, tempPoint.y);
                                        }
                                    }
                                }
                            }
                            if (nearLine) {
                                const color = args.canEdit ? "#fff" : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT;
                                // draw near line
                                ctx.save();
                                ctx.translate(nearLine.x1, nearLine.y1);
                                const angle = this.globalAngle(polygon);
                                ctx.rotate(Phaser.Math.DegToRad(angle));
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(nearLine.x2 - nearLine.x1, nearLine.y2 - nearLine.y1);
                                ctx.strokeStyle = color;
                                ctx.lineWidth = 3;
                                ctx.stroke();
                                ctx.restore();
                                // draw near point
                                ctx.save();
                                ctx.translate(nearPoint.x, nearPoint.y);
                                ctx.rotate(Phaser.Math.DegToRad(this.globalAngle(polygon)));
                                this.drawRect(ctx, args.canEdit ? "#faa" : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                                ctx.restore();
                            }
                        }
                        // paint highlight point
                        for (const point of points) {
                            ctx.save();
                            ctx.translate(point.x, point.y);
                            const angle = this.globalAngle(polygon);
                            ctx.rotate(Phaser.Math.DegToRad(angle));
                            const color = point === highlightPoint ? "#f00" : "#fff";
                            this.drawRect(ctx, args.canEdit ? color : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                            ctx.restore();
                        }
                        this._newPoint = nearPoint ? this.getPolygonLocalPoint(polygon, nearPoint) : undefined;
                        this._newPointIndex = nearPointIndex;
                        this._highlightPointIndex = highlightPointIndex;
                    }
                    getPolygonScreenPoints(polygon) {
                        const points = [];
                        const worldPoint = new Phaser.Math.Vector2(0, 0);
                        for (const point of polygon.getPolygonGeom().points) {
                            polygon.getWorldTransformMatrix().transformPoint(point.x - polygon.displayOriginX, point.y - polygon.displayOriginY, worldPoint);
                            const screenPoint = polygon.scene.cameras.main.getScreenPoint(worldPoint.x, worldPoint.y);
                            points.push(screenPoint);
                        }
                        return points;
                    }
                    getPolygonLocalPoint(polygon, point) {
                        const camera = polygon.scene.cameras.main;
                        point = camera.getWorldPoint2(point.x, point.y);
                        const localPoint = polygon.getWorldTransformMatrix().applyInverse(point.x, point.y);
                        localPoint.x += polygon.displayOriginX;
                        localPoint.y += polygon.displayOriginY;
                        return localPoint;
                    }
                    containsPoint(args) {
                        if (this._newPoint) {
                            return true;
                        }
                        const points = this.getPolygonScreenPoints(args.objects[0]);
                        for (const point of points) {
                            if (this.isCursorOnPoint(args.x, args.y, point)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    isCursorOnPoint(cursorX, cursorY, point) {
                        return cursorX >= point.x - 5 && cursorX <= point.x + 5
                            && cursorY >= point.y - 5 && cursorY <= point.y + 5;
                    }
                    _startDragTime = 0;
                    onStartDrag(args) {
                        this._startDragTime = Date.now();
                        const polygon = args.objects[0];
                        if (this._newPoint) {
                            const points = polygon.getPolygonGeom().points;
                            let newPoints = [];
                            for (let i = 0; i < points.length; i++) {
                                const point = points[i];
                                newPoints.push(point);
                                if (this._newPointIndex === i) {
                                    newPoints.push(this._newPoint);
                                }
                            }
                            polygon.points = newPoints.map(p => `${p.x} ${p.y}`).join(" ");
                        }
                        const cursor = args.editor.getMouseManager().getMousePosition();
                        const points = this.getPolygonScreenPoints(polygon);
                        for (let i = 0; i < points.length; i++) {
                            const point = points[i];
                            if (this.isCursorOnPoint(cursor.x, cursor.y, point)) {
                                polygon.setData("PolygonToolItem", {
                                    initPoints: polygon.points
                                });
                                this._draggingIndex = i;
                                this._dragging = true;
                                break;
                            }
                        }
                    }
                    static getInitialPoints(polygon) {
                        return polygon.getData("PolygonToolItem").initPoints;
                    }
                    isValidFor(objects) {
                        return objects.length === 1
                            && objects[0].getEditorSupport().hasComponent(sceneobjects.PolygonComponent);
                    }
                    onDrag(args) {
                        if (!this._dragging) {
                            return;
                        }
                        const polygon = args.objects[0];
                        const points = polygon.getPolygonGeom().points;
                        const point = points[this._draggingIndex];
                        const newPoint = args.editor.getScene().getCamera().getWorldPoint(args.x, args.y);
                        polygon.getWorldTransformMatrix().applyInverse(newPoint.x, newPoint.y, newPoint);
                        point.x = newPoint.x + polygon.displayOriginX;
                        point.y = newPoint.y + polygon.displayOriginY;
                        polygon.points = points.map(p => `${p.x} ${p.y}`).join(" ");
                        args.editor.updateInspectorViewSection(sceneobjects.PolygonSection.SECTION_ID);
                    }
                    onStopDrag(args) {
                        this._newPoint = undefined;
                        if (this._dragging) {
                            if (Date.now() - this._startDragTime > 300) {
                                args.editor.getUndoManager().add(new sceneobjects.PolygonOperation(args));
                            }
                            this._dragging = false;
                        }
                    }
                }
                sceneobjects.PolygonToolItem = PolygonToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RotateLineToolItem extends ui.editor.tools.SceneToolItem {
                    _start;
                    constructor(start) {
                        super();
                        this._start = start;
                    }
                    render(args) {
                        let globalStartAngle = 0;
                        let globalEndAngle = 0;
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const endAngle = this.globalAngle(sprite);
                            let startAngle = 0;
                            if (args.localCoords) {
                                if (sprite.parentContainer) {
                                    startAngle = this.globalAngle(sprite.parentContainer);
                                }
                            }
                            globalStartAngle += startAngle;
                            globalEndAngle += endAngle;
                        }
                        const len = args.objects.length;
                        globalStartAngle /= len;
                        globalEndAngle /= len;
                        const angle = this._start ? globalStartAngle : globalEndAngle;
                        const point = this.getAvgScreenPointOfObjects(args);
                        const ctx = args.canvasContext;
                        ctx.save();
                        ctx.translate(point.x, point.y);
                        ctx.rotate(Phaser.Math.DegToRad(angle));
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(100, 0);
                        ctx.strokeStyle = "#000";
                        ctx.lineWidth = 4;
                        ctx.stroke();
                        ctx.strokeStyle = args.canEdit ? sceneobjects.RotateToolItem.COLOR : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        ctx.restore();
                    }
                    containsPoint(args) {
                        return false;
                    }
                    onStartDrag(args) {
                        // nothing
                    }
                    onDrag(args) {
                        // nothing
                    }
                    onStopDrag(args) {
                        // nothing
                    }
                }
                sceneobjects.RotateLineToolItem = RotateLineToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../../editor/tools/SceneToolOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RotateOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialValue(obj) {
                        return sceneobjects.RotateToolItem.getInitialAngle(obj);
                    }
                    getFinalValue(obj) {
                        return obj.angle;
                    }
                    setValue(obj, value) {
                        obj.angle = value;
                    }
                }
                sceneobjects.RotateOperation = RotateOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseObjectTool.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RotateTool extends sceneobjects.BaseObjectTool {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.RotateTool";
                    constructor() {
                        super({
                            id: RotateTool.ID,
                            command: ui.editor.commands.CMD_ROTATE_SCENE_OBJECT,
                        }, sceneobjects.TransformComponent.angle);
                        this.addItems(new sceneobjects.RotateLineToolItem(true), new sceneobjects.RotateLineToolItem(false), new ui.editor.tools.CenterPointToolItem(sceneobjects.RotateToolItem.COLOR), new sceneobjects.RotateToolItem());
                    }
                    onActivated(args) {
                        super.onActivated(args);
                        this.confirmUnlockProperty(args, [sceneobjects.TransformComponent.angle], "angle", sceneobjects.TransformSection.SECTION_ID);
                    }
                }
                sceneobjects.RotateTool = RotateTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RotateToolItem extends ui.editor.tools.SceneToolItem {
                    static COLOR = "#aaf";
                    _initCursorPos;
                    constructor() {
                        super();
                    }
                    getPoint(args) {
                        return this.getAvgScreenPointOfObjects(args);
                    }
                    render(args) {
                        const point = this.getPoint(args);
                        const ctx = args.canvasContext;
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 100, 0, Math.PI * 2);
                        ctx.lineWidth = 4;
                        ctx.strokeStyle = "#000";
                        ctx.stroke();
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = args.canEdit ? RotateToolItem.COLOR : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT;
                        ctx.stroke();
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        const d = Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y);
                        return Math.abs(d - 100) < 10;
                    }
                    onStartDrag(args) {
                        if (!this.containsPoint(args)) {
                            return;
                        }
                        this._initCursorPos = { x: args.x, y: args.y };
                        for (const obj of args.objects) {
                            obj.setData("AngleToolItem.initAngle", obj.angle);
                        }
                    }
                    onDrag(args) {
                        if (!this._initCursorPos) {
                            return;
                        }
                        const dx = this._initCursorPos.x - args.x;
                        const dy = this._initCursorPos.y - args.y;
                        if (Math.abs(dx) < 1 || Math.abs(dy) < 1) {
                            return;
                        }
                        const point = this.getPoint(args);
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const deltaRadians = angleBetweenTwoPointsWithFixedPoint(args.x, args.y, this._initCursorPos.x, this._initCursorPos.y, point.x, point.y);
                            const initAngle = sprite.getData("AngleToolItem.initAngle");
                            const deltaAngle = Phaser.Math.RadToDeg(deltaRadians);
                            sprite.angle = Math.round(initAngle + deltaAngle);
                        }
                        args.editor.updateInspectorViewSection(sceneobjects.TransformSection.SECTION_ID);
                    }
                    static getInitialAngle(obj) {
                        return obj.getData("AngleToolItem.initAngle");
                    }
                    onStopDrag(args) {
                        if (!this._initCursorPos) {
                            return;
                        }
                        args.editor.getUndoManager().add(new sceneobjects.RotateOperation(args));
                        this._initCursorPos = null;
                    }
                }
                sceneobjects.RotateToolItem = RotateToolItem;
                function angleBetweenTwoPointsWithFixedPoint(point1X, point1Y, point2X, point2Y, fixedX, fixedY) {
                    const angle1 = Math.atan2(point1Y - fixedY, point1X - fixedX);
                    const angle2 = Math.atan2(point2Y - fixedY, point2X - fixedX);
                    return angle1 - angle2;
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ScaleOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialValue(obj) {
                        return sceneobjects.ScaleToolItem.getInitialScale(obj);
                    }
                    getFinalValue(obj) {
                        const sprite = obj;
                        return { x: sprite.scaleX, y: sprite.scaleY };
                    }
                    setValue(obj, value) {
                        const sprite = obj;
                        sprite.setScale(value.x, value.y);
                    }
                }
                sceneobjects.ScaleOperation = ScaleOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseObjectTool.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ScaleTool extends sceneobjects.BaseObjectTool {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.ScaleTool";
                    constructor() {
                        super({
                            id: ScaleTool.ID,
                            command: ui.editor.commands.CMD_SCALE_SCENE_OBJECT,
                        }, sceneobjects.TransformComponent.scaleX, sceneobjects.TransformComponent.scaleY);
                        this.addItems(new sceneobjects.ScaleToolItem(1, 0.5), new sceneobjects.ScaleToolItem(1, 1), new sceneobjects.ScaleToolItem(0.5, 1));
                    }
                    onActivated(args) {
                        super.onActivated(args);
                        this.confirmUnlockProperty(args, [sceneobjects.TransformComponent.scale.x, sceneobjects.TransformComponent.scale.y], "scale", sceneobjects.TransformSection.SECTION_ID);
                    }
                }
                sceneobjects.ScaleTool = ScaleTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ScaleToolItem extends ui.editor.tools.SceneToolItem {
                    _x;
                    _y;
                    _dragging;
                    constructor(x, y) {
                        super();
                        this._x = x;
                        this._y = y;
                    }
                    getPoint(args) {
                        return this.getAvgScreenPointOfObjects(args, (sprite) => {
                            const originX = sprite.getEditorSupport().computeOrigin().originX;
                            return this._x - originX;
                        }, (sprite) => {
                            const originY = sprite.getEditorSupport().computeOrigin().originY;
                            return this._y - originY;
                        });
                    }
                    render(args) {
                        const point = this.getPoint(args);
                        const ctx = args.canvasContext;
                        ctx.save();
                        ctx.translate(point.x, point.y);
                        const angle = this.globalAngle(args.objects[0]);
                        ctx.rotate(Phaser.Math.DegToRad(angle));
                        this.drawRect(ctx, args.canEdit ? "#0ff" : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                        ctx.restore();
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        return Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y) < 20;
                    }
                    onStartDrag(args) {
                        if (!this.containsPoint(args)) {
                            return;
                        }
                        this._dragging = true;
                        const point = this.getPoint(args);
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const worldTx = new Phaser.GameObjects.Components.TransformMatrix();
                            const initLocalPos = new Phaser.Math.Vector2();
                            sprite.getWorldTransformMatrix(worldTx);
                            worldTx.applyInverse(point.x, point.y, initLocalPos);
                            const { width, height } = sprite.getEditorSupport().computeSize();
                            sprite.setData("ScaleToolItem", {
                                initScaleX: sprite.scaleX,
                                initScaleY: sprite.scaleY,
                                initWidth: width,
                                initHeight: height,
                                initLocalPos: initLocalPos,
                                initWorldTx: worldTx
                            });
                        }
                    }
                    static getInitialScale(obj) {
                        const data = obj.getData("ScaleToolItem");
                        return { x: data.initScaleX, y: data.initScaleY };
                    }
                    onDrag(args) {
                        if (!this._dragging) {
                            return;
                        }
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const data = sprite.data.get("ScaleToolItem");
                            const initLocalPos = data.initLocalPos;
                            const localPos = new Phaser.Math.Vector2();
                            const worldTx = data.initWorldTx;
                            worldTx.applyInverse(args.x, args.y, localPos);
                            let flipX = sprite.flipX ? -1 : 1;
                            let flipY = sprite.flipY ? -1 : 1;
                            if (sprite instanceof Phaser.GameObjects.TileSprite) {
                                flipX = 1;
                                flipY = 1;
                            }
                            const dx = (localPos.x - initLocalPos.x) * flipX / args.camera.zoom;
                            const dy = (localPos.y - initLocalPos.y) * flipY / args.camera.zoom;
                            const { displayOriginX, displayOriginY } = sprite.getEditorSupport()
                                .computeDisplayOrigin();
                            let width = data.initWidth - displayOriginX;
                            let height = data.initHeight - displayOriginY;
                            if (width === 0) {
                                width = data.initWidth;
                            }
                            if (height === 0) {
                                height = data.initHeight;
                            }
                            const scaleDX = dx / width * data.initScaleX;
                            const scaleDY = dy / height * data.initScaleY;
                            const newScaleX = data.initScaleX + scaleDX;
                            const newScaleY = data.initScaleY + scaleDY;
                            const changeAll = this._x === 1 && this._y === 1;
                            const changeX = this._x === 1 && this._y === 0.5 || changeAll;
                            const changeY = this._x === 0.5 && this._y === 1 || changeAll;
                            if (args.event.shiftKey) {
                                if (changeX && changeY) {
                                    const scale = Math.max(newScaleX, newScaleY);
                                    sprite.setScale(scale);
                                }
                                else {
                                    sprite.setScale(changeX ? newScaleX : newScaleY);
                                }
                            }
                            else {
                                if (changeX) {
                                    sprite.scaleX = newScaleX;
                                }
                                if (changeY) {
                                    sprite.scaleY = newScaleY;
                                }
                            }
                            args.editor.updateInspectorViewSection(sceneobjects.TransformSection.SECTION_ID);
                        }
                    }
                    onStopDrag(args) {
                        if (this._dragging) {
                            args.editor.getUndoManager().add(new sceneobjects.ScaleOperation(args));
                            this._dragging = false;
                        }
                    }
                }
                sceneobjects.ScaleToolItem = ScaleToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_74) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SelectionRegionTool extends ui.editor.tools.SceneTool {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.SelectionRegionTool";
                    _cursorStartPoint;
                    _cursorCurrentPoint;
                    constructor() {
                        super({
                            command: ui.editor.commands.CMD_SELECT_REGION,
                            id: SelectionRegionTool.ID
                        });
                    }
                    onStartDrag(args) {
                        this._cursorStartPoint = new Phaser.Math.Vector2(args.x, args.y);
                        if (!args.event.ctrlKey) {
                            args.editor.setSelection([]);
                        }
                    }
                    onDrag(args) {
                        if (this._cursorStartPoint) {
                            this._cursorCurrentPoint = new Phaser.Math.Vector2(args.x, args.y);
                            args.editor.getOverlayLayer().render();
                        }
                    }
                    onStopDrag(args) {
                        if (this._cursorStartPoint && this._cursorCurrentPoint) {
                            const result = this.getRegionResult(args.editor);
                            const newSel = result
                                .filter(item => item.points.length === item.points.filter(p => p.contains).length)
                                .map(item => item.obj);
                            this._cursorStartPoint = null;
                            this._cursorCurrentPoint = null;
                            if (args.event.ctrlKey) {
                                const sel = [...args.editor.getSelection()];
                                for (const obj of newSel) {
                                    if (sel.indexOf(obj) < 0) {
                                        sel.push(obj);
                                    }
                                }
                                args.editor.setSelection(sel);
                            }
                            else {
                                args.editor.setSelection(newSel);
                            }
                        }
                        else {
                            args.editor.repaint();
                        }
                    }
                    canEdit(obj) {
                        return false;
                    }
                    canRender(obj) {
                        return false;
                    }
                    isObjectTool() {
                        return false;
                    }
                    getRegionResult(editor) {
                        const scene = editor.getScene();
                        const start = this._cursorStartPoint;
                        const end = this._cursorCurrentPoint;
                        const result = [];
                        // TODO: don't enter in prefab objects
                        scene.visitAllAskChildren(obj => {
                            if (sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.TransformComponent)) {
                                const points = obj.getEditorSupport().getScreenBounds(scene.getCamera());
                                const x1 = Math.min(start.x, end.x);
                                const x2 = Math.max(start.x, end.x);
                                const y1 = Math.min(start.y, end.y);
                                const y2 = Math.max(start.y, end.y);
                                const pointsData = points.map(point => {
                                    if (point.x >= x1 && point.x <= x2 && point.y >= y1 && point.y <= y2) {
                                        return {
                                            point,
                                            contains: true
                                        };
                                    }
                                    else {
                                        return {
                                            point,
                                            contains: false
                                        };
                                    }
                                });
                                result.push({
                                    obj,
                                    points: pointsData
                                });
                            }
                            if (obj.getEditorSupport().isPrefabInstance()) {
                                return false;
                            }
                            if (obj instanceof sceneobjects.Container) {
                                if (!obj.getEditorSupport().isAllowPickChildren()) {
                                    return false;
                                }
                            }
                            return true;
                        });
                        return result;
                    }
                    render(args) {
                        if (!this._cursorStartPoint || !this._cursorCurrentPoint) {
                            return;
                        }
                        const ctx = args.canvasContext;
                        ctx.save();
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 4;
                        ctx.strokeRect(this._cursorStartPoint.x, this._cursorStartPoint.y, this._cursorCurrentPoint.x - this._cursorStartPoint.x, this._cursorCurrentPoint.y - this._cursorStartPoint.y);
                        ctx.strokeStyle = "#00ff00";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(this._cursorStartPoint.x, this._cursorStartPoint.y, this._cursorCurrentPoint.x - this._cursorStartPoint.x, this._cursorCurrentPoint.y - this._cursorStartPoint.y);
                        ctx.restore();
                        ctx.save();
                        const result = this.getRegionResult(args.editor);
                        for (const resultItem of result) {
                            if (resultItem.points.filter(p => p.contains).length > 0) {
                                for (const pointData of resultItem.points) {
                                    ctx.beginPath();
                                    ctx.arc(pointData.point.x, pointData.point.y, 2, 0, Math.PI * 2);
                                    ctx.fillStyle = pointData.contains ? "#0f0" : "#fff";
                                    ctx.fill();
                                    ctx.strokeStyle = "#000";
                                    ctx.stroke();
                                }
                            }
                        }
                        ctx.restore();
                    }
                }
                sceneobjects.SelectionRegionTool = SelectionRegionTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_74.ui || (scene_74.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SizeOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialValue(obj) {
                        return sceneobjects.SizeToolItem.getInitialSize(obj);
                    }
                    getFinalValue(obj) {
                        const [w, h] = obj.getEditorSupport().getSizeProperties();
                        return { x: w.getValue(obj), y: h.getValue(obj) };
                    }
                    setValue(obj, value) {
                        const [w, h] = obj.getEditorSupport().getSizeProperties();
                        w.setValue(obj, value.x);
                        h.setValue(obj, value.y);
                    }
                }
                sceneobjects.SizeOperation = SizeOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SizeTool extends sceneobjects.BaseObjectTool {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.SizeTool";
                    constructor() {
                        super({
                            id: SizeTool.ID,
                            command: ui.editor.commands.CMD_RESIZE_SCENE_OBJECT,
                        });
                        this.addItems(new sceneobjects.SizeToolItem(1, 0.5), new sceneobjects.SizeToolItem(1, 1), new sceneobjects.SizeToolItem(0.5, 1));
                    }
                    getProperties(obj) {
                        return obj.getEditorSupport().getSizeProperties();
                    }
                    onActivated(args) {
                        super.onActivated(args);
                        const props = args.objects.flatMap(obj => obj.getEditorSupport().getSizeProperties());
                        const sections = args.objects.flatMap(obj => obj.getEditorSupport().getSizeSectionId());
                        this.confirmUnlockProperty(args, props, "size", ...sections);
                    }
                }
                sceneobjects.SizeTool = SizeTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SizeToolItem extends ui.editor.tools.SceneToolItem {
                    _x;
                    _y;
                    _dragging;
                    constructor(x, y) {
                        super();
                        this._x = x;
                        this._y = y;
                    }
                    getPoint(args) {
                        return this.getAvgScreenPointOfObjects(args, (sprite) => this._x - sprite.getEditorSupport().computeOrigin().originX, (sprite) => this._y - sprite.getEditorSupport().computeOrigin().originY);
                    }
                    render(args) {
                        const point = this.getPoint(args);
                        const ctx = args.canvasContext;
                        ctx.save();
                        ctx.translate(point.x, point.y);
                        const angle = this.globalAngle(args.objects[0]);
                        ctx.rotate(Phaser.Math.DegToRad(angle));
                        this.drawRect(ctx, args.canEdit ? "#00f" : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                        ctx.restore();
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        return Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y) < 20;
                    }
                    onStartDrag(args) {
                        if (!this.containsPoint(args)) {
                            return;
                        }
                        this._dragging = true;
                        const point = this.getPoint(args);
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const worldTx = new Phaser.GameObjects.Components.TransformMatrix();
                            const initLocalPos = new Phaser.Math.Vector2();
                            sprite.getWorldTransformMatrix(worldTx);
                            worldTx.applyInverse(point.x, point.y, initLocalPos);
                            sprite.setData("SizeTool", {
                                initWidth: sprite.width,
                                initHeight: sprite.height,
                                initLocalPos: initLocalPos,
                                initWorldTx: worldTx
                            });
                        }
                    }
                    static getInitialSize(obj) {
                        const data = obj.getData("SizeTool");
                        return { x: data.initWidth, y: data.initHeight };
                    }
                    onDrag(args) {
                        if (!this._dragging) {
                            return;
                        }
                        const camera = args.camera;
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const data = sprite.data.get("SizeTool");
                            const initLocalPos = data.initLocalPos;
                            const worldTx = data.initWorldTx;
                            const localPos = new Phaser.Math.Vector2();
                            worldTx.applyInverse(args.x, args.y, localPos);
                            const flipX = sprite.flipX ? -1 : 1;
                            const flipY = sprite.flipY ? -1 : 1;
                            const { originX, originY } = sprite.getEditorSupport()
                                .computeOrigin();
                            const dx = (localPos.x - initLocalPos.x) * flipX / camera.zoom;
                            const dy = (localPos.y - initLocalPos.y) * flipY / camera.zoom;
                            const dw = dx / (1 - (originX === 1 ? 0 : originX));
                            const dh = dy / (1 - (originY === 1 ? 0 : originY));
                            const { x: width, y: height } = args.editor.getScene().snapPoint(data.initWidth + dw, data.initHeight + dh);
                            const changeAll = this._x === 1 && this._y === 1;
                            const changeX = this._x === 1 && this._y === 0.5 || changeAll;
                            const changeY = this._x === 0.5 && this._y === 1 || changeAll;
                            const [widthProp, heightProp] = sprite.getEditorSupport().getSizeProperties();
                            if (changeX) {
                                widthProp.setValue(sprite, Math.floor(width));
                            }
                            if (changeY) {
                                heightProp.setValue(sprite, Math.floor(height));
                            }
                            args.editor.updateInspectorViewSection(obj.getEditorSupport().getSizeSectionId());
                        }
                    }
                    onStopDrag(args) {
                        if (this._dragging) {
                            args.editor.getUndoManager().add(new sceneobjects.SizeOperation(args));
                            this._dragging = false;
                        }
                    }
                }
                sceneobjects.SizeToolItem = SizeToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SliceOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialValue(obj) {
                        return sceneobjects.SliceToolItem.getInitialData(obj);
                    }
                    getFinalValue(obj) {
                        if (obj instanceof sceneobjects.NineSlice) {
                            return {
                                leftWidth: obj.leftWidth,
                                rightWidth: obj.rightWidth,
                                topHeight: obj.topHeight,
                                bottomHeight: obj.bottomHeight
                            };
                        }
                        return {
                            leftWidth: obj.leftWidth,
                            rightWidth: obj.rightWidth,
                            topHeight: 0,
                            bottomHeight: 0
                        };
                    }
                    setValue(obj, value) {
                        const props = obj instanceof sceneobjects.NineSlice ?
                            sceneobjects.NineSliceComponent.sliceProperties : sceneobjects.ThreeSliceComponent.sliceProperties;
                        for (const prop of props) {
                            console.log("set ", prop.name, value[prop.name]);
                            prop.setValue(obj, value[prop.name]);
                        }
                    }
                }
                sceneobjects.SliceOperation = SliceOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SliceTool extends sceneobjects.BaseObjectTool {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.SliceTool";
                    constructor() {
                        super({
                            id: SliceTool.ID,
                            command: ui.editor.commands.CMD_EDIT_SLICE_SCENE_OBJECT,
                        });
                        this.addItems(new sceneobjects.SliceToolItem("leftWidth"), new sceneobjects.SliceToolItem("rightWidth"), new sceneobjects.SliceToolItem("topHeight"), new sceneobjects.SliceToolItem("bottomHeight"));
                    }
                    isValidForAll(objects) {
                        return objects.length === 1;
                    }
                    getProperties(obj) {
                        if (obj instanceof sceneobjects.NineSlice) {
                            return sceneobjects.NineSliceComponent.sliceProperties;
                        }
                        if (obj instanceof sceneobjects.ThreeSlice) {
                            return sceneobjects.ThreeSliceComponent.sliceProperties;
                        }
                        return [];
                    }
                    onActivated(args) {
                        super.onActivated(args);
                        const props = args.objects.flatMap(obj => {
                            if (obj instanceof sceneobjects.NineSlice) {
                                return sceneobjects.NineSliceComponent.sliceProperties;
                            }
                            return sceneobjects.ThreeSliceComponent.sliceProperties;
                        });
                        const sections = args.objects.flatMap(obj => {
                            if (obj instanceof sceneobjects.NineSlice) {
                                return sceneobjects.NineSliceSection.SECTION_ID;
                            }
                            return sceneobjects.ThreeSliceSection.SECTION_ID;
                        });
                        this.confirmUnlockProperty(args, props, "slice", ...sections);
                    }
                }
                sceneobjects.SliceTool = SliceTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                const HANDLER_ANGLE = {
                    "leftWidth": 90,
                    "rightWidth": -90,
                    "topHeight": 0,
                    "bottomHeight": -180
                };
                const HANDLER_OFFSET = 12;
                const HANDLER_OFFSET_DIR = {
                    "leftWidth": { x: 0, y: -1 },
                    "rightWidth": { x: 0, y: 1 },
                    "topHeight": { x: -1, y: 0 },
                    "bottomHeight": { x: 1, y: 0 }
                };
                const HANDLER_COLOR = "skyblue";
                class SliceToolItem extends ui.editor.tools.SceneToolItem {
                    _slice;
                    _dragging;
                    constructor(slice) {
                        super();
                        this._slice = slice;
                    }
                    isValidFor(objects) {
                        for (const obj of objects) {
                            if (obj instanceof sceneobjects.ThreeSlice) {
                                if (this._slice === "topHeight" || this._slice == "bottomHeight") {
                                    return false;
                                }
                            }
                            if (!(obj instanceof sceneobjects.ThreeSlice) && !(obj instanceof sceneobjects.NineSlice)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    getPoint(args) {
                        return this.getAvgScreenPointOfObjects(args, (sprite) => {
                            const ox = sprite.getEditorSupport().computeOrigin().originX;
                            switch (this._slice) {
                                case "leftWidth":
                                    return sprite.leftWidth / sprite.width - ox;
                                case "rightWidth":
                                    return 1 - sprite.rightWidth / sprite.width - ox;
                                case "topHeight":
                                    return -ox;
                                case "bottomHeight":
                                    return 1 - ox;
                            }
                        }, (sprite) => {
                            const oy = sprite.getEditorSupport().computeOrigin().originY;
                            switch (this._slice) {
                                case "leftWidth":
                                    return -oy;
                                case "rightWidth":
                                    return 1 - oy;
                                case "topHeight":
                                    return sprite.topHeight / sprite.height - oy;
                                case "bottomHeight":
                                    return 1 - sprite.bottomHeight / sprite.height - oy;
                            }
                        });
                    }
                    render(args) {
                        const point = this.getPoint(args);
                        const ctx = args.canvasContext;
                        ctx.save();
                        ctx.translate(point.x, point.y);
                        let angle = this.globalAngle(args.objects[0]);
                        ctx.rotate(Phaser.Math.DegToRad(angle));
                        ctx.save();
                        const obj = args.objects[0];
                        const scale = this.getScreenToObjectScale(args, obj);
                        scale.x *= obj.scaleX;
                        scale.y *= obj.scaleY;
                        ctx.strokeStyle = "#fff";
                        switch (this._slice) {
                            case "leftWidth":
                                this.drawLinePath(ctx, HANDLER_COLOR, 0, 0, 0, obj.height * scale.y, true);
                                break;
                            case "rightWidth":
                                this.drawLinePath(ctx, HANDLER_COLOR, 0, 0, 0, -obj.height * scale.y, true);
                                break;
                            case "topHeight":
                                this.drawLinePath(ctx, HANDLER_COLOR, 0, 0, obj.width * scale.x, 0, true);
                                break;
                            case "bottomHeight":
                                this.drawLinePath(ctx, HANDLER_COLOR, 0, 0, -obj.width * scale.x, 0, true);
                                break;
                        }
                        ctx.restore();
                        ctx.translate(HANDLER_OFFSET_DIR[this._slice].x * HANDLER_OFFSET, HANDLER_OFFSET_DIR[this._slice].y * HANDLER_OFFSET);
                        ctx.rotate(Phaser.Math.DegToRad(HANDLER_ANGLE[this._slice]));
                        this.drawArrowPath(ctx, args.canEdit ? HANDLER_COLOR : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                        ctx.restore();
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        return Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y) < 20;
                    }
                    onStartDrag(args) {
                        if (!this.containsPoint(args)) {
                            return;
                        }
                        this._dragging = true;
                        const point = this.getPoint(args);
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const worldTx = new Phaser.GameObjects.Components.TransformMatrix();
                            const initLocalPos = new Phaser.Math.Vector2();
                            sprite.getWorldTransformMatrix(worldTx);
                            worldTx.applyInverse(point.x, point.y, initLocalPos);
                            sprite.setData("SliceTool", {
                                initLeftWidth: sprite.leftWidth,
                                initRightWidth: sprite.rightWidth,
                                initTopHeight: sprite.topHeight,
                                initBottomHeight: sprite.bottomHeight,
                                initLocalPos: initLocalPos,
                                initWorldTx: worldTx
                            });
                        }
                    }
                    onDrag(args) {
                        if (!this._dragging) {
                            return;
                        }
                        const mirror = args.event.shiftKey;
                        const camera = args.camera;
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const data = sprite.data.get("SliceTool");
                            const initLocalPos = data.initLocalPos;
                            const worldTx = data.initWorldTx;
                            const { initLeftWidth, initRightWidth, initTopHeight, initBottomHeight } = data;
                            const localPos = new Phaser.Math.Vector2();
                            worldTx.applyInverse(args.x, args.y, localPos);
                            const dx = Math.floor((localPos.x - initLocalPos.x) / camera.zoom);
                            const dy = Math.floor((localPos.y - initLocalPos.y) / camera.zoom);
                            const comp = obj instanceof sceneobjects.NineSlice ? sceneobjects.NineSliceComponent : sceneobjects.ThreeSliceComponent;
                            let value;
                            switch (this._slice) {
                                case "leftWidth":
                                    value = initLeftWidth + dx;
                                    comp.leftWidth.setValue(obj, value);
                                    if (mirror) {
                                        comp.rightWidth.setValue(obj, value);
                                    }
                                    break;
                                case "rightWidth":
                                    value = initRightWidth - dx;
                                    comp.rightWidth.setValue(obj, value);
                                    if (mirror) {
                                        comp.leftWidth.setValue(obj, value);
                                    }
                                    break;
                                case "topHeight":
                                    value = initTopHeight + dy;
                                    sceneobjects.NineSliceComponent.topHeight.setValue(obj, value);
                                    if (mirror) {
                                        sceneobjects.NineSliceComponent.bottomHeight.setValue(obj, value);
                                    }
                                    break;
                                case "bottomHeight":
                                    value = initBottomHeight - dy;
                                    sceneobjects.NineSliceComponent.bottomHeight.setValue(obj, value);
                                    if (mirror) {
                                        sceneobjects.NineSliceComponent.topHeight.setValue(obj, value);
                                    }
                                    break;
                            }
                        }
                        for (const obj of args.objects) {
                            if (obj instanceof sceneobjects.NineSlice) {
                                args.editor.updateInspectorViewSection(sceneobjects.NineSliceSection.SECTION_ID);
                                break;
                            }
                        }
                        for (const obj of args.objects) {
                            if (obj instanceof sceneobjects.ThreeSlice) {
                                args.editor.updateInspectorViewSection(sceneobjects.ThreeSliceSection.SECTION_ID);
                                break;
                            }
                        }
                    }
                    onStopDrag(args) {
                        if (this._dragging) {
                            args.editor.getUndoManager().add(new sceneobjects.SliceOperation(args));
                            this._dragging = false;
                        }
                    }
                    static getInitialData(obj) {
                        const data = obj.getData("SliceTool");
                        return {
                            leftWidth: data.initLeftWidth,
                            rightWidth: data.initRightWidth,
                            topHeight: data.initTopHeight,
                            bottomHeight: data.initBottomHeight
                        };
                    }
                }
                sceneobjects.SliceToolItem = SliceToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../../editor/tools/SceneToolOperation.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TranslateOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialValue(obj) {
                        return sceneobjects.TranslateToolItem.getInitObjectPosition(obj);
                    }
                    getFinalValue(obj) {
                        const sprite = obj;
                        return { x: sprite.x, y: sprite.y };
                    }
                    setValue(obj, value) {
                        const sprite = obj;
                        sprite.x = value.x;
                        sprite.y = value.y;
                    }
                }
                sceneobjects.TranslateOperation = TranslateOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TranslateTool extends sceneobjects.BaseObjectTool {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.TranslateTool";
                    constructor() {
                        super({
                            id: TranslateTool.ID,
                            command: ui.editor.commands.CMD_TRANSLATE_SCENE_OBJECT,
                        }, sceneobjects.TransformComponent.x, sceneobjects.TransformComponent.y);
                        const x = new sceneobjects.TranslateToolItem("x");
                        const y = new sceneobjects.TranslateToolItem("y");
                        const xy = new sceneobjects.TranslateToolItem("xy");
                        this.addItems(new ui.editor.tools.LineToolItem("#f00", xy, x), new ui.editor.tools.LineToolItem("#0f0", xy, y), xy, x, y);
                    }
                    onActivated(args) {
                        super.onActivated(args);
                        this.confirmUnlockProperty(args, [sceneobjects.TransformComponent.x, sceneobjects.TransformComponent.y], "position", sceneobjects.TransformSection.SECTION_ID);
                    }
                }
                sceneobjects.TranslateTool = TranslateTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TranslateToolItem extends ui.editor.tools.SceneToolItem {
                    _axis;
                    _initCursorPos;
                    constructor(axis) {
                        super();
                        this._axis = axis;
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        const d = Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y);
                        return d < 20;
                    }
                    onStartDrag(args) {
                        if (this.containsPoint(args)) {
                            this._initCursorPos = { x: args.x, y: args.y };
                            for (const obj of args.objects) {
                                const sprite = obj;
                                const worldPoint = new Phaser.Math.Vector2();
                                sprite.getWorldTransformMatrix().transformPoint(0, 0, worldPoint);
                                sprite.setData("TranslateTool.localInitPosition", { x: sprite.x, y: sprite.y });
                                sprite.setData("TranslateTool.objInitWorldPosition", worldPoint);
                            }
                        }
                    }
                    onDrag(args) {
                        if (!this._initCursorPos) {
                            return;
                        }
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const worldDelta = this.getTranslationInAxisWorldDelta(this._axis, this._initCursorPos.x, this._initCursorPos.y, args);
                            const spriteWorldPosition1 = sprite.getData("TranslateTool.objInitWorldPosition");
                            const spriteWorldPosition2 = worldDelta.add(spriteWorldPosition1);
                            args.editor.getScene().snapVector(spriteWorldPosition2);
                            let spriteLocalPosition2 = new Phaser.Math.Vector2();
                            if (sprite.parentContainer) {
                                sprite.parentContainer.getWorldTransformMatrix()
                                    .applyInverse(spriteWorldPosition2.x, spriteWorldPosition2.y, spriteLocalPosition2);
                            }
                            else {
                                spriteLocalPosition2 = spriteWorldPosition2;
                            }
                            sprite.setPosition(Math.round(spriteLocalPosition2.x), Math.round(spriteLocalPosition2.y));
                        }
                        args.editor.updateInspectorViewSection(sceneobjects.TransformSection.SECTION_ID);
                    }
                    static getInitObjectPosition(obj) {
                        return obj.getData("TranslateTool.localInitPosition");
                    }
                    onStopDrag(args) {
                        if (this._initCursorPos) {
                            const editor = args.editor;
                            editor.getUndoManager().add(new sceneobjects.TranslateOperation(args));
                        }
                        this._initCursorPos = null;
                    }
                    getPoint(args) {
                        return this.getSimpleTranslationPoint(this._axis, args);
                    }
                    render(args) {
                        const { x, y } = this.getPoint(args);
                        this.renderSimpleAxis(this._axis, x, y, "#ff0", args);
                    }
                }
                sceneobjects.TranslateToolItem = TranslateToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BaseArcadeBodyOffsetToolItem extends ui.editor.tools.SceneToolItem {
                    _x;
                    _y;
                    _dragging;
                    constructor(x, y) {
                        super();
                        this._x = x;
                        this._y = y;
                    }
                    getPoint(args) {
                        return this.getAvgScreenPointOfObjects(args, (sprite) => this._x, (sprite) => this._y, 
                        // remove rotation, not supported by the arcade body
                        true);
                    }
                    getScreenPointOfObject(args, sprite, fx, fy, removeRotation = false) {
                        const worldPoint = new Phaser.Geom.Point(0, 0);
                        let width;
                        let height;
                        if (sceneobjects.ArcadeComponent.isCircleBody(sprite)) {
                            width = sceneobjects.ArcadeComponent.radius.getValue(sprite) * 2;
                            height = width;
                        }
                        else {
                            const size = this.computeSize(sprite);
                            width = size.width;
                            height = size.height;
                        }
                        let { displayOriginX, displayOriginY } = sprite.getEditorSupport().computeDisplayOrigin();
                        if (sprite instanceof sceneobjects.Container) {
                            displayOriginX = 0;
                            displayOriginY = 0;
                        }
                        const body = sceneobjects.ArcadeComponent.getBody(sprite);
                        const x = body.offset.x - displayOriginX + fx * width;
                        const y = body.offset.y - displayOriginY + fy * height;
                        const tx = sprite.getWorldTransformMatrix();
                        if (removeRotation) {
                            tx.rotate(-tx.rotation);
                        }
                        tx.transformPoint(x, y, worldPoint);
                        return args.camera.getScreenPoint(worldPoint.x, worldPoint.y);
                    }
                    computeSize(obj) {
                        return {
                            width: sceneobjects.ArcadeComponent.size.x.getValue(obj),
                            height: sceneobjects.ArcadeComponent.size.y.getValue(obj)
                        };
                    }
                    render(args) {
                        const point = this.getPoint(args);
                        const ctx = args.canvasContext;
                        ctx.save();
                        ctx.translate(point.x, point.y);
                        // remove totation, not supported by the Arcade body
                        // const angle = this.globalAngle(args.objects[0] as any);
                        // ctx.rotate(Phaser.Math.DegToRad(angle));
                        this.drawRect(ctx, args.canEdit ?
                            sceneobjects.ArcadeBodyTool.BODY_TOOL_COLOR : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                        ctx.restore();
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        return Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y) < 20;
                    }
                    onStartDrag(args) {
                        if (!this.containsPoint(args)) {
                            return;
                        }
                        this._dragging = true;
                        const point = this.getPoint(args);
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const worldTx = new Phaser.GameObjects.Components.TransformMatrix();
                            const initLocalPos = new Phaser.Math.Vector2();
                            sprite.getWorldTransformMatrix(worldTx);
                            worldTx.applyInverse(point.x, point.y, initLocalPos);
                            sprite.setData("ArcadeBodyOffsetToolItem", {
                                initLocalPos: initLocalPos,
                                initLocalOffset: sprite.body.offset.clone(),
                                initWorldTx: worldTx
                            });
                        }
                    }
                    static getInitialOffset(obj) {
                        const data = obj.getData("ArcadeBodyOffsetToolItem");
                        return data.initLocalPos;
                    }
                    onDrag(args) {
                        if (!this._dragging) {
                            return;
                        }
                        const camera = args.camera;
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const data = sprite.data.get("ArcadeBodyOffsetToolItem");
                            const initLocalPos = data.initLocalPos;
                            const worldTx = data.initWorldTx;
                            const localPos = new Phaser.Math.Vector2();
                            worldTx.applyInverse(args.x, args.y, localPos);
                            const flipX = sprite.flipX ? -1 : 1;
                            const flipY = sprite.flipY ? -1 : 1;
                            const dx = (localPos.x - initLocalPos.x) * flipX / camera.zoom;
                            const dy = (localPos.y - initLocalPos.y) * flipY / camera.zoom;
                            const x = data.initLocalOffset.x + dx;
                            const y = data.initLocalOffset.y + dy;
                            const changeAll = this._x === 0 && this._y === 0 || this._x === 0.5 && this._y === 0.5;
                            const changeX = this._x === 0 && this._y === 0.5 || changeAll;
                            const changeY = this._x === 0.5 && this._y === 0 || changeAll;
                            const xProp = sceneobjects.ArcadeComponent.offset.x;
                            const yProp = sceneobjects.ArcadeComponent.offset.y;
                            if (changeX) {
                                xProp.setValue(sprite, Math.floor(x));
                            }
                            if (changeY) {
                                yProp.setValue(sprite, Math.floor(y));
                            }
                            args.editor.updateInspectorViewSection(sceneobjects.ArcadeGeometrySection.ID);
                        }
                    }
                    onStopDrag(args) {
                        if (this._dragging) {
                            args.editor.getUndoManager().add(new sceneobjects.BodyOffsetOperation(args));
                            this._dragging = false;
                        }
                    }
                }
                sceneobjects.BaseArcadeBodyOffsetToolItem = BaseArcadeBodyOffsetToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseArcadeBodyOffsetToolItem.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeBodyCircleOffsetToolItem extends sceneobjects.BaseArcadeBodyOffsetToolItem {
                    constructor() {
                        super(0.5, 0.5);
                    }
                    computeSize(obj) {
                        const d = sceneobjects.ArcadeComponent.radius.getValue(obj) * 2;
                        return { width: d, height: d };
                    }
                    isValidFor(objects) {
                        for (const obj of objects) {
                            if (sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.ArcadeComponent)) {
                                if (!sceneobjects.ArcadeComponent.isCircleBody(obj)) {
                                    return false;
                                }
                            }
                            else {
                                return false;
                            }
                        }
                        return true;
                    }
                }
                sceneobjects.ArcadeBodyCircleOffsetToolItem = ArcadeBodyCircleOffsetToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeBodyCollisionSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ArcadeCollideSection", "Arcade Physics Body Collision");
                    }
                    getSectionHelpPath() {
                        return "scene-editor/arcade-physics-properties.html#arcade-physics-body-collision-section";
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesBoolXY(parent);
                        this.createPropertyBoolean(comp, sceneobjects.ArcadeComponent.pushable).checkElement.style.gridColumn = "span 4";
                        this.createPropertyBoolean(comp, sceneobjects.ArcadeComponent.immovable).checkElement.style.gridColumn = "span 4";
                        this.createPropertyFloatRow(comp, sceneobjects.ArcadeComponent.mass).style.gridColumn = "span 4";
                        this.createPropertyXYRow(comp, sceneobjects.ArcadeComponent.bounce);
                        this.createPropertyXYRow(comp, sceneobjects.ArcadeComponent.friction);
                        this.createPropertyXYRow(comp, sceneobjects.ArcadeComponent.overlap);
                        this.createPropertyFloatRow(comp, sceneobjects.ArcadeComponent.overlapR).style.gridColumn = "span 4";
                        for (const collisionProp of [
                            sceneobjects.ArcadeComponent.collideWorldBounds,
                            sceneobjects.ArcadeComponent.onWorldBounds,
                            sceneobjects.ArcadeComponent.checkCollisionNone,
                            sceneobjects.ArcadeComponent.checkCollisionUp,
                            sceneobjects.ArcadeComponent.checkCollisionDown,
                            sceneobjects.ArcadeComponent.checkCollisionLeft,
                            sceneobjects.ArcadeComponent.checkCollisionRight,
                        ]) {
                            this.createPropertyBoolean(comp, collisionProp).checkElement.style.gridColumn = "span 4";
                        }
                    }
                    canEdit(obj, n) {
                        return n > 0 && sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.ArcadeComponent);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.ArcadeBodyCollisionSection = ArcadeBodyCollisionSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeBodyMovementSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ArcadeBodyMovementSection", "Arcade Physics Body Movement");
                    }
                    getSectionHelpPath() {
                        return "scene-editor/arcade-physics-properties.html#arcade-physics-body-movement-section";
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesBoolXY(parent);
                        this.createPropertyBoolean(comp, sceneobjects.ArcadeComponent.moves).checkElement.style.gridColumn = "span 4";
                        this.createPropertyXYRow(comp, sceneobjects.ArcadeComponent.velocity);
                        this.createPropertyXYRow(comp, sceneobjects.ArcadeComponent.maxVelocity);
                        this.createPropertyFloatRow(comp, sceneobjects.ArcadeComponent.maxSpeed).style.gridColumn = "span 4";
                        this.createPropertyBoolean(comp, sceneobjects.ArcadeComponent.allowGravity).checkElement.style.gridColumn = "span 4";
                        this.createPropertyXYRow(comp, sceneobjects.ArcadeComponent.gravity);
                        this.createPropertyXYRow(comp, sceneobjects.ArcadeComponent.acceleration);
                        this.createPropertyBoolean(comp, sceneobjects.ArcadeComponent.useDamping).checkElement.style.gridColumn = "span 4";
                        this.createPropertyBoolean(comp, sceneobjects.ArcadeComponent.allowDrag).checkElement.style.gridColumn = "span 4";
                        this.createPropertyXYRow(comp, sceneobjects.ArcadeComponent.drag);
                        this.createPropertyBoolean(comp, sceneobjects.ArcadeComponent.allowRotation).checkElement.style.gridColumn = "span 4";
                        this.createPropertyFloatRow(comp, sceneobjects.ArcadeComponent.angularVelocity).style.gridColumn = "span 4";
                        this.createPropertyFloatRow(comp, sceneobjects.ArcadeComponent.angularAcceleration).style.gridColumn = "span 4";
                        this.createPropertyFloatRow(comp, sceneobjects.ArcadeComponent.angularDrag).style.gridColumn = "span 4";
                        this.createPropertyFloatRow(comp, sceneobjects.ArcadeComponent.maxAngular).style.gridColumn = "span 4";
                    }
                    canEdit(obj, n) {
                        return n > 0 && sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.ArcadeComponent);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.ArcadeBodyMovementSection = ArcadeBodyMovementSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseArcadeBodyOffsetToolItem.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeBodyOffsetToolItem extends sceneobjects.BaseArcadeBodyOffsetToolItem {
                    constructor(x, y) {
                        super(x, y);
                    }
                    computeSize(obj) {
                        return {
                            width: sceneobjects.ArcadeComponent.size.x.getValue(obj),
                            height: sceneobjects.ArcadeComponent.size.y.getValue(obj)
                        };
                    }
                    isValidFor(objects) {
                        for (const obj of objects) {
                            if (sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.ArcadeComponent)) {
                                if (sceneobjects.ArcadeComponent.isCircleBody(obj)) {
                                    return false;
                                }
                            }
                            else {
                                return false;
                            }
                        }
                        return true;
                    }
                }
                sceneobjects.ArcadeBodyOffsetToolItem = ArcadeBodyOffsetToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BaseArcadeBodySizeToolItem extends ui.editor.tools.SceneToolItem {
                    _x;
                    _y;
                    _dragging;
                    constructor(x, y) {
                        super();
                        this._x = x;
                        this._y = y;
                    }
                    getPoint(args) {
                        return this.getAvgScreenPointOfObjects(args, (sprite) => this._x, (sprite) => this._y, 
                        // remove rotation, not supported by the arcade body
                        true);
                    }
                    getScreenPointOfObject(args, sprite, fx, fy) {
                        const worldPoint = new Phaser.Geom.Point(0, 0);
                        const { width, height } = this.computeSize(sprite);
                        let { displayOriginX, displayOriginY } = sprite.getEditorSupport().computeDisplayOrigin();
                        if (sprite instanceof sceneobjects.Container) {
                            displayOriginX = 0;
                            displayOriginY = 0;
                        }
                        const body = sceneobjects.ArcadeComponent.getBody(sprite);
                        const x = body.offset.x - displayOriginX + fx * width;
                        const y = body.offset.y - displayOriginY + fy * height;
                        const tx = sprite.getWorldTransformMatrix();
                        tx.transformPoint(x, y, worldPoint);
                        return args.camera.getScreenPoint(worldPoint.x, worldPoint.y);
                    }
                    computeSize(obj) {
                        return {
                            width: sceneobjects.ArcadeComponent.size.x.getValue(obj),
                            height: sceneobjects.ArcadeComponent.size.y.getValue(obj)
                        };
                    }
                    render(args) {
                        const point = this.getPoint(args);
                        const ctx = args.canvasContext;
                        ctx.save();
                        ctx.translate(point.x, point.y);
                        // remove totation, not supported by the Arcade body
                        // const angle = this.globalAngle(args.objects[0] as any);
                        // ctx.rotate(Phaser.Math.DegToRad(angle));
                        this.drawRect(ctx, args.canEdit ?
                            sceneobjects.ArcadeBodyTool.BODY_TOOL_COLOR : ui.editor.tools.SceneTool.COLOR_CANNOT_EDIT);
                        ctx.restore();
                    }
                    containsPoint(args) {
                        const point = this.getPoint(args);
                        return Phaser.Math.Distance.Between(args.x, args.y, point.x, point.y) < 20;
                    }
                    onStartDrag(args) {
                        if (!this.containsPoint(args)) {
                            return;
                        }
                        this._dragging = true;
                        const point = this.getPoint(args);
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const worldTx = new Phaser.GameObjects.Components.TransformMatrix();
                            const initLocalPos = new Phaser.Math.Vector2();
                            sprite.getWorldTransformMatrix(worldTx);
                            worldTx.applyInverse(point.x, point.y, initLocalPos);
                            const { width, height } = this.computeSize(sprite);
                            sprite.setData(this.getDataKey(), {
                                initWidth: width,
                                initHeight: height,
                                initLocalPos: initLocalPos,
                                initWorldTx: worldTx
                            });
                        }
                    }
                    getInitialSize(obj) {
                        const data = obj.getData(this.getDataKey());
                        return { x: data.initWidth, y: data.initHeight };
                    }
                    onDrag(args) {
                        if (!this._dragging) {
                            return;
                        }
                        const camera = args.camera;
                        for (const obj of args.objects) {
                            const sprite = obj;
                            const data = sprite.data.get(this.getDataKey());
                            const initLocalPos = data.initLocalPos;
                            const worldTx = data.initWorldTx;
                            const localPos = new Phaser.Math.Vector2();
                            worldTx.applyInverse(args.x, args.y, localPos);
                            const flipX = sprite.flipX ? -1 : 1;
                            const flipY = sprite.flipY ? -1 : 1;
                            let originX = 0;
                            let originY = 0;
                            const dx = (localPos.x - initLocalPos.x) * flipX / camera.zoom;
                            const dy = (localPos.y - initLocalPos.y) * flipY / camera.zoom;
                            const dw = dx / (1 - (originX === 1 ? 0 : originX));
                            const dh = dy / (1 - (originY === 1 ? 0 : originY));
                            const { x: width, y: height } = args.editor.getScene().snapPoint(data.initWidth + dw, data.initHeight + dh);
                            const changeAll = this._x === 1 && this._y === 1;
                            const changeX = this._x === 1 && this._y === 0.5 || changeAll;
                            const changeY = this._x === 0.5 && this._y === 1 || changeAll;
                            this.onDragValues(sprite, changeX, changeY, width, height);
                            args.editor.updateInspectorViewSection(sceneobjects.ArcadeGeometrySection.ID);
                        }
                    }
                    onStopDrag(args) {
                        if (this._dragging) {
                            args.editor.getUndoManager().add(this.createStopDragOperation(args));
                            this._dragging = false;
                        }
                    }
                }
                sceneobjects.BaseArcadeBodySizeToolItem = BaseArcadeBodySizeToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseArcadeBodySizeToolItem.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeBodyRadiusToolItem extends sceneobjects.BaseArcadeBodySizeToolItem {
                    constructor() {
                        super(1, 0.5);
                    }
                    computeSize(obj) {
                        const d = sceneobjects.ArcadeComponent.radius.getValue(obj) * 2;
                        return { width: d, height: d };
                    }
                    onDragValues(sprite, changeX, changeY, width, height) {
                        const radius = width / 2;
                        sceneobjects.ArcadeComponent.radius.setValue(sprite, Math.floor(radius));
                    }
                    isValidFor(objects) {
                        for (const obj of objects) {
                            if (!sceneobjects.ArcadeComponent.isCircleBody(obj)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    getDataKey() {
                        return "ArcadeBodyRadiusToolItem";
                    }
                    createStopDragOperation(args) {
                        return new sceneobjects.BodyRadiusOperation(args, obj => this.getInitialSize(obj).x / 2);
                    }
                }
                sceneobjects.ArcadeBodyRadiusToolItem = ArcadeBodyRadiusToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeBodySection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ArcadeSection", "Arcade Physics Body");
                    }
                    getSectionHelpPath() {
                        return "scene-editor/arcade-physics-properties.html#arcade-physics-body-section";
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesBoolXY(parent);
                        this.createPropertyEnumRow(comp, sceneobjects.ArcadeComponent.bodyType, false).style.gridColumn = "span 4";
                        this.createPropertyBoolean(comp, sceneobjects.ArcadeComponent.enable).checkElement.style.gridColumn = "span 4";
                    }
                    canEdit(obj, n) {
                        return n > 0 && sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.ArcadeComponent);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.ArcadeBodySection = ArcadeBodySection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./BaseArcadeBodySizeToolItem.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeBodySizeToolItem extends sceneobjects.BaseArcadeBodySizeToolItem {
                    isValidFor(objects) {
                        for (const obj of objects) {
                            if (sceneobjects.ArcadeComponent.isCircleBody(obj)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    onDragValues(sprite, changeX, changeY, width, height) {
                        const widthProp = sceneobjects.ArcadeComponent.size.x;
                        const heightProp = sceneobjects.ArcadeComponent.size.y;
                        if (changeX) {
                            widthProp.setValue(sprite, Math.floor(width));
                        }
                        if (changeY) {
                            heightProp.setValue(sprite, Math.floor(height));
                        }
                    }
                    getDataKey() {
                        return "ArcadeBodySizeToolItem";
                    }
                    createStopDragOperation(args) {
                        return new sceneobjects.BodySizeOperation(args, obj => this.getInitialSize(obj));
                    }
                }
                sceneobjects.ArcadeBodySizeToolItem = ArcadeBodySizeToolItem;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeBodyTool extends sceneobjects.BaseObjectTool {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.ArcadeBodyTool";
                    static BODY_TOOL_COLOR = "pink";
                    constructor() {
                        super({
                            id: ArcadeBodyTool.ID,
                            command: ui.editor.commands.CMD_EDIT_ARCADE_BODY,
                        }, sceneobjects.ArcadeComponent.offset.x, sceneobjects.ArcadeComponent.offset.y, sceneobjects.ArcadeComponent.radius, sceneobjects.ArcadeComponent.size.x, sceneobjects.ArcadeComponent.size.y);
                        this.addItems(new sceneobjects.ArcadeBodySizeToolItem(1, 0.5), new sceneobjects.ArcadeBodySizeToolItem(1, 1), new sceneobjects.ArcadeBodySizeToolItem(0.5, 1), new sceneobjects.ArcadeBodyOffsetToolItem(0, 0), new sceneobjects.ArcadeBodyOffsetToolItem(0.5, 0), new sceneobjects.ArcadeBodyOffsetToolItem(0, 0.5), new sceneobjects.ArcadeBodyCircleOffsetToolItem(), new sceneobjects.ArcadeBodyRadiusToolItem());
                    }
                    getProperties(obj) {
                        if (sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.ArcadeComponent)) {
                            const props = this.getSizeOrRadiusProperties(obj);
                            props.push(sceneobjects.ArcadeComponent.offset.x, sceneobjects.ArcadeComponent.offset.y);
                            return props;
                        }
                        return [];
                    }
                    getSizeOrRadiusProperties(obj) {
                        if (sceneobjects.ArcadeComponent.isCircleBody(obj)) {
                            return [
                                sceneobjects.ArcadeComponent.radius
                            ];
                        }
                        return [
                            sceneobjects.ArcadeComponent.size.x,
                            sceneobjects.ArcadeComponent.size.y
                        ];
                    }
                    async onActivated(args) {
                        super.onActivated(args);
                        for (const obj of args.objects) {
                            if (!obj.getEditorSupport().hasComponent(sceneobjects.ArcadeComponent)) {
                                return;
                            }
                        }
                        const sections = [sceneobjects.ArcadeGeometrySection.ID];
                        const props = new Set();
                        for (const obj of args.objects) {
                            const objProps = this.getProperties(obj);
                            for (const prop of objProps) {
                                props.add(prop);
                            }
                        }
                        await this.confirmUnlockProperty(args, [sceneobjects.ArcadeComponent.offset.x, sceneobjects.ArcadeComponent.offset.y], "body.offset", ...sections);
                        await this.confirmUnlockProperty(args, [...props], "body size", ...sections);
                    }
                    render(args) {
                        for (const obj of args.objects) {
                            this.renderObj(args, obj);
                        }
                        super.render(args);
                    }
                    renderObj(args, obj) {
                        const ctx = args.canvasContext;
                        ctx.save();
                        if (sceneobjects.ArcadeComponent.isCircleBody(obj)) {
                            this.renderCircle(obj, args, ctx);
                        }
                        else {
                            this.renderRect(obj, args, ctx);
                        }
                        ctx.restore();
                    }
                    renderRect(obj, args, ctx) {
                        const body = sceneobjects.ArcadeComponent.getBody(obj);
                        const p = new Phaser.Math.Vector2();
                        const origin = obj.getEditorSupport().computeDisplayOrigin();
                        if (obj instanceof sceneobjects.Container) {
                            origin.displayOriginX = 0;
                            origin.displayOriginY = 0;
                        }
                        let x1 = body.offset.x - origin.displayOriginX;
                        let y1 = body.offset.y - origin.displayOriginY;
                        let x2 = x1 + body.width;
                        let y2 = y1 + body.height;
                        const tx = obj.getWorldTransformMatrix();
                        // removes rotation
                        tx.rotate(-tx.rotation);
                        tx.transformPoint(x1, y1, p);
                        x1 = p.x;
                        y1 = p.y;
                        tx.transformPoint(x2, y2, p);
                        x2 = p.x;
                        y2 = p.y;
                        const p1 = args.camera.getScreenPoint(x1, y1);
                        const p2 = args.camera.getScreenPoint(x2, y2);
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 3;
                        ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                        ctx.strokeStyle = ArcadeBodyTool.BODY_TOOL_COLOR;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                    }
                    renderCircle(obj, args, ctx) {
                        const body = sceneobjects.ArcadeComponent.getBody(obj);
                        const p = new Phaser.Math.Vector2();
                        const origin = obj.getEditorSupport().computeDisplayOrigin();
                        if (obj instanceof sceneobjects.Container) {
                            origin.displayOriginX = 0;
                            origin.displayOriginY = 0;
                        }
                        const bodyRadius = sceneobjects.ArcadeComponent.radius.getValue(obj);
                        let x1 = body.offset.x - origin.displayOriginX;
                        let y1 = body.offset.y - origin.displayOriginY;
                        let x2 = x1 + bodyRadius * 2;
                        let y2 = y1 + bodyRadius * 2;
                        const tx = obj.getWorldTransformMatrix();
                        // removes rotation
                        tx.rotate(-tx.rotation);
                        tx.transformPoint(x1, y1, p);
                        x1 = p.x;
                        y1 = p.y;
                        tx.transformPoint(x2, y2, p);
                        x2 = p.x;
                        y2 = p.y;
                        const p1 = args.camera.getScreenPoint(x1, y1);
                        const p2 = args.camera.getScreenPoint(x2, y2);
                        const r = (p2.x - p1.x) / 2;
                        const x = p1.x + r;
                        const y = p1.y + r;
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.ellipse(x, y, r, r, 0, 0, 360);
                        ctx.stroke();
                        ctx.strokeStyle = ArcadeBodyTool.BODY_TOOL_COLOR;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.ellipse(x, y, r, r, 0, 0, 360);
                        ctx.stroke();
                    }
                }
                sceneobjects.ArcadeBodyTool = ArcadeBodyTool;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeCenterBodyOperation extends sceneobjects.SceneGameObjectOperation {
                    transformValue(obj) {
                        const objES = obj.getEditorSupport();
                        const body = sceneobjects.ArcadeComponent.getBody(obj);
                        let x;
                        let y;
                        const { width, height } = objES.computeSize();
                        if (sceneobjects.ArcadeComponent.isCircleBody(obj)) {
                            const r = sceneobjects.ArcadeComponent.radius.getValue(obj);
                            x = width / 2 - r;
                            y = height / 2 - r;
                        }
                        else {
                            x = (width - body.width) / 2;
                            y = (height - body.height) / 2;
                        }
                        if (obj instanceof sceneobjects.Container) {
                            const origin = objES.computeDisplayOrigin();
                            x -= origin.displayOriginX;
                            y -= origin.displayOriginY;
                        }
                        return { x, y };
                    }
                    getValue(obj) {
                        const body = sceneobjects.ArcadeComponent.getBody(obj);
                        return { ...body.offset };
                    }
                    setValue(obj, value) {
                        const body = sceneobjects.ArcadeComponent.getBody(obj);
                        body.setOffset(value.x, value.y);
                    }
                }
                sceneobjects.ArcadeCenterBodyOperation = ArcadeCenterBodyOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                const BODY_TYPE_NAME = {
                    [Phaser.Physics.Arcade.DYNAMIC_BODY]: "DYNAMIC_BODY",
                    [Phaser.Physics.Arcade.STATIC_BODY]: "STATIC_BODY"
                };
                function SimpleBodyProperty(name, defValue, label, editorField, tooptip, increment, min, max) {
                    editorField = editorField ?? name;
                    return {
                        name,
                        codeName: `body.${name}`,
                        defValue,
                        label,
                        increment,
                        incrementMin: min,
                        incrementMax: max,
                        tooltip: tooptip ?? `phaser:Phaser.Physics.Arcade.Body.${name}`,
                        getValue: obj => obj.body[editorField] ?? defValue,
                        setValue: (obj, value) => {
                            obj.body[editorField] = value;
                        }
                    };
                }
                function CheckCollisionProperty(name, defValue) {
                    return {
                        name,
                        codeName: `body.checkCollision.${name}`,
                        defValue,
                        label: `Check Collision ${name.substring(0, 1).toUpperCase()}${name.substring(1)}`,
                        tooltip: `phaser:Phaser.Physics.Arcade.Body.checkCollision`,
                        getValue: obj => obj.body.checkCollision[name] ?? defValue,
                        setValue: (obj, value) => {
                            obj.body.checkCollision[name] = value;
                        }
                    };
                }
                function simpleBodyVectorProperty(vectorName, axis, defValue, increment, min, max) {
                    return {
                        name: `body.${vectorName}.${axis}`,
                        codeName: `body.${vectorName}.${axis}`,
                        label: axis.toUpperCase(),
                        defValue: defValue,
                        getValue: obj => obj.body[vectorName][axis],
                        setValue: (obj, value) => obj.body[vectorName][axis] = value,
                        tooltip: `phaser:Phaser.Physics.Arcade.Body.${vectorName}`,
                        increment,
                        incrementMin: min,
                        incrementMax: max
                    };
                }
                function SimpleBodyVectorProperty(vectorName, label, defValueX, defValueY, setterName, increment, min, max) {
                    return {
                        label,
                        setterName: setterName ? `body.${setterName}` : undefined,
                        tooltip: "phaser:Phaser.Physics.Arcade.Body." + vectorName,
                        x: simpleBodyVectorProperty(vectorName, "x", defValueX, increment, min, max),
                        y: simpleBodyVectorProperty(vectorName, "y", defValueY ?? defValueX, increment, min, max),
                    };
                }
                const GEOM_CIRCLE = 0;
                const GEOM_RECT = 1;
                function updateBodyGeom(obj) {
                    const isCircle = ArcadeComponent.isCircleBody(obj);
                    const body = ArcadeComponent.getBody(obj);
                    if (isCircle) {
                        const radius = ArcadeComponent.radius.getValue(obj);
                        body.setCircle(radius);
                    }
                    else {
                        if (obj instanceof sceneobjects.Container) {
                            const { width, height } = obj.getEditorSupport().computeSize();
                            body.setSize(width, height, false);
                        }
                        else {
                            const width = obj.frame ? obj.frame.realWidth : obj.width;
                            const height = obj.frame ? obj.frame.realHeight : obj.height;
                            body.setSize(width, height, false);
                        }
                    }
                }
                function bodyTypeProperty() {
                    return {
                        name: "physicsType",
                        label: "Type",
                        tooltip: "The type of the body",
                        values: [
                            Phaser.Physics.Arcade.DYNAMIC_BODY,
                            Phaser.Physics.Arcade.STATIC_BODY
                        ],
                        getValueLabel: function (value) {
                            return BODY_TYPE_NAME[value];
                        },
                        getValue: function (obj) {
                            return obj["__arcadeBodyPhysicsType"] || Phaser.Physics.Arcade.DYNAMIC_BODY;
                        },
                        setValue: function (obj, value) {
                            obj["__arcadeBodyPhysicsType"] = value;
                        },
                        defValue: Phaser.Physics.Arcade.DYNAMIC_BODY,
                    };
                }
                function geometryProperty() {
                    return {
                        name: "bodyGeometry",
                        label: "Geometry",
                        tooltip: "Select the body's shape.",
                        values: [GEOM_CIRCLE, GEOM_RECT],
                        getValue: obj => (obj.body["__isCircle"] ? GEOM_CIRCLE : GEOM_RECT),
                        setValue: (obj, value) => {
                            const body = ArcadeComponent.getBody(obj);
                            body["__isCircle"] = value === GEOM_CIRCLE;
                            updateBodyGeom(obj);
                        },
                        getValueLabel: value => (value === GEOM_CIRCLE ? "CIRCULAR" : "RECTANGULAR"),
                        defValue: GEOM_RECT
                    };
                }
                function sizeProperty(axis) {
                    return {
                        name: `body.${axis}`,
                        label: axis === "width" ? "W" : "H",
                        tooltip: "The size of the body, if it is rectangular.",
                        increment: 1,
                        incrementMin: 0,
                        getValue: obj => obj.body[axis],
                        setValue: (obj, value) => {
                            const body = ArcadeComponent.getBody(obj);
                            if (axis === "width") {
                                body.setSize(value, body.height, false);
                            }
                            else {
                                body.setSize(body.width, value, false);
                            }
                        },
                        defValue: 0
                    };
                }
                class ArcadeComponent extends sceneobjects.Component {
                    // properties
                    static enable = SimpleBodyProperty("enable", true, "Enable", "__enable");
                    static bodyType = bodyTypeProperty();
                    static moves = SimpleBodyProperty("moves", true, "Moves");
                    static velocity = SimpleBodyVectorProperty("velocity", "Velocity", 0, 0, undefined, 1);
                    static maxVelocity = SimpleBodyVectorProperty("maxVelocity", "Max Velocity", 10000, 10000, undefined, 1);
                    static maxSpeed = SimpleBodyProperty("maxSpeed", -1, "Max Speed", undefined, undefined, 1);
                    static friction = SimpleBodyVectorProperty("friction", "Friction", 1, 0, undefined, 0.05);
                    static allowGravity = SimpleBodyProperty("allowGravity", true, "Allow Gravity");
                    static gravity = SimpleBodyVectorProperty("gravity", "Gravity", 0, undefined, undefined, 1);
                    static acceleration = SimpleBodyVectorProperty("acceleration", "Acceleration", 0, undefined, undefined, 1);
                    static useDamping = SimpleBodyProperty("useDamping", false, "Use Damping");
                    static allowDrag = SimpleBodyProperty("allowDrag", true, "Allow Drag");
                    static drag = SimpleBodyVectorProperty("drag", "Drag", 0, undefined, undefined, 0.05, 0, 1);
                    static bounce = SimpleBodyVectorProperty("bounce", "Bounce", 0, undefined, undefined, 0.05, 0);
                    static collideWorldBounds = SimpleBodyProperty("collideWorldBounds", false, "Collide World Bounds");
                    static onWorldBounds = SimpleBodyProperty("onWorldBounds", false, "On World Bounds");
                    static checkCollisionNone = CheckCollisionProperty("none", false);
                    static checkCollisionUp = CheckCollisionProperty("up", true);
                    static checkCollisionDown = CheckCollisionProperty("down", true);
                    static checkCollisionLeft = CheckCollisionProperty("left", true);
                    static checkCollisionRight = CheckCollisionProperty("right", true);
                    static allowRotation = SimpleBodyProperty("allowRotation", true, "Allow Rotation");
                    static angularVelocity = SimpleBodyProperty("angularVelocity", 0, "Angular Velocity", undefined, undefined, 1);
                    static angularAcceleration = SimpleBodyProperty("angularAcceleration", 0, "Angular Acceleration", undefined, undefined, 1);
                    static angularDrag = SimpleBodyProperty("angularDrag", 0, "Angular Drag", undefined, undefined, 1);
                    static maxAngular = SimpleBodyProperty("maxAngular", 1000, "Max Angular", undefined, undefined, 1);
                    static pushable = SimpleBodyProperty("pushable", true, "Pushable");
                    static immovable = SimpleBodyProperty("immovable", false, "Immovable");
                    static overlap = {
                        label: "Overlap",
                        tooltip: "The amount of horizontal/vertical overlap (before separation), if this Body is colliding with another.",
                        x: SimpleBodyProperty("overlapX", 0, "X", undefined, undefined, 1, 0),
                        y: SimpleBodyProperty("overlapY", 0, "Y", undefined, undefined, 1, 0),
                    };
                    static overlapR = SimpleBodyProperty("overlapR", 0, "Overlap R", undefined, undefined, 1, 0);
                    static mass = SimpleBodyProperty("mass", 1, "Mass", undefined, undefined, 1, 0);
                    static geometry = geometryProperty();
                    static radius = SimpleBodyProperty("radius", 64, "Radius", "__radius", undefined, 1, 0);
                    static offset = SimpleBodyVectorProperty("offset", "Offset", 0, 0, "setOffset", 1, 0);
                    static size = {
                        label: "Size",
                        tooltip: "Size",
                        x: sizeProperty("width"),
                        y: sizeProperty("height")
                    };
                    static isCircleBody(obj) {
                        return ArcadeComponent.geometry.getValue(obj) === GEOM_CIRCLE;
                    }
                    static isStaticBody(obj) {
                        return ArcadeComponent.bodyType.getValue(obj) === Phaser.Physics.Arcade.STATIC_BODY;
                    }
                    static getBody(obj) {
                        return obj.body;
                    }
                    static enableBody(obj) {
                        const sprite = obj;
                        // I have to scale to 1 and later restore the original scale
                        // see issue https://github.com/PhaserEditor2D/PhaserEditor2D-v3/issues/250
                        const { scaleX, scaleY } = sprite;
                        sprite.setScale(1, 1);
                        sprite.scene.physics.add.existing(sprite);
                        sprite.setScale(scaleX, scaleY);
                        const body = ArcadeComponent.getBody(obj);
                        body.enable = false;
                        obj.getEditorSupport().setComponentActive(ArcadeComponent, true);
                    }
                    static disableBody(obj) {
                        const body = ArcadeComponent.getBody(obj);
                        body.world.remove(body);
                        obj.getEditorSupport().setComponentActive(ArcadeComponent, false);
                    }
                    constructor(obj, active) {
                        super(obj, [
                            ArcadeComponent.bodyType,
                            ArcadeComponent.enable,
                            ArcadeComponent.moves,
                            ArcadeComponent.velocity.x,
                            ArcadeComponent.velocity.y,
                            ArcadeComponent.maxSpeed,
                            ArcadeComponent.maxVelocity.x,
                            ArcadeComponent.maxVelocity.y,
                            ArcadeComponent.friction.x,
                            ArcadeComponent.friction.y,
                            ArcadeComponent.gravity.x,
                            ArcadeComponent.gravity.y,
                            ArcadeComponent.allowGravity,
                            ArcadeComponent.acceleration.x,
                            ArcadeComponent.acceleration.y,
                            ArcadeComponent.drag.x,
                            ArcadeComponent.drag.y,
                            ArcadeComponent.bounce.x,
                            ArcadeComponent.bounce.y,
                            ArcadeComponent.collideWorldBounds,
                            ArcadeComponent.onWorldBounds,
                            ArcadeComponent.checkCollisionNone,
                            ArcadeComponent.checkCollisionUp,
                            ArcadeComponent.checkCollisionDown,
                            ArcadeComponent.checkCollisionLeft,
                            ArcadeComponent.checkCollisionRight,
                            ArcadeComponent.overlap.x,
                            ArcadeComponent.overlap.y,
                            ArcadeComponent.overlapR,
                            ArcadeComponent.useDamping,
                            ArcadeComponent.allowDrag,
                            ArcadeComponent.allowRotation,
                            ArcadeComponent.angularAcceleration,
                            ArcadeComponent.angularDrag,
                            ArcadeComponent.angularVelocity,
                            ArcadeComponent.maxAngular,
                            ArcadeComponent.pushable,
                            ArcadeComponent.immovable,
                            ArcadeComponent.mass,
                            ArcadeComponent.geometry,
                            ArcadeComponent.radius,
                            ArcadeComponent.size.x,
                            ArcadeComponent.size.y,
                            ArcadeComponent.offset.x,
                            ArcadeComponent.offset.y
                        ], active);
                    }
                    readJSON(ser) {
                        const active = ser.read(`${this.getComponentName()}.active`, false);
                        if (active) {
                            ArcadeComponent.enableBody(this.getObject());
                        }
                        super.readJSON(ser);
                    }
                    buildPrefabTypeScriptDefinitionsCodeDOM(args) {
                        const obj = args.prefabObj;
                        if (obj.getEditorSupport().isPrefabInstance()) {
                            // hey, this is a variant prefab!
                            // the body was set in the root prefab
                            return;
                        }
                        const isStatic = ArcadeComponent.isStaticBody(obj);
                        const type = isStatic ? "Phaser.Physics.Arcade.StaticBody" : "Phaser.Physics.Arcade.Body";
                        const fieldDecl = new code.FieldDeclCodeDOM("body", type);
                        fieldDecl.setInterfaceMember(true);
                        const interDecl = new code.InterfaceDeclCodeDOM(args.clsName);
                        interDecl.getBody().push(fieldDecl);
                        args.unit.getTypeScriptInterfaces().push(interDecl);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildEnableBodyCodeDOM(args);
                        // float properties
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, ArcadeComponent.velocity.x, ArcadeComponent.velocity.y, ArcadeComponent.maxVelocity.x, ArcadeComponent.maxVelocity.y, ArcadeComponent.maxSpeed, ArcadeComponent.gravity.x, ArcadeComponent.gravity.y, ArcadeComponent.acceleration.x, ArcadeComponent.acceleration.y, ArcadeComponent.drag.x, ArcadeComponent.drag.y, ArcadeComponent.friction.x, ArcadeComponent.friction.y, ArcadeComponent.bounce.x, ArcadeComponent.bounce.y, ArcadeComponent.overlap.x, ArcadeComponent.overlap.y, ArcadeComponent.overlapR, ArcadeComponent.mass, ArcadeComponent.angularAcceleration, ArcadeComponent.angularDrag, ArcadeComponent.angularVelocity, ArcadeComponent.maxAngular);
                        // boolean properties
                        this.buildSetObjectPropertyCodeDOM_BooleanProperty(args, ArcadeComponent.enable, ArcadeComponent.moves, ArcadeComponent.allowGravity, ArcadeComponent.useDamping, ArcadeComponent.allowDrag, ArcadeComponent.allowRotation, ArcadeComponent.collideWorldBounds, ArcadeComponent.onWorldBounds, ArcadeComponent.checkCollisionNone, ArcadeComponent.checkCollisionUp, ArcadeComponent.checkCollisionDown, ArcadeComponent.checkCollisionLeft, ArcadeComponent.checkCollisionRight, ArcadeComponent.pushable, ArcadeComponent.immovable);
                        // geometry
                        const obj = this.getObject();
                        const objES = this.getEditorSupport();
                        this.buildSetObjectPropertyXYCodeDOM_FloatXY(args, ArcadeComponent.offset);
                        if (ArcadeComponent.isCircleBody(obj)) {
                            let generateSetCircle = { value: false };
                            this.buildSetObjectPropertyCodeDOM([ArcadeComponent.radius], (args2) => {
                                generateSetCircle.value = true;
                            });
                            if (!generateSetCircle.value && !objES.isPrefabInstance()) {
                                // we should force the setCircle() call.
                                generateSetCircle.value = true;
                            }
                            if (generateSetCircle.value) {
                                const dom = new code.MethodCallCodeDOM("body.setCircle", args.objectVarName);
                                const r = ArcadeComponent.radius.getValue(obj);
                                dom.arg(r);
                                args.statements.push(dom);
                            }
                        }
                        else {
                            this.buildSetObjectPropertyCodeDOM([ArcadeComponent.size.x], (args2) => {
                                const dom = new code.MethodCallCodeDOM("body.setSize", args.objectVarName);
                                const x = ArcadeComponent.size.x.getValue(obj);
                                const y = ArcadeComponent.size.y.getValue(obj);
                                dom.arg(x);
                                dom.arg(y);
                                dom.argBool(false);
                                args.statements.push(dom);
                            });
                        }
                    }
                    getExplicitTypesForMethodFactory(baseType) {
                        const obj = this.getObject();
                        const objES = obj.getEditorSupport();
                        if (obj instanceof sceneobjects.ArcadeImage || obj instanceof sceneobjects.ArcadeSprite) {
                        }
                        else {
                            if (objES.isUnlockedProperty(ArcadeComponent.bodyType)) {
                                const bodyType = ArcadeComponent.isStaticBody(obj) ? "StaticBody" : "Body";
                                return `${baseType} & { body: Phaser.Physics.Arcade.${bodyType} }`;
                            }
                        }
                        return undefined;
                    }
                    buildEnableBodyCodeDOM(args) {
                        const obj = this.getObject();
                        const objES = obj.getEditorSupport();
                        if (obj instanceof sceneobjects.ArcadeImage || obj instanceof sceneobjects.ArcadeSprite) {
                            if (objES.isScenePrefabObject()) {
                                if (objES.isUnlockedProperty(ArcadeComponent.bodyType)) {
                                    const body = args.statements;
                                    const stmt = new code.MethodCallCodeDOM("existing", "scene.physics.add");
                                    stmt.arg("this");
                                    stmt.argBool(ArcadeComponent.isStaticBody(this.getObject()));
                                    body.push(stmt);
                                }
                            }
                        }
                        else {
                            if (objES.isUnlockedProperty(ArcadeComponent.bodyType)) {
                                const body = args.statements;
                                const ctx = objES.getScene().isPrefabSceneType() ? "scene" : "this";
                                const stmt = new code.MethodCallCodeDOM("existing", `${ctx}.physics.add`);
                                stmt.arg(args.objectVarName);
                                stmt.argBool(ArcadeComponent.isStaticBody(this.getObject()));
                                body.push(stmt);
                            }
                        }
                    }
                }
                sceneobjects.ArcadeComponent = ArcadeComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeGeometrySection extends sceneobjects.SceneGameObjectSection {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.ArcadeGeometrySection";
                    constructor(page) {
                        super(page, ArcadeGeometrySection.ID, "Arcade Physics Body Geometry");
                    }
                    getSectionHelpPath() {
                        return "scene-editor/arcade-physics-properties.html#arcade-physics-body-geometry-section";
                    }
                    createMenu(menu) {
                        this.createToolMenuItem(menu, sceneobjects.ArcadeBodyTool.ID);
                        menu.addSeparator();
                        menu.addCommand(ui.editor.commands.CMD_ARCADE_CENTER_BODY);
                        menu.addCommand(ui.editor.commands.CMD_ARCADE_RESIZE_TO_OBJECT_BODY);
                        menu.addSeparator();
                        super.createMenu(menu);
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesBoolXY(parent);
                        this.createPropertyEnumRow(comp, sceneobjects.ArcadeComponent.geometry, false).style.gridColumn = "span 4";
                        this.createPropertyXYRow(comp, sceneobjects.ArcadeComponent.offset);
                        this.createSeparatorForXYGrid(comp, "Circular");
                        {
                            const input = this.createPropertyFloatRow(comp, sceneobjects.ArcadeComponent.radius);
                            input.style.gridColumn = "span 4";
                            this.addCheckGeometryUpdater(true, [input]);
                        }
                        this.createSeparatorForXYGrid(comp, "Rectangular");
                        {
                            const elements = this.createPropertyXYRow(comp, sceneobjects.ArcadeComponent.size);
                            this.addCheckGeometryUpdater(false, elements);
                        }
                    }
                    addCheckGeometryUpdater(expectingCircle, elements) {
                        this.addUpdater(() => {
                            const isCircle = this.flatValues_BooleanAnd(this.getSelection().map(obj => sceneobjects.ArcadeComponent.isCircleBody(obj)));
                            for (const elem of elements) {
                                elem.disabled = elem.disabled || isCircle !== expectingCircle;
                            }
                        });
                    }
                    canEdit(obj, n) {
                        return n > 0 && sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.ArcadeComponent);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.ArcadeGeometrySection = ArcadeGeometrySection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_75) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeImage extends Phaser.Physics.Arcade.Image {
                    _editorSupport;
                    constructor(scene, x, y, texture, frame) {
                        super(scene, x, y, texture, frame);
                        this._editorSupport = new sceneobjects.ArcadeImageEditorSupport(this, scene);
                        this.body = new Phaser.Physics.Arcade.Body(scene.physics.world, this);
                        this.body.enable = false;
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.ArcadeImage = ArcadeImage;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_75.ui || (scene_75.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ISceneGameObjectCodeDOMBuilder extends sceneobjects.BaseImageCodeDOMBuilder {
                    constructor(ISceneGameObjectType) {
                        super(ISceneGameObjectType, "physics.add");
                    }
                    getFactoryMethodName(obj) {
                        const defaultFactory = super.getFactoryMethodName(obj);
                        if (sceneobjects.ArcadeComponent.bodyType.getValue(obj) === Phaser.Physics.Arcade.DYNAMIC_BODY) {
                            return defaultFactory;
                        }
                        if (defaultFactory === "image") {
                            return "staticImage";
                        }
                        return "staticSprite";
                    }
                }
                sceneobjects.ISceneGameObjectCodeDOMBuilder = ISceneGameObjectCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_76) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeImageEditorSupport extends sceneobjects.BaseImageEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.ArcadeImageExtension.getInstance(), obj, scene, true);
                        this.addComponent(new sceneobjects.ArcadeComponent(obj, true));
                    }
                }
                sceneobjects.ArcadeImageEditorSupport = ArcadeImageEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_76.ui || (scene_76.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_77) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeImageExtension extends sceneobjects.BaseImageExtension {
                    static _instance = new ArcadeImageExtension();
                    static getInstance() {
                        return this._instance;
                    }
                    constructor() {
                        super({
                            typeName: "ArcadeImage",
                            phaserTypeName: "Phaser.Physics.Arcade.Image",
                            category: scene_77.SCENE_OBJECT_ARCADE_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_IMAGE_TYPE)
                        });
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.ISceneGameObjectCodeDOMBuilder("image");
                    }
                    newObject(scene, x, y, key, frame) {
                        return new sceneobjects.ArcadeImage(scene, x, y, key || null, frame);
                    }
                    async collectExtraDataForCreateDefaultObject(editor, inReplaceTypeContext) {
                        if (inReplaceTypeContext) {
                            return {};
                        }
                        return this.collectTextureDataCreateDefaultObject(editor);
                    }
                }
                sceneobjects.ArcadeImageExtension = ArcadeImageExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_77.ui || (scene_77.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeResizeBodyToObjectOperation extends sceneobjects.SceneGameObjectOperation {
                    transformValue(obj) {
                        let offsetX;
                        let offsetY;
                        let width;
                        let height;
                        let radius;
                        const isCircle = sceneobjects.ArcadeComponent.isCircleBody(obj);
                        const objES = obj.getEditorSupport();
                        const objSize = objES.computeSize();
                        if (isCircle) {
                            radius = objSize.width / 2;
                            offsetX = objSize.width / 2 - radius;
                            offsetY = objSize.height / 2 - radius;
                        }
                        else {
                            offsetX = 0;
                            offsetY = 0;
                            width = objSize.width;
                            height = objSize.height;
                        }
                        if (obj instanceof sceneobjects.Container) {
                            const origin = objES.computeDisplayOrigin();
                            offsetX -= origin.displayOriginX;
                            offsetY -= origin.displayOriginY;
                        }
                        return { offsetX, offsetY, width, height, radius, isCircle };
                    }
                    getValue(obj) {
                        const body = sceneobjects.ArcadeComponent.getBody(obj);
                        return {
                            offsetX: body.offset.x,
                            offsetY: body.offset.y,
                            width: body.width,
                            height: body.height,
                            radius: sceneobjects.ArcadeComponent.radius.getValue(obj),
                            isCircle: sceneobjects.ArcadeComponent.isCircleBody(obj)
                        };
                    }
                    setValue(obj, value) {
                        const body = sceneobjects.ArcadeComponent.getBody(obj);
                        body.setOffset(value.offsetX, value.offsetY);
                        if (value.isCircle) {
                            sceneobjects.ArcadeComponent.radius.setValue(obj, value.radius);
                        }
                        else {
                            sceneobjects.ArcadeComponent.size.x.setValue(obj, value.width);
                            sceneobjects.ArcadeComponent.size.y.setValue(obj, value.height);
                        }
                    }
                }
                sceneobjects.ArcadeResizeBodyToObjectOperation = ArcadeResizeBodyToObjectOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_78) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeSprite extends Phaser.Physics.Arcade.Image {
                    _editorSupport;
                    constructor(scene, x, y, texture, frame) {
                        super(scene, x, y, texture, frame);
                        this._editorSupport = new sceneobjects.ArcadeSpriteEditorSupport(this, scene);
                        this.body = new Phaser.Physics.Arcade.Body(scene.physics.world, this);
                        this.body.enable = false;
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.ArcadeSprite = ArcadeSprite;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_78.ui || (scene_78.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_79) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeSpriteEditorSupport extends sceneobjects.BaseImageEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.ArcadeSpriteExtension.getInstance(), obj, scene, true);
                        this.addComponent(new sceneobjects.ArcadeComponent(obj, true));
                    }
                }
                sceneobjects.ArcadeSpriteEditorSupport = ArcadeSpriteEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_79.ui || (scene_79.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_80) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ArcadeSpriteExtension extends sceneobjects.BaseImageExtension {
                    static _instance = new ArcadeSpriteExtension();
                    static getInstance() {
                        return this._instance;
                    }
                    constructor() {
                        super({
                            typeName: "ArcadeSprite",
                            phaserTypeName: "Phaser.Physics.Arcade.Sprite",
                            category: scene_80.SCENE_OBJECT_ARCADE_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_SPRITE_TYPE)
                        });
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.ISceneGameObjectCodeDOMBuilder("sprite");
                    }
                    newObject(scene, x, y, key, frame) {
                        return new sceneobjects.ArcadeSprite(scene, x, y, key || null, frame);
                    }
                    async collectExtraDataForCreateDefaultObject(editor, inReplaceTypeContext) {
                        if (inReplaceTypeContext) {
                            return {};
                        }
                        return this.collectTextureDataCreateDefaultObject(editor);
                    }
                }
                sceneobjects.ArcadeSpriteExtension = ArcadeSpriteExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_80.ui || (scene_80.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BodyOffsetOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialValue(obj) {
                        return sceneobjects.ArcadeBodyOffsetToolItem.getInitialOffset(obj);
                    }
                    getFinalValue(obj) {
                        return {
                            x: sceneobjects.ArcadeComponent.offset.x.getValue(obj),
                            y: sceneobjects.ArcadeComponent.offset.y.getValue(obj)
                        };
                    }
                    setValue(obj, value) {
                        sceneobjects.ArcadeComponent.offset.x.setValue(obj, value.x);
                        sceneobjects.ArcadeComponent.offset.y.setValue(obj, value.y);
                    }
                }
                sceneobjects.BodyOffsetOperation = BodyOffsetOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BodyRadiusOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialRadius;
                    constructor(toolArgs, getInitialRadius) {
                        super(toolArgs);
                        this.getInitialRadius = getInitialRadius;
                    }
                    getInitialValue(obj) {
                        return this.getInitialRadius(obj);
                    }
                    getFinalValue(obj) {
                        return sceneobjects.ArcadeComponent.radius.getValue(obj);
                    }
                    setValue(obj, value) {
                        sceneobjects.ArcadeComponent.radius.setValue(obj, value);
                        sceneobjects.ArcadeComponent.getBody(obj).setCircle(value);
                    }
                }
                sceneobjects.BodyRadiusOperation = BodyRadiusOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BodySizeOperation extends ui.editor.tools.SceneToolOperation {
                    getInitialSize;
                    constructor(toolArgs, getInitialSize) {
                        super(toolArgs);
                        this.getInitialSize = getInitialSize;
                    }
                    getInitialValue(obj) {
                        return this.getInitialSize(obj);
                    }
                    getFinalValue(obj) {
                        return {
                            x: sceneobjects.ArcadeComponent.size.x.getValue(obj),
                            y: sceneobjects.ArcadeComponent.size.y.getValue(obj)
                        };
                    }
                    setValue(obj, value) {
                        sceneobjects.ArcadeComponent.size.x.setValue(obj, value.x);
                        sceneobjects.ArcadeComponent.size.y.setValue(obj, value.y);
                    }
                }
                sceneobjects.BodySizeOperation = BodySizeOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_81) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Collider {
                    object1 = "";
                    object2 = "";
                    overlapOnly = false;
                    collideCallback = "";
                    processCallback = "";
                    callbackContext = "";
                    _editorSupport;
                    constructor(scene) {
                        this._editorSupport = new sceneobjects.ColliderEditorSupport(scene, this);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.Collider = Collider;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_81.ui || (scene_81.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../PlainObjectComponent.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ColliderComponent extends sceneobjects.PlainObjectComponent {
                    static object1 = sceneobjects.SimpleProperty("object1", "", "Object 1", "phaser:Phaser.Physics.Arcade.Collider(object1)", true);
                    static object2 = sceneobjects.SimpleProperty("object2", "", "Object 2", "phaser:Phaser.Physics.Arcade.Collider(object2)", true);
                    static overlapOnly = sceneobjects.SimpleProperty("overlapOnly", false, "Overlap Only", "phaser:Phaser.Physics.Arcade.Collider(overlapOnly)", true);
                    static collideCallback = sceneobjects.SimpleProperty("collideCallback", "", "Collide Callback", "phaser:Phaser.Physics.Arcade.Collider(collideCallback)", true);
                    static processCallback = sceneobjects.SimpleProperty("processCallback", "", "Process Callback", "phaser:Phaser.Physics.Arcade.Collider(processCallback)", true);
                    static callbackContext = sceneobjects.SimpleProperty("callbackContext", "", "Callback Context", "phaser:Phaser.Physics.Arcade.Collider(callbackContext)", true);
                    constructor(obj) {
                        super(obj, ColliderComponent.object1, ColliderComponent.object2, ColliderComponent.overlapOnly, ColliderComponent.collideCallback, ColliderComponent.processCallback, ColliderComponent.callbackContext);
                    }
                }
                sceneobjects.ColliderComponent = ColliderComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_82) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ColliderEditorSupport extends sceneobjects.ScenePlainObjectEditorSupport {
                    constructor(scene, obj) {
                        super(sceneobjects.ColliderExtension.getInstance(), obj, scene, new sceneobjects.ColliderComponent(obj));
                        this.setScope(sceneobjects.ObjectScope.LOCAL);
                    }
                    destroy() {
                        // nothing
                    }
                    async buildDependencyHash(args) {
                        // nothing
                    }
                }
                sceneobjects.ColliderEditorSupport = ColliderEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_82.ui || (scene_82.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ColliderExtension extends sceneobjects.ScenePlainObjectExtension {
                    static _instance = new ColliderExtension();
                    static getInstance() {
                        return this._instance;
                    }
                    constructor() {
                        super({
                            category: scene.SCENE_OBJECT_ARCADE_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_ARCADE_COLLIDER),
                            phaserTypeName: "Phaser.Physics.Arcade.Collider",
                            typeName: "Collider"
                        });
                    }
                    createPlainObjectWithData(args) {
                        const collider = new sceneobjects.Collider(args.scene);
                        collider.getEditorSupport().readJSON(args.data);
                        return collider;
                    }
                    async getAssetsFromObjectData(args) {
                        return [];
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const methodName = obj.overlapOnly ? "overlap" : "collider";
                        const call = new scene.core.code.MethodCallCodeDOM(methodName, `${args.gameObjectFactoryExpr}.physics.add`);
                        call.arg(obj.object1 || "undefined");
                        call.arg(obj.object2 || "undefined");
                        call.arg(obj.collideCallback || "undefined");
                        call.arg(obj.processCallback || "undefined");
                        call.arg(obj.callbackContext || "undefined");
                        call.setDeclareReturnToVar(false);
                        return {
                            lazyStatements: [call],
                            objectFactoryMethodCall: call
                        };
                    }
                    createDefaultSceneObject(args) {
                        return [new sceneobjects.Collider(args.scene)];
                    }
                }
                sceneobjects.ColliderExtension = ColliderExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../object/properties/PlainObjectSection.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ColliderSection extends sceneobjects.PlainObjectSection {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.ColliderSection";
                    constructor(page) {
                        super(page, ColliderSection.ID, "Collider", false, false);
                    }
                    createForm(parent) {
                        const comp = this.createDefaultGridElement(parent);
                        this.createPropertyBoolean(comp, sceneobjects.ColliderComponent.overlapOnly);
                        this.createPropertyObjectVar(comp, sceneobjects.ColliderComponent.object1);
                        this.createPropertyObjectVar(comp, sceneobjects.ColliderComponent.object2);
                        this.createPropertyString(comp, sceneobjects.ColliderComponent.collideCallback);
                        this.createPropertyString(comp, sceneobjects.ColliderComponent.processCallback);
                        this.createPropertyString(comp, sceneobjects.ColliderComponent.callbackContext);
                    }
                    canEdit(obj, n) {
                        return n > 0 && obj instanceof sceneobjects.Collider;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.ColliderSection = ColliderSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EnableArcadeBodyOperation extends sceneobjects.SceneGameObjectOperation {
                    constructor(editor, enable) {
                        super(editor, editor.getSelectedGameObjects(), enable);
                    }
                    getValue(obj) {
                        return obj.getEditorSupport().hasComponent(sceneobjects.ArcadeComponent);
                    }
                    setValue(obj, enable) {
                        if (enable) {
                            sceneobjects.ArcadeComponent.enableBody(obj);
                        }
                        else {
                            sceneobjects.ArcadeComponent.disableBody(obj);
                        }
                    }
                }
                sceneobjects.EnableArcadeBodyOperation = EnableArcadeBodyOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                var io = colibri.core.io;
                class AddScriptDialog extends controls.dialogs.ViewerDialog {
                    static createViewer() {
                        const viewer = new controls.viewers.TreeViewer("AddScriptsDialog");
                        viewer.setStyledLabelProvider(new sceneobjects.ScriptStyledLabelProvider());
                        viewer.setLabelProvider(new controls.viewers.LabelProviderFromStyledLabelProvider(viewer.getStyledLabelProvider()));
                        viewer.setContentProvider(new sceneobjects.ScriptsContentProvider);
                        viewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider(e => {
                            let icon = phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_BUILD);
                            if (e instanceof io.FilePath && e.isFolder()) {
                                icon = colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER);
                            }
                            return new controls.viewers.IconImageCellRenderer(icon);
                        }));
                        viewer.setInput([]);
                        return viewer;
                    }
                    _editor;
                    constructor(editor) {
                        super(AddScriptDialog.createViewer(), false);
                        this._editor = editor;
                    }
                    create() {
                        super.create();
                        this.setTitle("Add Script");
                        this.enableButtonOnlyWhenOneElementIsSelected(this.addOpenButton("Add Script", sel => {
                            this.addScript(sel[0]);
                        }), (obj) => {
                            return obj instanceof sceneobjects.ScriptNodeExtension || obj.isFile();
                        });
                        this.addCancelButton();
                    }
                    addScript(script) {
                        this._editor.getUndoManager().add(new ui.editor.undo.CreateObjectWithAssetOperation(this._editor, [script], 0, 0));
                    }
                }
                sceneobjects.AddScriptDialog = AddScriptDialog;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class BrowseScriptsDialog extends controls.dialogs.ViewerDialog {
                    static createViewer(editor) {
                        const viewer = new controls.viewers.TreeViewer("BrowseScriptsDialog");
                        viewer.setLabelProvider(new ui.editor.outline.SceneEditorOutlineLabelProvider());
                        viewer.setStyledLabelProvider(new ui.editor.outline.SceneEditorOutlineStyledLabelProvider());
                        viewer.setCellRendererProvider(new ui.editor.outline.SceneEditorOutlineRendererProvider());
                        viewer.setContentProvider(new ScriptDialogContentProvider(editor));
                        viewer.setInput([]);
                        viewer.expandRoots();
                        return viewer;
                    }
                    _editor;
                    constructor(editor) {
                        super(BrowseScriptsDialog.createViewer(editor), true);
                        this._editor = editor;
                    }
                    create() {
                        super.create();
                        this.setTitle("Browse Scripts");
                        this.addOpenButton("Select", sel => {
                            this._editor.setSelection(sel);
                        });
                        this.addCancelButton();
                    }
                }
                sceneobjects.BrowseScriptsDialog = BrowseScriptsDialog;
                class ScriptDialogContentProvider extends ui.editor.outline.SceneEditorOutlineContentProvider {
                    getRoots(input) {
                        const sel = this._editor.getSelectedGameObjects();
                        let result;
                        if (sel.length === 0) {
                            result = [...this._editor.getScene().getGameObjects()].reverse();
                        }
                        else {
                            sel.sort(sceneobjects.gameObjectSortingWeight);
                            result = sel;
                        }
                        result = result.filter(obj => {
                            return obj instanceof sceneobjects.ScriptNode || this.hasUserComponentOrScriptNode(obj);
                        });
                        return result;
                    }
                    getChildren(parent) {
                        const children = super.getChildren(parent);
                        let result = [];
                        for (const obj of children) {
                            if (obj instanceof sceneobjects.ScriptNode) {
                                result.push(obj);
                            }
                            else if (sceneobjects.isGameObject(obj)) {
                                if (this.hasUserComponentOrScriptNode(obj)) {
                                    result.push(obj);
                                }
                            }
                        }
                        return result;
                    }
                    hasUserComponentOrScriptNode(obj) {
                        let result = obj.getEditorSupport().getObjectScriptNodes().length
                            + obj.getEditorSupport().getUserComponentsComponent()
                                .getUserComponentNodes().length > 0;
                        if (!result) {
                            const children = super.getChildren(obj);
                            for (const child of children) {
                                if (sceneobjects.isGameObject(child)) {
                                    if (child instanceof sceneobjects.ScriptNode) {
                                        return true;
                                    }
                                    result = this.hasUserComponentOrScriptNode(child);
                                    if (result) {
                                        return true;
                                    }
                                }
                            }
                        }
                        return result;
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_83) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ScriptNode extends Phaser.GameObjects.GameObject {
                    _editorSupport;
                    _parent;
                    constructor(scene) {
                        super(scene, "ScriptNode");
                        this._editorSupport = new sceneobjects.ScriptNodeEditorSupport(scene, this);
                        this._parent = scene.children;
                    }
                    getParentDisplayObject() {
                        if (this._parent) {
                            if (this._parent instanceof ScriptNode) {
                                return this._parent.getParentDisplayObject();
                            }
                            else if (sceneobjects.isGameObject(this._parent)) {
                                return this._parent;
                            }
                        }
                        return undefined;
                    }
                    willRender(camera) {
                        return false;
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                    getParent() {
                        return this._parent;
                    }
                    setParent(parent) {
                        this._parent = parent;
                    }
                    removeFromParent() {
                        if (sceneobjects.isGameObject(this._parent)) {
                            this._parent.getEditorSupport().removeObjectChild(this);
                        }
                        else {
                            this.scene.removeGameObject(this);
                        }
                        this._parent = undefined;
                    }
                }
                sceneobjects.ScriptNode = ScriptNode;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_83.ui || (scene_83.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class ScriptNodeCodeDOMBuilder extends sceneobjects.GameObjectCodeDOMBuilder {
                    constructor() {
                        super("ScriptNode");
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const call = new code.MethodCallCodeDOM("ScriptNode");
                        call.setConstructor(true);
                        call.arg(args.parentVarName || args.sceneExpr);
                        return call;
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const call = args.methodCallDOM;
                        call.arg(args.parentVarName || args.sceneExpr);
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const types = sceneobjects.ScriptNodeEditorSupport.DEFAULT_PARENT_VARIABLE_TYPES;
                        args.importTypes = types;
                        const decl = args.ctrDeclCodeDOM;
                        // remove the scene arg
                        decl.getArgs().pop();
                        decl.arg("parent", types.join(" | "));
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        const call = args.superMethodCallCodeDOM;
                        // remove the scene arg
                        call.getArgs().pop();
                        call.arg("parent");
                    }
                }
                sceneobjects.ScriptNodeCodeDOMBuilder = ScriptNodeCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ScriptNodeCodeResources extends scene.core.code.CodeResources2 {
                    static _instance = new ScriptNodeCodeResources();
                    static getInstance() {
                        return this._instance;
                    }
                    constructor() {
                        super("phasereditor2d.scene/code/scriptnode");
                        this.addCodeResource("ScriptNode");
                    }
                }
                sceneobjects.ScriptNodeCodeResources = ScriptNodeCodeResources;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_84) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ScriptNodeEditorSupport extends sceneobjects.GameObjectEditorSupport {
                    static DEFAULT_PARENT_VARIABLE_TYPES = ["ScriptNode", "Phaser.GameObjects.GameObject", "Phaser.Scene"];
                    constructor(scene, obj) {
                        super(sceneobjects.ScriptNodeExtension.getInstance(), obj, scene);
                    }
                    destroy() {
                        this.getObject().removeFromParent();
                        super.destroy();
                    }
                    isDisplayObject() {
                        return false;
                    }
                    setInteractive() {
                        // nothing
                    }
                    getCellRenderer() {
                        return new controls.viewers.IconImageCellRenderer(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_BUILD));
                    }
                    getObjectParent() {
                        const parent = this.getObject().getParent();
                        if (sceneobjects.isGameObject(parent)) {
                            return parent;
                        }
                        return undefined;
                    }
                }
                sceneobjects.ScriptNodeEditorSupport = ScriptNodeEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_84.ui || (scene_84.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ScriptNodeExtension extends sceneobjects.SceneGameObjectExtension {
                    static _instance;
                    static getInstance() {
                        return this._instance || (this._instance = new ScriptNodeExtension());
                    }
                    constructor() {
                        super({
                            typeName: "ScriptNode",
                            phaserTypeName: "ScriptNode",
                            category: scene.SCENE_OBJECT_SCRIPT_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_BUILD)
                        });
                    }
                    getHelp() {
                        return "A custom Phaser Editor 2D object for implementing game logic and object behaviors.";
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        // not supported
                        return null;
                    }
                    createGameObjectWithData(args) {
                        const script = new sceneobjects.ScriptNode(args.scene);
                        script.getEditorSupport().readJSON(args.data);
                        return script;
                    }
                    async getAssetsFromObjectData(args) {
                        return [];
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.ScriptNodeCodeDOMBuilder();
                    }
                    createDefaultSceneObject(args) {
                        const script = new sceneobjects.ScriptNode(args.scene);
                        return [script];
                    }
                }
                sceneobjects.ScriptNodeExtension = ScriptNodeExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var io = colibri.core.io;
                var code = phasereditor2d.ide.core.code;
                class ScriptsContentProvider {
                    getRoots(input) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const files = finder.getScriptPrefabFiles();
                        files.sort((a, b) => {
                            const aa = a.getFullName();
                            const bb = b.getFullName();
                            return aa.localeCompare(bb);
                        });
                        files.sort((a, b) => {
                            const aa = code.isNodeLibraryFile(a) || code.isCopiedLibraryFile(a) ? -1 : 1;
                            const bb = code.isNodeLibraryFile(b) || code.isCopiedLibraryFile(b) ? -1 : 1;
                            return aa - bb;
                        });
                        const folders = [];
                        for (const file of files) {
                            let parent = file.getParent();
                            if (folders.indexOf(parent) < 0) {
                                folders.push(parent);
                            }
                        }
                        return [sceneobjects.ScriptNodeExtension.getInstance(), ...folders];
                    }
                    getChildren(parent) {
                        if (parent instanceof io.FilePath) {
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            const files = finder.getScriptPrefabFiles();
                            return files.filter(f => f.getParent() === parent);
                        }
                        return [];
                    }
                }
                sceneobjects.ScriptsContentProvider = ScriptsContentProvider;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                var io = colibri.core.io;
                var code = phasereditor2d.ide.core.code;
                class ScriptStyledLabelProvider {
                    getStyledTexts(obj, dark) {
                        let text;
                        let color;
                        if (obj instanceof io.FilePath && obj.isFolder()) {
                            if (code.isNodeLibraryFile(obj)) {
                                text = code.findNodeModuleName(obj);
                                color = scene.ScenePlugin.getInstance().getScriptsLibraryColor();
                            }
                            else if (code.isCopiedLibraryFile(obj)) {
                                text = obj.getName();
                                color = scene.ScenePlugin.getInstance().getScriptsLibraryColor();
                            }
                            else {
                                text = obj.getName();
                                color = controls.Controls.getTheme().viewerForeground;
                            }
                        }
                        else if (obj instanceof sceneobjects.ScriptNodeExtension) {
                            text = obj.getTypeName();
                            color = controls.Controls.getTheme().viewerForeground;
                        }
                        else {
                            text = sceneobjects.getSceneDisplayName(obj);
                            color = scene.ScenePlugin.getInstance().getPrefabColor();
                        }
                        return [{ text, color }];
                    }
                }
                sceneobjects.ScriptStyledLabelProvider = ScriptStyledLabelProvider;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ShapeBlockCellRenderer {
                    renderCell(args) {
                        const ctx = args.canvasContext;
                        ctx.save();
                        const selected = args.viewer.isSelected(args.obj);
                        const theme = controls.Controls.getTheme();
                        ctx.strokeStyle = selected ? theme.viewerSelectionForeground : theme.viewerForeground;
                        ctx.translate(0.5, 0.5);
                        this.renderShapeCell(ctx, args);
                        ctx.restore();
                    }
                    cellHeight(args) {
                        return args.viewer.getCellSize();
                    }
                    async preload(args) {
                        return controls.PreloadResult.NOTHING_LOADED;
                    }
                }
                sceneobjects.ShapeBlockCellRenderer = ShapeBlockCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ShapeComponent extends sceneobjects.Component {
                    static fillColor = sceneobjects.NumberColorProperty("fillColor", "#fff", "Fill Color", "phaser:Phaser.GameObjects.Shape.fillColor");
                    static isFilled = sceneobjects.SimpleProperty("isFilled", false, "Is Filled", "phaser:Phaser.GameObjects.Shape.isFilled");
                    static fillAlpha = sceneobjects.SimpleProperty("fillAlpha", 1, "Fill Alpha", "phaser:Phaser.GameObjects.Shape.fillAlpha", false, undefined, 0.01, 0, 1);
                    static isStroked = sceneobjects.SimpleProperty("isStroked", false, "Is Stroked", "phaser:Phaser.GameObjects.Shape.isStroked");
                    static strokeColor = sceneobjects.NumberColorProperty("strokeColor", "#fff", "Stroke Color", "phaser:Phaser.GameObjects.Shape.strokeColor");
                    static strokeAlpha = sceneobjects.SimpleProperty("strokeAlpha", 1, "Stroke Alpha", "phaser:Phaser.GameObjects.Shape.strokeAlpha", false, undefined, 0.01, 0, 1);
                    static lineWidth = sceneobjects.SimpleProperty("lineWidth", 1, "Line Width", "phaser:Phaser.GameObjects.Shape.lineWidth", false, undefined, 0.05, 0);
                    constructor(obj) {
                        super(obj, [
                            ShapeComponent.isFilled,
                            ShapeComponent.fillColor,
                            ShapeComponent.fillAlpha,
                            ShapeComponent.strokeColor,
                            ShapeComponent.strokeAlpha,
                            ShapeComponent.lineWidth,
                            ShapeComponent.isStroked
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_BooleanProperty(args, ShapeComponent.isFilled);
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, sceneobjects.NumberColorPropertyCodeDomAdapter2(ShapeComponent.fillColor));
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, ShapeComponent.fillAlpha);
                        this.buildSetObjectPropertyCodeDOM_BooleanProperty(args, ShapeComponent.isStroked);
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, sceneobjects.NumberColorPropertyCodeDomAdapter2(ShapeComponent.strokeColor));
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, ShapeComponent.strokeAlpha);
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, ShapeComponent.lineWidth);
                    }
                }
                sceneobjects.ShapeComponent = ShapeComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_85) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ShapeEditorSupport extends sceneobjects.GameObjectEditorSupport {
                    static isShape(obj) {
                        return sceneobjects.isGameObject(obj)
                            && obj.getEditorSupport() instanceof ShapeEditorSupport;
                    }
                    constructor(ext, obj, scene) {
                        super(ext, obj, scene);
                        this.addComponent(new sceneobjects.TransformComponent(obj), new sceneobjects.OriginComponent(obj), new sceneobjects.VisibleComponent(obj), new sceneobjects.AlphaSingleComponent(obj), new sceneobjects.ArcadeComponent(obj, false), new sceneobjects.ShapeComponent(obj));
                    }
                    getCellRenderer() {
                        // return new ObjectCellRenderer();
                        return this.getExtension().getBlockCellRenderer();
                    }
                    setInteractive() {
                        this.getObject().setInteractive(sceneobjects.interactive_shape);
                    }
                    computeContentHash() {
                        return this.computeContentHashWithComponent(this.getObject(), sceneobjects.ShapeComponent);
                    }
                }
                sceneobjects.ShapeEditorSupport = ShapeEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_85.ui || (scene_85.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ShapeSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.ShapeSection", "Shape", false, false);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/shape-object.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr auto";
                        this.createPropertyBoolean(comp, sceneobjects.ShapeComponent.isFilled)
                            .checkElement.style.gridColumn = "3 / span 2";
                        this.createPropertyColorRow(comp, sceneobjects.ShapeComponent.fillColor, false)
                            .element.style.gridColumn = "3 / span 2";
                        this.createPropertyFloatRow(comp, sceneobjects.ShapeComponent.fillAlpha)
                            .style.gridColumn = "3 / span 2";
                        this.createPropertyBoolean(comp, sceneobjects.ShapeComponent.isStroked)
                            .checkElement.style.gridColumn = "3 / span 2";
                        this.createPropertyColorRow(comp, sceneobjects.ShapeComponent.strokeColor, false)
                            .element.style.gridColumn = "3 / span 2";
                        this.createPropertyFloatRow(comp, sceneobjects.ShapeComponent.strokeAlpha)
                            .style.gridColumn = "3 / span 2";
                        this.createPropertyFloatRow(comp, sceneobjects.ShapeComponent.lineWidth)
                            .style.gridColumn = "3 / span 2";
                    }
                    canEdit(obj, n) {
                        return sceneobjects.ShapeEditorSupport.isShape(obj);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.ShapeSection = ShapeSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_86) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Ellipse extends Phaser.GameObjects.Ellipse {
                    _editorSupport;
                    constructor(scene, x, y) {
                        super(scene, x, y);
                        this._editorSupport = new sceneobjects.EllipseEditorSupport(scene, this);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                    setSize(width, height) {
                        const self = this;
                        const geom = this.geom;
                        geom.setPosition(width / 2, height / 2);
                        geom.setSize(width, height);
                        this.width = width;
                        this.height = height;
                        this.updateDisplayOrigin();
                        self.updateData();
                        return this;
                    }
                }
                sceneobjects.Ellipse = Ellipse;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_86.ui || (scene_86.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../ShapeBlockCellRenderer.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseBlockCellRenderer extends sceneobjects.ShapeBlockCellRenderer {
                    static _instance;
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new EllipseBlockCellRenderer());
                    }
                    renderShapeCell(ctx, args) {
                        const size = Math.floor(Math.max(8, Math.floor(Math.min(args.w, args.h) * 0.5)));
                        const x = Math.floor(args.x + args.w / 2);
                        const y = Math.floor(args.y + args.h / 2);
                        const r = Math.floor(size / 2);
                        ctx.beginPath();
                        ctx.ellipse(x, y, r, r, 0, 0, 360);
                        ctx.stroke();
                    }
                }
                sceneobjects.EllipseBlockCellRenderer = EllipseBlockCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class EllipseCodeDOMBuilder extends sceneobjects.BaseImageCodeDOMBuilder {
                    constructor() {
                        super("ellipse");
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        args.methodCallDOM.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        this.buildCreatePrefabInstanceCodeDOM_Size_Arguments(args);
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                        ctr.arg("width", "number", true);
                        ctr.arg("height", "number", true);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        const obj = args.prefabObj;
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_SizeParameters(args);
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("ellipse", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        call.argFloat(obj.width);
                        call.argFloat(obj.height);
                        return call;
                    }
                }
                sceneobjects.EllipseCodeDOMBuilder = EllipseCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseComponent extends sceneobjects.Component {
                    static smoothness = sceneobjects.SimpleProperty("smoothness", 64, "Smoothness", "phaser:Phaser.GameObjects.Ellipse.smoothness", false, undefined, 1, 0);
                    constructor(obj) {
                        super(obj, [
                            EllipseComponent.smoothness
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, EllipseComponent.smoothness);
                    }
                }
                sceneobjects.EllipseComponent = EllipseComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../ShapeEditorSupport.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_87) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseEditorSupport extends sceneobjects.ShapeEditorSupport {
                    constructor(scene, obj) {
                        super(sceneobjects.EllipseExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.SizeComponent(obj), new sceneobjects.EllipseComponent(obj));
                    }
                    computeContentHash() {
                        let hash = super.computeContentHash();
                        hash += this.computeContentHashWithComponent(this.getObject(), sceneobjects.EllipseComponent);
                        return hash;
                    }
                }
                sceneobjects.EllipseEditorSupport = EllipseEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_87.ui || (scene_87.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseExtension extends sceneobjects.SceneGameObjectExtension {
                    static _instance;
                    static getInstance() {
                        return this._instance ?? (this._instance = new EllipseExtension());
                    }
                    constructor() {
                        super({
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_GROUP),
                            phaserTypeName: "Phaser.GameObjects.Ellipse",
                            category: scene.SCENE_OBJECT_SHAPE_CATEGORY,
                            typeName: "Ellipse"
                        });
                    }
                    getBlockCellRenderer() {
                        return sceneobjects.EllipseBlockCellRenderer.getInstance();
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        // not supported
                        return null;
                    }
                    createGameObjectWithData(args) {
                        const obj = new sceneobjects.Ellipse(args.scene, 0, 0);
                        obj.getEditorSupport().readJSON(args.data);
                        return obj;
                    }
                    createDefaultSceneObject(args) {
                        const obj = new sceneobjects.Ellipse(args.scene, args.x, args.y);
                        obj.isFilled = true;
                        return [obj];
                    }
                    async getAssetsFromObjectData(args) {
                        return [];
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.EllipseCodeDOMBuilder();
                    }
                }
                sceneobjects.EllipseExtension = EllipseExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class EllipseSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.EllipseSection", "Ellipse", false, true);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto auto 1fr";
                        this.createNumberProperty(comp, sceneobjects.EllipseComponent.smoothness);
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.Ellipse;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.EllipseSection = EllipseSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_88) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Polygon extends Phaser.GameObjects.Polygon {
                    static DEFAULT_POINTS = [
                        -35 + 70, 50 + 50,
                        -70 + 70, 0 + 50,
                        0 + 70, -50 + 50,
                        70 + 70, 0 + 50,
                        35 + 70, 50 + 50
                    ].join(" ");
                    _editorSupport;
                    constructor(scene, x, y, points) {
                        super(scene, x, y, points);
                        this._editorSupport = new sceneobjects.PolygonEditorSupport(scene, this);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                    getPointsString() {
                        return this.getPolygonGeom().points.map(p => `${p.x} ${p.y}`).join(" ");
                    }
                    get points() {
                        if (this.getPolygonGeom()) {
                            return this.getPolygonGeom().points.map(p => `${p.x} ${p.y}`).join(" ");
                        }
                        return "";
                    }
                    set points(points) {
                        this.getPolygonGeom().setTo(points);
                        var bounds = Phaser.Geom.Polygon.GetAABB(this.geom);
                        this.setSize(bounds.width, bounds.height);
                        this.updateDisplayOrigin();
                        this.updateData();
                        this.updateDisplayOrigin();
                    }
                    getPolygonGeom() {
                        return this.geom;
                    }
                }
                sceneobjects.Polygon = Polygon;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_88.ui || (scene_88.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../ShapeBlockCellRenderer.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PolygonBlockCellRenderer extends sceneobjects.ShapeBlockCellRenderer {
                    static _instance;
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new PolygonBlockCellRenderer());
                    }
                    renderShapeCell(ctx, args) {
                        const size = Math.floor(Math.max(8, Math.floor(Math.min(args.w, args.h) * 0.5)));
                        const x = Math.floor(args.x + args.w / 2);
                        const y = Math.floor(args.y + args.h / 2);
                        const r = Math.floor(size / 2);
                        ctx.beginPath();
                        ctx.moveTo(x - r / 2, y + r);
                        ctx.lineTo(x - r, y);
                        ctx.lineTo(x, y - r);
                        ctx.lineTo(x + r, y);
                        ctx.lineTo(x + r / 2, y + r);
                        ctx.closePath();
                        ctx.stroke();
                    }
                }
                sceneobjects.PolygonBlockCellRenderer = PolygonBlockCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class PolygonCodeDOMBuilder extends sceneobjects.BaseImageCodeDOMBuilder {
                    constructor() {
                        super("polygon");
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const obj = args.obj;
                        const support = obj.getEditorSupport();
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        if (support.isUnlockedProperty(sceneobjects.PolygonComponent.points)) {
                            call.argLiteral(sceneobjects.PolygonComponent.points.getValue(obj));
                        }
                        else {
                            call.arg("undefined");
                        }
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                        ctr.arg("points", "string", true);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        const obj = args.prefabObj;
                        const support = obj.getEditorSupport();
                        const call = args.superMethodCallCodeDOM;
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        const p = sceneobjects.PolygonComponent.points;
                        if (support.isUnlockedProperty(p)) {
                            call.arg(`${p.name} ?? "${p.getValue(obj)}"`);
                        }
                        else {
                            call.arg("undefined");
                        }
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("polygon", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        call.argLiteral(sceneobjects.PolygonComponent.points.getValue(obj));
                        return call;
                    }
                }
                sceneobjects.PolygonCodeDOMBuilder = PolygonCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PolygonComponent extends sceneobjects.Component {
                    static points = sceneobjects.SimpleProperty("points", sceneobjects.Polygon.DEFAULT_POINTS, "Points", "The polygon's points, in a string format `X1 Y1 Y2 X2...`");
                    constructor(obj) {
                        super(obj, [PolygonComponent.points]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const obj = this.getObject();
                        const support = obj.getEditorSupport();
                        if (support.isNestedPrefabInstance()
                            && support.isUnlockedProperty(PolygonComponent.points)) {
                            const dom = new scene.core.code.MethodCallCodeDOM("setTo", args.objectVarName);
                            dom.argLiteral(obj.points);
                            args.statements.push(dom);
                        }
                    }
                }
                sceneobjects.PolygonComponent = PolygonComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../ShapeEditorSupport.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_89) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PolygonEditorSupport extends sceneobjects.ShapeEditorSupport {
                    constructor(scene, obj) {
                        super(sceneobjects.PolygonExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.PolygonComponent(obj));
                    }
                    getScreenBounds(camera) {
                        const polygon = this.getObject();
                        let left = Number.MAX_VALUE;
                        let right = Number.MIN_VALUE;
                        let top = Number.MAX_VALUE;
                        let bottom = Number.MIN_VALUE;
                        let temp = new Phaser.Math.Vector2();
                        for (const point of polygon.getPolygonGeom().points) {
                            polygon.getWorldTransformMatrix().transformPoint(point.x - polygon.displayOriginX, point.y - polygon.displayOriginY, temp);
                            temp = camera.getScreenPoint(temp.x, temp.y);
                            left = Math.min(left, temp.x);
                            right = Math.max(right, temp.x);
                            top = Math.min(top, temp.y);
                            bottom = Math.max(bottom, temp.y);
                        }
                        return [
                            new Phaser.Math.Vector2(left, top),
                            new Phaser.Math.Vector2(right, top),
                            new Phaser.Math.Vector2(right, bottom),
                            new Phaser.Math.Vector2(left, bottom)
                        ];
                    }
                    computeContentHash() {
                        let hash = super.computeContentHash();
                        hash += this.computeContentHashWithComponent(this.getObject(), sceneobjects.PolygonComponent);
                        return hash;
                    }
                }
                sceneobjects.PolygonEditorSupport = PolygonEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_89.ui || (scene_89.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PolygonExtension extends sceneobjects.SceneGameObjectExtension {
                    static _instance;
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new PolygonExtension());
                    }
                    constructor() {
                        super({
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_GROUP),
                            phaserTypeName: "Phaser.GameObjects.Polygon",
                            typeName: "Polygon",
                            category: scene.SCENE_OBJECT_SHAPE_CATEGORY,
                        });
                    }
                    getBlockCellRenderer() {
                        return sceneobjects.PolygonBlockCellRenderer.getInstance();
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        // not supported
                        return null;
                    }
                    createGameObjectWithData(args) {
                        const obj = new sceneobjects.Polygon(args.scene, 0, 0, sceneobjects.Polygon.DEFAULT_POINTS);
                        obj.getEditorSupport().readJSON(args.data);
                        return obj;
                    }
                    createDefaultSceneObject(args) {
                        const obj = new sceneobjects.Polygon(args.scene, args.x, args.y, sceneobjects.Polygon.DEFAULT_POINTS);
                        obj.isFilled = true;
                        return [obj];
                    }
                    async getAssetsFromObjectData(args) {
                        return [];
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.PolygonCodeDOMBuilder();
                    }
                }
                sceneobjects.PolygonExtension = PolygonExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PolygonSection extends sceneobjects.SceneGameObjectSection {
                    static SECTION_ID = "phasereditor2d.scene.ui.sceneobjects.PolygonSection";
                    constructor(page) {
                        super(page, PolygonSection.SECTION_ID, "Polygon", false, true);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 3);
                        this.createPropertyStringDialogRow(comp, sceneobjects.PolygonComponent.points);
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.Polygon;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.PolygonSection = PolygonSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_90) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Rectangle extends Phaser.GameObjects.Rectangle {
                    _editorSupport;
                    constructor(scene, x, y) {
                        super(scene, x, y);
                        this._editorSupport = new sceneobjects.RectangleEditorSupport(scene, this);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                    setSize(width, height) {
                        super.setSize(width, height);
                        const geom = this.geom;
                        geom.setSize(width, height);
                        this.updateDisplayOrigin();
                        const self = this;
                        self.updateData();
                        return this;
                    }
                }
                sceneobjects.Rectangle = Rectangle;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_90.ui || (scene_90.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../ShapeBlockCellRenderer.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RectangleBlockCellRenderer extends sceneobjects.ShapeBlockCellRenderer {
                    static _instance;
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new RectangleBlockCellRenderer());
                    }
                    renderShapeCell(ctx, args) {
                        const size = Math.floor(Math.max(8, Math.floor(Math.min(args.w, args.h) * 0.5)));
                        const x = Math.floor(args.x + (args.w - size) / 2);
                        const y = Math.floor(args.y + (args.h - size) / 2);
                        ctx.beginPath();
                        ctx.rect(x, y, size, size);
                        ctx.stroke();
                    }
                }
                sceneobjects.RectangleBlockCellRenderer = RectangleBlockCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class RectangleCodeDOMBuilder extends sceneobjects.BaseImageCodeDOMBuilder {
                    constructor() {
                        super("rectangle");
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        this.buildCreatePrefabInstanceCodeDOM_Size_Arguments(args);
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                        ctr.arg("width", "number", true);
                        ctr.arg("height", "number", true);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_SizeParameters(args);
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("rectangle", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        call.argFloat(obj.width);
                        call.argFloat(obj.height);
                        return call;
                    }
                }
                sceneobjects.RectangleCodeDOMBuilder = RectangleCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../ShapeEditorSupport.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_91) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RectangleEditorSupport extends sceneobjects.ShapeEditorSupport {
                    constructor(scene, obj) {
                        super(sceneobjects.RectangleExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.SizeComponent(obj));
                    }
                    computeContentHash() {
                        let hash = super.computeContentHash();
                        hash += this.computeContentHashWithComponent(this.getObject(), sceneobjects.SizeComponent);
                        return hash;
                    }
                }
                sceneobjects.RectangleEditorSupport = RectangleEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_91.ui || (scene_91.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class RectangleExtension extends sceneobjects.SceneGameObjectExtension {
                    static _instance;
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new RectangleExtension());
                    }
                    constructor() {
                        super({
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_GROUP),
                            phaserTypeName: "Phaser.GameObjects.Rectangle",
                            category: scene.SCENE_OBJECT_SHAPE_CATEGORY,
                            typeName: "Rectangle"
                        });
                    }
                    getBlockCellRenderer() {
                        return sceneobjects.RectangleBlockCellRenderer.getInstance();
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        // not supported
                        return null;
                    }
                    createGameObjectWithData(args) {
                        const obj = new sceneobjects.Rectangle(args.scene, 0, 0);
                        obj.getEditorSupport().readJSON(args.data);
                        return obj;
                    }
                    createDefaultSceneObject(args) {
                        const obj = new sceneobjects.Rectangle(args.scene, args.x, args.y);
                        obj.isFilled = true;
                        return [obj];
                    }
                    async getAssetsFromObjectData(args) {
                        return [];
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.RectangleCodeDOMBuilder();
                    }
                }
                sceneobjects.RectangleExtension = RectangleExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_92) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Triangle extends Phaser.GameObjects.Triangle {
                    _editorSupport;
                    _triangle;
                    constructor(scene, x, y) {
                        super(scene, x, y);
                        this._editorSupport = new sceneobjects.TriangleEditorSupport(scene, this);
                        this._triangle = this.geom;
                    }
                    getTriangleGeom() {
                        return this._triangle;
                    }
                    get x1() {
                        return this.getTriangleGeom().x1;
                    }
                    set x1(val) {
                        this.setTo(val, this.y1, this.x2, this.y2, this.x3, this.y3);
                    }
                    get x2() {
                        return this.getTriangleGeom().x2;
                    }
                    set x2(val) {
                        this.setTo(this.x1, this.y1, val, this.y2, this.x3, this.y3);
                    }
                    get x3() {
                        return this.getTriangleGeom().x3;
                    }
                    set x3(val) {
                        this.setTo(this.x1, this.y1, this.x2, this.y2, val, this.y3);
                    }
                    get y1() {
                        return this.getTriangleGeom().y1;
                    }
                    set y1(val) {
                        this.setTo(this.x1, val, this.x2, this.y2, this.x3, this.y3);
                    }
                    get y2() {
                        return this.getTriangleGeom().y2;
                    }
                    set y2(val) {
                        this.setTo(this.x1, this.y1, this.x2, val, this.x3, this.y3);
                    }
                    get y3() {
                        return this.getTriangleGeom().y3;
                    }
                    set y3(val) {
                        this.setTo(this.x1, this.y1, this.x2, this.y2, this.x3, val);
                    }
                    setTo(x1, y1, x2, y2, x3, y3) {
                        super.setTo(x1, y1, x2, y2, x3, y3);
                        const geom = this.getTriangleGeom();
                        const width = geom.right - geom.left;
                        const height = geom.bottom - geom.top;
                        this["setSize"](width, height);
                        this.updateDisplayOrigin();
                        return this;
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.Triangle = Triangle;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_92.ui || (scene_92.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../ShapeBlockCellRenderer.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TriangleBlockCellRenderer extends sceneobjects.ShapeBlockCellRenderer {
                    static _instance;
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new TriangleBlockCellRenderer());
                    }
                    renderShapeCell(ctx, args) {
                        const size = Math.floor(Math.max(8, Math.floor(Math.min(args.w, args.h) * 0.5)));
                        const x = Math.floor(args.x + args.w / 2);
                        const y = Math.floor(args.y + args.h / 2);
                        const r = Math.floor(size / 2);
                        ctx.beginPath();
                        ctx.moveTo(x - r, y + r);
                        ctx.lineTo(x, y - r);
                        ctx.lineTo(x + r, y + r);
                        ctx.closePath();
                        ctx.stroke();
                    }
                }
                sceneobjects.TriangleBlockCellRenderer = TriangleBlockCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class TriangleCodeDOMBuilder extends sceneobjects.BaseImageCodeDOMBuilder {
                    constructor() {
                        super("triangle");
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const obj = args.obj;
                        const support = obj.getEditorSupport();
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        for (const p of [sceneobjects.TriangleComponent.p1, sceneobjects.TriangleComponent.p2, sceneobjects.TriangleComponent.p3]) {
                            if (support.isUnlockedPropertyXY(p)) {
                                call.argFloat(p.x.getValue(obj));
                                call.argFloat(p.y.getValue(obj));
                            }
                            else {
                                call.arg("undefined");
                                call.arg("undefined");
                            }
                        }
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                        ctr.arg("x1", "number", true);
                        ctr.arg("y1", "number", true);
                        ctr.arg("x2", "number", true);
                        ctr.arg("y2", "number", true);
                        ctr.arg("x3", "number", true);
                        ctr.arg("y3", "number", true);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        const obj = args.prefabObj;
                        const support = obj.getEditorSupport();
                        const call = args.superMethodCallCodeDOM;
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        for (const p of [sceneobjects.TriangleComponent.p1, sceneobjects.TriangleComponent.p2, sceneobjects.TriangleComponent.p3]) {
                            if (support.isUnlockedPropertyXY(p)) {
                                call.arg(`${p.x.name} ?? ${p.x.getValue(obj)}`);
                                call.arg(`${p.y.name} ?? ${p.y.getValue(obj)}`);
                            }
                            else {
                                call.arg("undefined");
                                call.arg("undefined");
                            }
                        }
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("triangle", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        call.argFloat(obj.x1);
                        call.argFloat(obj.y1);
                        call.argFloat(obj.x2);
                        call.argFloat(obj.y2);
                        call.argFloat(obj.x3);
                        call.argFloat(obj.y3);
                        return call;
                    }
                }
                sceneobjects.TriangleCodeDOMBuilder = TriangleCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TriangleComponent extends sceneobjects.Component {
                    static x1 = sceneobjects.SimpleProperty("x1", 0, "X", "phaser:Phaser.Geom.Triangle.x1", false, undefined, 1);
                    static y1 = sceneobjects.SimpleProperty("y1", 128, "Y", "phaser:Phaser.Geom.Triangle.y1", false, undefined, 1);
                    static x2 = sceneobjects.SimpleProperty("x2", 64, "X", "phaser:Phaser.Geom.Triangle.x2", false, undefined, 1);
                    static y2 = sceneobjects.SimpleProperty("y2", 0, "Y", "phaser:Phaser.Geom.Triangle.y2", false, undefined, 1);
                    static x3 = sceneobjects.SimpleProperty("x3", 128, "X", "phaser:Phaser.Geom.Triangle.x3", false, undefined, 1);
                    static y3 = sceneobjects.SimpleProperty("y3", 128, "Y", "phaser:Phaser.Geom.Triangle.y3", false, undefined, 1);
                    static p1 = {
                        label: "Point 1",
                        x: TriangleComponent.x1,
                        y: TriangleComponent.y1
                    };
                    static p2 = {
                        label: "Point 2",
                        x: TriangleComponent.x2,
                        y: TriangleComponent.y2
                    };
                    static p3 = {
                        label: "Point 3",
                        x: TriangleComponent.x3,
                        y: TriangleComponent.y3
                    };
                    constructor(obj) {
                        super(obj, [TriangleComponent.x1,
                            TriangleComponent.y1,
                            TriangleComponent.x2,
                            TriangleComponent.y2,
                            TriangleComponent.x3,
                            TriangleComponent.y3]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const obj = this.getObject();
                        const support = obj.getEditorSupport();
                        if (support.isNestedPrefabInstance() &&
                            (support.isUnlockedPropertyXY(TriangleComponent.p1)
                                || support.isUnlockedPropertyXY(TriangleComponent.p2)
                                || support.isUnlockedPropertyXY(TriangleComponent.p3))) {
                            const dom = new scene.core.code.MethodCallCodeDOM("setTo", args.objectVarName);
                            dom.argFloat(obj.x1);
                            dom.argFloat(obj.y1);
                            dom.argFloat(obj.x2);
                            dom.argFloat(obj.y2);
                            dom.argFloat(obj.x3);
                            dom.argFloat(obj.y3);
                            args.statements.push(dom);
                        }
                    }
                }
                sceneobjects.TriangleComponent = TriangleComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../ShapeEditorSupport.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_93) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TriangleEditorSupport extends sceneobjects.ShapeEditorSupport {
                    constructor(scene, obj) {
                        super(sceneobjects.TriangleExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.TriangleComponent(obj));
                    }
                    computeContentHash() {
                        let hash = super.computeContentHash();
                        hash += this.computeContentHashWithComponent(this.getObject(), sceneobjects.TriangleComponent);
                        return hash;
                    }
                }
                sceneobjects.TriangleEditorSupport = TriangleEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_93.ui || (scene_93.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TriangleExtension extends sceneobjects.SceneGameObjectExtension {
                    static _instance;
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new TriangleExtension());
                    }
                    constructor() {
                        super({
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_GROUP),
                            phaserTypeName: "Phaser.GameObjects.Triangle",
                            typeName: "Triangle",
                            category: scene.SCENE_OBJECT_SHAPE_CATEGORY,
                        });
                    }
                    getBlockCellRenderer() {
                        return sceneobjects.TriangleBlockCellRenderer.getInstance();
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        // not supported
                        return null;
                    }
                    createGameObjectWithData(args) {
                        const obj = new sceneobjects.Triangle(args.scene, 0, 0);
                        obj.getEditorSupport().readJSON(args.data);
                        return obj;
                    }
                    createDefaultSceneObject(args) {
                        const obj = new sceneobjects.Triangle(args.scene, args.x, args.y);
                        obj.isFilled = true;
                        return [obj];
                    }
                    async getAssetsFromObjectData(args) {
                        return [];
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.TriangleCodeDOMBuilder();
                    }
                }
                sceneobjects.TriangleExtension = TriangleExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TriangleSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.TriangleSection", "Triangle", false, true);
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createPropertyXYRow(comp, sceneobjects.TriangleComponent.p1);
                        this.createPropertyXYRow(comp, sceneobjects.TriangleComponent.p2);
                        this.createPropertyXYRow(comp, sceneobjects.TriangleComponent.p3);
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.Triangle;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.TriangleSection = TriangleSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class UserPropertyType {
                    _id;
                    _defValue;
                    _expressionType;
                    constructor(id, defValue) {
                        this._id = id;
                        this._defValue = defValue;
                        this._expressionType = "any";
                    }
                    getExpressionType() {
                        return this._expressionType;
                    }
                    setExpressionType(expressionType) {
                        this._expressionType = expressionType;
                    }
                    hasCustomPropertyType() {
                        return false;
                    }
                    getId() {
                        return this._id;
                    }
                    getDefaultValue() {
                        return this._defValue;
                    }
                    writeJSON(data) {
                        data.id = this._id;
                        if (this.hasCustomPropertyType()) {
                            data.expressionType = this.getExpressionType();
                        }
                    }
                    readJSON(data) {
                        if (this.hasCustomPropertyType()) {
                            this._expressionType = data.expressionType || "any";
                        }
                    }
                    buildStringFieldCode(prop, value) {
                        const decl = new code.FieldDeclCodeDOM(prop.getInfo().name, "string", true);
                        decl.setInitialValueExpr(code.CodeDOM.quote(value));
                        return decl;
                    }
                    buildExpressionFieldCode(prop, type, value) {
                        const decl = new code.FieldDeclCodeDOM(prop.getInfo().name, type, true);
                        decl.setAllowUndefined(true);
                        decl.setInitialValueExpr(value);
                        return decl;
                    }
                    buildNumberFieldCode(prop, value) {
                        const decl = new code.FieldDeclCodeDOM(prop.getInfo().name, "number", true);
                        decl.setInitialValueExpr(value.toString());
                        return decl;
                    }
                    buildBooleanFieldCode(prop, value) {
                        const decl = new code.FieldDeclCodeDOM(prop.getInfo().name, "boolean", true);
                        decl.setInitialValueExpr(value.toString());
                        return decl;
                    }
                }
                sceneobjects.UserPropertyType = UserPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./UserPropertyType.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class StringPropertyType extends sceneobjects.UserPropertyType {
                    constructor(typeId = "string", defValue = "") {
                        super(typeId, defValue);
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon) {
                        section.createPropertyStringDialogRow(parent, userProp.getComponentProperty(), lockIcon);
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        return this.buildStringFieldCode(prop, value);
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_StringProperty(args, userProp.getComponentProperty());
                    }
                    getName() {
                        return "String";
                    }
                    createEditorElement(getValue, setValue) {
                        const element = document.createElement("input");
                        element.type = "text";
                        element.classList.add("formText");
                        element.addEventListener("change", e => {
                            setValue(element.value);
                        });
                        const update = () => {
                            element.value = getValue();
                        };
                        return {
                            element,
                            update
                        };
                    }
                }
                sceneobjects.StringPropertyType = StringPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./StringPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class AbstractDialogPropertyType extends sceneobjects.StringPropertyType {
                    _name;
                    _hasCustomIcon;
                    _dialogTitle;
                    constructor(config) {
                        super(config.id);
                        this._name = config.name;
                        this._dialogTitle = config.dialogTitle;
                        this._hasCustomIcon = config.hasCustomIcon === undefined ? false : config.hasCustomIcon;
                    }
                    getName() {
                        return this._name;
                    }
                    getEditor() {
                        return colibri.Platform.getWorkbench()
                            .getActiveWindow().getEditorArea()
                            .getSelectedEditor();
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon, previewAction) {
                        const prop = userProp.getComponentProperty();
                        if (lockIcon) {
                            section.createLock(parent, prop);
                        }
                        const label = section.createLabel(parent, prop.label, scene.PhaserHelp(prop.tooltip));
                        label.style.gridColumn = "2";
                        const comp = this.createEditorComp(Boolean(previewAction));
                        parent.appendChild(comp);
                        const text = section.createStringField(comp, prop);
                        const { buttonElement, iconControl } = this.createSearchButton(() => prop.getValue(section.getSelectionFirstElement()), value => {
                            text.value = value;
                            const editor = section.getEditor();
                            editor.getUndoManager().add(new sceneobjects.SimpleOperation(editor, section.getSelection(), prop, value));
                        });
                        section.addUpdater(() => {
                            buttonElement.disabled = !section.isUnlocked(prop);
                            const value = prop.getValue(section.getSelectionFirstElement());
                            this.updateIcon(iconControl, value);
                        });
                        comp.appendChild(buttonElement);
                        if (previewAction) {
                            section.createButton(comp, phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_PLAY), () => {
                                previewAction();
                            });
                        }
                    }
                    createEditorComp(withPreviewButton = false) {
                        const comp = document.createElement("div");
                        comp.style.display = "grid";
                        comp.style.gridTemplateColumns = withPreviewButton ? "1fr auto auto" : "1fr auto";
                        comp.style.gap = "5px";
                        comp.style.alignItems = "center";
                        return comp;
                    }
                    createSearchButton(getValue, callback) {
                        const iconControl = new controls.IconControl(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                        const btn = document.createElement("button");
                        btn.appendChild(iconControl.getCanvas());
                        btn.addEventListener("click", async (e) => {
                            const value = getValue();
                            this.createSearchDialog(value, callback);
                        });
                        if (this._hasCustomIcon) {
                            this.updateIcon(iconControl, getValue());
                        }
                        return { buttonElement: btn, iconControl };
                    }
                    async updateIcon(iconControl, value) {
                        // iconControl.setIcon(icon);
                    }
                    hasCustomIcon() {
                        return false;
                    }
                    getDialogTitle() {
                        return this._dialogTitle;
                    }
                    getDialogSize() {
                        return {
                            width: undefined,
                            height: window.innerHeight * 2 / 3
                        };
                    }
                    async createSearchDialog(revealValue, callback) {
                        const viewer = await this.createViewer();
                        viewer.setInput([]);
                        const dlg = this.createDialogInstance(viewer, true);
                        const size = this.getDialogSize();
                        dlg.setSize(size.width, size.height);
                        dlg.create();
                        dlg.setTitle(this.getDialogTitle());
                        dlg.enableButtonOnlyWhenOneElementIsSelected(dlg.addOpenButton("Select", sel => {
                            const value = this.valueToString(viewer, sel[0]);
                            callback(value);
                        }));
                        dlg.addCancelButton();
                        await this.loadViewerInput(viewer);
                        this.revealValue(viewer, revealValue);
                        controls.viewers.GridTreeViewerRenderer.expandSections(viewer);
                    }
                    createDialogInstance(viewer, showZoomControls) {
                        return new controls.dialogs.ViewerDialog(viewer, showZoomControls);
                    }
                    revealValue(viewer, value) {
                        const found = viewer.findElementByLabel(value);
                        if (found) {
                            viewer.setSelection([found]);
                            viewer.reveal(found);
                        }
                    }
                    createEditorElement(getValue, setValue, previewAction) {
                        const comp = this.createEditorComp(Boolean(previewAction));
                        const formBuilder = new controls.properties.FormBuilder();
                        const inputElement = formBuilder.createText(comp, false);
                        inputElement.addEventListener("change", e => {
                            setValue(inputElement.value);
                        });
                        const { buttonElement, iconControl } = this.createSearchButton(getValue, setValue);
                        comp.appendChild(buttonElement);
                        const update = () => {
                            const value = getValue();
                            inputElement.value = value;
                            this.updateIcon(iconControl, value);
                        };
                        if (previewAction) {
                            formBuilder.createButton(comp, phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_PLAY), () => {
                                previewAction();
                            });
                        }
                        return {
                            element: comp,
                            update
                        };
                    }
                    formatKeyFrame(key, frame) {
                        if (frame === undefined || frame === null) {
                            return key;
                        }
                        return frame.toString();
                    }
                }
                sceneobjects.AbstractDialogPropertyType = AbstractDialogPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpineSkinCellRenderer {
                    getSkinItem(args) {
                        return args.obj;
                    }
                    renderCell(args) {
                        const skin = this.getSkinItem(args);
                        const cache = scene.ScenePlugin.getInstance().getSpineThumbnailCache();
                        const image = cache.getContent(skin);
                        if (image) {
                            image.paint(args.canvasContext, args.x, args.y, args.w, args.h, args.center);
                        }
                    }
                    cellHeight(args) {
                        return args.viewer.getCellSize();
                    }
                    preload(args) {
                        const skin = this.getSkinItem(args);
                        const cache = scene.ScenePlugin.getInstance().getSpineThumbnailCache();
                        return cache.preload(skin);
                    }
                }
                sceneobjects.SpineSkinCellRenderer = SpineSkinCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../userProperties/AbstractDialogPropertyType.ts" />
/// <reference path="./SpineSkinCellRenderer.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                function getSkin(obj) {
                    const skins = obj.spineAsset.getGuessSkinItems();
                    const skin = skins[Math.floor(skins.length / 2)];
                    return skin;
                }
                class SpineAnimationNamePropertyType extends sceneobjects.AbstractDialogPropertyType {
                    constructor() {
                        super({
                            id: "spine-animation-name",
                            name: "Spine Animation Name",
                            dialogTitle: "Select Animation",
                            hasCustomIcon: true
                        });
                    }
                    async updateIcon(iconControl, value) {
                        const animationItems = await sceneobjects.SpineUtils.getSpineAnimationItems();
                        const sameNameAnimationItems = animationItems.filter(i => i.animationName === value);
                        if (sameNameAnimationItems.length === 1) {
                            const [animationItem] = sameNameAnimationItems;
                            const skin = getSkin(animationItem);
                            if (skin) {
                                const img = sceneobjects.SpineUtils.getSpineSkinItemImage(skin);
                                if (img) {
                                    await img.preload();
                                }
                                iconControl.setIcon(img);
                                return;
                            }
                        }
                        iconControl.setIcon(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_SPINE));
                    }
                    async createViewer() {
                        const viewer = new controls.viewers.TreeViewer("SpineAnimationNamePropertyType");
                        viewer.setLabelProvider(new AnimationLabelProvider());
                        viewer.setStyledLabelProvider(new AnimationStyledCellLabelProvider());
                        viewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider(() => new AnimationCellRenderer()));
                        viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        viewer.setCellSize(64, true);
                        return viewer;
                    }
                    valueToString(viewer, value) {
                        return value.animationName;
                    }
                    async loadViewerInput(viewer) {
                        const input = await sceneobjects.SpineUtils.getSpineAnimationItems();
                        viewer.setInput(input);
                    }
                }
                sceneobjects.SpineAnimationNamePropertyType = SpineAnimationNamePropertyType;
                class AnimationCellRenderer extends sceneobjects.SpineSkinCellRenderer {
                    renderCell(args) {
                        const skin = getSkin(args.obj);
                        if (skin) {
                            const args2 = args.clone();
                            args2.obj = skin;
                            super.renderCell(args2);
                        }
                    }
                    async preload(args) {
                        const skin = getSkin(args.obj);
                        if (skin) {
                            const args2 = args.clone();
                            args2.obj = skin;
                            return super.preload(args2);
                        }
                        return controls.PreloadResult.RESOURCES_LOADED;
                    }
                }
                class AnimationLabelProvider {
                    getLabel(obj) {
                        return obj.animationName + " - " + obj.spineAsset.getKey();
                    }
                }
                class AnimationStyledCellLabelProvider {
                    getStyledTexts(obj, dark) {
                        const theme = controls.Controls.getTheme();
                        return [
                            {
                                color: theme.viewerForeground,
                                text: obj.animationName
                            },
                            {
                                color: theme.viewerForeground + "90",
                                text: " - " + obj.spineAsset.getKey()
                            }
                        ];
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpineAnimationSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.SpineAnimartionSection", "Spine Animation", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/spine-animations-game-object-animations.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 3);
                        this.createPropertyFloatRow(comp, sceneobjects.SpineComponent.timeScale);
                        this.createPropertyFloatRow(comp, sceneobjects.SpineComponent.defaultMix);
                        {
                            // Mixes
                            this.createLock(comp, sceneobjects.SpineComponent.animationMixes);
                            this.createLabel(comp, "Mixes", scene.PhaserHelp("phaser:spine.AnimationStateData.setMixWith"));
                            const btn = this.createButton(comp, "Configure", () => {
                                const dlg = new sceneobjects.SpineGameObjectPreviewDialog(this.getSelectionFirstElement());
                                dlg.create();
                            });
                            this.addUpdater(() => {
                                const obj = this.getSelectionFirstElement();
                                const count = (obj.animationMixes || []).length;
                                btn.textContent = `${count} mix${count === 1 ? "" : "es"}`;
                            });
                        }
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.SpineObject;
                    }
                    canEditNumber(n) {
                        return n == 1;
                    }
                }
                sceneobjects.SpineAnimationSection = SpineAnimationSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class SpineAssetPackCellRendererExtension extends phasereditor2d.pack.ui.AssetPackViewerExtension {
                    acceptObject(obj) {
                        return obj instanceof phasereditor2d.pack.core.SpineSkinItem
                            || obj instanceof phasereditor2d.pack.core.SpineAnimationItem;
                    }
                    getCellRenderer(obj) {
                        if (obj instanceof phasereditor2d.pack.core.SpineSkinItem) {
                            return new sceneobjects.SpineSkinCellRenderer();
                        }
                        return new controls.viewers.IconImageCellRenderer(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_SPINE));
                    }
                    getLabel(obj) {
                        if (obj instanceof phasereditor2d.pack.core.SpineSkinItem) {
                            return obj.skinName;
                        }
                        return obj.animationName;
                    }
                }
                sceneobjects.SpineAssetPackCellRendererExtension = SpineAssetPackCellRendererExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpineAssetPreviewSection extends colibri.ui.ide.properties.BaseManyImagePreviewSection {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.SpineAssetPreviewSection";
                    constructor(page) {
                        super(page, SpineAssetPreviewSection.ID, "Spine Preview", true, false);
                    }
                    hasMenu() {
                        return true;
                    }
                    createMenu(menu) {
                        super.createMenu(menu);
                        phasereditor2d.ide.IDEPlugin.getInstance().createHelpMenuItem(menu, "scene-editor/spine-animations-assets-preview.html");
                    }
                    async getViewerInput() {
                        return this.getSelection().flatMap(obj => obj.getGuessSkinItems());
                    }
                    prepareViewer(viewer) {
                        viewer.setLabelProvider(new ui.blocks.SceneEditorBlocksLabelProvider());
                        viewer.setCellRendererProvider(new ui.blocks.SceneEditorBlocksCellRendererProvider());
                        viewer.setCellSize(128, true);
                    }
                    canEdit(obj, n) {
                        return obj instanceof phasereditor2d.pack.core.SpineAssetPackItem;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.SpineAssetPreviewSection = SpineAssetPreviewSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpineBoundsProviderSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.SpineBoundsProviderSection", "Spine Bounds Provider", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/spine-animations-game-object-bounds.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 3);
                        this.createPropertyEnumRow(comp, sceneobjects.SpineComponent.bpType);
                        const btn1 = this.createPropertyEnumRow(comp, sceneobjects.SpineComponent.bpSkin, false);
                        const btn2 = this.createPropertyEnumRow(comp, sceneobjects.SpineComponent.bpAnimation, false);
                        const btn3 = this.createPropertyFloatRow(comp, sceneobjects.SpineComponent.bpTimeStep, false);
                        this.addUpdater(() => {
                            let enable = false;
                            const typeProp = sceneobjects.SpineComponent.bpType;
                            const unlockedObjs = this.getSelection()
                                .filter(obj => obj.getEditorSupport().isUnlockedProperty(typeProp));
                            if (unlockedObjs.length !== this.getSelection().length) {
                                return;
                            }
                            for (const obj of this.getSelection()) {
                                const type = typeProp.getValue(obj);
                                if (type === sceneobjects.BoundsProviderType.SKINS_AND_ANIMATION_TYPE) {
                                    enable = true;
                                    break;
                                }
                            }
                            btn1.disabled = !enable;
                            btn2.disabled = !enable;
                            btn3.disabled = !enable;
                        });
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.SpineObject;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.SpineBoundsProviderSection = SpineBoundsProviderSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_94) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene_94.core.code;
                class SpineCodeDOMBuilder extends sceneobjects.GameObjectCodeDOMBuilder {
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("spine", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        call.argLiteral(obj.dataKey);
                        call.argLiteral(obj.atlasKey);
                        if (obj.bpType !== sceneobjects.SpineComponent.bpType.defValue) {
                            const expr = SpineCodeDOMBuilder.generateNewBoundsProviderExpression(obj, args.unit);
                            call.arg(expr);
                        }
                        return call;
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const obj = args.obj;
                        const objES = obj.getEditorSupport();
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        call.arg(`${args.sceneExpr}.spine`);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        // The dataKey and atlasKey can't be overriden in instances
                        // so it uses those defined in the prefab class
                        // call.argLiteral(dataKey);
                        // call.argLiteral(atlasKey);
                        if (objES.isUnlockedProperty(sceneobjects.SpineComponent.bpType)) {
                            const expr = SpineCodeDOMBuilder.generateNewBoundsProviderExpression(obj, args.unit);
                            call.arg(expr);
                        }
                    }
                    static generateNewBoundsProviderExpression(obj, unit) {
                        if (obj.bpType === sceneobjects.BoundsProviderType.SETUP_TYPE) {
                            unit.addImport("SetupPoseBoundsProvider", "@esotericsoftware/spine-phaser", false);
                            const cls = this.spineClassName(obj, "SetupPoseBoundsProvider");
                            return `new ${cls}()`;
                        }
                        unit.addImport("SkinsAndAnimationBoundsProvider", "@esotericsoftware/spine-phaser", false);
                        const cls = this.spineClassName(obj, "SkinsAndAnimationBoundsProvider");
                        const animation = JSON.stringify(obj.bpAnimation);
                        let skins = [];
                        if (obj.bpSkin === sceneobjects.BoundsProviderSkin.CURRENT_SKIN) {
                            if (obj.skeleton.skin) {
                                skins = [obj.skeleton.skin.name];
                            }
                        }
                        else {
                            skins = obj.skeleton.data.skins.map(skin => skin.name);
                        }
                        if (obj.bpTimeStep == 0.05) {
                            return `new ${cls}(${animation}, ${JSON.stringify(skins)})`;
                        }
                        return `new ${cls}(${animation}, ${JSON.stringify(skins)}, ${obj.bpTimeStep})`;
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const obj = args.prefabObj;
                        const objES = obj.getEditorSupport();
                        args.importTypes.push("Phaser.Scene");
                        args.unit.addImport("SpinePlugin", "@esotericsoftware/spine-phaser", false);
                        args.unit.addImport("SpineGameObjectBoundsProvider", "@esotericsoftware/spine-phaser", false);
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("plugin", SpineCodeDOMBuilder.spineClassName(obj, "SpinePlugin"));
                        ctr.arg("x", "number");
                        ctr.arg("y", "number");
                        // you can't override the dataKey and atlasKey of a spine game object
                        // ctr.arg("dataKey", "string");
                        // ctr.arg("atlasKey", "string");
                        ctr.arg("boundsProvider", SpineCodeDOMBuilder.spineClassName(obj, "SpineGameObjectBoundsProvider"), true);
                    }
                    static spineClassName(obj, cls) {
                        const scene = obj.getEditorSupport().getScene();
                        if (scene.isESModule()) {
                            return cls;
                        }
                        return "spine." + cls;
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        const obj = args.prefabObj;
                        const objES = obj.getEditorSupport();
                        const call = args.superMethodCallCodeDOM;
                        call.arg("plugin");
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        if (!objES.isPrefabInstance()) {
                            // hey, this is a prefab variant
                            // the dataKey and atlasKey are set in the super prefab
                            call.argLiteral(sceneobjects.SpineComponent.dataKey.getValue(obj));
                            call.argLiteral(sceneobjects.SpineComponent.atlasKey.getValue(obj));
                        }
                        const expr = SpineCodeDOMBuilder.generateNewBoundsProviderExpression(obj, args.unit);
                        if (objES.isUnlockedProperty(sceneobjects.SpineComponent.bpType)) {
                            call.arg(`boundsProvider ?? ${expr}`);
                        }
                        else {
                            call.arg("boundsProvider");
                        }
                    }
                }
                sceneobjects.SpineCodeDOMBuilder = SpineCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_94.ui || (scene_94.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_95) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                let BoundsProviderType;
                (function (BoundsProviderType) {
                    BoundsProviderType[BoundsProviderType["SETUP_TYPE"] = 0] = "SETUP_TYPE";
                    BoundsProviderType[BoundsProviderType["SKINS_AND_ANIMATION_TYPE"] = 1] = "SKINS_AND_ANIMATION_TYPE";
                })(BoundsProviderType = sceneobjects.BoundsProviderType || (sceneobjects.BoundsProviderType = {}));
                let BoundsProviderSkin;
                (function (BoundsProviderSkin) {
                    BoundsProviderSkin[BoundsProviderSkin["ALL_SKINS"] = 0] = "ALL_SKINS";
                    BoundsProviderSkin[BoundsProviderSkin["CURRENT_SKIN"] = 1] = "CURRENT_SKIN";
                })(BoundsProviderSkin = sceneobjects.BoundsProviderSkin || (sceneobjects.BoundsProviderSkin = {}));
                class SpineObject extends spine.SpineGameObject {
                    static DEFAULT_BP_TIME_STEP = 0.05;
                    _editorSupport;
                    dataKey;
                    atlasKey;
                    bpType;
                    bpSkin;
                    bpAnimation;
                    bpTimeStep;
                    animationMixes;
                    constructor(scene, x, y, dataKey, atlasKey) {
                        super(scene, scene.spine, x, y, dataKey, atlasKey);
                        this.dataKey = dataKey;
                        this.atlasKey = atlasKey;
                        this.bpType = BoundsProviderType.SETUP_TYPE;
                        this.bpSkin = BoundsProviderSkin.CURRENT_SKIN;
                        this.bpAnimation = null;
                        this.bpTimeStep = SpineObject.DEFAULT_BP_TIME_STEP;
                        this._editorSupport = new sceneobjects.SpineEditorSupport(this, scene);
                    }
                    get timeScale() {
                        return this.animationState.timeScale;
                    }
                    set timeScale(timeScale) {
                        this.animationState.timeScale = timeScale;
                    }
                    get defaultMix() {
                        return this.animationStateData.defaultMix;
                    }
                    set defaultMix(defaultMix) {
                        this.animationStateData.defaultMix = defaultMix;
                    }
                    updateBoundsProvider() {
                        if (this.bpType === BoundsProviderType.SETUP_TYPE) {
                            this.boundsProvider = new spine.SetupPoseBoundsProvider();
                            this.updateSize();
                        }
                        else {
                            try {
                                let skins = [];
                                if (this.bpSkin === BoundsProviderSkin.CURRENT_SKIN) {
                                    if (this.skeleton.skin) {
                                        skins = [this.skeleton.skin.name];
                                    }
                                }
                                else {
                                    skins = this.skeleton.data.skins.map(s => s.name);
                                }
                                // TODO: missing timeStep argument
                                this.boundsProvider = new spine.SkinsAndAnimationBoundsProvider(this.bpAnimation, skins, this.bpTimeStep);
                                this.updateSize();
                            }
                            catch (e) {
                                console.error(e);
                                alert(e.message);
                            }
                        }
                        this.setInteractive();
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.SpineObject = SpineObject;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_95.ui || (scene_95.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./SpineObject.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                const BoundsProviderTypeLabels = {
                    [sceneobjects.BoundsProviderType.SETUP_TYPE]: "SETUP_POSE",
                    [sceneobjects.BoundsProviderType.SKINS_AND_ANIMATION_TYPE]: "SKINS_AND_ANIMATION"
                };
                const BoundsProviderSkinLabels = {
                    [sceneobjects.BoundsProviderSkin.ALL_SKINS]: "ALL",
                    [sceneobjects.BoundsProviderSkin.CURRENT_SKIN]: "CURRENT"
                };
                class SpineComponent extends sceneobjects.Component {
                    static dataKey = sceneobjects.SimpleProperty("dataKey", undefined, "Data Key", "The skeleton data key");
                    static atlasKey = sceneobjects.SimpleProperty("atlasKey", undefined, "Atlas Key", "The skeleton data key");
                    static skin = {
                        name: "skinName",
                        defValue: null,
                        label: "Skin",
                        tooltip: "Skeleton's current skin.",
                        getEnumValues: obj => [...obj.skeleton.data.skins.map(s => s.name), null],
                        getValueLabel: val => val ?? "NULL",
                        getValue: (obj) => {
                            return obj.skeleton.skin?.name || null;
                        },
                        setValue: function (obj, value) {
                            try {
                                if (value) {
                                    obj.skeleton.setSkinByName(value);
                                }
                                else {
                                    obj.skeleton.setSkin(null);
                                }
                                obj.skeleton.setToSetupPose();
                                obj.updateBoundsProvider();
                            }
                            catch (e) {
                                obj.skeleton.setSkin(null);
                            }
                        },
                    };
                    // animations
                    static animationMixes = sceneobjects.SimpleProperty("animationMixes", undefined, "Animation Mixes", "The animation mixes");
                    static defaultMix = sceneobjects.SimpleProperty({
                        name: "defaultMix", codeName: "animationStateData.defaultMix",
                    }, 0, "Default Mix", "phaser:spine.AnimationStateData.defaultMix", false, undefined, 1, 0);
                    static timeScale = sceneobjects.SimpleProperty({ name: "timeScale", codeName: "animationState.timeScale" }, 1, "Time Scale", "phaser:spine.AnimationState.timeScale", false, undefined, 0.01, 0);
                    // bounds provider
                    static bpType = {
                        name: "bpType",
                        label: "BP Type",
                        tooltip: "The type of the bounds provider.",
                        defValue: sceneobjects.BoundsProviderType.SETUP_TYPE,
                        values: [sceneobjects.BoundsProviderType.SETUP_TYPE, sceneobjects.BoundsProviderType.SKINS_AND_ANIMATION_TYPE],
                        getValue: obj => obj.bpType,
                        setValue: (obj, val) => {
                            obj.bpType = val;
                            obj.updateBoundsProvider();
                        },
                        getValueLabel: val => BoundsProviderTypeLabels[val]
                    };
                    static bpSkin = {
                        name: "bpSkin",
                        label: "BP Skin",
                        tooltip: "phaser:spine.SkinsAndAnimationBoundsProvider(skins)",
                        defValue: sceneobjects.BoundsProviderSkin.CURRENT_SKIN,
                        values: [sceneobjects.BoundsProviderSkin.CURRENT_SKIN, sceneobjects.BoundsProviderSkin.ALL_SKINS],
                        getValue: obj => obj.bpSkin,
                        setValue: (obj, val) => {
                            obj.bpSkin = val;
                            obj.updateBoundsProvider();
                        },
                        getValueLabel: val => BoundsProviderSkinLabels[val]
                    };
                    static bpAnimation = {
                        name: "bpAnimation",
                        label: "BP Animation",
                        tooltip: "phaser:spine.SkinsAndAnimationBoundsProvider(animation)",
                        defValue: null,
                        getEnumValues: obj => [...obj.skeleton.data.animations.map(a => a.name), null],
                        getValue: obj => obj.bpAnimation,
                        setValue: (obj, val) => {
                            obj.bpAnimation = val;
                            obj.updateBoundsProvider();
                        },
                        getValueLabel: val => val ? val.toString() : "NULL"
                    };
                    static bpTimeStep = sceneobjects.SimpleProperty("bpTimeStep", sceneobjects.SpineObject.DEFAULT_BP_TIME_STEP, "BP Time Step", "phaser:spine.SkinsAndAnimationBoundsProvider(timeStep)", false, (obj) => {
                        obj.updateBoundsProvider();
                    }, 0.01, 0);
                    constructor(obj) {
                        super(obj, [
                            SpineComponent.dataKey,
                            SpineComponent.atlasKey,
                            SpineComponent.skin,
                            SpineComponent.bpType,
                            SpineComponent.bpSkin,
                            SpineComponent.bpAnimation,
                            SpineComponent.bpTimeStep,
                            SpineComponent.animationMixes,
                            SpineComponent.defaultMix,
                            SpineComponent.timeScale
                        ]);
                    }
                    readJSON(ser) {
                        super.readJSON(ser);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        // skin
                        this.buildSetObjectPropertyCodeDOM([SpineComponent.skin], args2 => {
                            const dom = new code.MethodCallCodeDOM("skeleton.setSkinByName", args.objectVarName);
                            dom.argLiteral(args2.value);
                            args.statements.push(dom);
                        });
                        // bounds provider
                        const obj = this.getObject();
                        const objES = this.getEditorSupport();
                        if (objES.isNestedPrefabInstance()) {
                            if (objES.isUnlockedProperty(SpineComponent.bpType)) {
                                const newBoundsProviderExpr = sceneobjects.SpineCodeDOMBuilder.generateNewBoundsProviderExpression(this.getObject(), args.unit);
                                const propDom = new code.AssignPropertyCodeDOM("boundsProvider", args.objectVarName);
                                propDom.value(newBoundsProviderExpr);
                                const updateSizeDom = new code.MethodCallCodeDOM("updateSize", args.objectVarName);
                                args.statements.push(propDom, updateSizeDom);
                            }
                        }
                        // simple properties
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, SpineComponent.timeScale, SpineComponent.defaultMix);
                        // mixes
                        if (objES.isUnlockedProperty(SpineComponent.animationMixes)) {
                            if (objES.isPrefabInstance()) {
                                const dom = new code.AssignPropertyCodeDOM("animationStateData.animationToMixTime", args.objectVarName);
                                dom.value("{}");
                                args.statements.push(dom);
                            }
                            const mixes = obj.animationMixes || [];
                            for (const mix of mixes) {
                                const dom = new code.MethodCallCodeDOM("setMix", `${args.objectVarName}.animationStateData`);
                                dom.argLiteral(mix[0]);
                                dom.argLiteral(mix[1]);
                                dom.argFloat(mix[2]);
                                args.statements.push(dom);
                            }
                        }
                    }
                }
                sceneobjects.SpineComponent = SpineComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class SpineConfigWizard extends controls.dialogs.WizardDialog {
                    _finder;
                    _spineDataPage;
                    _spineAtlasPage;
                    _spineSkinPage;
                    _initSpineDataAsset;
                    _finishCallback;
                    _cancelCallback;
                    constructor(finder, spineDataAsset) {
                        super();
                        this._finder = finder;
                        this._initSpineDataAsset = spineDataAsset;
                        this.setSize(undefined, 500, true);
                    }
                    create() {
                        if (this._initSpineDataAsset) {
                            this._spineAtlasPage = new SpineAtlasPage();
                            this._spineSkinPage = new SpineSkinPage();
                            this.addPages(this._spineAtlasPage, this._spineSkinPage);
                        }
                        else {
                            this._spineDataPage = new SpineDataPage();
                            this._spineAtlasPage = new SpineAtlasPage();
                            this._spineSkinPage = new SpineSkinPage();
                            this.addPages(this._spineDataPage, this._spineAtlasPage, this._spineSkinPage);
                        }
                        super.create();
                        this.setTitle("Spine Object Configuration");
                    }
                    setFinishCallback(cb) {
                        this._finishCallback = cb;
                    }
                    setCancelCallback(cb) {
                        this._cancelCallback = cb;
                    }
                    finishButtonPressed() {
                        this._finishCallback();
                    }
                    cancelButtonPressed() {
                        this._cancelCallback();
                    }
                    getSpineDataAssets() {
                        return this._finder.getAssets(item => item instanceof phasereditor2d.pack.core.SpineAssetPackItem);
                    }
                    getSpineAtlasAssets() {
                        return this._finder.getAssets(item => item instanceof phasereditor2d.pack.core.SpineAtlasAssetPackItem);
                    }
                    getSelection() {
                        return {
                            dataAsset: this._initSpineDataAsset || this._spineDataPage.getSpineDataAsset(),
                            atlasAsset: this._spineAtlasPage.getSpineAtlasAsset(),
                            skinName: this._spineSkinPage.getSkinName()
                        };
                    }
                }
                sceneobjects.SpineConfigWizard = SpineConfigWizard;
                class SpineDataPage extends controls.dialogs.WizardPage {
                    _viewer;
                    _spineDataAsset;
                    constructor() {
                        super("Spine Data", "Select the JSON or Binary Spine data file.");
                    }
                    getSpineDataAsset() {
                        return this._spineDataAsset;
                    }
                    createElements(parent) {
                        this._viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.SpineDataPage");
                        this._viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        this._viewer.setLabelProvider(new controls.viewers.LabelProvider((spineAsset) => {
                            return spineAsset.getKey();
                        }));
                        this._viewer.setCellRendererProvider(controls.viewers.EmptyCellRendererProvider.withIcon(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_SPINE)));
                        this._viewer.setInput(this.getWizard().getSpineDataAssets());
                        const filteredViewer = new controls.viewers.FilteredViewerInElement(this._viewer, false);
                        parent.appendChild(filteredViewer.getElement());
                        this._viewer.eventSelectionChanged.addListener(sel => {
                            this._spineDataAsset = this._viewer.getSelectionFirstElement();
                            this.getWizard().updateWizardButtons();
                        });
                        this.updateUI();
                    }
                    updateUI() {
                        if (this._spineDataAsset) {
                            this._viewer.setSelection([this._spineDataAsset]);
                            this._viewer.reveal(this._spineDataAsset);
                        }
                        this.getWizard().updateWizardButtons();
                    }
                    canFinish() {
                        return this.canGoNext();
                    }
                    canGoNext() {
                        return this._spineDataAsset !== undefined && this._spineDataAsset !== null;
                    }
                    getWizard() {
                        return super.getWizard();
                    }
                }
                class SpineAtlasPage extends controls.dialogs.WizardPage {
                    _viewer;
                    _spineAtlasAsset;
                    constructor() {
                        super("Spine Atlas", "Select the Spine Atlas file.");
                    }
                    getSpineAtlasAsset() {
                        return this._spineAtlasAsset;
                    }
                    createElements(parent) {
                        this._viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.SpineAtlasPage");
                        this._viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        this._viewer.setLabelProvider(new controls.viewers.LabelProvider((atlasAsset) => {
                            return atlasAsset.getKey();
                        }));
                        this._viewer.setCellRendererProvider(new phasereditor2d.pack.ui.viewers.AssetPackCellRendererProvider("tree"));
                        this._viewer.setInput(this.getWizard().getSpineAtlasAssets());
                        const filteredViewer = new controls.viewers.FilteredViewerInElement(this._viewer, false);
                        parent.appendChild(filteredViewer.getElement());
                        this._viewer.eventSelectionChanged.addListener(sel => {
                            this._spineAtlasAsset = this._viewer.getSelectionFirstElement();
                            this.getWizard().updateWizardButtons();
                        });
                        setTimeout(() => {
                            this._viewer.repaint();
                        }, 100);
                        this.updateUI();
                    }
                    updateUI() {
                        if (this._spineAtlasAsset) {
                            this._viewer.setSelection([this._spineAtlasAsset]);
                            this._viewer.reveal(this._spineAtlasAsset);
                        }
                        this.getWizard().updateWizardButtons();
                    }
                    canFinish() {
                        return this.canGoNext();
                    }
                    canGoNext() {
                        return this._spineAtlasAsset !== undefined && this._spineAtlasAsset !== null;
                    }
                    getWizard() {
                        return super.getWizard();
                    }
                }
                class SpineSkinPage extends controls.dialogs.WizardPage {
                    _viewer;
                    _skinName;
                    constructor() {
                        super("Skin", "Select the skin.");
                    }
                    getSkinName() {
                        return this._skinName;
                    }
                    createElements(parent) {
                        try {
                            this._viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.SpineSkinPage");
                            this._viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                            this._viewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider());
                            this._viewer.setLabelProvider(new controls.viewers.LabelProvider((skin) => {
                                return skin ? skin : "NULL";
                            }));
                            const { dataAsset, atlasAsset } = this.getWizard().getSelection();
                            const skeletonData = dataAsset.buildSkeleton(atlasAsset);
                            const skins = skeletonData ? [...skeletonData.skins.map(s => s.name), null] : [];
                            this._viewer.setInput(skins);
                            const filteredViewer = new controls.viewers.FilteredViewerInElement(this._viewer, false);
                            parent.appendChild(filteredViewer.getElement());
                            this._viewer.eventSelectionChanged.addListener(sel => {
                                this._skinName = this._viewer.getSelectionFirstElement();
                                this.getWizard().updateWizardButtons();
                            });
                            setTimeout(() => {
                                this._viewer.repaint();
                            }, 100);
                            this.updateUI();
                        }
                        catch (e) {
                            alert(e.message);
                        }
                    }
                    updateUI() {
                        if (this._skinName) {
                            this._viewer.setSelection([this._skinName]);
                            this._viewer.reveal(this._skinName);
                        }
                        this.getWizard().updateWizardButtons();
                    }
                    canFinish() {
                        return this.canGoNext();
                    }
                    canGoNext() {
                        return this._skinName !== undefined;
                    }
                    getWizard() {
                        return super.getWizard();
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_96) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpineEditorSupport extends sceneobjects.GameObjectEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.SpineExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.SpineComponent(obj), new sceneobjects.TransformComponent(obj), new sceneobjects.ArcadeComponent(obj, false));
                    }
                    setInteractive() {
                        this.getObject().setInteractive();
                    }
                    computeContentHash() {
                        return this.computeContentHashWithProperties(this.getObject(), sceneobjects.SpineComponent.atlasKey, sceneobjects.SpineComponent.dataKey, sceneobjects.SpineComponent.skin);
                    }
                    getCellRenderer() {
                        return new sceneobjects.SpineObjectCellRenderer();
                    }
                    setUnlockedProperty(property, unlock) {
                        super.setUnlockedProperty(property, unlock);
                        if (property === sceneobjects.SpineComponent.bpType) {
                            super.setUnlockedProperty(sceneobjects.SpineComponent.bpSkin, unlock);
                            super.setUnlockedProperty(sceneobjects.SpineComponent.bpAnimation, unlock);
                            super.setUnlockedProperty(sceneobjects.SpineComponent.bpTimeStep, unlock);
                        }
                    }
                }
                sceneobjects.SpineEditorSupport = SpineEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_96.ui || (scene_96.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_97) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpineExtension extends sceneobjects.SceneGameObjectExtension {
                    static _instance;
                    static getInstance() {
                        if (!this._instance) {
                            this._instance = new SpineExtension();
                        }
                        return this._instance;
                    }
                    constructor() {
                        super({
                            typeName: "SpineGameObject",
                            phaserTypeName: "SpineGameObject",
                            phaserTypeThirdPartyLib: "spine",
                            phaserTypeThirdPartyLibModule: "@esotericsoftware/spine-phaser",
                            category: scene_97.SCENE_OBJECT_SPINE_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_SPINE)
                        });
                    }
                    async collectExtraDataForCreateDefaultObject(editor) {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        const promise = new Promise((resolve, reject) => {
                            const dlg = new sceneobjects.SpineConfigWizard(finder);
                            dlg.setFinishCallback(async () => {
                                const { dataAsset, atlasAsset, skinName } = dlg.getSelection();
                                const scene = editor.getScene();
                                for (const asset of [dataAsset, atlasAsset]) {
                                    const updater = scene_97.ScenePlugin.getInstance().getLoaderUpdaterForAsset(asset);
                                    await updater.updateLoader(scene, asset);
                                }
                                const result = {
                                    data: { dataAsset, atlasAsset, skinName }
                                };
                                resolve(result);
                            });
                            dlg.setCancelCallback(() => {
                                const result = {
                                    abort: true
                                };
                                resolve(result);
                            });
                            dlg.create();
                        });
                        return promise;
                    }
                    adaptDataAfterTypeConversion(serializer, originalObject, extraData) {
                        if (extraData && extraData.dataAsset) {
                            serializer.write("dataKey", extraData.dataAsset.getKey());
                            serializer.write("atlasKey", extraData.atlasAsset.getKey());
                            serializer.write("skinName", extraData.skinName);
                        }
                    }
                    acceptsDropData(data) {
                        return data instanceof phasereditor2d.pack.core.SpineAssetPackItem || data instanceof phasereditor2d.pack.core.SpineSkinItem;
                    }
                    createDefaultSceneObject(args) {
                        const { dataAsset, atlasAsset, skinName } = args.extraData;
                        const obj = new sceneobjects.SpineObject(args.scene, args.x, args.y, dataAsset.getKey(), atlasAsset.getKey());
                        sceneobjects.SpineComponent.skin.setValue(obj, skinName);
                        return [obj];
                    }
                    async createSceneObjectWithAsset(args) {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        if (args.asset instanceof phasereditor2d.pack.core.SpineSkinItem) {
                            const { spineAsset, spineAtlasAsset, skinName } = args.asset;
                            const obj = await this.newSpineObject(args, spineAsset, spineAtlasAsset, skinName);
                            return obj;
                        }
                        const asset = args.asset;
                        return new Promise((resolve, reject) => {
                            const dlg = new sceneobjects.SpineConfigWizard(finder, asset);
                            dlg.setFinishCallback(async () => {
                                const { dataAsset, atlasAsset, skinName } = dlg.getSelection();
                                const obj = await this.newSpineObject(args, dataAsset, atlasAsset, skinName);
                                resolve(obj);
                            });
                            dlg.setCancelCallback(() => {
                                resolve(undefined);
                            });
                            dlg.create();
                        });
                    }
                    async newSpineObject(args, dataAsset, atlasAsset, skinName) {
                        for (const asset of [dataAsset, atlasAsset]) {
                            const updater = scene_97.ScenePlugin.getInstance().getLoaderUpdaterForAsset(asset);
                            await updater.updateLoader(args.scene, asset);
                        }
                        const obj = new sceneobjects.SpineObject(args.scene, args.x, args.y, dataAsset.getKey(), atlasAsset.getKey());
                        const objES = obj.getEditorSupport();
                        if (skinName && skinName !== "default") {
                            objES.setLabel(skinName);
                        }
                        else {
                            objES.setLabel(dataAsset.getKey());
                        }
                        // select a skin
                        sceneobjects.SpineComponent.skin.setValue(obj, skinName);
                        // select bounds provider
                        if (obj.skeleton.skin) {
                            obj.bpType = sceneobjects.BoundsProviderType.SKINS_AND_ANIMATION_TYPE;
                            obj.bpSkin = sceneobjects.BoundsProviderSkin.CURRENT_SKIN;
                        }
                        else if (obj.skeleton.data.defaultSkin) {
                            obj.bpType = sceneobjects.BoundsProviderType.SETUP_TYPE;
                        }
                        else {
                            obj.bpType = sceneobjects.BoundsProviderType.SKINS_AND_ANIMATION_TYPE;
                            obj.bpAnimation = null;
                            obj.bpSkin = sceneobjects.BoundsProviderSkin.ALL_SKINS;
                        }
                        obj.updateBoundsProvider();
                        return obj;
                    }
                    createGameObjectWithData(args) {
                        const objData = args.data;
                        const serializer = args.scene.getMaker().getSerializer(objData);
                        const dataKey = serializer.read("dataKey");
                        const atlasKey = serializer.read("atlasKey");
                        const obj = new sceneobjects.SpineObject(args.scene, 0, 0, dataKey, atlasKey);
                        obj.getEditorSupport().readJSON(objData);
                        return obj;
                    }
                    async getAssetsFromObjectData(args) {
                        const dataKey = args.serializer.read("dataKey");
                        const atlasKey = args.serializer.read("atlasKey");
                        const dataAsset = args.finder.findAssetPackItem(dataKey);
                        const atlasAsset = args.finder.findAssetPackItem(atlasKey);
                        // Maybe it contains FX objects depending on textures
                        const childrenAssets = await sceneobjects.ContainerExtension.getAssetsFromNestedData(args);
                        return [dataAsset, atlasAsset, ...childrenAssets];
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.SpineCodeDOMBuilder();
                    }
                    createInitObjectDataFromChild(childData) {
                        const data = super.createInitObjectDataFromChild(childData);
                        data["dataKey"] = childData["dataKey"];
                        data["atlasKey"] = childData["atlasKey"];
                        return data;
                    }
                }
                sceneobjects.SpineExtension = SpineExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_97.ui || (scene_97.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui_1) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class SpineGameObjectPreviewDialog extends controls.dialogs.Dialog {
                    _leftArea;
                    _rightArea;
                    _previewManager;
                    _currentTrack = 0;
                    _trackAnimationMap = new Map();
                    _trackBtn;
                    _animBtn;
                    _currentLoop = true;
                    _spineObject;
                    _animationMixes;
                    _mixesParent;
                    _defaultMix;
                    _timeScale;
                    _isUnlockedDefaultMix;
                    _isUnlockedTimeScale;
                    _isUnlockedMixes;
                    constructor(spineObject) {
                        super();
                        this.setSize(window.innerWidth * 0.75, window.innerHeight * 0.75);
                        this._spineObject = spineObject;
                        this._animationMixes = [...(spineObject.animationMixes || [])];
                        this._defaultMix = spineObject.defaultMix;
                        this._timeScale = spineObject.timeScale;
                        const objES = spineObject.getEditorSupport();
                        this._isUnlockedTimeScale = objES.isUnlockedProperty(sceneobjects.SpineComponent.timeScale);
                        this._isUnlockedDefaultMix = objES.isUnlockedProperty(sceneobjects.SpineComponent.defaultMix);
                        this._isUnlockedMixes = objES.isUnlockedProperty(sceneobjects.SpineComponent.animationMixes);
                    }
                    createDialogArea() {
                        this.createLeftArea();
                        this.createRightArea();
                        const clientArea = document.createElement("div");
                        clientArea.classList.add("DialogClientArea");
                        const style = clientArea.style;
                        style.display = "grid";
                        style.gridTemplateColumns = "1fr 2fr";
                        style.gridTemplateRows = "1fr";
                        style.width = "100%";
                        style.height = "100%";
                        style.minHeight = "0";
                        clientArea.appendChild(this._leftArea);
                        clientArea.appendChild(this._rightArea);
                        this.getElement().appendChild(clientArea);
                    }
                    createRightArea() {
                        this._rightArea = document.createElement("div");
                        const style = this._rightArea.style;
                        style.width = "100%";
                        style.height = "100%";
                        this._previewManager = new sceneobjects.SpinePreviewManager(this._rightArea);
                    }
                    createLeftArea() {
                        this._leftArea = document.createElement("div");
                        const style = this._leftArea.style;
                        style.width = "100%";
                        style.display = "grid";
                        style.gridTemplateColumns = "auto 1fr";
                        style.gridAutoRows = "min-content";
                        style.alignItems = "center";
                        style.gap = "5px";
                        style.overflow = "auto";
                        style.padding = "5px";
                        style.boxSizing = "border-box";
                    }
                    createUI() {
                        const parentElement = this._leftArea;
                        const builder = new controls.properties.FormBuilder();
                        this.createPreviewSettings(builder, parentElement);
                        this.createObjectSettings(parentElement, builder);
                        // game canvas
                        setTimeout(() => {
                            const cache = this._spineObject.getEditorSupport().getScene().getPackCache();
                            const spineAsset = cache.findAsset(this._spineObject.dataKey);
                            const spineAtlasAsset = cache.findAsset(this._spineObject.atlasKey);
                            const skinName = this._spineObject.skeleton.skin?.name;
                            const animationMixes = this._spineObject.animationMixes;
                            this._previewManager.createGame({
                                spineAsset,
                                spineAtlasAsset,
                                skinName,
                                animationMixes,
                            });
                        }, 10);
                    }
                    createPreviewSettings(builder, parentElement) {
                        builder.createSeparator(parentElement, "PREVIEW", "1 / span 2");
                        // Track
                        {
                            builder.createLabel(parentElement, "Preview Track");
                            this._trackBtn = builder.createMenuButton(parentElement, "Track 0", () => [0, 1, 2, 3, 4, 5].map(t => ({
                                name: this.getTrackName(t),
                                value: t
                            })), track => {
                                this._currentTrack = track;
                                this._trackBtn.textContent = this.getTrackName(track);
                            });
                        }
                        // Animations
                        {
                            builder.createLabel(parentElement, "Preview Animation");
                            let animations = this._spineObject.skeleton.data.animations.map(a => a.name);
                            animations = [null, ...animations,];
                            this._animBtn = builder.createMenuButton(parentElement, "EMPTY", () => animations.map(a => ({
                                name: a ?? "EMPTY",
                                value: a
                            })), animation => {
                                this._animBtn.textContent = animation ?? "EMPTY";
                                if (animation) {
                                    this._trackAnimationMap.set(this._currentTrack, animation);
                                }
                                else {
                                    this._trackAnimationMap.delete(this._currentTrack);
                                }
                                this._previewManager.setAnimation(this._currentTrack, animation, this._currentLoop);
                                this._trackBtn.textContent = this.getTrackName(this._currentTrack);
                            });
                        }
                        // Loop
                        {
                            const check = builder.createCheckbox(parentElement, builder.createLabel(parentElement, "Preview Loop"));
                            check.addEventListener("change", () => {
                                this._currentLoop = check.checked;
                            });
                            check.checked = true;
                        }
                        // Events
                        {
                            const check = builder.createCheckbox(parentElement, builder.createLabel(parentElement, "Preview Events"));
                            check.addEventListener("change", () => {
                                this._previewManager.setDisplayEvents(check.checked);
                            });
                            check.checked = true;
                        }
                    }
                    createObjectSettings(parentElement, builder) {
                        builder.createSeparator(parentElement, "Object Settings", "1 / span 2");
                        // Time Scale
                        {
                            builder.createLabel(parentElement, "Time Scale");
                            const text = builder.createText(parentElement);
                            text.value = this._timeScale.toString();
                            text.addEventListener("change", () => {
                                const n = Number(text.value);
                                if (Number.isNaN(n)) {
                                    text.value = this._timeScale.toString();
                                    return;
                                }
                                this._timeScale = n;
                                this._previewManager.setTimeScale(n);
                            });
                            text.readOnly = !this._isUnlockedTimeScale;
                        }
                        // Mix Time
                        {
                            builder.createLabel(parentElement, "Default Mix");
                            const text = builder.createText(parentElement);
                            // TODO
                            text.value = this._defaultMix.toString();
                            text.addEventListener("change", () => {
                                const n = Number(text.value);
                                if (Number.isNaN(n)) {
                                    text.value = this._defaultMix.toString();
                                    return;
                                }
                                this._defaultMix = n;
                                this._previewManager.setMixTime(n);
                            });
                            text.readOnly = !this._isUnlockedDefaultMix;
                        }
                        // Mixes
                        {
                            this._mixesParent = document.createElement("div");
                            this._mixesParent.style.display = "grid";
                            this._mixesParent.style.gap = "5px";
                            this._mixesParent.style.gridTemplateColumns = this._isUnlockedMixes ? "1fr 1fr 3em auto" : "1fr 1fr 3em";
                            this._mixesParent.style.gridColumn = "1 / span 2";
                            this._mixesParent.style.alignItems = "center";
                            parentElement.appendChild(this._mixesParent);
                            for (const mix of this._animationMixes) {
                                if (this._isUnlockedMixes) {
                                    this.createMixEditRow(builder, mix);
                                }
                                else {
                                    builder.createText(this._mixesParent, true).value = mix[0];
                                    builder.createText(this._mixesParent, true).value = mix[1];
                                    builder.createText(this._mixesParent, true).value = mix[2].toString();
                                }
                            }
                            if (this._isUnlockedMixes) {
                                const addMixBtn = builder.createButton(parentElement, "Add Mix", () => {
                                    const animations = this._spineObject.skeleton.data.animations.map(a => a.name);
                                    const mix = [animations[0], animations[0], 0];
                                    this._animationMixes.push(mix);
                                    this.createMixEditRow(builder, mix);
                                });
                                addMixBtn.style.gridColumn = "1 / span 2";
                            }
                        }
                    }
                    createMixEditRow(builder, mix) {
                        const animations = this._spineObject.skeleton.data.animations.map(a => a.name);
                        const ui = {};
                        // From
                        ui.fromBtn = builder.createMenuButton(this._mixesParent, mix[0], () => animations.map(a => ({
                            name: a,
                            value: a
                        })), animation => {
                            ui.fromBtn.textContent = animation;
                            mix[0] = animation;
                            this.emitUpdateAnimationMixes();
                        });
                        // To
                        ui.toBtn = builder.createMenuButton(this._mixesParent, mix[1], () => animations.map(a => ({
                            name: a,
                            value: a
                        })), animation => {
                            ui.toBtn.textContent = animation;
                            mix[1] = animation;
                            this.emitUpdateAnimationMixes();
                        });
                        ui.durationText = builder.createText(this._mixesParent);
                        ui.durationText.addEventListener("change", () => {
                            const n = Number.parseFloat(ui.durationText.value);
                            if (Number.isNaN(n)) {
                                ui.durationText.value = mix[2].toString();
                            }
                            else {
                                mix[2] = n;
                            }
                            this.emitUpdateAnimationMixes();
                        });
                        ui.durationText.value = mix[2].toString();
                        // Del
                        const delControl = builder.createIcon(this._mixesParent, colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_DELETE), true);
                        delControl.getCanvas().addEventListener("click", () => {
                            if (!this._isUnlockedMixes) {
                                return;
                            }
                            this._animationMixes = this._animationMixes.filter(m => m !== mix);
                            this.emitUpdateAnimationMixes();
                            ui.fromBtn.remove();
                            ui.toBtn.remove();
                            ui.durationText.remove();
                            delControl.getCanvas().remove();
                        });
                        ui.fromBtn.disabled = ui.toBtn.disabled = ui.durationText.readOnly = !this._isUnlockedMixes;
                    }
                    emitUpdateAnimationMixes() {
                        this._previewManager.setAnimationMixes(this._animationMixes);
                    }
                    getTrackName(track) {
                        const animation = this._trackAnimationMap.has(track) ?
                            ` (${this._trackAnimationMap.get(track)})` : "";
                        const trackName = "Track " + track + animation;
                        return trackName;
                    }
                    create(hideParentDialog) {
                        super.create(hideParentDialog);
                        this.createUI();
                        this.setTitle("Spine Game Object Preview");
                        if (this._isUnlockedDefaultMix || this._isUnlockedMixes || this._isUnlockedTimeScale) {
                            this.addButton("Update", () => this.onUpdateButtonPressed());
                            this.addCancelButton();
                        }
                        else {
                            this.addCancelButton().textContent = "Close";
                        }
                        this.eventDialogClose.addListener(() => {
                            this._previewManager.dispose();
                        });
                    }
                    onUpdateButtonPressed() {
                        const newMixes = this._animationMixes.length === 0 ?
                            undefined : [...this._animationMixes];
                        const editor = this._spineObject.getEditorSupport().getScene().getEditor();
                        editor.getUndoManager().add(new UpdateOperation(this._spineObject, {
                            animationMixes: newMixes,
                            defaultMix: this._defaultMix,
                            timeScale: this._timeScale
                        }));
                        this.close();
                    }
                }
                sceneobjects.SpineGameObjectPreviewDialog = SpineGameObjectPreviewDialog;
                class UpdateOperation extends sceneobjects.SceneGameObjectOperation {
                    constructor(obj, value) {
                        super(obj.getEditorSupport().getScene().getEditor(), [obj], value);
                    }
                    getValue(obj) {
                        return {
                            defaultMix: obj.defaultMix,
                            animationMixes: obj.animationMixes,
                            timeScale: obj.timeScale
                        };
                    }
                    setValue(obj, value) {
                        obj.animationMixes = value.animationMixes;
                        obj.defaultMix = value.defaultMix;
                        obj.timeScale = value.timeScale;
                    }
                }
            })(sceneobjects = ui_1.sceneobjects || (ui_1.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_98) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpineLoaderUpdater extends sceneobjects.LoaderUpdaterExtension {
                    clearCache(scene) {
                        const spineAtlasCache = scene.cache.custom["esotericsoftware.spine.atlas.cache"];
                        const spineSkeletonCache = scene.cache.custom["esotericsoftware.spine.skeletonFile.cache"];
                        const caches = [
                            scene.cache.json,
                            scene.cache.binary,
                            spineAtlasCache,
                            spineSkeletonCache
                        ]
                            .filter(c => Boolean(c));
                        for (const cache of caches) {
                            const keys = cache.getKeys();
                            for (const key of keys) {
                                cache.remove(key);
                            }
                        }
                    }
                    acceptAsset(asset) {
                        return asset instanceof phasereditor2d.pack.core.SpineAssetPackItem
                            || asset instanceof phasereditor2d.pack.core.SpineAtlasAssetPackItem;
                    }
                    async updateLoader(scene, asset) {
                        const item = asset;
                        await item.preload();
                        item.addToPhaserCache(scene.game, scene.getPackCache());
                    }
                    async updateLoaderWithObjData(scene, data) {
                        const serializer = new scene_98.core.json.Serializer(data);
                        const type = serializer.getType();
                        if (type === sceneobjects.SpineExtension.getInstance().getTypeName()) {
                            const dataKey = serializer.read("dataKey");
                            const atlasKey = serializer.read("atlerKey");
                            const finder = scene.getMaker().getPackFinder();
                            for (const key of [dataKey, atlasKey]) {
                                if (key) {
                                    const asset = finder.findAssetPackItem(key);
                                    if (asset && this.acceptAsset(asset)) {
                                        await this.updateLoader(scene, asset);
                                    }
                                }
                            }
                        }
                    }
                }
                sceneobjects.SpineLoaderUpdater = SpineLoaderUpdater;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_98.ui || (scene_98.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class SpineObjectCellRenderer {
                    renderCell(args) {
                        const cache = scene.ScenePlugin.getInstance().getSpineThumbnailCache();
                        const skinItem = this.findSkinItem(args.obj);
                        if (!skinItem) {
                            return;
                        }
                        const image = cache.getContent(skinItem);
                        if (image) {
                            image.paint(args.canvasContext, args.x, args.y, args.w, args.h, args.center);
                        }
                    }
                    findSkinItem(obj) {
                        const packCache = obj.getEditorSupport().getScene().getPackCache();
                        const spineAsset = packCache.findAsset(obj.dataKey);
                        const spineAtlasAsset = packCache.findAsset(obj.atlasKey);
                        if (!spineAsset || !spineAtlasAsset) {
                            return null;
                        }
                        const skin = obj.skeleton.skin || obj.skeleton.data.defaultSkin;
                        if (!skin) {
                            return null;
                        }
                        const skinName = skin.name;
                        // const skinItem = spineAsset.getGuessSkinItems().find(s => s.skinName === skinName);
                        const skinItem = new phasereditor2d.pack.core.SpineSkinItem(spineAsset, spineAtlasAsset, skinName);
                        return skinItem;
                    }
                    cellHeight(args) {
                        return args.viewer.getCellSize();
                    }
                    preload(args) {
                        const cache = scene.ScenePlugin.getInstance().getSpineThumbnailCache();
                        const skinItem = this.findSkinItem(args.obj);
                        if (!skinItem) {
                            return controls.Controls.resolveResourceLoaded();
                        }
                        return cache.preload(skinItem);
                    }
                }
                sceneobjects.SpineObjectCellRenderer = SpineObjectCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class SpinePreviewDialog extends controls.dialogs.Dialog {
                    _leftArea;
                    _rightArea;
                    _previewManager;
                    _currentTrack = 0;
                    _trackAnimationMap = new Map();
                    _trackBtn;
                    _skinBtn;
                    _animBtn;
                    _spineAsset;
                    _spineAtlasAsset;
                    _skinName;
                    _currentLoop = true;
                    constructor(spineAsset, spineAtlasAsset, skinName) {
                        super();
                        this.setSize(window.innerWidth * 0.5, window.innerHeight * 0.5);
                        this._spineAsset = spineAsset;
                        this._spineAtlasAsset = spineAtlasAsset;
                        this._skinName = skinName;
                    }
                    createDialogArea() {
                        this.createLeftArea();
                        this.createRightArea();
                        const clientArea = document.createElement("div");
                        clientArea.classList.add("DialogClientArea");
                        const style = clientArea.style;
                        style.display = "grid";
                        style.gridTemplateColumns = "1fr 2fr";
                        style.gridTemplateRows = "1fr";
                        style.width = "100%";
                        style.height = "100%";
                        style.minHeight = "0";
                        clientArea.appendChild(this._leftArea);
                        clientArea.appendChild(this._rightArea);
                        this.getElement().appendChild(clientArea);
                    }
                    createRightArea() {
                        this._rightArea = document.createElement("div");
                        const style = this._rightArea.style;
                        style.width = "100%";
                        style.height = "100%";
                        this._previewManager = new sceneobjects.SpinePreviewManager(this._rightArea);
                    }
                    createLeftArea() {
                        this._leftArea = document.createElement("div");
                        const style = this._leftArea.style;
                        style.width = "100%";
                        style.display = "grid";
                        style.gridTemplateColumns = "auto 1fr";
                        style.gridAutoRows = "min-content";
                        style.alignItems = "center";
                        style.gap = "5px";
                        style.overflow = "auto";
                        style.padding = "5px";
                        style.boxSizing = "border-box";
                    }
                    createUI() {
                        if (!this._skinName) {
                            const skeleton = this._spineAsset.getGuessSkeleton();
                            this._skinName = skeleton.defaultSkin?.name;
                        }
                        const parentElement = this._leftArea;
                        const builder = new controls.properties.FormBuilder();
                        // Skins
                        {
                            builder.createLabel(parentElement, "Skin");
                            this._skinBtn = builder.createMenuButton(parentElement, this._skinName ?? "", () => this._spineAsset.getGuessSkinItems().map(s => ({
                                name: s.skinName,
                                value: s.skinName
                            })), skin => {
                                this._skinBtn.textContent = skin;
                                this._previewManager.setSkin(skin);
                            });
                            if (this._skinName) {
                                this._skinBtn.textContent = this._skinName;
                            }
                        }
                        // Track
                        {
                            builder.createLabel(parentElement, "Track");
                            this._trackBtn = builder.createMenuButton(parentElement, "Track 0", () => [0, 1, 2, 3, 4, 5].map(t => ({
                                name: this.getTrackName(t),
                                value: t
                            })), track => {
                                this._currentTrack = track;
                                this._trackBtn.textContent = this.getTrackName(track);
                            });
                        }
                        // Animations
                        {
                            builder.createLabel(parentElement, "Animation");
                            let animations = this._spineAsset.getGuessSkeleton().animations.map(a => a.name);
                            animations = [null, ...animations,];
                            this._animBtn = builder.createMenuButton(parentElement, "EMPTY", () => animations.map(a => ({
                                name: a ?? "EMPTY",
                                value: a
                            })), animation => {
                                this._animBtn.textContent = animation ?? "EMPTY";
                                if (animation) {
                                    this._trackAnimationMap.set(this._currentTrack, animation);
                                }
                                else {
                                    this._trackAnimationMap.delete(this._currentTrack);
                                }
                                this._previewManager.setAnimation(this._currentTrack, animation, this._currentLoop);
                                this._trackBtn.textContent = this.getTrackName(this._currentTrack);
                            });
                        }
                        // Loop
                        {
                            const check = builder.createCheckbox(parentElement, builder.createLabel(parentElement, "Loop"));
                            check.addEventListener("change", () => {
                                this._currentLoop = check.checked;
                            });
                            check.checked = true;
                        }
                        // Events
                        {
                            const check = builder.createCheckbox(parentElement, builder.createLabel(parentElement, "Events"));
                            check.addEventListener("change", () => {
                                this._previewManager.setDisplayEvents(check.checked);
                                localStorage.setItem("phasereditor2d.scene.ui.sceneobjects.SpinePreviewDialog.events", check.checked ? "1" : "0");
                            });
                            check.checked = (localStorage.getItem("phasereditor2d.scene.ui.sceneobjects.SpinePreviewDialog.events") || "1") === "1";
                        }
                        // Mix Time
                        {
                            builder.createLabel(parentElement, "Default Mix");
                            const text = builder.createText(parentElement);
                            text.value = localStorage.getItem("phasereditor2d.scene.ui.sceneobjects.SpinePreviewDialog.mixTime") ?? "0";
                            text.addEventListener("change", () => {
                                const n = Number(text.value);
                                this._previewManager.setMixTime(n);
                                localStorage.setItem("phasereditor2d.scene.ui.sceneobjects.SpinePreviewDialog.mixTime", n.toString());
                            });
                        }
                        // Time Scale
                        {
                            builder.createLabel(parentElement, "Time Scale");
                            const text = builder.createText(parentElement);
                            text.value = localStorage.getItem("phasereditor2d.scene.ui.sceneobjects.SpinePreviewDialog.timeScale") ?? "1";
                            text.addEventListener("change", () => {
                                const n = Number(text.value);
                                this._previewManager.setTimeScale(n);
                                localStorage.setItem("phasereditor2d.scene.ui.sceneobjects.SpinePreviewDialog.timeScale", n.toString());
                            });
                        }
                        // game canvas
                        setTimeout(() => {
                            this._previewManager.createGame({
                                spineAsset: this._spineAsset,
                                spineAtlasAsset: this._spineAtlasAsset,
                                skinName: this._skinName
                            });
                        }, 10);
                    }
                    getTrackName(track) {
                        const animation = this._trackAnimationMap.has(track) ?
                            ` (${this._trackAnimationMap.get(track)})` : "";
                        const trackName = "Track " + track + animation;
                        return trackName;
                    }
                    create(hideParentDialog) {
                        super.create(hideParentDialog);
                        this.createUI();
                        this.setTitle("Spine Preview");
                        this.addButton("Close", () => this.close());
                        this.eventDialogClose.addListener(() => {
                            this._previewManager.dispose();
                        });
                    }
                }
                sceneobjects.SpinePreviewDialog = SpinePreviewDialog;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpinePreviewManager {
                    _parent;
                    _game;
                    constructor(parent) {
                        this._parent = parent;
                    }
                    dispose() {
                        if (this._game) {
                            scene.ScenePlugin.getInstance().getCanvasManager().releaseCanvas(this._game.canvas);
                            this._game.destroy(true);
                        }
                    }
                    setAnimation(track, animationName, loop) {
                        this._game.events.emit("updateAnimation", track, animationName, loop);
                    }
                    setSkin(skinName) {
                        this._game.events.emit("updateSkinName", skinName);
                    }
                    setMixTime(mixTime) {
                        this._game.events.emit("updateMixTime", mixTime);
                    }
                    setTimeScale(timeScale) {
                        this._game.events.emit("updateTimeScale", timeScale);
                    }
                    setAnimationMixes(animationMixes) {
                        this._game.events.emit("updateAnimationMixes", animationMixes);
                    }
                    setDisplayEvents(displayEvents) {
                        this._game.events.emit("updateDisplayEvents", displayEvents);
                    }
                    createGame(data) {
                        const { width, height } = this._parent.getBoundingClientRect();
                        const canvas = scene.ScenePlugin.getInstance().getCanvasManager().takeCanvas();
                        canvas.style.visibility = "hidden";
                        this._game = new Phaser.Game({
                            type: scene.ScenePlugin.DEFAULT_EDITOR_CANVAS_CONTEXT,
                            width, height,
                            canvas,
                            parent: this._parent,
                            transparent: true,
                            fps: {
                                target: 30,
                            },
                            scale: {
                                mode: Phaser.Scale.ScaleModes.NONE,
                                resizeInterval: 10
                            },
                            plugins: {
                                scene: [
                                    { key: "spine.SpinePlugin", plugin: spine.SpinePlugin, mapping: "spine" }
                                ]
                            }
                        });
                        this._game.canvas.classList.add("SpinePreviewCanvas");
                        this._game.scene.add("PreviewScene", PreviewScene, true, data);
                        this._game.scene.add("EventScene", EventScene);
                        setTimeout(() => {
                            canvas.style.visibility = "visible";
                            this._game.scale.refresh();
                        }, 10);
                    }
                }
                sceneobjects.SpinePreviewManager = SpinePreviewManager;
                class PreviewScene extends Phaser.Scene {
                    _data;
                    _wheelListener;
                    init(data) {
                        this._data = data;
                    }
                    create() {
                        console.log("repaintSpine", this._data.spineAsset.getKey(), this._data.spineAtlasAsset.getKey());
                        const packCache = new phasereditor2d.pack.core.parsers.AssetPackCache();
                        this._data.spineAtlasAsset.addToPhaserCache(this.game, packCache);
                        this._data.spineAsset.addToPhaserCache(this.game, packCache);
                        const key = this._data.spineAsset.getKey();
                        const atlas = this._data.spineAtlasAsset.getKey();
                        const obj = new spine.SpineGameObject(this, this.spine, 400, 400, key, atlas);
                        this.add.existing(obj);
                        this.sys.updateList.add(obj);
                        obj.on("drag", (pointer, dragX, dragY) => {
                            obj.setPosition(dragX, dragY);
                        });
                        obj.boundsProvider = new spine.SkinsAndAnimationBoundsProvider(null, obj.skeleton.data.skins.map(s => s.name));
                        if (this._data.skinName) {
                            obj.skeleton.setSkinByName(this._data.skinName);
                        }
                        obj.updateSize();
                        if (this._data.animationMixes) {
                            for (const mix of this._data.animationMixes) {
                                const [from, to, duration] = mix;
                                obj.animationStateData.setMix(from, to, duration);
                            }
                        }
                        const w = 100000;
                        obj.setInteractive({
                            draggable: true,
                            hitArea: new Phaser.Geom.Rectangle(-w, -w, w * 2, w * 2),
                            hitAreaCallback: Phaser.Geom.Rectangle.Contains
                        });
                        const objWidth = obj.width;
                        const objHeight = obj.height;
                        const camera = this.cameras.main;
                        const gameWidth = camera.width;
                        const gameHeight = camera.height;
                        const fx = gameWidth / objWidth;
                        const fy = gameHeight / objHeight;
                        const z = Math.min(fx, fy);
                        const displayOriginX = objWidth * obj.originX;
                        const displayOriginY = objHeight * obj.originY;
                        const objCX = objWidth / 2;
                        const objCY = objHeight / 2;
                        const cx = gameWidth / 2 + displayOriginX - objCX;
                        const cy = gameHeight / 2 + displayOriginY - objCY;
                        obj.setPosition(cx, cy);
                        camera.zoom = z;
                        this.scene.launch("EventScene");
                        const eventScene = this.scene.get("EventScene");
                        obj.animationState.addListener(eventScene);
                        this._wheelListener = (e) => {
                            const deltaY = e.deltaY;
                            const scrollWidth = Math.abs(deltaY) * 2;
                            const screenWidth = camera.width;
                            const zoomDelta = scrollWidth / (screenWidth + scrollWidth);
                            const zoomFactor = (deltaY > 0 ? 1 - zoomDelta : 1 + zoomDelta);
                            camera.zoom *= zoomFactor;
                            camera.zoom = Math.min(100, Math.max(0.2, camera.zoom));
                        };
                        this.game.canvas.addEventListener("wheel", this._wheelListener);
                        this.game.events.on("updateAnimation", (track, animationName, loop) => {
                            if (animationName) {
                                obj.animationState.setAnimation(track, animationName, loop);
                            }
                            else {
                                obj.animationState.setEmptyAnimation(track);
                            }
                        });
                        this.game.events.on("updateSkinName", (skinName) => {
                            obj.skeleton.setSkinByName(skinName);
                            obj.skeleton.setToSetupPose();
                        });
                        this.game.events.on("updateMixTime", (mixTime) => {
                            obj.animationStateData.defaultMix = mixTime;
                        });
                        this.game.events.on("updateTimeScale", (timeScale) => {
                            obj.animationState.timeScale = timeScale;
                        });
                        this.game.events.on("updateAnimationMixes", (mixes) => {
                            obj.animationStateData.animationToMixTime = {};
                            for (const mix of mixes) {
                                const [from, to, duration] = mix;
                                obj.animationStateData.setMix(from, to, duration);
                            }
                        });
                        this.game.events.once(Phaser.Core.Events.DESTROY, () => this.removeListeners());
                    }
                    removeListeners() {
                        this.game.canvas.removeEventListener("wheel", this._wheelListener);
                    }
                }
                class EventScene extends Phaser.Scene {
                    _displayEvents = true;
                    create() {
                        this.game.events.on("updateDisplayEvents", (displayEvents) => {
                            this._displayEvents = displayEvents;
                        });
                    }
                    event(entry, event) {
                        if (!this._displayEvents) {
                            return;
                        }
                        const cam = this.cameras.main;
                        const text = this.add.text(20, cam.height, event.data.name, {
                            color: "#fff",
                            stroke: "#000",
                            strokeThickness: 2,
                            fontSize: Math.max(14, Math.floor(18 * cam.zoom)) + "px"
                        });
                        text.setOrigin(0, 1);
                        this.add.tween({
                            targets: text,
                            duration: 1000,
                            alpha: 0.2,
                            y: text.y - 100,
                            onComplete: () => {
                                text.destroy();
                            }
                        });
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpineSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.SpineSection", "Spine");
                    }
                    getSectionHelpPath() {
                        return "scene-editor/spine-animations-game-object-properties.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 3);
                        this.createPropertyStringRow(comp, sceneobjects.SpineComponent.dataKey, false, true);
                        this.createPropertyStringRow(comp, sceneobjects.SpineComponent.atlasKey, false, true);
                        this.createPropertyEnumRow(comp, sceneobjects.SpineComponent.skin);
                        this.createConfigureButton(comp);
                    }
                    createConfigureButton(comp) {
                        const elem = document.createElement("hr");
                        elem.style.gridColumn = "1 / span 3";
                        elem.style.width = "100%";
                        elem.style.opacity = "0.25";
                        comp.appendChild(elem);
                        {
                            // Configure
                            const btn = this.createButton(comp, "Configure", async () => {
                                const finder = new phasereditor2d.pack.core.PackFinder();
                                await finder.preload();
                                const dlg = new sceneobjects.SpineConfigWizard(finder);
                                dlg.setFinishCallback(async () => {
                                    const { dataAsset, atlasAsset, skinName } = dlg.getSelection();
                                    const editor = this.getEditor();
                                    editor.getUndoManager().add(new ConfigureObjectOperation(editor, dataAsset.getKey(), atlasAsset.getKey(), skinName));
                                });
                                dlg.create();
                            });
                            btn.style.gridColumn = "1 / span 3";
                            this.addUpdater(() => {
                                let disabled = false;
                                for (const obj of this.getSelection()) {
                                    if (obj.getEditorSupport().isPrefabInstance()) {
                                        disabled = true;
                                        break;
                                    }
                                }
                                btn.disabled = disabled;
                            });
                        }
                        {
                            // Preview
                            const btn = this.createButton(comp, "Preview", () => {
                                const dlg = new sceneobjects.SpineGameObjectPreviewDialog(this.getSelectionFirstElement());
                                dlg.create();
                            });
                            btn.style.gridColumn = "1 / span 3";
                        }
                    }
                    createMenu(menu) {
                        menu.addCommand(ui.editor.commands.CMD_SELECT_ALL_OBJECTS_SAME_SPINE_SKELETON);
                        menu.addCommand(ui.editor.commands.CMD_SELECT_ALL_OBJECTS_SAME_SPINE_SKIN);
                        super.createMenu(menu);
                    }
                    canEditAll(selection) {
                        const first = selection[0];
                        const { dataKey } = first;
                        for (const obj of selection) {
                            if (obj.dataKey !== dataKey) {
                                return false;
                            }
                        }
                        return true;
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.SpineObject;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.SpineSection = SpineSection;
                class ConfigureObjectOperation extends ui.editor.undo.ObjectSnapshotOperation {
                    dataKey;
                    atlasKey;
                    skinName;
                    constructor(editor, dataKey, atlasKey, skinName) {
                        super(editor, editor.getSelectedGameObjects());
                        this.dataKey = dataKey;
                        this.atlasKey = atlasKey;
                        this.skinName = skinName;
                    }
                    makeChangeSnapshot(input) {
                        const result = {
                            objects: []
                        };
                        for (const obj of input) {
                            const objData = {};
                            obj.getEditorSupport().writeJSON(objData);
                            objData[sceneobjects.SpineComponent.dataKey.name] = this.dataKey;
                            objData[sceneobjects.SpineComponent.atlasKey.name] = this.atlasKey;
                            objData[sceneobjects.SpineComponent.skin.name] = this.skinName;
                            const parentId = obj.getEditorSupport().getParentId();
                            result.objects.push({
                                objData,
                                parentId
                            });
                        }
                        return result;
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class SpineSkeletonDataSection extends controls.properties.PropertySection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.SpineSkeletonDataSection", "Spine Skeleton", false, false);
                    }
                    hasMenu() {
                        return true;
                    }
                    createMenu(menu) {
                        super.createMenu(menu);
                        phasereditor2d.ide.IDEPlugin.getInstance().createHelpMenuItem(menu, "scene-editor/spine-animations-assets-preview.html");
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        {
                            // key
                            this.createLabel(comp, "Skeleton Key");
                            const text = this.createText(comp, true);
                            this.addUpdater(() => {
                                text.value = this.getSpineAsset().getKey();
                            });
                        }
                        {
                            // atlas
                            this.createLabel(comp, "Atlas Key");
                            const text = this.createText(comp, true);
                            this.addUpdater(() => {
                                const asset = this.getSpineAsset();
                                const atlas = asset.guessAtlasAsset();
                                text.value = atlas ? atlas.getKey() : `Not found "${asset.getKey()}-atlas"`;
                            });
                        }
                        {
                            // preview animations
                            const btn = this.createButton(comp, "Preview Animations", async () => {
                                const asset = this.getSpineAsset();
                                const atlas = asset.guessAtlasAsset();
                                if (!atlas) {
                                    alert(`Cannot find an atlas file for this skeleton.`
                                        + `Please, add a "spineAtlas" file to the Asset Pack.`
                                        + `Use the key <code>${asset.getKey()}-atlas</code>.`);
                                    return;
                                }
                                await asset.preload();
                                await atlas.preload();
                                await atlas.preloadImages();
                                const dlg = new sceneobjects.SpinePreviewDialog(asset, atlas, this.getSkinName());
                                dlg.create();
                            });
                            btn.style.gridColumn = "1 / span 2";
                        }
                    }
                    getSpineAsset() {
                        const obj = this.getSelectionFirstElement();
                        if (obj instanceof phasereditor2d.pack.core.SpineAssetPackItem) {
                            return obj;
                        }
                        return obj.spineAsset;
                    }
                    getSkinName() {
                        const obj = this.getSelectionFirstElement();
                        if (obj instanceof phasereditor2d.pack.core.SpineSkinItem) {
                            return obj.skinName;
                        }
                        return null;
                    }
                    canEdit(obj, n) {
                        return obj instanceof phasereditor2d.pack.core.SpineAssetPackItem || obj instanceof phasereditor2d.pack.core.SpineSkinItem;
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.SpineSkeletonDataSection = SpineSkeletonDataSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpineSkinItemPreviewSection extends colibri.ui.ide.properties.BaseImagePreviewSection {
                    static ID = "phasereditor2d.scene.ui.sceneobjects.SpinePreviewSection";
                    constructor(page) {
                        super(page, SpineSkinItemPreviewSection.ID, "Spine Preview", true, false);
                    }
                    createMenu(menu) {
                        super.createMenu(menu);
                        phasereditor2d.ide.IDEPlugin.getInstance().createHelpMenuItem(menu, "scene-editor/spine-animations-assets-preview.html");
                    }
                    getSelectedImage() {
                        return scene.ScenePlugin.getInstance()
                            .getSpineThumbnailCache()
                            .getContent(this.getSelectionFirstElement());
                    }
                    canEdit(obj, n) {
                        return obj instanceof phasereditor2d.pack.core.SpineSkinItem;
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.SpineSkinItemPreviewSection = SpineSkinItemPreviewSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../userProperties/AbstractDialogPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class SpineSkinNamePropertyType extends sceneobjects.AbstractDialogPropertyType {
                    constructor() {
                        super({
                            id: "spine-skin-name",
                            name: "Spine Skin Name",
                            dialogTitle: "Select Skin",
                            hasCustomIcon: true
                        });
                    }
                    async createViewer() {
                        const viewer = new controls.viewers.TreeViewer("SpineSkinNamePropertyType");
                        viewer.setLabelProvider(new SkinLabelProvider());
                        viewer.setStyledLabelProvider(new SkinStyledCellLabelProvider());
                        viewer.setCellRendererProvider(new phasereditor2d.pack.ui.viewers.AssetPackCellRendererProvider("tree"));
                        viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        viewer.setCellSize(64, true);
                        return viewer;
                    }
                    valueToString(viewer, value) {
                        return value.skinName;
                    }
                    async loadViewerInput(viewer) {
                        const input = await sceneobjects.SpineUtils.getSpineSkinItems();
                        viewer.setInput(input);
                    }
                    async updateIcon(iconControl, value) {
                        const skinItems = await sceneobjects.SpineUtils.getSpineSkinItems();
                        const sameNameSkinItems = skinItems.filter(s => s.skinName === value);
                        if (sameNameSkinItems.length === 1) {
                            const [skinItem] = sameNameSkinItems;
                            const img = sceneobjects.SpineUtils.getSpineSkinItemImage(skinItem);
                            if (img) {
                                await img.preload();
                            }
                            iconControl.setIcon(img);
                        }
                        else {
                            iconControl.setIcon(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_SPINE));
                        }
                    }
                }
                sceneobjects.SpineSkinNamePropertyType = SpineSkinNamePropertyType;
                class SkinLabelProvider {
                    getLabel(obj) {
                        return obj.skinName + " - " + obj.spineAsset.getKey();
                    }
                }
                class SkinStyledCellLabelProvider {
                    getStyledTexts(obj, dark) {
                        const theme = controls.Controls.getTheme();
                        return [
                            {
                                color: theme.viewerForeground,
                                text: obj.skinName
                            },
                            {
                                color: theme.viewerForeground + "90",
                                text: " - " + obj.spineAsset.getKey()
                            }
                        ];
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpineUtils {
                    static getSpineSkinItemImage(skinItem) {
                        const img = scene.ScenePlugin.getInstance().getSpineThumbnailCache().getContent(skinItem);
                        return img;
                    }
                    static async getSpineSkinItems() {
                        const result = [];
                        const packs = await phasereditor2d.pack.core.AssetPackUtils.getAllPacks();
                        for (const thePack of packs) {
                            for (const item of thePack.getItems()) {
                                if (item instanceof phasereditor2d.pack.core.SpineAssetPackItem) {
                                    await item.preload();
                                    const skins = item.getGuessSkinItems();
                                    result.push(...skins);
                                }
                            }
                        }
                        return result;
                    }
                    static async getSpineAnimationItems() {
                        const result = [];
                        const packs = await phasereditor2d.pack.core.AssetPackUtils.getAllPacks();
                        for (const thePack of packs) {
                            for (const item of thePack.getItems()) {
                                if (item instanceof phasereditor2d.pack.core.SpineAssetPackItem) {
                                    await item.preload();
                                    const skins = item.getGuessAnimationItems();
                                    result.push(...skins);
                                }
                            }
                        }
                        return result;
                    }
                    static async getSpineEventItems() {
                        const result = [];
                        const packs = await phasereditor2d.pack.core.AssetPackUtils.getAllPacks();
                        for (const thePack of packs) {
                            for (const item of thePack.getItems()) {
                                if (item instanceof phasereditor2d.pack.core.SpineAssetPackItem) {
                                    await item.preload();
                                    const events = item.getGuessEventItems();
                                    result.push(...events);
                                }
                            }
                        }
                        return result;
                    }
                }
                sceneobjects.SpineUtils = SpineUtils;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class AnimationPreviewDialog extends controls.dialogs.Dialog {
                    _previewManager;
                    _animationAsset;
                    _config;
                    constructor(animationAsset, config) {
                        super();
                        const size = Math.min(window.innerWidth * 0.5, window.innerHeight * 0.5);
                        this.setSize(size, size);
                        this._animationAsset = animationAsset;
                        this._config = config;
                    }
                    createDialogArea() {
                        const clientArea = document.createElement("div");
                        clientArea.classList.add("DialogClientArea");
                        this.getElement().appendChild(clientArea);
                        this._previewManager = new sceneobjects.AnimationPreviewManager(clientArea);
                    }
                    createUI() {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        finder.preload().then(() => {
                            setTimeout(() => {
                                this._previewManager.createGame({
                                    animationAsset: this._animationAsset,
                                    config: this._config,
                                    finder
                                });
                            }, 10);
                        });
                    }
                    create(hideParentDialog) {
                        super.create(hideParentDialog);
                        this.createUI();
                        this.setTitle("Animation Preview");
                        this.addButton("Close", () => this.close());
                        this.addButton("Play", () => {
                            this._previewManager.play(false);
                        });
                        this.addButton("Play Repeat", () => {
                            this._previewManager.play(true);
                        });
                        this.eventDialogClose.addListener(() => {
                            this._previewManager.dispose();
                        });
                    }
                }
                sceneobjects.AnimationPreviewDialog = AnimationPreviewDialog;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AnimationPreviewManager {
                    _parent;
                    _game;
                    constructor(parent) {
                        this._parent = parent;
                    }
                    dispose() {
                        if (this._game) {
                            scene.ScenePlugin.getInstance().getCanvasManager().releaseCanvas(this._game.canvas);
                            this._game.destroy(false);
                        }
                    }
                    play(forceRepeat) {
                        this._game.events.emit("play", forceRepeat);
                    }
                    createGame(data) {
                        const { width, height } = this._parent.getBoundingClientRect();
                        const canvas = scene.ScenePlugin.getInstance().getCanvasManager().takeCanvas();
                        this._game = new Phaser.Game({
                            width, height: height - 5,
                            parent: this._parent,
                            canvas,
                            type: scene.ScenePlugin.DEFAULT_EDITOR_CANVAS_CONTEXT,
                            transparent: true,
                            pixelArt: true,
                            fps: {
                                target: 30,
                            },
                            scale: {
                                mode: Phaser.Scale.ScaleModes.NONE,
                                resizeInterval: 10
                            }
                        });
                        canvas.style.visibility = "hidden";
                        this._game.scene.add("PreviewScene", PreviewScene, true, data);
                        setTimeout(() => {
                            canvas.style.visibility = "visible";
                            this._game.scale.refresh();
                        }, 10);
                    }
                }
                sceneobjects.AnimationPreviewManager = AnimationPreviewManager;
                class PreviewScene extends Phaser.Scene {
                    _data;
                    _wheelListener;
                    init(data) {
                        this._data = data;
                    }
                    preload() {
                        const asset = this._data.animationAsset;
                        if (asset instanceof phasereditor2d.pack.core.AnimationsAssetPackItem) {
                            const cache = new phasereditor2d.pack.core.parsers.AssetPackCache();
                            for (const item of this._data.finder.getAssets()) {
                                item.addToPhaserCache(this.game, cache);
                            }
                            this.load.animation(asset.getKey(), asset.getAnimationsFile().getExternalUrl());
                        }
                        else {
                            const asset2 = asset;
                            const textureURL = asset2.getTextureFile().getExternalUrl();
                            const atlasURL = asset2.getAnimationsFile().getExternalUrl();
                            this.load.aseprite(asset2.getKey(), textureURL, atlasURL);
                        }
                    }
                    create() {
                        this.anims.createFromAseprite(this._data.animationAsset.getKey());
                        const obj = this.add.sprite(400, 400, null);
                        obj.play(this._data.config);
                        obj.on("drag", (pointer, dragX, dragY) => {
                            obj.setPosition(dragX, dragY);
                        });
                        const w = 100000;
                        obj.setInteractive({
                            draggable: true,
                            hitArea: new Phaser.Geom.Rectangle(-w, -w, w * 2, w * 2),
                            hitAreaCallback: Phaser.Geom.Rectangle.Contains
                        });
                        const camera = this.cameras.main;
                        const gameWidth = camera.width;
                        const gameHeight = camera.height;
                        const fx = gameWidth / obj.width;
                        const fy = gameHeight / obj.height;
                        const z = Math.min(fx, fy);
                        obj.setOrigin(0.5, 0.5);
                        obj.setPosition(this.game.scale.width / 2, this.game.scale.height / 2);
                        camera.zoom = z;
                        this._wheelListener = (e) => {
                            const deltaY = e.deltaY;
                            const scrollWidth = Math.abs(deltaY) * 2;
                            const screenWidth = camera.width;
                            const zoomDelta = scrollWidth / (screenWidth + scrollWidth);
                            const zoomFactor = (deltaY > 0 ? 1 - zoomDelta : 1 + zoomDelta);
                            camera.zoom *= zoomFactor;
                            camera.zoom = Math.min(100, Math.max(0.2, camera.zoom));
                        };
                        this.game.canvas.addEventListener("wheel", this._wheelListener);
                        this.game.events.on("play", (forceRepeat) => {
                            if (forceRepeat) {
                                obj.play({ ...this._data.config, repeat: -1 });
                            }
                            else {
                                obj.play(this._data.config);
                            }
                        });
                        this.game.events.once(Phaser.Core.Events.DESTROY, () => this.removeListeners());
                    }
                    removeListeners() {
                        this.game.canvas.removeEventListener("wheel", this._wheelListener);
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_99) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                let AnimationPlayMethod;
                (function (AnimationPlayMethod) {
                    AnimationPlayMethod[AnimationPlayMethod["NONE"] = 0] = "NONE";
                    AnimationPlayMethod[AnimationPlayMethod["PLAY"] = 1] = "PLAY";
                    AnimationPlayMethod[AnimationPlayMethod["PLAY_REVERSE"] = 2] = "PLAY_REVERSE";
                })(AnimationPlayMethod = sceneobjects.AnimationPlayMethod || (sceneobjects.AnimationPlayMethod = {}));
                class Sprite extends Phaser.GameObjects.Image {
                    _editorSupport;
                    animationPlayMethod = AnimationPlayMethod.NONE;
                    animationKey = "";
                    animationCustomConfig = false;
                    animationFrameRate = 24;
                    animationDelay = 0;
                    animationRepeat = 0;
                    animationRepeatDelay = 0;
                    animationYoyo = false;
                    animationShowBeforeDelay = false;
                    animationShowOnStart = false;
                    animationHideOnComplete = false;
                    animationStartFrame = 0;
                    animationTimeScale = 1;
                    constructor(scene, x, y, texture, frame) {
                        super(scene, x, y, texture, frame);
                        this._editorSupport = new sceneobjects.SpriteEditorSupport(this, scene);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.Sprite = Sprite;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_99.ui || (scene_99.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpriteAnimationConfigSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.SpriteAnimationConfigSection", "Animation Configuration");
                    }
                    getSectionHelpPath() {
                        return "scene-editor/animations-properties.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 3);
                        this.createNumberPropertyRow(comp, sceneobjects.SpriteComponent.animationFrameRate);
                        this.createNumberPropertyRow(comp, sceneobjects.SpriteComponent.animationDelay);
                        this.createNumberPropertyRow(comp, sceneobjects.SpriteComponent.animationRepeat);
                        this.createNumberPropertyRow(comp, sceneobjects.SpriteComponent.animationRepeatDelay);
                        this.createPropertyBoolean(comp, sceneobjects.SpriteComponent.animationYoyo)
                            .labelElement.style.gridColumn = "2 / span 2";
                        this.createPropertyBoolean(comp, sceneobjects.SpriteComponent.animationShowBeforeDelay)
                            .labelElement.style.gridColumn = "2 / span 2";
                        this.createPropertyBoolean(comp, sceneobjects.SpriteComponent.animationShowOnStart)
                            .labelElement.style.gridColumn = "2 / span 2";
                        this.createPropertyBoolean(comp, sceneobjects.SpriteComponent.animationHideOnComplete)
                            .labelElement.style.gridColumn = "2 / span 2";
                        this.createNumberPropertyRow(comp, sceneobjects.SpriteComponent.animationStartFrame);
                        this.createNumberPropertyRow(comp, sceneobjects.SpriteComponent.animationTimeScale);
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.Sprite && obj.animationCustomConfig;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.SpriteAnimationConfigSection = SpriteAnimationConfigSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class SpriteAnimationSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.SpriteAnimationSection", "Animation");
                    }
                    getSectionHelpPath() {
                        return "scene-editor/animations-properties.html";
                    }
                    createMenu(menu) {
                        menu.addAction({
                            text: "Open Animation File",
                            callback: async () => {
                                const sprite = this.getSelectionFirstElement();
                                const finder = new phasereditor2d.pack.core.PackFinder();
                                await finder.preload();
                                const anim = finder.findAnimationByKey(sprite.animationKey);
                                if (anim) {
                                    scene.ScenePlugin.getInstance().openAnimationInEditor(anim);
                                }
                            }
                        });
                        super.createMenu(menu);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 4);
                        comp.style.gridTemplateColumns = "auto auto 1fr auto";
                        {
                            const btn = this.createPropertyEnumRow(comp, sceneobjects.SpriteComponent.animationPlayMethod);
                            btn.style.gridColumn = "3 / span 2";
                        }
                        const animationToolbar = document.createElement("div");
                        animationToolbar.style.display = "flex";
                        animationToolbar.style.gap = "5px";
                        // play animation
                        this.createPropertyStringRow(comp, sceneobjects.SpriteComponent.animationKey);
                        comp.appendChild(animationToolbar);
                        this.createAnimationKeyDialogButton(comp, animationToolbar);
                        this.createPreviewDialogButton(animationToolbar);
                        // enable config
                        this.createPropertyBoolean(comp, sceneobjects.SpriteComponent.animationCustomConfig);
                    }
                    createPreviewDialogButton(animationToolbar) {
                        const btn = this.createButton(animationToolbar, phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_PLAY), async () => {
                            const sprite = this.getSelectionFirstElement();
                            const finder = new phasereditor2d.pack.core.PackFinder();
                            await finder.preload();
                            const anim = finder.findAnimationByKey(sprite.animationKey);
                            if (anim) {
                                const config = {
                                    key: anim.getKey()
                                };
                                if (sprite.animationCustomConfig) {
                                    sceneobjects.SpriteComponent.buildPlayConfig(sprite, config);
                                }
                                const dlg = new sceneobjects.AnimationPreviewDialog(anim.getParent(), config);
                                dlg.create();
                            }
                            else {
                                alert("Animation not found.");
                            }
                        });
                        btn.style.gridColumn = "1 / span 4";
                    }
                    createAnimationKeyDialogButton(comp, animationToolbar) {
                        const btnUI = this.createButtonDialog({
                            dialogTittle: "Select Animation Key",
                            createDialogViewer: async (revealValue) => {
                                const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.AnimationSection." + this.getId());
                                viewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider(e => new phasereditor2d.pack.ui.viewers.AnimationConfigCellRenderer()));
                                viewer.setLabelProvider(new phasereditor2d.pack.ui.viewers.AssetPackLabelProvider());
                                viewer.setTreeRenderer(new controls.viewers.TreeViewerRenderer(viewer));
                                viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                                const finder = new phasereditor2d.pack.core.PackFinder();
                                await finder.preload();
                                const animations = finder
                                    .getAssets(i => i instanceof phasereditor2d.pack.core.BaseAnimationsAssetPackItem)
                                    .flatMap((i) => i.getAnimations());
                                viewer.setInput(animations);
                                viewer.revealAndSelect(animations.find(a => a.getKey() === revealValue));
                                return viewer;
                            },
                            getValue: () => {
                                return this.getSelection()[0].animationKey || "";
                            },
                            onValueSelected: (value) => {
                                this.getEditor().getUndoManager().add(new sceneobjects.SimpleOperation(this.getEditor(), this.getSelection(), sceneobjects.SpriteComponent.animationKey, value));
                            },
                            dialogElementToString: (viewer, value) => {
                                return value.getKey();
                            },
                            updateIconCallback: async (iconControl, value) => {
                                const finder = new phasereditor2d.pack.core.PackFinder();
                                await finder.preload();
                                const image = sceneobjects.AnimationKeyPropertyType.getAnimationIcon(finder, value);
                                iconControl.setIcon(image);
                            },
                        });
                        animationToolbar.appendChild(btnUI.buttonElement);
                        this.addUpdater(() => {
                            btnUI.buttonElement.disabled = this.getSelection()
                                .filter(sprite => !sprite.getEditorSupport()
                                .isUnlockedProperty(sceneobjects.SpriteComponent.animationKey))
                                .length > 0;
                            btnUI.updateDialogButtonIcon();
                        });
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.Sprite;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.SpriteAnimationSection = SpriteAnimationSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpriteComponent extends sceneobjects.Component {
                    static animationPlayMethod = {
                        name: "animationPlayMethod",
                        label: "Action",
                        defValue: sceneobjects.AnimationPlayMethod.NONE,
                        getValue: obj => obj.animationPlayMethod,
                        setValue: (obj, val) => { obj.animationPlayMethod = val; },
                        getValueLabel: val => {
                            switch (val) {
                                case sceneobjects.AnimationPlayMethod.NONE:
                                    return "NONE";
                                case sceneobjects.AnimationPlayMethod.PLAY:
                                    return "PLAY";
                                case sceneobjects.AnimationPlayMethod.PLAY_REVERSE:
                                    return "PLAY_REVERSE";
                            }
                        },
                        values: [sceneobjects.AnimationPlayMethod.NONE, sceneobjects.AnimationPlayMethod.PLAY, sceneobjects.AnimationPlayMethod.PLAY_REVERSE],
                    };
                    static animationKey = sceneobjects.SimpleProperty({ name: "animationKey", codeName: "key" }, "", "Animation Key", "The animation key to auto-play.");
                    static animationCustomConfig = sceneobjects.SimpleProperty("animationCustomConfig", false, "Custom Config", "Set a new configuration?");
                    static animationFrameRate = sceneobjects.SimpleProperty({ name: "animationFrameRate", codeName: "frameRate" }, 24, "Frame Rate", "phaser:Phaser.Types.Animations.PlayAnimationConfig.frameRate");
                    static animationDelay = sceneobjects.SimpleProperty({ name: "animationDelay", codeName: "delay" }, 0, "Delay", "phaser:Phaser.Types.Animations.PlayAnimationConfig.delay");
                    static animationRepeat = sceneobjects.SimpleProperty({ name: "animationRepeat", codeName: "repeat" }, 0, "Repeat", "phaser:Phaser.Types.Animations.PlayAnimationConfig.repeat");
                    static animationRepeatDelay = sceneobjects.SimpleProperty({ name: "animationRepeatDelay", codeName: "repeatDelay" }, 0, "Repeat Delay", "phaser:Phaser.Types.Animations.PlayAnimationConfig.repeatDelay");
                    static animationYoyo = sceneobjects.SimpleProperty({ name: "animationYoyo", codeName: "yoyo" }, false, "Yoyo", "phaser:Phaser.Types.Animations.PlayAnimationConfig.yoyo");
                    static animationShowBeforeDelay = sceneobjects.SimpleProperty({ name: "animationShowBeforeDelay", codeName: "showBeforeDelay" }, false, "Show Before Delay", "phaser:Phaser.Types.Animations.PlayAnimationConfig.showBeforeDelay");
                    static animationShowOnStart = sceneobjects.SimpleProperty({ name: "animationShowOnStart", codeName: "showOnStart" }, false, "Show Before Start", "phaser:Phaser.Types.Animations.PlayAnimationConfig.showBeforeStart");
                    static animationHideOnComplete = sceneobjects.SimpleProperty({ name: "animationHideOnComplete", codeName: "hideOnComplete" }, false, "Hide On Complete", "phaser:Phaser.Types.Animations.PlayAnimationConfig.hideOnComplete");
                    static animationStartFrame = sceneobjects.SimpleProperty({ name: "animationStartFrame", codeName: "startFrame" }, 0, "Start Frame", "phaser:Phaser.Types.Animations.PlayAnimationConfig.startFrame");
                    static animationTimeScale = sceneobjects.SimpleProperty({ name: "animationTimeScale", codeName: "timeScale" }, 1, "Time Scale", "phaser:Phaser.Types.Animations.PlayAnimationConfig.timeScale");
                    constructor(obj) {
                        super(obj, [
                            SpriteComponent.animationPlayMethod,
                            SpriteComponent.animationKey,
                            SpriteComponent.animationCustomConfig,
                            SpriteComponent.animationFrameRate,
                            SpriteComponent.animationDelay,
                            SpriteComponent.animationRepeat,
                            SpriteComponent.animationRepeatDelay,
                            SpriteComponent.animationYoyo,
                            SpriteComponent.animationShowBeforeDelay,
                            SpriteComponent.animationShowOnStart,
                            SpriteComponent.animationHideOnComplete,
                            SpriteComponent.animationStartFrame,
                            SpriteComponent.animationTimeScale,
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM([SpriteComponent.animationPlayMethod], args2 => {
                            const sprite = args.obj;
                            const method = sprite.animationPlayMethod;
                            if (method === sceneobjects.AnimationPlayMethod.PLAY || method === sceneobjects.AnimationPlayMethod.PLAY_REVERSE) {
                                const name = method === sceneobjects.AnimationPlayMethod.PLAY ? "play" : "playReverse";
                                const call = new scene.core.code.MethodCallCodeDOM(name, args.objectVarName);
                                if (sprite.animationCustomConfig) {
                                    const config = {};
                                    SpriteComponent.buildPlayConfig(sprite, config);
                                    call.arg(JSON.stringify(config));
                                }
                                else {
                                    call.argLiteral(sprite.animationKey);
                                }
                                args.statements.push(call);
                            }
                        });
                    }
                    static buildPlayConfig(sprite, config) {
                        for (const prop of [
                            SpriteComponent.animationKey,
                            SpriteComponent.animationFrameRate,
                            SpriteComponent.animationDelay,
                            SpriteComponent.animationRepeat,
                            SpriteComponent.animationRepeatDelay,
                            SpriteComponent.animationYoyo,
                            SpriteComponent.animationShowBeforeDelay,
                            SpriteComponent.animationShowOnStart,
                            SpriteComponent.animationHideOnComplete,
                            SpriteComponent.animationStartFrame,
                            SpriteComponent.animationTimeScale
                        ]) {
                            colibri.core.json.write(config, prop.codeName, prop.getValue(sprite), prop.defValue);
                        }
                    }
                }
                sceneobjects.SpriteComponent = SpriteComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../image/BaseImageEditorSupport.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_100) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpriteEditorSupport extends sceneobjects.BaseImageEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.SpriteExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.SpriteComponent(obj));
                    }
                }
                sceneobjects.SpriteEditorSupport = SpriteEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_100.ui || (scene_100.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_101) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class SpriteExtension extends sceneobjects.BaseImageExtension {
                    static _instance = new SpriteExtension();
                    static getInstance() {
                        return this._instance;
                    }
                    constructor() {
                        super({
                            phaserTypeName: "Phaser.GameObjects.Sprite",
                            typeName: "Sprite",
                            category: scene_101.SCENE_OBJECT_IMAGE_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_SPRITE_TYPE)
                        });
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.BaseImageCodeDOMBuilder("sprite");
                    }
                    acceptsDropData(data) {
                        if (data instanceof phasereditor2d.pack.core.AnimationConfigInPackItem) {
                            return data.getFrames().length > 0;
                        }
                        return super.acceptsDropData(data);
                    }
                    createSceneObjectWithAsset(args) {
                        const animConfig = args.asset;
                        const frames = animConfig.getFrames();
                        const frame = frames[0];
                        const args2 = {
                            ...args,
                            asset: frame.getTextureFrame()
                        };
                        const sprite = super.createSceneObjectWithAsset(args2);
                        sprite.getEditorSupport().setLabel(animConfig.getKey());
                        sprite.animationPlayMethod = sceneobjects.AnimationPlayMethod.PLAY;
                        sprite.animationKey = animConfig.getKey();
                        return sprite;
                    }
                    newObject(scene, x, y, key, frame) {
                        return new sceneobjects.Sprite(scene, x, y, key || null, frame);
                    }
                }
                sceneobjects.SpriteExtension = SpriteExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_101.ui || (scene_101.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_102) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Text extends Phaser.GameObjects.Text {
                    _editorSupport;
                    constructor(scene, x, y, text, style) {
                        super(scene, x, y, text, style);
                        this._editorSupport = new sceneobjects.TextEditorSupport(this, scene);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.Text = Text;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_102.ui || (scene_102.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class TextCellRenderer {
                    constructor() {
                    }
                    renderCell(args) {
                        const obj = args.obj;
                        const canvas = obj.canvas;
                        controls.DefaultImage.paintImageElement(args.canvasContext, canvas, args.x, args.y, args.w, args.h, true);
                    }
                    cellHeight(args) {
                        return args.viewer.getCellSize();
                    }
                    async preload(args) {
                        return controls.PreloadResult.RESOURCES_LOADED;
                    }
                }
                sceneobjects.TextCellRenderer = TextCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class TextCodeDOMBuilder extends sceneobjects.GameObjectCodeDOMBuilder {
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("text", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        call.argLiteral("");
                        call.arg("{}");
                        return call;
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        const call = args.superMethodCallCodeDOM;
                        if (!args.prefabObj.getEditorSupport().isPrefabInstance()) {
                            call.argLiteral("");
                            call.arg("{}");
                        }
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                    }
                }
                sceneobjects.TextCodeDOMBuilder = TextCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                function fontValueComputer(fontSize, increment, min, max) {
                    if (!increment) {
                        return fontSize;
                    }
                    const match = fontSize.match(/^([\d.]+)([a-z]+)$/);
                    if (match) {
                        const originalSize = parseFloat(match[1]);
                        const unit = match[2];
                        const newSize = colibri.ui.controls.properties.clamp(originalSize + increment, min, max);
                        return `${newSize}${unit}`;
                    }
                    else {
                        return fontSize;
                    }
                }
                class TextComponent extends sceneobjects.Component {
                    static fixedWidth = {
                        name: "fixedWidth",
                        label: "Width",
                        tooltip: "phaser:Phaser.Types.GameObjects.Text.TextStyle.fixedWidth",
                        defValue: 0,
                        increment: 1,
                        incrementMin: 0,
                        getValue: obj => obj.style.fixedWidth,
                        setValue: (obj, value) => obj.setFixedSize(value, obj.style.fixedHeight)
                    };
                    static fixedHeight = {
                        name: "fixedHeight",
                        label: "Height",
                        tooltip: "phaser:Phaser.Types.GameObjects.Text.TextStyle.fixedHeight",
                        defValue: 0,
                        increment: 1,
                        incrementMin: 0,
                        getValue: obj => obj.style.fixedHeight,
                        setValue: (obj, value) => obj.setFixedSize(obj.style.fixedWidth, value)
                    };
                    static fixedSize = {
                        label: "Fixed Size",
                        tooltip: "phaser:Phaser.GameObjects.TextStyle.setFixedSize",
                        x: TextComponent.fixedWidth,
                        y: TextComponent.fixedHeight
                    };
                    static paddingLeft = {
                        name: "paddingLeft",
                        label: "Padding Left",
                        tooltip: "phaser:Phaser.Types.GameObjects.Text.TextPadding.left",
                        defValue: 0,
                        increment: 1,
                        incrementMin: 0,
                        getValue: obj => obj.padding["left"],
                        setValue: (obj, value) => { obj.padding["left"] = value; obj.updateText(); }
                    };
                    static paddingTop = {
                        name: "paddingTop",
                        label: "Padding Top",
                        tooltip: "phaser:Phaser.Types.GameObjects.Text.TextPadding.top",
                        defValue: 0,
                        increment: 1,
                        incrementMin: 0,
                        getValue: obj => obj.padding["top"],
                        setValue: (obj, value) => { obj.padding["top"] = value; obj.updateText(); }
                    };
                    static paddingRight = {
                        name: "paddingRight",
                        label: "Padding Right",
                        tooltip: "phaser:Phaser.Types.GameObjects.Text.TextPadding.right",
                        defValue: 0,
                        increment: 1,
                        incrementMin: 0,
                        getValue: obj => obj.padding["right"],
                        setValue: (obj, value) => { obj.padding["right"] = value; obj.updateText(); }
                    };
                    static paddingBottom = {
                        name: "paddingBottom",
                        label: "Padding Bottom",
                        tooltip: "phaser:Phaser.Types.GameObjects.Text.TextPadding.bottom",
                        defValue: 0,
                        increment: 1,
                        incrementMin: 0,
                        getValue: obj => obj.padding["bottom"],
                        setValue: (obj, value) => { obj.padding["bottom"] = value; obj.updateText(); }
                    };
                    static lineSpacing = {
                        name: "lineSpacing",
                        label: "Line Spacing",
                        tooltip: "phaser:Phaser.GameObjects.Text.lineSpacing",
                        defValue: 0,
                        increment: 0.5,
                        incrementMin: 0,
                        getValue: obj => obj.lineSpacing,
                        setValue: (obj, value) => obj.setLineSpacing(value)
                    };
                    static align = {
                        name: "align",
                        label: "Align",
                        tooltip: "phaser:Phaser.GameObjects.Text.setAlign",
                        defValue: "left",
                        getValue: obj => obj.style.align,
                        setValue: (obj, value) => obj.setAlign(value),
                        values: ["left", "right", "center", "justify"],
                        getValueLabel: value => value.toUpperCase()
                    };
                    static fontFamily = {
                        name: "fontFamily",
                        label: "Font Family",
                        tooltip: "phaser:Phaser.GameObjects.Text.setFontFamily",
                        defValue: "Courier",
                        getValue: obj => obj.style.fontFamily,
                        setValue: (obj, value) => obj.setFontFamily(value)
                    };
                    static fontSize = {
                        name: "fontSize",
                        label: "Font Size",
                        tooltip: "phaser:Phaser.GameObjects.Text.setFontSize",
                        defValue: "16px",
                        increment: 1,
                        incrementMin: 0,
                        incrementValueComputer: fontValueComputer,
                        getValue: obj => obj.style.fontSize,
                        setValue: (obj, value) => obj.setFontSize(value)
                    };
                    static fontStyle = {
                        name: "fontStyle",
                        label: "Font Style",
                        tooltip: "phaser:Phaser.GameObjects.Text.setFontStyle",
                        defValue: "",
                        getValue: obj => obj.style.fontStyle,
                        setValue: (obj, value) => obj.setFontStyle(value),
                        values: ["", "italic", "bold", "bold italic"],
                        getValueLabel: value => value === "" ? "(Default)" : value.toUpperCase()
                    };
                    static color = {
                        name: "color",
                        label: "Color",
                        tooltip: "phaser:Phaser.GameObjects.Text.setColor",
                        defValue: "#fff",
                        getValue: obj => obj.style.color,
                        setValue: (obj, value) => obj.setColor(value)
                    };
                    static stroke = {
                        name: "stroke",
                        label: "Stroke",
                        tooltip: "phaser:Phaser.GameObjects.Text.setStroke(color)",
                        defValue: "#fff",
                        getValue: obj => obj.style.stroke,
                        setValue: (obj, value) => obj.setStroke(value, obj.style.strokeThickness)
                    };
                    static strokeThickness = {
                        name: "strokeThickness",
                        label: "Stroke Thickness",
                        tooltip: "phaser:Phaser.GameObjects.Text.setStroke(thickness)",
                        defValue: 0,
                        increment: 1,
                        incrementMin: 0,
                        getValue: obj => obj.style.strokeThickness,
                        setValue: (obj, value) => obj.setStroke(obj.style.stroke, value)
                    };
                    static backgroundColor = {
                        name: "backgroundColor",
                        label: "Background Color",
                        tooltip: "phaser:Phaser.GameObjects.Text.setBackgroundColor",
                        defValue: null,
                        getValue: obj => obj.style.backgroundColor,
                        setValue: (obj, value) => obj.setBackgroundColor(value)
                    };
                    static shadowOffsetX = {
                        name: "shadow.offsetX",
                        label: "X",
                        tooltip: "phaser:Phaser.GameObjects.Text.setShadowOffset(x)",
                        defValue: 0,
                        increment: 1,
                        incrementMin: 0,
                        getValue: obj => obj.style.shadowOffsetX,
                        setValue: (obj, value) => obj.setShadowOffset(value, obj.style.shadowOffsetY)
                    };
                    static shadowOffsetY = {
                        name: "shadow.offsetY",
                        label: "Y",
                        tooltip: "phaser:Phaser.GameObjects.Text.setShadowOffset(y)",
                        defValue: 0,
                        increment: 1,
                        incrementMin: 0,
                        getValue: obj => obj.style.shadowOffsetY,
                        setValue: (obj, value) => obj.setShadowOffset(obj.style.shadowOffsetX, value)
                    };
                    static shadowOffset = {
                        label: "Shadow Offset",
                        tooltip: "phaser:Phaser.GameObjects.Text.setShadowOffset",
                        x: TextComponent.shadowOffsetX,
                        y: TextComponent.shadowOffsetY
                    };
                    static shadowStroke = {
                        name: "shadow.stroke",
                        label: "Stroke",
                        tooltip: "phaser:Phaser.GameObjects.Text.setShadowStroke",
                        defValue: false,
                        getValue: obj => obj.style.shadowStroke,
                        setValue: (obj, value) => obj.setShadowStroke(value)
                    };
                    static shadowFill = {
                        name: "shadow.fill",
                        label: "Fill",
                        tooltip: "phaser:Phaser.GameObjects.Text.setShadowFill",
                        defValue: false,
                        getValue: obj => obj.style.shadowFill,
                        setValue: (obj, value) => obj.setShadowFill(value)
                    };
                    static shadow = {
                        label: "Shadow",
                        tooltip: "Shadow stroke and fill.",
                        x: TextComponent.shadowStroke,
                        y: TextComponent.shadowFill
                    };
                    static shadowColor = {
                        name: "shadow.color",
                        label: "Shadow Color",
                        tooltip: "phaser:Phaser.GameObjects.Text.setShadowColor",
                        defValue: "#000",
                        getValue: obj => obj.style.shadowColor,
                        setValue: (obj, value) => obj.setShadowColor(value)
                    };
                    static shadowBlur = {
                        name: "shadow.blur",
                        label: "Shadow Blur",
                        tooltip: "phaser:Phaser.GameObjects.Text.setShadowBlur",
                        defValue: 0,
                        increment: 1,
                        incrementMin: 0,
                        getValue: obj => obj.style.shadowBlur,
                        setValue: (obj, value) => obj.setShadowBlur(value)
                    };
                    static baselineX = {
                        name: "baselineX",
                        label: "X",
                        tooltip: "phaser:Phaser.GameObjects.TextStyle.baselineX",
                        defValue: 1.2,
                        increment: 0.05,
                        incrementMin: 0,
                        getValue: obj => obj.style.baselineX,
                        setValue: (obj, value) => obj.style.baselineX = value
                    };
                    static baselineY = {
                        name: "baselineY",
                        label: "Y",
                        tooltip: "phaser:Phaser.GameObjects.TextStyle.baselineY",
                        defValue: 1.4,
                        increment: 0.05,
                        incrementMin: 0,
                        getValue: obj => obj.style.baselineY,
                        setValue: (obj, value) => obj.style.baselineY = value
                    };
                    static baseline = {
                        label: "Baseline",
                        tooltip: "Baseline",
                        x: TextComponent.baselineX,
                        y: TextComponent.baselineY
                    };
                    static maxLines = {
                        name: "maxLines",
                        label: "Max Lines",
                        tooltip: "phaser:Phaser.GameObjects.Text.setMaxLines",
                        defValue: 0,
                        increment: 1,
                        incrementMin: 0,
                        getValue: obj => obj.style.maxLines,
                        setValue: (obj, value) => obj.setMaxLines(value)
                    };
                    static wordWrapWidth = {
                        name: "wordWrapWidth",
                        label: "Word Wrap Width",
                        tooltip: "phaser:Phaser.GameObjects.Text.setWordWrapWidth(width)",
                        defValue: 0,
                        increment: 1,
                        incrementMin: 0,
                        getValue: obj => obj.style.wordWrapWidth || 0,
                        setValue: (obj, value) => {
                            try {
                                obj.setWordWrapWidth(value, obj.style.wordWrapUseAdvanced === true);
                            }
                            catch (e) {
                                alert(e.message);
                            }
                        }
                    };
                    static useAdvancedWrap = {
                        name: "wordWrapUseAdvanced",
                        label: "Advanced Wrap",
                        tooltip: "phaser:Phaser.GameObjects.Text.setWordWrapWidth(useAdvancedWrap)",
                        defValue: false,
                        getValue: obj => obj.style.wordWrapUseAdvanced || false,
                        setValue: (obj, value) => obj.setWordWrapWidth(obj.style.wordWrapWidth || 0, value)
                    };
                    constructor(obj) {
                        super(obj, [
                            TextComponent.fixedWidth,
                            TextComponent.fixedHeight,
                            TextComponent.paddingLeft,
                            TextComponent.paddingTop,
                            TextComponent.paddingRight,
                            TextComponent.paddingBottom,
                            TextComponent.lineSpacing,
                            TextComponent.align,
                            TextComponent.fontFamily,
                            TextComponent.fontSize,
                            TextComponent.fontStyle,
                            TextComponent.color,
                            TextComponent.stroke,
                            TextComponent.strokeThickness,
                            TextComponent.backgroundColor,
                            TextComponent.shadowOffsetX,
                            TextComponent.shadowOffsetY,
                            TextComponent.shadowStroke,
                            TextComponent.shadowFill,
                            TextComponent.shadowColor,
                            TextComponent.shadowBlur,
                            TextComponent.baselineX,
                            TextComponent.baselineY,
                            TextComponent.maxLines,
                            TextComponent.wordWrapWidth,
                            TextComponent.useAdvancedWrap
                        ]);
                    }
                    styleToJson() {
                        const comp = TextComponent;
                        const obj = this.getObject();
                        const support = obj.getEditorSupport();
                        const data = {};
                        const simpleProps = [
                            comp.align,
                            comp.backgroundColor,
                            comp.baselineX,
                            comp.baselineY,
                            comp.color,
                            comp.fixedWidth,
                            comp.fixedHeight,
                            comp.fontFamily,
                            comp.fontSize,
                            comp.fontStyle,
                            comp.maxLines,
                            comp.stroke,
                            comp.strokeThickness,
                            comp.shadowOffsetX,
                            comp.shadowOffsetY,
                            comp.shadowColor,
                            comp.shadowBlur,
                            comp.shadowStroke,
                            comp.shadowFill
                        ];
                        if (support.isPrefabInstance()) {
                            for (const prop of simpleProps) {
                                if (support.isUnlockedProperty(prop)) {
                                    data[prop.name] = prop.getValue(obj);
                                }
                            }
                        }
                        else {
                            for (const prop of simpleProps) {
                                const value = prop.getValue(obj);
                                if (value !== prop.defValue) {
                                    data[prop.name] = value;
                                }
                            }
                        }
                        return data;
                    }
                    stringify(style) {
                        let s = JSON.stringify(style);
                        s = s.replaceAll("\":\"", "\": \"")
                            .replaceAll("{\"", "{ \"")
                            .replaceAll("\"}", "\" }")
                            .replaceAll("\",", "\", ");
                        return s;
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const obj = this.getObject();
                        const support = obj.getEditorSupport();
                        {
                            // style
                            const style = this.styleToJson();
                            const literal = this.stringify(style);
                            if (literal !== "{}") {
                                const dom = new code.MethodCallCodeDOM("setStyle", args.objectVarName);
                                dom.arg(literal);
                                args.statements.push(dom);
                            }
                        }
                        {
                            // padding
                            const comp = TextComponent;
                            const padding = {};
                            const map = {
                                left: comp.paddingLeft,
                                top: comp.paddingTop,
                                right: comp.paddingRight,
                                bottom: comp.paddingBottom
                            };
                            if (support.isPrefabInstance()) {
                                // tslint:disable-next-line:forin
                                for (const key in map) {
                                    const prop = map[key];
                                    if (support.isUnlockedProperty(prop)) {
                                        padding[key] = prop.getValue(obj);
                                    }
                                }
                            }
                            else {
                                // tslint:disable-next-line:forin
                                for (const key in map) {
                                    const prop = map[key];
                                    const value = prop.getValue(obj);
                                    if (value !== prop.defValue) {
                                        padding[key] = value;
                                    }
                                }
                            }
                            const literal = JSON.stringify(padding);
                            if (literal !== "{}") {
                                const dom = new code.MethodCallCodeDOM("setPadding", args.objectVarName);
                                dom.arg(literal);
                                args.statements.push(dom);
                            }
                        }
                        {
                            // lineSpacing
                            this.buildSetObjectPropertyCodeDOM([TextComponent.lineSpacing], args2 => {
                                const dom = new code.MethodCallCodeDOM("setLineSpacing", args.objectVarName);
                                dom.arg(args2.value);
                                args.statements.push(dom);
                            });
                        }
                        {
                            // wordWrapWidth
                            const widthProp = TextComponent.wordWrapWidth;
                            const advancedProp = TextComponent.useAdvancedWrap;
                            const widthValue = widthProp.getValue(obj);
                            const advancedValue = advancedProp.getValue(obj);
                            const dom = new code.MethodCallCodeDOM("setWordWrapWidth", args.objectVarName);
                            let addDom = false;
                            if (support.isUnlockedProperty(widthProp) && widthValue !== 0) {
                                addDom = true;
                                dom.arg(widthValue);
                            }
                            else {
                                dom.arg(args.objectVarName + ".style.wordWrapWidth");
                            }
                            if (support.isUnlockedProperty(advancedProp) && advancedValue) {
                                addDom = true;
                                dom.arg(advancedValue);
                            }
                            if (addDom) {
                                args.statements.push(dom);
                            }
                        }
                    }
                }
                sceneobjects.TextComponent = TextComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_103) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TextEditorSupport extends sceneobjects.GameObjectEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.TextExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.TransformComponent(obj), new sceneobjects.OriginComponent(obj), new sceneobjects.FlipComponent(obj), new sceneobjects.VisibleComponent(obj), new sceneobjects.AlphaComponent(obj), new sceneobjects.TintComponent(obj), new sceneobjects.ArcadeComponent(obj, false), new sceneobjects.TextContentComponent(obj), new sceneobjects.TextComponent(obj));
                    }
                    computeContentHash() {
                        return this.computeContentHashWithComponent(this.getObject(), sceneobjects.FlipComponent, sceneobjects.TintComponent, sceneobjects.TextContentComponent, sceneobjects.TextComponent);
                    }
                    getCellRenderer() {
                        return new sceneobjects.TextCellRenderer();
                    }
                    setInteractive() {
                        this.getObject().setInteractive();
                    }
                    getPropertyDefaultValue(prop) {
                        if (prop === sceneobjects.OriginComponent.originX || prop === sceneobjects.OriginComponent.originY) {
                            return 0;
                        }
                        return super.getPropertyDefaultValue(prop);
                    }
                }
                sceneobjects.TextEditorSupport = TextEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_103.ui || (scene_103.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TextExtension extends sceneobjects.SceneGameObjectExtension {
                    static _instance = new TextExtension();
                    static getInstance() {
                        return this._instance;
                    }
                    constructor() {
                        super({
                            phaserTypeName: "Phaser.GameObjects.Text",
                            typeName: "Text",
                            category: scene.SCENE_OBJECT_TEXT_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_TEXT_TYPE)
                        });
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        return null;
                    }
                    createDefaultSceneObject(args) {
                        const text = new sceneobjects.Text(args.scene, args.x, args.y, "New text", {});
                        return [text];
                    }
                    createGameObjectWithData(args) {
                        const text = new sceneobjects.Text(args.scene, 0, 0, "", {});
                        text.getEditorSupport().readJSON(args.data);
                        return text;
                    }
                    async getAssetsFromObjectData(args) {
                        // Maybe it contains FX objects depending on textures
                        const childrenAssets = await sceneobjects.ContainerExtension.getAssetsFromNestedData(args);
                        return childrenAssets;
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.TextCodeDOMBuilder();
                    }
                }
                sceneobjects.TextExtension = TextExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TextSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor.scene.ui.sceneobjects.TextSection", "Text");
                    }
                    getSectionHelpPath() {
                        return "scene-editor/text-object.html#text-type-properties";
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        // fontFamily
                        this.createPropertyStringRow(comp, sceneobjects.TextComponent.fontFamily).text.style.gridColumn = "3 / span 4";
                        // fontSize
                        {
                            const row = this.createPropertyStringRow(comp, sceneobjects.TextComponent.fontSize, true, false, true);
                            row.text.style.gridColumn = "3 / span 4";
                        }
                        // fontStyle
                        this.createPropertyEnumRow(comp, sceneobjects.TextComponent.fontStyle).style.gridColumn = "3 / span 4";
                        // align
                        this.createPropertyEnumRow(comp, sceneobjects.TextComponent.align).style.gridColumn = "3 / span 4";
                        // color
                        this.createPropertyColorRow(comp, sceneobjects.TextComponent.color).element.style.gridColumn = "3 / span 4";
                        // stroke
                        this.createPropertyColorRow(comp, sceneobjects.TextComponent.stroke).element.style.gridColumn = "3 / span 4";
                        // strokeThickness
                        this.createPropertyFloatRow(comp, sceneobjects.TextComponent.strokeThickness).style.gridColumn = "3 / span 4";
                        // backgroundColor
                        this.createPropertyColorRow(comp, sceneobjects.TextComponent.backgroundColor).element.style.gridColumn = "3 / span 4";
                        // shadow
                        this.createPropertyBoolXYRow(comp, sceneobjects.TextComponent.shadow);
                        // shadowOffset
                        this.createPropertyXYRow(comp, sceneobjects.TextComponent.shadowOffset);
                        // shadowColor
                        this.createPropertyColorRow(comp, sceneobjects.TextComponent.shadowColor).element.style.gridColumn = "3 / span 4";
                        // shadowBlur
                        this.createPropertyFloatRow(comp, sceneobjects.TextComponent.shadowBlur).style.gridColumn = "3 / span 4";
                        // fixedSize
                        this.createPropertyXYRow(comp, sceneobjects.TextComponent.fixedSize);
                        {
                            // padding
                            const comp2 = this.createGridElement(comp);
                            comp2.style.gridTemplateColumns = "1fr 1fr 1fr 1fr";
                            comp2.style.gridColumn = "3 / span 4";
                            comp2.style.paddingBottom = "0px";
                            comp.appendChild(comp2);
                            this.createLabel(comp2, "Left").style.justifySelf = "center";
                            this.createLabel(comp2, "Top").style.justifySelf = "center";
                            this.createLabel(comp2, "Right").style.justifySelf = "center";
                            this.createLabel(comp2, "Bottom").style.justifySelf = "center";
                            this.createLock(comp, sceneobjects.TextComponent.paddingLeft, sceneobjects.TextComponent.paddingTop, sceneobjects.TextComponent.paddingRight, sceneobjects.TextComponent.paddingBottom);
                            this.createLabel(comp, "Padding", scene.PhaserHelp("phaser:Phaser.GameObjects.Text.setPadding"));
                            const comp3 = this.createGridElement(comp);
                            comp3.style.gridTemplateColumns = "1fr 1fr 1fr 1fr";
                            comp3.style.gridColumn = "3 / span 4";
                            comp.appendChild(comp3);
                            this.createFloatField(comp3, sceneobjects.TextComponent.paddingLeft);
                            this.createFloatField(comp3, sceneobjects.TextComponent.paddingTop);
                            this.createFloatField(comp3, sceneobjects.TextComponent.paddingRight);
                            this.createFloatField(comp3, sceneobjects.TextComponent.paddingBottom);
                        }
                        // baseline
                        this.createPropertyXYRow(comp, sceneobjects.TextComponent.baseline);
                        // lineSpacing
                        this.createPropertyFloatRow(comp, sceneobjects.TextComponent.lineSpacing).style.gridColumn = "3 / span 4";
                        // maxLines
                        this.createPropertyFloatRow(comp, sceneobjects.TextComponent.maxLines).style.gridColumn = "3 / span 4";
                        // wordWrapWidth
                        this.createPropertyFloatRow(comp, sceneobjects.TextComponent.wordWrapWidth).style.gridColumn = "3 / span 4";
                        // useAdvancedWrap
                        this.createPropertyBoolean(comp, sceneobjects.TextComponent.useAdvancedWrap)
                            .checkElement.style.gridColumn = "3 / span 4";
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.Text;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.TextSection = TextSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ChangeTextureOperation extends sceneobjects.SceneGameObjectOperation {
                    static canChangeTextureOf(obj) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.TextureComponent)
                            && (!obj.getEditorSupport().isPrefabInstance()
                                || obj.getEditorSupport().isUnlockedProperty(sceneobjects.TextureComponent.texture));
                    }
                    static async runDialog(editor, atlasKey) {
                        const cache = editor.getScene().getPackCache();
                        const lockedObjects = editor.getSelectedGameObjects().filter(obj => obj.getEditorSupport().isLockedProperty(sceneobjects.TextureComponent.texture));
                        if (lockedObjects.length > 0) {
                            const ok = await editor.confirmUnlockProperty([sceneobjects.TextureComponent.texture], "texture", sceneobjects.TextureSection.SECTION_ID);
                            if (!ok) {
                                return;
                            }
                        }
                        const objects = editor.getSelectedGameObjects().filter(obj => this.canChangeTextureOf(obj));
                        const objectKeys = objects
                            .map(obj => sceneobjects.GameObjectEditorSupport.getObjectComponent(obj, sceneobjects.TextureComponent))
                            .map(comp => comp.getTextureKeys());
                        const selectedFrames = objectKeys.map(k => cache.getImage(k.key, k.frame));
                        const callback = async (sel) => {
                            const frame = sel[0];
                            let newKeys;
                            const item = frame.getPackItem();
                            item.addToPhaserCache(editor.getGame(), cache);
                            if (item instanceof phasereditor2d.pack.core.ImageAssetPackItem) {
                                newKeys = { key: item.getKey() };
                            }
                            else {
                                newKeys = { key: item.getKey(), frame: frame.getName() };
                            }
                            editor
                                .getUndoManager().add(new ChangeTextureOperation(editor, objects, newKeys));
                        };
                        if (atlasKey) {
                            sceneobjects.TextureFrameSelectionDialog.createDialog(editor.getPackFinder(), selectedFrames, callback, atlasKey);
                        }
                        else {
                            sceneobjects.TextureSelectionDialog.createDialog(editor, selectedFrames, callback);
                        }
                    }
                    constructor(editor, objects, value) {
                        super(editor, objects, value);
                    }
                    getValue(obj) {
                        const comp = obj.getEditorSupport().getComponent(sceneobjects.TextureComponent);
                        return comp.getTextureKeys();
                    }
                    setValue(obj, value) {
                        const finder = this.getEditor().getPackFinder();
                        const item = finder.findAssetPackItem(value.key);
                        if (item) {
                            item.addToPhaserCache(this.getEditor().getGame(), this.getScene().getPackCache());
                        }
                        const comp = obj.getEditorSupport().getComponent(sceneobjects.TextureComponent);
                        comp.setTextureKeys(value);
                        const editor = this.getEditor();
                        editor.refreshDependenciesHash();
                        editor.dispatchSelectionChanged();
                        editor.repaint();
                    }
                }
                sceneobjects.ChangeTextureOperation = ChangeTextureOperation;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class PhaserTextureCellRenderer {
                    renderCell(args) {
                        const image = this.getImage(args);
                        if (image) {
                            image.paint(args.canvasContext, args.x, args.y, args.w, args.h, false);
                        }
                        else {
                            controls.DefaultImage.paintEmpty(args.canvasContext, args.x, args.y, args.w, args.h);
                        }
                    }
                    getImage(args) {
                        const obj = args.obj;
                        const texture = obj.scene.textures.get(obj.texture.key);
                        if (texture) {
                            const canvas = texture.getSourceImage();
                            return new controls.ImageWrapper(canvas);
                        }
                        return null;
                    }
                    cellHeight(args) {
                        return args.viewer.getCellSize();
                    }
                    async preload(args) {
                        const image = this.getImage(args);
                        if (image) {
                            return image.preload();
                        }
                        return controls.PreloadResult.NOTHING_LOADED;
                    }
                }
                sceneobjects.PhaserTextureCellRenderer = PhaserTextureCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class TextureCellRenderer {
                    renderCell(args) {
                        const image = this.getImage(args);
                        if (image) {
                            image.paint(args.canvasContext, args.x, args.y, args.w, args.h, false);
                        }
                        else {
                            controls.DefaultImage.paintEmpty(args.canvasContext, args.x, args.y, args.w, args.h);
                        }
                    }
                    getImage(args) {
                        const obj = args.obj;
                        const support = obj.getEditorSupport();
                        const textureComp = support.getComponent(sceneobjects.TextureComponent);
                        if (textureComp) {
                            const { key, frame } = textureComp.getTextureKeys();
                            const image = support.getScene().getPackCache().getImage(key, frame);
                            return image;
                        }
                        return null;
                    }
                    cellHeight(args) {
                        return args.viewer.getCellSize();
                    }
                    async preload(args) {
                        const image = this.getImage(args);
                        if (image) {
                            return image.preload();
                        }
                        return controls.PreloadResult.NOTHING_LOADED;
                    }
                }
                sceneobjects.TextureCellRenderer = TextureCellRenderer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../Component.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TextureComponent extends sceneobjects.Component {
                    static texture = {
                        name: "texture",
                        defValue: {},
                        getValue: obj => {
                            const textureComponent = obj.getEditorSupport().getComponent(TextureComponent);
                            return textureComponent.getTextureKeys();
                        },
                        setValue: (obj, value) => {
                            const textureComponent = obj.getEditorSupport().getComponent(TextureComponent);
                            textureComponent.setTextureKeys(value);
                        }
                    };
                    _textureKeys;
                    constructor(obj) {
                        super(obj, [
                            TextureComponent.texture
                        ]);
                        this._textureKeys = {};
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        const obj = this.getObject();
                        const support = obj.getEditorSupport();
                        const prop = TextureComponent.texture;
                        if (support.isNestedPrefabInstance()
                            && support.isUnlockedProperty(prop)) {
                            const dom = new scene.core.code.MethodCallCodeDOM("setTexture", args.objectVarName);
                            const keys = prop.getValue(obj);
                            dom.argLiteral(keys.key);
                            dom.argStringOrFloat(keys.frame);
                            args.statements.push(dom);
                        }
                    }
                    getTextureKeys() {
                        return this._textureKeys;
                    }
                    setTextureKeys(keys) {
                        this._textureKeys = keys;
                        if (this._textureKeys.frame === null) {
                            this._textureKeys.frame = undefined;
                        }
                        const obj = this.getObject();
                        const ox = obj.originX;
                        const oy = obj.originY;
                        obj.setTexture(keys.key || null, keys.frame);
                        const objES = obj.getEditorSupport();
                        if (objES.hasComponent(sceneobjects.OriginComponent)) {
                            obj.setOrigin(ox, oy);
                        }
                        objES.onUpdateAfterSetTexture();
                    }
                    removeTexture() {
                        this.setTextureKeys({});
                    }
                }
                sceneobjects.TextureComponent = TextureComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class TextureFrameSelectionDialog extends controls.dialogs.ViewerDialog {
                    _finder;
                    static async createDialog(finder, selected, callback, atlasKey) {
                        const dlg = new TextureFrameSelectionDialog(finder, callback, atlasKey);
                        dlg.create();
                        dlg.getViewer().setSelection(selected);
                        dlg.getViewer().reveal(...selected);
                        return dlg;
                    }
                    _callback;
                    _atlasKey;
                    constructor(finder, callback, atlasKey) {
                        super(new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.TextureFrameSelectionDialog"), true);
                        this._finder = finder;
                        this._callback = callback;
                        this._atlasKey = atlasKey;
                        this.setSize(900, 500, true);
                    }
                    create() {
                        const viewer = this.getViewer();
                        viewer.setLabelProvider(new phasereditor2d.pack.ui.viewers.AssetPackLabelProvider());
                        viewer.setTreeRenderer(new phasereditor2d.pack.ui.viewers.AssetPackTreeViewerRenderer(viewer, false));
                        viewer.setCellRendererProvider(new phasereditor2d.pack.ui.viewers.AssetPackCellRendererProvider("grid"));
                        viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        viewer.setCellSize(64, true);
                        let input;
                        const item = this._finder.findAssetPackItem(this._atlasKey);
                        if (item instanceof phasereditor2d.pack.core.ImageFrameContainerAssetPackItem) {
                            input = item.getFrames();
                        }
                        else {
                            input = [];
                        }
                        viewer.setInput(input);
                        viewer.expandRoots();
                        super.create();
                        this.setTitle("Select Texture Frame");
                        const btn = this.addButton("Select", () => {
                            this._callback(this.getViewer().getSelection());
                            this.close();
                        });
                        btn.disabled = true;
                        viewer.eventSelectionChanged.addListener(() => {
                            btn.disabled = this.getViewer().getSelection().length !== 1
                                || !phasereditor2d.pack.core.AssetPackUtils.isImageFrameOrImage(this.getViewer().getSelectionFirstElement());
                        });
                        viewer.eventOpenItem.addListener(() => btn.click());
                        this.addButton("Cancel", () => this.close());
                    }
                }
                sceneobjects.TextureFrameSelectionDialog = TextureFrameSelectionDialog;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                var ide = colibri.ui.ide;
                class TextureSection extends sceneobjects.SceneGameObjectSection {
                    static SECTION_ID = "phasereditor2d.scene.ui.sceneobjects.TextureSection";
                    constructor(page) {
                        super(page, TextureSection.SECTION_ID, "Texture", false, false);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/texture-property.html";
                    }
                    createMenu(menu) {
                        this.getEditor().getMenuCreator().createTextureMenuItems(menu);
                        menu.addSeparator();
                        super.createMenu(menu);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent);
                        comp.style.gridTemplateColumns = "auto 1fr auto";
                        // Preview
                        const imgComp = document.createElement("div");
                        imgComp.style.gridColumn = "1/ span 3";
                        imgComp.style.height = "200px";
                        comp.appendChild(imgComp);
                        const imgControl = new controls.ImageControl(ide.IMG_SECTION_PADDING);
                        imgControl.getElement().style.position = "relative";
                        this.getPage().eventControlLayout.addListener(() => {
                            imgControl.resizeTo();
                        });
                        imgComp.appendChild(imgControl.getElement());
                        requestAnimationFrame(() => imgControl.resizeTo());
                        this.addUpdater(async () => {
                            const frames = this.getSelectedFrames();
                            imgControl.setImage(new controls.MultiImage(frames, 10, 10));
                            requestAnimationFrame(() => imgControl.resizeTo());
                        });
                        {
                            // Size
                            const label = this.createLabel(comp);
                            label.style.gridColumn = "1 / span 3";
                            label.style.justifySelf = "center";
                            this.addUpdater(() => {
                                const frames = this.getSelectedFrames();
                                if (frames.length === 1) {
                                    const frame = frames[0];
                                    label.innerHTML = frame.getWidth() + "x" + frame.getHeight();
                                }
                                else {
                                    label.innerHTML = "";
                                }
                            });
                        }
                        {
                            // Lock
                            this.createLock(comp, sceneobjects.TextureComponent.texture);
                        }
                        {
                            // Buttons
                            const changeBtn = this.createButton(comp, "Select", e => {
                                sceneobjects.ChangeTextureOperation.runDialog(this.getEditor());
                            });
                            controls.Tooltip.tooltip(changeBtn, "Click to select a new texture.");
                            const deleteBtn = this.createButton(comp, "Delete", e => {
                                this.getEditor().getUndoManager()
                                    .add(new sceneobjects.ChangeTextureOperation(this.getEditor(), this.getSelection(), {}));
                            });
                            controls.Tooltip.tooltip(deleteBtn, "Removes the texture of the object.");
                            this.addUpdater(() => {
                                if (this.getSelection().length === 1) {
                                    const obj = this.getSelection()[0];
                                    const textureComp = this.getTextureComponent(obj);
                                    const { key, frame } = textureComp.getTextureKeys();
                                    let str = "(Select)";
                                    if (frame !== undefined) {
                                        str = frame + " @ " + key;
                                    }
                                    else if (key) {
                                        str = key;
                                    }
                                    changeBtn.textContent = str;
                                }
                                else {
                                    changeBtn.textContent = "Multiple Textures";
                                }
                                const unlocked = this.isUnlocked(sceneobjects.TextureComponent.texture);
                                changeBtn.disabled = !unlocked;
                                deleteBtn.disabled = !unlocked;
                            });
                        }
                    }
                    getSelectedFrames() {
                        // this happens when the editor is opened but the scene is not yet created
                        if (!this.getEditor().getScene()) {
                            return [];
                        }
                        const cache = this.getEditor().getScene().getPackCache();
                        const images = new Set();
                        for (const obj of this.getSelection()) {
                            const textureComp = this.getTextureComponent(obj);
                            const { key, frame } = textureComp.getTextureKeys();
                            const img = cache.getImage(key, frame);
                            if (img) {
                                images.add(img);
                            }
                        }
                        return [...images];
                    }
                    getTextureComponent(obj) {
                        return obj.getEditorSupport().getComponent(sceneobjects.TextureComponent);
                    }
                    canEdit(obj, n) {
                        return sceneobjects.GameObjectEditorSupport.hasObjectComponent(obj, sceneobjects.TextureComponent);
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.TextureSection = TextureSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                const grouping = phasereditor2d.pack.ui.viewers.AssetPackGrouping;
                const TYPES = [
                    phasereditor2d.pack.core.IMAGE_TYPE,
                    phasereditor2d.pack.core.SVG_TYPE,
                    phasereditor2d.pack.core.ATLAS_TYPE,
                    phasereditor2d.pack.core.SPRITESHEET_TYPE,
                    phasereditor2d.pack.core.ASEPRITE_TYPE
                ];
                class TextureSelectionDialog extends controls.dialogs.ViewerDialog {
                    _cancelButton;
                    static createDialog(editor, selected, callback) {
                        const dlg = new TextureSelectionDialog(editor, callback);
                        dlg.create();
                        dlg.getViewer().setSelection(selected);
                        dlg.getViewer().reveal(...selected);
                        return dlg;
                    }
                    static async selectOneTexture(editor, selected, cancelButtonLabel) {
                        return new Promise((resolver, reject) => {
                            const dlg = this.createDialog(editor, selected ?? [], (selection) => {
                                resolver(selection[0]);
                            });
                            dlg.eventDialogClose.addListener(() => {
                                resolver(undefined);
                            });
                            if (cancelButtonLabel) {
                                dlg.getCancelButton().innerHTML = cancelButtonLabel;
                            }
                        });
                    }
                    _callback;
                    _editor;
                    constructor(editor, callback) {
                        super(new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.TextureSelectionDialog"), true);
                        this._editor = editor;
                        this._callback = callback;
                        this.setSize(window.innerWidth / 2, window.innerHeight * 0.7, true);
                    }
                    create() {
                        const viewer = this.getViewer();
                        viewer.setLabelProvider(new phasereditor2d.pack.ui.viewers.AssetPackLabelProvider());
                        viewer.setTreeRenderer(new phasereditor2d.pack.ui.viewers.AssetPackTreeViewerRenderer(viewer, false));
                        viewer.setCellRendererProvider(new class extends phasereditor2d.pack.ui.viewers.AssetPackCellRendererProvider {
                            getCellRenderer(element) {
                                if (element instanceof phasereditor2d.pack.core.AnimationConfigInPackItem) {
                                    return new phasereditor2d.pack.ui.viewers.AnimationConfigCellRenderer("square");
                                }
                                return super.getCellRenderer(element);
                            }
                        }("grid"));
                        viewer.setContentProvider(new (class extends ui.blocks.SceneEditorBlocksContentProvider {
                            getRoots(input) {
                                return input;
                            }
                            getChildren(parent) {
                                if (parent instanceof phasereditor2d.pack.core.AsepriteAssetPackItem) {
                                    return parent.getFrames();
                                }
                                return super.getChildren(parent);
                            }
                        })(this._editor, () => this._editor.getPackFinder().getPacks()));
                        viewer.setCellSize(64, true);
                        viewer.setInput(TYPES);
                        viewer.expandRoots();
                        super.create();
                        this.setTitle("Select Texture");
                        const btn = this.addButton("Select", () => {
                            this._callback(this.getViewer().getSelection());
                            this.close();
                        });
                        btn.disabled = true;
                        viewer.eventSelectionChanged.addListener(() => {
                            btn.disabled = this.getViewer().getSelection().length !== 1
                                || !phasereditor2d.pack.core.AssetPackUtils.isImageFrameOrImage(this.getViewer().getSelectionFirstElement());
                        });
                        viewer.eventOpenItem.addListener(() => btn.click());
                        this._cancelButton = this.addCancelButton();
                        this.updateFromGroupingType();
                    }
                    getCancelButton() {
                        return this._cancelButton;
                    }
                    updateFromGroupingType() {
                        const type = grouping.getGroupingPreference();
                        const viewer = this.getViewer();
                        switch (type) {
                            case grouping.GROUP_ASSETS_BY_TYPE:
                                viewer.setInput(TYPES);
                                break;
                            case grouping.GROUP_ASSETS_BY_PACK:
                                viewer.setInput(this._editor.getPackFinder().getPacks());
                                break;
                            case grouping.GROUP_ASSETS_BY_LOCATION:
                                viewer.setInput(grouping.getAssetsFolders(this._editor.getPackFinder().getPacks()));
                                break;
                        }
                        viewer.repaint();
                        viewer.expandRoots();
                    }
                    fillContextMenu(menu) {
                        const selectedType = grouping.getGroupingPreference();
                        for (const type of grouping.GROUP_ASSET_TYPES) {
                            menu.addAction({
                                text: "Group By " + grouping.GROUP_ASSET_TYPE_LABEL_MAP[type],
                                selected: type === selectedType,
                                callback: () => {
                                    grouping.setGroupingPreference(type);
                                    this.updateFromGroupingType();
                                }
                            });
                        }
                    }
                }
                sceneobjects.TextureSelectionDialog = TextureSelectionDialog;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_104) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class Tilemap extends Phaser.Tilemaps.Tilemap {
                    _key;
                    static createTilemapData(scene, key) {
                        const tilemapData = scene.cache.tilemap.get(key);
                        if (tilemapData) {
                            const mapData = Phaser.Tilemaps.Parsers.Parse(key, tilemapData.format, tilemapData.data, undefined, undefined, undefined);
                            return mapData;
                        }
                        return new Phaser.Tilemaps.MapData();
                    }
                    _editorSupport;
                    constructor(scene, key) {
                        super(scene, Tilemap.createTilemapData(scene, key));
                        this._key = key;
                        this._editorSupport = new sceneobjects.TilemapEditorSupport(scene, this);
                        for (const tileset of this.tilesets) {
                            tileset["__tilemap"] = this;
                        }
                    }
                    static getTilemapFromTileset(tileset) {
                        return tileset["__tilemap"];
                    }
                    getTilemapAssetKey() {
                        return this._key;
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.Tilemap = Tilemap;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_104.ui || (scene_104.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class TilemapConfigWizard extends controls.dialogs.WizardDialog {
                    _finder;
                    _tilemapKeyPage;
                    _tilesetsPage;
                    _finishCallback;
                    _cancelCallback;
                    _tilemapLayerNamePage;
                    constructor(finder) {
                        super();
                        this._finder = finder;
                        this.setSize(undefined, 500, true);
                    }
                    getFinder() {
                        return this._finder;
                    }
                    create() {
                        this._tilemapKeyPage = new TilemapKeyPage();
                        this._tilesetsPage = new TilesetsPage();
                        this._tilemapLayerNamePage = new TilemapLayerNamePage();
                        this.addPages(this._tilemapKeyPage, this._tilesetsPage, this._tilemapLayerNamePage);
                        super.create();
                        this.setTitle("Tilemap Configuration");
                    }
                    getTilemapKeyPage() {
                        return this._tilemapKeyPage;
                    }
                    getTilesetsPage() {
                        return this._tilesetsPage;
                    }
                    getTilemapLayerNamePage() {
                        return this._tilemapLayerNamePage;
                    }
                    getTilemapAssets() {
                        return this._finder
                            .getAssets(a => a instanceof phasereditor2d.pack.core.TilemapTiledJSONAssetPackItem);
                    }
                    setFinishCallback(cb) {
                        this._finishCallback = cb;
                    }
                    setCancelCallback(cb) {
                        this._cancelCallback = cb;
                    }
                    finishButtonPressed() {
                        this._finishCallback();
                    }
                    cancelButtonPressed() {
                        this._cancelCallback();
                    }
                }
                sceneobjects.TilemapConfigWizard = TilemapConfigWizard;
                class BasePage extends controls.dialogs.WizardPage {
                    getWizard() {
                        return super.getWizard();
                    }
                }
                class TilemapKeyPage extends BasePage {
                    _tilemapAsset;
                    _viewer;
                    constructor() {
                        super("Tilemap Key", "Select the tilemap key.");
                    }
                    getTilemapAsset() {
                        return this._tilemapAsset;
                    }
                    createElements(parent) {
                        this._viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.TilemapKeyPage");
                        this._viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        this._viewer.setLabelProvider(new controls.viewers.LabelProvider((tilemap) => {
                            return tilemap.getKey();
                        }));
                        this._viewer.setCellRendererProvider(controls.viewers.EmptyCellRendererProvider.withIcon(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_TILEMAP)));
                        this._viewer.setInput(this.getWizard().getTilemapAssets());
                        const filteredViewer = new controls.viewers.FilteredViewerInElement(this._viewer, false);
                        parent.appendChild(filteredViewer.getElement());
                        this._viewer.eventSelectionChanged.addListener(sel => {
                            this._tilemapAsset = this._viewer.getSelectionFirstElement();
                            this.getWizard().updateWizardButtons();
                        });
                        this.updateUI();
                    }
                    updateUI() {
                        if (this._tilemapAsset) {
                            this._viewer.setSelection([this._tilemapAsset]);
                            this._viewer.reveal(this._tilemapAsset);
                        }
                        this.getWizard().updateWizardButtons();
                    }
                    canFinish() {
                        return this.canGoNext();
                    }
                    canGoNext() {
                        return this._tilemapAsset !== undefined && this._tilemapAsset !== null;
                    }
                }
                class TilesetsPage extends BasePage {
                    _imageMap;
                    _assignButton;
                    _tilesetViewer;
                    constructor() {
                        super("Tilesets", "Assign an image to each tileset.");
                        this._imageMap = new Map();
                    }
                    getImageMap() {
                        return this._imageMap;
                    }
                    autoSetImages() {
                        this._imageMap = new Map();
                        const tilesets = this.getWizard().getTilemapKeyPage().getTilemapAsset().getTilesetsData();
                        for (const tileset of tilesets) {
                            if (tileset.source) {
                                alert("Phaser does not support external tilesets.");
                                continue;
                            }
                            const asset = this.findTilesetImage(tileset.image);
                            if (asset) {
                                this._imageMap.set(tileset.name, asset);
                            }
                        }
                    }
                    findTilesetImage(tilesetImage) {
                        const finder = this.getWizard().getFinder();
                        const image1 = tilesetImage;
                        const image2 = colibri.ui.ide.FileUtils.getFileNameWithoutExtension(image1);
                        const split1 = image2.split("/");
                        const image3 = split1[split1.length - 1];
                        const split2 = image2.split("\\");
                        const image4 = split2[split2.length - 1];
                        for (const image of [image1, image2, image3, image4]) {
                            const result = finder.findAssetPackItem(image);
                            if (result && (result instanceof phasereditor2d.pack.core.ImageAssetPackItem
                                || result instanceof phasereditor2d.pack.core.SpritesheetAssetPackItem)) {
                                return result;
                            }
                        }
                        return undefined;
                    }
                    createElements(parent) {
                        this.autoSetImages();
                        const tilesets = this.getWizard().getTilemapKeyPage().getTilemapAsset().getTilesetsData();
                        const comp = document.createElement("div");
                        comp.style.display = "grid";
                        comp.style.gridTemplateRows = "1fr auto";
                        comp.style.gridTemplateColumns = "1fr";
                        comp.style.rowGap = "5px";
                        comp.style.height = "100%";
                        parent.appendChild(comp);
                        const viewerWrapperElement = document.createElement("div");
                        viewerWrapperElement.style.height = "100%";
                        comp.appendChild(viewerWrapperElement);
                        this._tilesetViewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.TilesetsPage");
                        this._tilesetViewer.setCellSize(64);
                        this._tilesetViewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        this._tilesetViewer.setLabelProvider(new controls.viewers.LabelProvider((tileset) => {
                            return tileset.name;
                        }));
                        this._tilesetViewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider((obj) => {
                            const item = this._imageMap.get(obj.name);
                            if (item) {
                                return new controls.viewers.ImageCellRenderer(phasereditor2d.pack.core.AssetPackUtils.getImageFromPackUrl(item.getPack(), item.getUrl()));
                            }
                            return new controls.viewers.EmptyCellRenderer(false);
                        }));
                        this._tilesetViewer.setInput(tilesets);
                        this._tilesetViewer.eventSelectionChanged.addListener(e => this.updateUI());
                        this._tilesetViewer.eventOpenItem.addListener(e => this.openAssignImageDialog());
                        const filteredViewer = new controls.viewers.FilteredViewerInElement(this._tilesetViewer, true);
                        viewerWrapperElement.appendChild(filteredViewer.getElement());
                        this._assignButton = document.createElement("button");
                        this._assignButton.textContent = "Set Tileset Image";
                        this._assignButton.style.justifySelf = "self-end";
                        comp.appendChild(this._assignButton);
                        this._assignButton.addEventListener("click", e => this.openAssignImageDialog());
                    }
                    openAssignImageDialog() {
                        const finder = this.getWizard().getFinder();
                        const dlg = new phasereditor2d.pack.ui.dialogs.AssetSelectionDialog("tree");
                        dlg.create(false);
                        dlg.getViewer().setInput(finder.getAssets(a => a instanceof phasereditor2d.pack.core.SpritesheetAssetPackItem
                            || a instanceof phasereditor2d.pack.core.ImageAssetPackItem));
                        dlg.setSelectionCallback((sel) => {
                            const tileset = this._tilesetViewer.getSelectionFirstElement();
                            const asset = sel[0];
                            this._imageMap.set(tileset.name, asset);
                            this.updateUI();
                        });
                    }
                    canFinish() {
                        const tilemap = this.getWizard().getTilemapKeyPage().getTilemapAsset();
                        if (tilemap) {
                            const tilesets = tilemap.getTilesetsData();
                            for (const tileset of tilesets) {
                                if (!this._imageMap.has(tileset.name)) {
                                    return false;
                                }
                            }
                            return true;
                        }
                        return false;
                    }
                    canGoNext() {
                        return this.canFinish();
                    }
                    updateUI() {
                        this._assignButton.disabled = this._tilesetViewer.getSelection().length === 0;
                        this._tilesetViewer.repaint();
                        this.getWizard().updateWizardButtons();
                    }
                }
                class TilemapLayerNamePage extends BasePage {
                    _viewer;
                    _tilemapLayerName;
                    constructor() {
                        super("Tilemap Layer", "Select a Tilemap Layer.");
                    }
                    createElements(parent) {
                        this._viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.LayerPage");
                        this._viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        this._viewer.setLabelProvider(new controls.viewers.LabelProvider((name) => name));
                        this._viewer.setCellRendererProvider(controls.viewers.EmptyCellRendererProvider.withIcon(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_TILEMAP_LAYER)));
                        this._viewer.setInput(this.getWizard().getTilemapKeyPage().getTilemapAsset().getLayerNames());
                        const filteredViewer = new controls.viewers.FilteredViewerInElement(this._viewer, false);
                        parent.appendChild(filteredViewer.getElement());
                        this._viewer.eventSelectionChanged.addListener(sel => {
                            this._tilemapLayerName = this._viewer.getSelectionFirstElement();
                            this.getWizard().updateWizardButtons();
                        });
                        this.updateUI();
                    }
                    getTilemapLayerName() {
                        return this._tilemapLayerName;
                    }
                    updateUI() {
                        if (this._tilemapLayerName) {
                            this._viewer.setSelection([this._tilemapLayerName]);
                            this._viewer.reveal(this._tilemapLayerName);
                        }
                        this.getWizard().updateWizardButtons();
                    }
                    canFinish() {
                        return true;
                    }
                    canGoBack() {
                        return true;
                    }
                    canGoNext() {
                        return true;
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_105) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TilemapEditorSupport extends sceneobjects.ScenePlainObjectEditorSupport {
                    constructor(scene, obj) {
                        super(sceneobjects.TilemapExtension.getInstance(), obj, scene);
                        this.setLabel(obj.getTilemapAssetKey());
                    }
                    writeJSON(data) {
                        super.writeJSON(data);
                        const tilemap = this.getObject();
                        data.key = tilemap.getTilemapAssetKey();
                        data.tilesets = [];
                        for (const tileset of tilemap.tilesets) {
                            data.tilesets.push({
                                name: tileset.name,
                                imageKey: tileset.image ? tileset.image.key : undefined
                            });
                        }
                    }
                    readJSON(data) {
                        super.readJSON(data);
                        const scene = this.getScene();
                        const textures = scene.sys.textures;
                        const tilemap = this.getObject();
                        for (const tileset of tilemap.tilesets) {
                            const tilesetData = data.tilesets.find(t => t.name === tileset.name);
                            if (tilesetData && tilesetData.imageKey) {
                                const imageKey = tilesetData.imageKey;
                                if (textures.exists(imageKey)) {
                                    tileset.setImage(textures.get(imageKey));
                                }
                            }
                        }
                    }
                    destroy() {
                        const tilemap = this.getObject();
                        const layers = [];
                        this.getScene().visitAll(obj => {
                            if (obj instanceof sceneobjects.TilemapLayer) {
                                if (obj.tilemap === tilemap) {
                                    layers.push(obj);
                                }
                            }
                        });
                        for (const layer of layers) {
                            layer.getEditorSupport().destroy();
                        }
                        tilemap.destroy();
                    }
                    async buildDependencyHash(args) {
                        //
                    }
                }
                sceneobjects.TilemapEditorSupport = TilemapEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_105.ui || (scene_105.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_106) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene_106.core.code;
                class TilemapExtension extends sceneobjects.ScenePlainObjectExtension {
                    static _instance;
                    static getInstance() {
                        return this._instance ?? (this._instance = new TilemapExtension());
                    }
                    constructor() {
                        super({
                            category: scene_106.SCENE_OBJECT_TILEMAP_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_TILEMAP),
                            phaserTypeName: "Phaser.Tilemaps.Tilemap",
                            typeName: "Tilemap"
                        });
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const statements = [];
                        const tilemap = args.obj;
                        const addTilemapDom = new code.MethodCallCodeDOM("tilemap", args.gameObjectFactoryExpr + ".add");
                        addTilemapDom.argLiteral(tilemap.getTilemapAssetKey());
                        statements.push(addTilemapDom);
                        for (const tileset of tilemap.tilesets) {
                            const addTilesetImageDom = new code.MethodCallCodeDOM("addTilesetImage", args.varname);
                            addTilesetImageDom.argLiteral(tileset.name);
                            addTilemapDom.setDeclareReturnToVar(true);
                            if (tileset.image) {
                                addTilesetImageDom.argLiteral(tileset.image.key);
                            }
                            statements.push(addTilesetImageDom);
                        }
                        return {
                            firstStatements: statements,
                            objectFactoryMethodCall: addTilemapDom
                        };
                    }
                    async getAssetsFromObjectData(args) {
                        const result = [];
                        const finder = args.finder;
                        const data = args.data;
                        const key = data.key;
                        const item = args.finder.findAssetPackItem(key);
                        if (item instanceof phasereditor2d.pack.core.TilemapTiledJSONAssetPackItem) {
                            result.push(item);
                        }
                        for (const tileset of data.tilesets) {
                            if (tileset.imageKey) {
                                const asset = finder.findAssetPackItem(tileset.imageKey);
                                if (asset instanceof phasereditor2d.pack.core.ImageAssetPackItem
                                    || asset instanceof phasereditor2d.pack.core.SpritesheetAssetPackItem) {
                                    result.push(asset);
                                }
                            }
                        }
                        return result;
                    }
                    async collectExtraDataForCreateDefaultObject(editor) {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        const promise = new Promise((resolve, reject) => {
                            const dlg = new sceneobjects.TilemapConfigWizard(finder);
                            dlg.setFinishCallback(async () => {
                                const tilemap = dlg.getTilemapKeyPage().getTilemapAsset();
                                const tilesetsImages = dlg.getTilesetsPage().getImageMap();
                                const tilemapLayerName = dlg.getTilemapLayerNamePage().getTilemapLayerName();
                                const scene = editor.getScene();
                                let updater = scene_106.ScenePlugin.getInstance().getLoaderUpdaterForAsset(tilemap);
                                await updater.updateLoader(scene, tilemap);
                                for (const [name, image] of tilesetsImages.entries()) {
                                    updater = scene_106.ScenePlugin.getInstance().getLoaderUpdaterForAsset(image);
                                    await updater.updateLoader(scene, image);
                                }
                                const result = {
                                    data: {
                                        tilemap,
                                        tilesetsImages,
                                        tilemapLayerName
                                    }
                                };
                                resolve(result);
                            });
                            dlg.setCancelCallback(() => {
                                const result = {
                                    abort: true
                                };
                                resolve(result);
                            });
                            dlg.create();
                        });
                        return promise;
                    }
                    createDefaultSceneObject(args) {
                        const extraData = args.extraData;
                        const tilesetsImages = extraData.tilesetsImages;
                        const tilemap = new sceneobjects.Tilemap(args.scene, extraData.tilemap.getKey());
                        for (const [name, image] of tilesetsImages.entries()) {
                            tilemap.addTilesetImage(name, image.getKey());
                        }
                        if (extraData.tilemapLayerName) {
                            const layer = new sceneobjects.TilemapLayer(args.scene, tilemap, extraData.tilemapLayerName);
                            return [tilemap, layer];
                        }
                        return [tilemap];
                    }
                    createPlainObjectWithData(args) {
                        const data = args.data;
                        const key = data.key;
                        const tilemap = new sceneobjects.Tilemap(args.scene, key);
                        tilemap.getEditorSupport().readJSON(data);
                        return tilemap;
                    }
                    isAvailableAsPrefabElement() {
                        return false;
                    }
                }
                sceneobjects.TilemapExtension = TilemapExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_106.ui || (scene_106.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_107) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TilemapLayer extends Phaser.Tilemaps.TilemapLayer {
                    _editorSupport;
                    constructor(scene, tilemap, layerName) {
                        super(scene, tilemap, tilemap.getLayerIndex(layerName), tilemap.tilesets);
                        this.setRenderOrder(tilemap.renderOrder);
                        this.setOrigin(0, 0);
                        // we do this to prevent a wrong culling when the camera is scrolled and zoomed.
                        this.setCullPadding(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
                        this._editorSupport = new sceneobjects.TilemapLayerEditorSupport(this, scene);
                    }
                    static scanTilesets(layer) {
                        const gidMap = new Map();
                        const allTilesets = layer.tilemap.tilesets;
                        for (const tileset of allTilesets) {
                            const s = tileset.firstgid;
                            for (let t = 0; t < tileset.total; t++) {
                                gidMap.set(s + t, tileset);
                            }
                        }
                        const layerTilesets = new Set();
                        for (let x = 0; x < layer.width; x++) {
                            for (let y = 0; y < layer.height; y++) {
                                const tile = layer.getTileAt(x, y);
                                if (tile) {
                                    const tileset = gidMap.get(tile.index);
                                    if (tileset) {
                                        layerTilesets.add(tileset);
                                    }
                                }
                            }
                        }
                        return [...layerTilesets];
                    }
                    destroy() {
                        super.destroy(true);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.TilemapLayer = TilemapLayer;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_107.ui || (scene_107.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class TilemapLayerCodeDOMBuilder extends sceneobjects.GameObjectCodeDOMBuilder {
                    _factoryMethod;
                    constructor(factoryMethod) {
                        super();
                        this._factoryMethod = factoryMethod;
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const tilemapLayer = args.obj;
                        const tilesets = sceneobjects.TilemapLayer.scanTilesets(tilemapLayer);
                        const tilesetArray = "[" + tilesets.map(t => code.CodeDOM.quote(t.name)).join(",") + "]";
                        const tilemap = tilemapLayer.tilemap;
                        const tilemapVarName = code.formatToValidVarName(tilemap.getEditorSupport().getLabel());
                        const call = new code.MethodCallCodeDOM(this._factoryMethod, tilemapVarName);
                        call.argLiteral(tilemapLayer.layer.name);
                        call.arg(tilesetArray);
                        call.argInt(tilemapLayer.x);
                        call.argInt(tilemapLayer.y);
                        call.setNonNullAssertion(true);
                        return call;
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        throw new Error("Not supported");
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        throw new Error("Not supported");
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        throw new Error("Not supported");
                    }
                }
                sceneobjects.TilemapLayerCodeDOMBuilder = TilemapLayerCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_108) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TilemapLayerEditorSupport extends sceneobjects.GameObjectEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.TilemapLayerExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.TransformComponent(obj), new sceneobjects.VisibleComponent(obj));
                        this.setLabel(obj.layer.name);
                    }
                    computeOrigin() {
                        if (this.getOrientation() === Phaser.Tilemaps.Orientation.ISOMETRIC) {
                            return { originX: 0.5, originY: 0 };
                        }
                        return super.computeOrigin();
                    }
                    isUnlockedProperty(property) {
                        if (property === sceneobjects.TransformComponent.angle) {
                            return false;
                        }
                        return super.isUnlockedProperty(property);
                    }
                    computeContentHash() {
                        const obj = this.getObject();
                        const tilesetHash = obj.tileset.map(t => t.image).filter(img => img).map(img => img.key);
                        return obj.tilemap.getEditorSupport().getId() + "-" + obj.layer.name + "-" + tilesetHash;
                    }
                    setInteractive() {
                        this.getObject().setInteractive(TilemapLayerEditorSupport.helper_interactiveCallback);
                    }
                    getCellRenderer() {
                        return new sceneobjects.ObjectCellRenderer();
                    }
                    writeJSON(data) {
                        super.writeJSON(data);
                        const layer = this.getObject();
                        const tilemap = layer.tilemap;
                        data.tilemapId = tilemap.getEditorSupport().getId();
                        data.layerName = layer.layer.name;
                        data.tilesets = tilemap.tilesets.map(t => t.name);
                    }
                    getOrientation() {
                        return this.getObject().tilemap.orientation;
                    }
                    static helper_interactiveCallback(hitArea, x, y, layer) {
                        if (x >= -layer.width && y >= -layer.height && x <= layer.width && y <= layer.height) {
                            let worldToTile;
                            const orientation = layer.tilemap.orientation;
                            if (orientation === Phaser.Tilemaps.Orientation.ISOMETRIC) {
                                worldToTile = TilemapLayerEditorSupport.isometricWorldToTileXY;
                            }
                            else {
                                worldToTile = TilemapLayerEditorSupport.worldToTileXY;
                            }
                            const { tileX, tileY } = worldToTile(x, y, layer);
                            const tile = layer.getTileAt(tileX, tileY);
                            return tile !== null && tile !== undefined;
                        }
                        return false;
                    }
                    static worldToTileXY(worldX, worldY, tilemapLayer) {
                        const layerData = tilemapLayer.layer;
                        const tileX = Math.floor(worldX / layerData.baseTileWidth * tilemapLayer.scaleX);
                        const tileY = Math.floor(worldY / layerData.baseTileHeight * tilemapLayer.scaleY);
                        return { tileX, tileY };
                    }
                    ;
                    static isometricWorldToTileXY(worldX, worldY, tilemapLayer) {
                        const layerData = tilemapLayer.layer;
                        let tileWidth = layerData.baseTileWidth;
                        let tileHeight = layerData.baseTileHeight;
                        tileHeight *= tilemapLayer.scaleY;
                        tileWidth *= tilemapLayer.scaleX;
                        worldX -= tileWidth / 2;
                        const tileX = Math.floor((worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2);
                        const tileY = Math.floor((worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2);
                        return { tileX, tileY };
                    }
                    ;
                }
                sceneobjects.TilemapLayerEditorSupport = TilemapLayerEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_108.ui || (scene_108.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_109) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class TilemapLayerExtension extends sceneobjects.SceneGameObjectExtension {
                    static _instance;
                    static getInstance() {
                        return this._instance ? this._instance : (this._instance = new TilemapLayerExtension());
                    }
                    constructor() {
                        super({
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_TILEMAP_LAYER),
                            phaserTypeName: "Phaser.Tilemaps.TilemapLayer",
                            typeName: "TilemapLayer",
                            typeNameAlias: ["StaticTilemapLayer", "DynamicTilemapLayer"],
                            category: scene_109.SCENE_OBJECT_TILEMAP_CATEGORY,
                        });
                    }
                    createTilemapLayer(scene, tilemap, layerName) {
                        const layer = new sceneobjects.TilemapLayer(scene, tilemap, layerName);
                        return layer;
                    }
                    getCodeFactoryMethod() {
                        return "createLayer";
                    }
                    /**
                     * Collect the data used to create a new, empty object. For example, a BitmapText requires
                     * a BitmapFont key to be created, so this method opens a dialog to select the font.
                     */
                    async collectExtraDataForCreateDefaultObject(editor) {
                        const tilemaps = editor.getScene().getPlainObjects()
                            .filter(o => o instanceof sceneobjects.Tilemap);
                        if (tilemaps.length === 0) {
                            return {
                                dataNotFoundMessage: "First, you need to add a Tilemap object to the scene."
                            };
                        }
                        const noImageTilesets = tilemaps
                            .flatMap(tilemap => tilemap.tilesets)
                            .filter(tileset => !tileset.image)
                            .map(tileset => tileset.name);
                        if (noImageTilesets.length > 0) {
                            const names = `<ul>${noImageTilesets.map(n => `<li>${n}</li>`).join("")}</ul>`;
                            return {
                                dataNotFoundMessage: "The following tilesets have no image:" + names
                            };
                        }
                        const layers = tilemaps
                            .flatMap(tilemap => tilemap.getTileLayerNames().map(layerName => {
                            return {
                                tilemap,
                                layerName
                            };
                        }));
                        if (layers.length === 0) {
                            return {
                                dataNotFoundMessage: "No layers are available in the current tilemaps."
                            };
                        }
                        if (layers.length === 1) {
                            return {
                                data: layers[0]
                            };
                        }
                        return new Promise((resolve, reject) => {
                            const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.CollectExtraDataDialog");
                            viewer.setLabelProvider(new DialogLabelProvider());
                            viewer.setCellRendererProvider(new DialogCellRendererProvider());
                            viewer.setContentProvider(new DialogContentProvider(editor));
                            // viewer.setTreeRenderer(new controls.viewers.TreeViewerRenderer(viewer));
                            viewer.setInput([]);
                            for (const tilemap of tilemaps) {
                                viewer.setExpanded(tilemap, true);
                            }
                            const dlg = new controls.dialogs.ViewerDialog(viewer, false);
                            dlg.create();
                            dlg.setTitle("Select Layer Name");
                            dlg.enableButtonOnlyWhenOneElementIsSelected(dlg.addOpenButton("Select", sel => {
                                const data = sel[0];
                                resolve({
                                    data
                                });
                            }), obj => !(obj instanceof sceneobjects.Tilemap));
                            dlg.addCancelButton();
                        });
                    }
                    acceptsDropData(data) {
                        return false;
                    }
                    createSceneObjectWithAsset(args) {
                        throw new Error("Method not implemented.");
                    }
                    createGameObjectWithData(args) {
                        const data = args.data;
                        const scene = args.scene;
                        const tilemap = scene.getPlainObjectById(data.tilemapId);
                        if (!tilemap) {
                            throw new Error("Cannot find Tilemap with id " + data.tilemapId);
                        }
                        const layer = this.createTilemapLayer(scene, tilemap, data.layerName);
                        layer.getEditorSupport().readJSON(data);
                        return layer;
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.TilemapLayerCodeDOMBuilder(this.getCodeFactoryMethod());
                    }
                    createDefaultSceneObject(args) {
                        const data = args.extraData;
                        const layer = this.createTilemapLayer(args.scene, data.tilemap, data.layerName);
                        layer.setPosition(args.x, args.y);
                        return [layer];
                    }
                    async getAssetsFromObjectData(args) {
                        return [];
                    }
                    isAvailableAsPrefabElement() {
                        return false;
                    }
                    createInitObjectDataFromChild(childData) {
                        // This is a very very ugly solution for this issue:
                        // https://github.com/PhaserEditor2D/PhaserEditor2D-v3/issues/229
                        // but making a bigger change in serialization at this moment could introduce a lot of bugs
                        // and the TilemapLayer is a rare case in Phaser & the editor.
                        // For example, you cannot create a prefab instance of a TilemapLayer
                        return childData;
                    }
                }
                sceneobjects.TilemapLayerExtension = TilemapLayerExtension;
                class DialogLabelProvider {
                    getLabel(element) {
                        if (element instanceof sceneobjects.Tilemap) {
                            return element.getTilemapAssetKey();
                        }
                        return `${element.layerName}`;
                    }
                }
                class DialogCellRendererProvider {
                    getCellRenderer(element) {
                        if (element instanceof sceneobjects.Tilemap) {
                            return new controls.viewers.IconGridCellRenderer(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_TILEMAP));
                        }
                        return new controls.viewers.IconGridCellRenderer(phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_TILEMAP_LAYER));
                    }
                    async preload(args) {
                        return controls.PreloadResult.NOTHING_LOADED;
                    }
                }
                class DialogContentProvider {
                    _editor;
                    _map;
                    constructor(editor) {
                        this._editor = editor;
                        this._map = new Map();
                    }
                    getRoots(input) {
                        const tilemaps = this._editor.getScene()
                            .getPlainObjects()
                            .filter(obj => obj instanceof sceneobjects.Tilemap);
                        return tilemaps;
                    }
                    getChildren(parent) {
                        if (parent instanceof sceneobjects.Tilemap) {
                            if (this._map.has(parent)) {
                                return this._map.get(parent);
                            }
                            const layers = parent.getTileLayerNames().map(layerName => {
                                return {
                                    tilemap: parent,
                                    layerName
                                };
                            });
                            this._map.set(parent, layers);
                            return layers;
                        }
                        return [];
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_109.ui || (scene_109.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TilemapLayerSection extends sceneobjects.SceneGameObjectSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.TilemapLayerData", "Tilemap Layer", false, false);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/tilemap-layer-object.html";
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        {
                            this.createLabel(comp, "Tilemap");
                            const btn = this.createButton(comp, "", () => {
                                this.getEditor().setSelection([this.getSelectionFirstElement().tilemap]);
                            });
                            this.addUpdater(() => {
                                const tilemap = this.getSelectionFirstElement().tilemap;
                                btn.textContent = tilemap.getEditorSupport().getLabel();
                            });
                        }
                        this.layerProp(comp, "name", "Layer Name");
                        this.layerProp(comp, "width", "Width");
                        this.layerProp(comp, "height", "Height");
                        this.layerProp(comp, "widthInPixels", "Width In Pixels");
                        this.layerProp(comp, "heightInPixels", "Height In Pixels");
                        this.layerProp(comp, "tileHeight", "Tile Height");
                        this.layerProp(comp, "tileWidth", "Tile Width");
                    }
                    layerProp(comp, prop, name) {
                        this.createLabel(comp, name, scene.ScenePlugin.getInstance().getPhaserDocs().getDoc("Phaser.Tilemaps.LayerData." + prop));
                        const text = this.createText(comp, true);
                        this.addUpdater(() => {
                            const layer = this.getSelectionFirstElement();
                            const tilemap = layer.tilemap;
                            const layerData = tilemap.layer;
                            text.value = layerData[prop];
                        });
                    }
                    canEdit(obj, n) {
                        return (obj instanceof sceneobjects.TilemapLayer)
                            && obj.tilemap !== undefined;
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.TilemapLayerSection = TilemapLayerSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_110) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TilemapLoaderUpdater extends sceneobjects.LoaderUpdaterExtension {
                    clearCache(scene) {
                        const keys = scene.cache.tilemap.getKeys();
                        for (const key of keys) {
                            scene.cache.tilemap.remove(key);
                        }
                    }
                    acceptAsset(asset) {
                        return asset instanceof phasereditor2d.pack.core.TilemapTiledJSONAssetPackItem;
                    }
                    async updateLoader(scene, asset) {
                        const item = asset;
                        await item.preload();
                        item.addToPhaserCache(scene.game, scene.getPackCache());
                    }
                    async updateLoaderWithObjData(scene, data) {
                        // nothing
                    }
                }
                sceneobjects.TilemapLoaderUpdater = TilemapLoaderUpdater;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_110.ui || (scene_110.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="../../editor/outline/SceneEditorOutlineExtension.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class TilemapOutlineExtension extends ui.editor.outline.SceneEditorOutlineExtension {
                    isLabelProviderFor(element) {
                        return element instanceof Phaser.Tilemaps.Tileset;
                    }
                    getLabelProvider() {
                        return new controls.viewers.LabelProvider(obj => {
                            if (obj instanceof Phaser.Tilemaps.Tileset) {
                                return obj.name;
                            }
                            return "";
                        });
                    }
                    isCellRendererProviderFor(element) {
                        return this.isLabelProviderFor(element);
                    }
                    getCellRendererProvider() {
                        return new controls.viewers.EmptyCellRendererProvider(obj => {
                            if (obj instanceof Phaser.Tilemaps.Tileset) {
                                if (obj.image) {
                                    const editor = colibri.Platform.getWorkbench().getActiveEditor();
                                    if (editor instanceof ui.editor.SceneEditor) {
                                        const cache = editor.getScene().getPackCache();
                                        const image = cache.getImage(obj.image.key)
                                            || cache.getSpritesheetImage(obj.image.key);
                                        if (image) {
                                            return new controls.viewers.ImageCellRenderer(image);
                                        }
                                    }
                                }
                            }
                            return new controls.viewers.EmptyCellRenderer(false);
                        });
                    }
                    isContentProviderFor(parent) {
                        return parent instanceof sceneobjects.Tilemap;
                    }
                    getContentProvider() {
                        return new TilemapContentProvider();
                    }
                }
                sceneobjects.TilemapOutlineExtension = TilemapOutlineExtension;
                class TilemapContentProvider {
                    getRoots(input) {
                        return [];
                    }
                    getChildren(parent) {
                        if (parent instanceof sceneobjects.Tilemap) {
                            return parent.tilesets;
                        }
                        return [];
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TilemapSection extends ui.editor.properties.BaseSceneSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.TilemapSection", "Tilemap", false, false);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/tilemap-object.html";
                    }
                    createForm(parent) {
                        const docs = scene.ScenePlugin.getInstance().getPhaserDocs();
                        const comp = this.createGridElement(parent, 2);
                        {
                            this.createLabel(comp, "Asset Key", docs.getDoc("Phaser.GameObjects.GameObjectFactory.tilemap(key)"));
                            const text = this.createText(comp, true);
                            this.addUpdater(() => {
                                text.value = this.getSelectionFirstElement().getTilemapAssetKey();
                            });
                        }
                        {
                            this.createLabel(comp, "Tile Width", docs.getDoc("Phaser.Tilemaps.Tilemap.tileWidth"));
                            const text = this.createText(comp, true);
                            this.addUpdater(() => {
                                text.value = this.getSelectionFirstElement().tileWidth.toString();
                            });
                        }
                        {
                            this.createLabel(comp, "Tile Height", docs.getDoc("Phaser.Tilemaps.Tilemap.tileHeight"));
                            const text = this.createText(comp, true);
                            this.addUpdater(() => {
                                text.value = this.getSelectionFirstElement().tileHeight.toString();
                            });
                        }
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.Tilemap;
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.TilemapSection = TilemapSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_111) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TilesetPreviewSection extends ui.editor.properties.BaseSceneSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.TilesetPreviewSection", "Tileset Preview", true, false);
                    }
                    createForm(parent) {
                        colibri.ui.ide.properties.BaseImagePreviewSection.createSectionForm(parent, this, () => this.getSelectedImage());
                    }
                    hasMenu() {
                        return false;
                    }
                    getSelectedImage() {
                        const tileset = this.getSelectionFirstElement();
                        if (tileset.image) {
                            const key = tileset.image.key;
                            const tilemap = sceneobjects.Tilemap.getTilemapFromTileset(tileset);
                            if (tilemap) {
                                const scene = tilemap.scene;
                                return scene.getPackCache().getImage(key) || scene.getPackCache().getSpritesheetImage(key);
                            }
                        }
                        return null;
                    }
                    canEdit(obj, n) {
                        return obj instanceof Phaser.Tilemaps.Tileset;
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.TilesetPreviewSection = TilesetPreviewSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_111.ui || (scene_111.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_112) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class TilesetSection extends ui.editor.properties.BaseSceneSection {
                    constructor(page) {
                        super(page, "phasereditor2d.scene.ui.sceneobjects.TilesetSection2", "Tileset", false, false);
                    }
                    createForm(parent) {
                        const comp = this.createGridElement(parent, 2);
                        this.simpleProperty(comp, "name", "Name");
                        {
                            this.createLabel(comp, "Image", this.help("image"));
                            const btn = this.createButton(comp, "", () => this.selectImage());
                            this.addUpdater(() => {
                                let text = "Select Image...";
                                const image = this.getSelectionFirstElement().image;
                                if (image) {
                                    text = image.key;
                                }
                                btn.textContent = text;
                            });
                            controls.Tooltip.tooltip(btn, "Select a new image for this tileset.");
                        }
                        this.simpleProperty(comp, "tileWidth", "Tile Width");
                        this.simpleProperty(comp, "tileHeight", "Tile Height");
                        this.simpleProperty(comp, "tileMargin", "Tile Margin");
                        this.simpleProperty(comp, "tileSpacing", "Tile Spacing");
                    }
                    help(prop) {
                        return scene_112.ScenePlugin.getInstance().getPhaserDocs().getDoc("Phaser.Tilemaps.Tileset." + prop);
                    }
                    simpleProperty(comp, prop, name) {
                        this.createLabel(comp, name, this.help(prop));
                        const text = this.createText(comp, true);
                        this.addUpdater(() => {
                            const tileset = this.getSelectionFirstElement();
                            text.value = tileset[prop].toString();
                        });
                    }
                    async selectImage() {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        const dlg = new phasereditor2d.pack.ui.dialogs.AssetSelectionDialog("tree");
                        dlg.create();
                        dlg.getViewer().setInput(finder.getAssets(i => i instanceof phasereditor2d.pack.core.ImageAssetPackItem
                            || i instanceof phasereditor2d.pack.core.SpritesheetAssetPackItem));
                        dlg.setSelectionCallback(async (sel) => {
                            const editor = this.getEditor();
                            const scene = this.getEditor().getScene();
                            const imageAsset = sel[0];
                            const textures = scene.sys.textures;
                            const imageKey = imageAsset.getKey();
                            let texture;
                            if (textures.exists(imageKey)) {
                                texture = textures.get(imageKey);
                            }
                            else {
                                const loaderExt = scene_112.ScenePlugin.getInstance().getLoaderUpdaterForAsset(imageAsset);
                                await loaderExt.updateLoader(scene, imageAsset);
                                texture = textures.get(imageKey);
                            }
                            editor.getUndoManager().add(new ui.editor.undo.SceneSnapshotOperation(editor, async () => {
                                const tileset = this.getSelectionFirstElement();
                                tileset.setImage(texture);
                                this.getEditor().refreshScene();
                            }));
                        });
                    }
                    canEdit(obj, n) {
                        return obj instanceof Phaser.Tilemaps.Tileset;
                    }
                    canEditNumber(n) {
                        return n === 1;
                    }
                }
                sceneobjects.TilesetSection = TilesetSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_112.ui || (scene_112.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_113) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TileSprite extends Phaser.GameObjects.TileSprite {
                    _editorSupport;
                    constructor(scene, x, y, width, height, texture, frame) {
                        super(scene, x, y, width, height, texture, frame);
                        this._editorSupport = new sceneobjects.TileSpriteEditorSupport(this, scene);
                    }
                    getEditorSupport() {
                        return this._editorSupport;
                    }
                }
                sceneobjects.TileSprite = TileSprite;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_113.ui || (scene_113.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var code = scene.core.code;
                class TileSpriteCodeDOMBuilder extends sceneobjects.BaseImageCodeDOMBuilder {
                    constructor() {
                        super("tileSprite");
                    }
                    buildCreatePrefabInstanceCodeDOM(args) {
                        const obj = args.obj;
                        const support = obj.getEditorSupport();
                        const call = args.methodCallDOM;
                        call.arg(args.sceneExpr);
                        this.buildCreatePrefabInstanceCodeDOM_XY_Arguments(args);
                        this.buildCreatePrefabInstanceCodeDOM_Size_Arguments(args);
                        if (support.isUnlockedProperty(sceneobjects.TextureComponent.texture)) {
                            this.addTextureFrameArgsToObjectFactoryMethodCallDOM(args.methodCallDOM, args.obj);
                        }
                    }
                    buildPrefabConstructorDeclarationCodeDOM(args) {
                        const ctr = args.ctrDeclCodeDOM;
                        ctr.arg("x", "number", true);
                        ctr.arg("y", "number", true);
                        ctr.arg("width", "number", true);
                        ctr.arg("height", "number", true);
                        ctr.arg("texture", "string", true);
                        ctr.arg("frame", "number | string", true);
                    }
                    buildPrefabConstructorDeclarationSupperCallCodeDOM(args) {
                        const obj = args.prefabObj;
                        const support = obj.getEditorSupport();
                        const call = args.superMethodCallCodeDOM;
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_XYParameters(args);
                        if (support.isUnlockedProperty(sceneobjects.SizeComponent.width)) {
                            call.arg("width ?? " + obj.width);
                            call.arg("height ?? " + obj.height);
                        }
                        else {
                            call.arg("width");
                            call.arg("height");
                        }
                        this.buildPrefabConstructorDeclarationSupperCallCodeDOM_TextureParameters(args, call);
                    }
                    buildCreateObjectWithFactoryCodeDOM(args) {
                        const obj = args.obj;
                        const call = new code.MethodCallCodeDOM("tileSprite", args.gameObjectFactoryExpr);
                        call.argFloat(obj.x);
                        call.argFloat(obj.y);
                        call.argFloat(obj.width);
                        call.argFloat(obj.height);
                        this.addTextureFrameArgsToObjectFactoryMethodCallDOM(call, obj);
                        return call;
                    }
                }
                sceneobjects.TileSpriteCodeDOMBuilder = TileSpriteCodeDOMBuilder;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TileSpriteComponent extends sceneobjects.Component {
                    static tilePositionX = sceneobjects.SimpleProperty("tilePositionX", 0, "X", "phaser:Phaser.GameObjects.TileSprite.tilePositionX", false, null, 1);
                    static tilePositionY = sceneobjects.SimpleProperty("tilePositionY", 0, "Y", "phaser:Phaser.GameObjects.TileSprite.tilePositionY", false, null, 1);
                    static tileScaleX = sceneobjects.SimpleProperty("tileScaleX", 1, "X", "Phaser.GameObjects.TileSprite.tileScaleX", false, null, 0.05, 0.01);
                    static tileScaleY = sceneobjects.SimpleProperty("tileScaleY", 1, "Y", "Phaser.GameObjects.TileSprite.tileScaleY", false, null, 0.05, 0.01);
                    static tilePosition = {
                        label: "Tile Position",
                        tooltip: "phaser:Phaser.GameObjects.TileSprite.setTilePosition",
                        x: TileSpriteComponent.tilePositionX,
                        y: TileSpriteComponent.tilePositionY
                    };
                    static tileScale = {
                        label: "Tile Scale",
                        tooltip: "phaser:Phaser.GameObjects.TileSprite.setTileScale",
                        x: TileSpriteComponent.tileScaleX,
                        y: TileSpriteComponent.tileScaleY
                    };
                    constructor(obj) {
                        super(obj, [
                            TileSpriteComponent.tilePositionX,
                            TileSpriteComponent.tilePositionY,
                            TileSpriteComponent.tileScaleX,
                            TileSpriteComponent.tileScaleY
                        ]);
                    }
                    buildSetObjectPropertiesCodeDOM(args) {
                        this.buildSetObjectPropertyCodeDOM_FloatProperty(args, TileSpriteComponent.tilePositionX, TileSpriteComponent.tilePositionY, TileSpriteComponent.tileScaleX, TileSpriteComponent.tileScaleY);
                    }
                }
                sceneobjects.TileSpriteComponent = TileSpriteComponent;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_114) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TileSpriteEditorSupport extends sceneobjects.BaseImageEditorSupport {
                    constructor(obj, scene) {
                        super(sceneobjects.TileSpriteExtension.getInstance(), obj, scene);
                        this.addComponent(new sceneobjects.SizeComponent(obj));
                        this.addComponent(new sceneobjects.TileSpriteComponent(obj));
                    }
                    setInteractive() {
                        this.getObject().setInteractive(sceneobjects.interactive_getAlpha_RenderTexture);
                    }
                }
                sceneobjects.TileSpriteEditorSupport = TileSpriteEditorSupport;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_114.ui || (scene_114.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_115) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TileSpriteExtension extends sceneobjects.BaseImageExtension {
                    static _instance = new TileSpriteExtension();
                    static getInstance() {
                        return this._instance;
                    }
                    constructor() {
                        super({
                            phaserTypeName: "Phaser.GameObjects.TileSprite",
                            typeName: "TileSprite",
                            category: scene_115.SCENE_OBJECT_IMAGE_CATEGORY,
                            icon: phasereditor2d.resources.getIconDescriptor(phasereditor2d.resources.ICON_TILESPRITE_TYPE)
                        });
                    }
                    adaptDataAfterTypeConversion(serializer, originalObject, extraData) {
                        super.adaptDataAfterTypeConversion(serializer, originalObject, extraData);
                        const obj = originalObject;
                        const width = obj.width === undefined ? 20 : obj.width;
                        const height = obj.height === undefined ? 20 : obj.height;
                        serializer.getData()[sceneobjects.SizeComponent.width.name] = width;
                        serializer.getData()[sceneobjects.SizeComponent.height.name] = height;
                    }
                    getCodeDOMBuilder() {
                        return new sceneobjects.TileSpriteCodeDOMBuilder();
                    }
                    newObject(scene, x, y, key, frame) {
                        if (key) {
                            return new sceneobjects.TileSprite(scene, x, y, 0, 0, key, frame);
                        }
                        return new sceneobjects.TileSprite(scene, x, y, 64, 64, null, null);
                    }
                }
                sceneobjects.TileSpriteExtension = TileSpriteExtension;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_115.ui || (scene_115.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TileSpriteSection extends sceneobjects.SceneGameObjectSection {
                    static SECTION_ID = "phasereditor2d.scene.ui.sceneobjects.TileSprite";
                    constructor(page) {
                        super(page, TileSpriteSection.SECTION_ID, "Tile Sprite", false, true);
                    }
                    getSectionHelpPath() {
                        return "scene-editor/tile-sprite-object.html#tile-sprite-properties";
                    }
                    createMenu(menu) {
                        this.createToolMenuItem(menu, sceneobjects.SizeTool.ID);
                        menu.addSeparator();
                        super.createMenu(menu);
                    }
                    createForm(parent) {
                        const comp = this.createGridElementWithPropertiesXY(parent);
                        this.createPropertyXYRow(comp, sceneobjects.TileSpriteComponent.tilePosition);
                        this.createPropertyXYRow(comp, sceneobjects.TileSpriteComponent.tileScale);
                    }
                    canEdit(obj, n) {
                        return obj instanceof sceneobjects.TileSprite && n > 0;
                    }
                    canEditNumber(n) {
                        return n > 0;
                    }
                }
                sceneobjects.TileSpriteSection = TileSpriteSection;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./StringPropertyType.ts" />
/// <reference path="./AbstractDialogPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class AbstractAssetKeyPropertyType extends sceneobjects.AbstractDialogPropertyType {
                    async updateIcon(iconControl, value) {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        const icon = this.getIcon(finder, value);
                        if (icon) {
                            iconControl.setIcon(icon);
                        }
                    }
                    getIcon(finder, value) {
                        return null;
                    }
                    async createViewer() {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.ui.sceneobjects.SelectAssetDialog." + this.getId());
                        viewer.setCellRendererProvider(new CellRendererProvider(finder, "tree"));
                        viewer.setLabelProvider(new phasereditor2d.pack.ui.viewers.AssetPackLabelProvider());
                        viewer.setTreeRenderer(new controls.viewers.TreeViewerRenderer(viewer));
                        viewer.setContentProvider(new AssetKeyContentProvider());
                        return viewer;
                    }
                    async loadViewerInput(viewer) {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        viewer.setInput(finder.getPacks());
                        for (const pack of finder.getPacks()) {
                            viewer.setExpanded(pack, true);
                        }
                    }
                    valueToString(viewer, selected) {
                        if (selected instanceof phasereditor2d.pack.core.AssetPackImageFrame) {
                            return this.formatKeyFrame(selected.getPackItem().getKey(), selected.getName());
                        }
                        const key = viewer.getLabelProvider().getLabel(selected);
                        return this.formatKeyFrame(key);
                    }
                    formatKeyFrame(key, frame) {
                        if (frame === undefined || frame === null) {
                            return key;
                        }
                        return frame.toString();
                    }
                }
                sceneobjects.AbstractAssetKeyPropertyType = AbstractAssetKeyPropertyType;
                class CellRendererProvider extends phasereditor2d.pack.ui.viewers.AssetPackCellRendererProvider {
                    _finder;
                    constructor(finder, layout) {
                        super(layout);
                        this._finder = finder;
                    }
                    getCellRenderer(element) {
                        if (element instanceof phasereditor2d.pack.core.AnimationConfigInPackItem) {
                            return new phasereditor2d.pack.ui.viewers.AnimationConfigCellRenderer();
                        }
                        return super.getCellRenderer(element);
                    }
                }
                class AssetKeyContentProvider {
                    getRoots(input) {
                        return input;
                    }
                    getChildren(parent) {
                        if (parent instanceof phasereditor2d.pack.core.AssetPack) {
                            return parent.getItems();
                        }
                        if (parent instanceof phasereditor2d.pack.core.ImageAssetPackItem) {
                            return [];
                        }
                        if (parent instanceof phasereditor2d.pack.core.ImageFrameContainerAssetPackItem) {
                            return parent.getFrames();
                        }
                        if (parent instanceof phasereditor2d.pack.core.BaseAnimationsAssetPackItem) {
                            return parent.getAnimations();
                        }
                        return [];
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./AbstractAssetKeyPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AnimationKeyPropertyType extends sceneobjects.AbstractAssetKeyPropertyType {
                    constructor() {
                        super({
                            id: "animation-key",
                            name: "Animation Key",
                            dialogTitle: "Select Animation Key",
                            hasCustomIcon: true
                        });
                    }
                    getIcon(finder, value) {
                        return AnimationKeyPropertyType.getAnimationIcon(finder, value);
                    }
                    static getAnimationIcon(finder, value) {
                        const animation = finder.getPacks()
                            .flatMap(pack => pack.getItems())
                            .filter(item => item instanceof phasereditor2d.pack.core.BaseAnimationsAssetPackItem)
                            .flatMap((item) => item.getAnimations())
                            .find(anim => anim.getKey() === value);
                        if (animation) {
                            return animation.getPreviewImageAsset();
                        }
                        return null;
                    }
                    async createViewer() {
                        const viewer = await super.createViewer();
                        viewer.setCellSize(64, true);
                        viewer.setContentProvider(new AnimationKeyContentProvider());
                        return viewer;
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon) {
                        super.createInspectorPropertyEditor(section, parent, userProp, lockIcon, async () => {
                            const finder = new phasereditor2d.pack.core.PackFinder();
                            await finder.preload();
                            const values = section.getSelection()
                                .map(o => userProp.getComponentProperty().getValue(o));
                            const key = section.flatValues_StringOneOrNothing(values);
                            const anim = finder.findAnimationByKey(key);
                            if (anim) {
                                const dlg = new sceneobjects.AnimationPreviewDialog(anim.getParent(), {
                                    key
                                });
                                dlg.create();
                            }
                            else {
                                alert("Animation key not found.");
                            }
                        });
                    }
                    createEditorElement(getValue, setValue) {
                        return super.createEditorElement(getValue, setValue, async () => {
                            const finder = new phasereditor2d.pack.core.PackFinder();
                            await finder.preload();
                            const key = getValue();
                            const anim = finder.findAnimationByKey(key);
                            if (anim) {
                                const dlg = new sceneobjects.AnimationPreviewDialog(anim.getParent(), {
                                    key
                                });
                                dlg.create();
                            }
                            else {
                                alert("Animation key not found.");
                            }
                        });
                    }
                }
                sceneobjects.AnimationKeyPropertyType = AnimationKeyPropertyType;
                class AnimationKeyContentProvider {
                    getRoots(input) {
                        const packs = input;
                        return packs
                            .flatMap(pack => pack.getItems())
                            .filter(item => item instanceof phasereditor2d.pack.core.BaseAnimationsAssetPackItem)
                            .flatMap((item) => item.getAnimations());
                    }
                    getChildren(parent) {
                        return [];
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./StringPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AssetKeyPropertyType extends sceneobjects.AbstractAssetKeyPropertyType {
                    constructor() {
                        super({
                            id: "asset-key",
                            name: "Asset Key",
                            dialogTitle: "Select Asset Key"
                        });
                    }
                }
                sceneobjects.AssetKeyPropertyType = AssetKeyPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class AudioKeyPropertyType extends sceneobjects.AbstractAssetKeyPropertyType {
                    constructor() {
                        super({
                            id: "audio-key",
                            name: "Audio Key",
                            dialogTitle: "Select Audio Key"
                        });
                    }
                    getDialogSize() {
                        const size = super.getDialogSize();
                        size.height = window.innerHeight / 2;
                        return size;
                    }
                    async createViewer() {
                        const viewer = await super.createViewer();
                        viewer.setContentProvider(new AudioKeyContentProvider());
                        return viewer;
                    }
                }
                sceneobjects.AudioKeyPropertyType = AudioKeyPropertyType;
                class AudioKeyContentProvider {
                    getRoots(input) {
                        const packs = input;
                        return packs
                            .flatMap(pack => pack.getItems())
                            .filter(item => item instanceof phasereditor2d.pack.core.AudioAssetPackItem);
                    }
                    getChildren(parent) {
                        return [];
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="UserPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class BooleanPropertyType extends sceneobjects.UserPropertyType {
                    constructor() {
                        super("boolean", false);
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon) {
                        section.createPropertyBoolean(parent, userProp.getComponentProperty(), lockIcon);
                    }
                    getName() {
                        return "Boolean";
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_BooleanProperty(args, userProp.getComponentProperty());
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        return this.buildBooleanFieldCode(prop, value);
                    }
                    createEditorElement(getValue, setValue) {
                        const element = document.createElement("input");
                        element.type = "checkbox";
                        element.classList.add("formCheckbox");
                        element.addEventListener("change", e => {
                            const value = element.checked;
                            setValue(value);
                        });
                        const update = () => {
                            element.checked = getValue();
                        };
                        return {
                            element,
                            update
                        };
                    }
                }
                sceneobjects.BooleanPropertyType = BooleanPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./UserPropertyType.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ColorPropertyType extends sceneobjects.StringPropertyType {
                    constructor(typeId = "color") {
                        super(typeId, "#ffffff");
                    }
                    getName() {
                        return "Color";
                    }
                    createEditorElement(getValue, setValue) {
                        const formBuilder = new controls.properties.FormBuilder();
                        const colorForm = formBuilder.createColor(undefined, false, true);
                        colorForm.text.addEventListener("change", e => {
                            setValue(colorForm.text.value);
                        });
                        const update = () => {
                            colorForm.text.value = getValue();
                            colorForm.btn.style.background = colorForm.text.value;
                        };
                        return {
                            element: colorForm.element,
                            update
                        };
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon) {
                        section.createPropertyColorRow(parent, userProp.getComponentProperty(), true, lockIcon);
                    }
                }
                sceneobjects.ColorPropertyType = ColorPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./UserPropertyType.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class EventPropertyType extends sceneobjects.AbstractDialogPropertyType {
                    constructor() {
                        super({
                            id: "event",
                            dialogTitle: "Select Event",
                            name: "Event Dialog",
                            hasCustomIcon: false
                        });
                    }
                    getName() {
                        return "Event";
                    }
                    isPhaserBuiltIn(value) {
                        return value.startsWith("Phaser.");
                    }
                    getCodeValue(value) {
                        if (this.isPhaserBuiltIn(value)) {
                            return value;
                        }
                        return `"${value}"`;
                    }
                    createDialogInstance(viewer, zoom) {
                        return new EventPropertyDialog(viewer);
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        const codeValue = this.getCodeValue(value);
                        return this.buildExpressionFieldCode(prop, "string", codeValue);
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        const prop = userProp.getComponentProperty();
                        const value = prop.getValue(args.obj);
                        if (this.isPhaserBuiltIn(value)) {
                            comp.buildSetObjectPropertyCodeDOM_StringVerbatimProperty(args, prop);
                        }
                        else {
                            comp.buildSetObjectPropertyCodeDOM_StringProperty(args, prop);
                        }
                    }
                    async createViewer() {
                        const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.editor.EventPropertyType.Dialog");
                        viewer.setCellRendererProvider(new EventCellRendererProvider());
                        viewer.setLabelProvider(new EventLabelProvider());
                        viewer.setStyledLabelProvider(new EventPropertyStyleLabelProvider());
                        viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        return viewer;
                    }
                    valueToString(viewer, value) {
                        return value.eventName;
                    }
                    async loadViewerInput(viewer) {
                        // Phaser events
                        const eventsDocs = scene.ScenePlugin.getInstance().getPhaserEventsDocs();
                        const phaserEventNames = eventsDocs.getKeys().map(k => new PhaserEventItem(k));
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const events = await finder.findUserEvents();
                        // user events
                        const userNames = events.map(e => new UserEventItem(e));
                        // Phaser animation dynamic events
                        const packFinder = new phasereditor2d.pack.core.PackFinder();
                        await packFinder.preload();
                        const animEvents = packFinder
                            .getAssets(i => i instanceof phasereditor2d.pack.core.BaseAnimationsAssetPackItem)
                            .map(i => i)
                            .flatMap(i => i.getAnimations())
                            .map(anim => new AnimationEventItem(`animationcomplete-${anim.getKey()}`, anim));
                        // Spine skeletons dynamic events
                        const spineEvents = (await sceneobjects.SpineUtils.getSpineEventItems()).map(e => new SkeletonEventItem(e));
                        // Phaser keyboard dynamic events
                        const keyboardEvents = [];
                        for (const k of Object.keys(Phaser.Input.Keyboard.KeyCodes)) {
                            keyboardEvents.push(new KeyboardEvent(`keydown-${k}`), new KeyboardEvent(`keyup-${k}`));
                        }
                        viewer.setInput([
                            ...userNames,
                            ...phaserEventNames,
                            ...keyboardEvents,
                            ...animEvents,
                            ...spineEvents
                        ]);
                    }
                }
                sceneobjects.EventPropertyType = EventPropertyType;
                class EventItem {
                    eventName;
                    constructor(eventName) {
                        this.eventName = eventName;
                    }
                    getPhaserHelp(eventName) {
                        const docs = scene.ScenePlugin.getInstance().getPhaserEventsDocs();
                        return docs.getDoc(eventName, false) || "";
                    }
                }
                class PhaserEventItem extends EventItem {
                    phaserNamespace;
                    constantName;
                    constructor(eventName) {
                        super(eventName);
                        const label = eventName;
                        const i = label.lastIndexOf(".");
                        this.phaserNamespace = label.substring(0, i + 1);
                        this.constantName = label.substring(i + 1);
                    }
                    async getHelp() {
                        return this.getPhaserHelp(this.eventName);
                    }
                }
                class UserEventItem extends EventItem {
                    userEvent;
                    constructor(userEvent) {
                        super(userEvent.name);
                        this.userEvent = userEvent;
                    }
                    async getHelp() {
                        const userEvents = await scene.ScenePlugin.getInstance().getSceneFinder().findUserEvents();
                        const event = userEvents.find(e => e.name === this.eventName);
                        if (event) {
                            return phasereditor2d.ide.core.PhaserDocs.markdownToHtml(event.help);
                        }
                        return "";
                    }
                }
                class AnimationEventItem extends EventItem {
                    animConfig;
                    constructor(name, animConfig) {
                        super(name);
                        this.animConfig = animConfig;
                    }
                    async getHelp() {
                        return this.getPhaserHelp("Phaser.Animations.Events.ANIMATION_COMPLETE_KEY");
                    }
                }
                class KeyboardEvent extends EventItem {
                    async getHelp() {
                        if (this.eventName.startsWith("keydown-")) {
                            return this.getPhaserHelp("Phaser.Input.Keyboard.Events.KEY_DOWN");
                        }
                        return this.getPhaserHelp("Phaser.Input.Keyboard.Events.KEY_UP");
                    }
                }
                class SkeletonEventItem extends EventItem {
                    spineEvent;
                    constructor(spineEvent) {
                        super(spineEvent.eventName);
                        this.spineEvent = spineEvent;
                    }
                    async getHelp() {
                        return "User spine event defined in the '" + this.spineEvent.spineAsset.getKey() + "' skeleton.";
                    }
                }
                class EventPropertyDialog extends controls.dialogs.ViewerFormDialog {
                    constructor(viewer) {
                        super(viewer, false);
                        this.setSize(undefined, 600, true);
                    }
                    createFormArea(formArea) {
                        const docsArea = document.createElement("div");
                        docsArea.innerHTML = "";
                        formArea.appendChild(docsArea);
                        formArea.classList.add("EventPropertyDialogHelpPane");
                        const viewer = this.getViewer();
                        viewer.eventSelectionChanged.addListener(async (sel) => {
                            const [item] = sel;
                            docsArea.innerHTML = await item.getHelp();
                        });
                    }
                }
                class EventCellRendererProvider {
                    constructor() {
                    }
                    getCellRenderer(element) {
                        if (element instanceof AnimationEventItem) {
                            return new AnimationEventCellRenderer();
                        }
                        else if (element instanceof SkeletonEventItem) {
                            return new SpineEventCellRenderer();
                        }
                        let icon;
                        if (element instanceof UserEventItem) {
                            icon = phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_FILE_TEXT);
                        }
                        else if (element instanceof KeyboardEvent) {
                            icon = phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_KEYBOARD_KEY);
                        }
                        else {
                            icon = phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_BUILD);
                        }
                        if (icon) {
                            return new controls.viewers.IconImageCellRenderer(icon);
                        }
                        return new controls.viewers.EmptyCellRenderer();
                    }
                    async preload(args) {
                        return controls.PreloadResult.RESOURCES_LOADED;
                    }
                }
                class AnimationEventCellRenderer extends phasereditor2d.pack.ui.viewers.AnimationConfigCellRenderer {
                    getAnimationConfig(args) {
                        const item = args.obj;
                        return item.animConfig;
                    }
                }
                class SpineEventCellRenderer extends sceneobjects.SpineSkinCellRenderer {
                    getSkinItem(args) {
                        const event = args.obj;
                        const skins = event.spineEvent.spineAsset.getGuessSkinItems();
                        return skins[Math.floor(skins.length / 2)];
                    }
                }
                class EventLabelProvider {
                    getLabel(obj) {
                        if (obj instanceof SkeletonEventItem) {
                            return obj.eventName + " - " + obj.spineEvent.spineAsset.getKey() + " (Spine)";
                        }
                        return obj.eventName;
                    }
                }
                class EventPropertyStyleLabelProvider {
                    getStyledTexts(obj, dark) {
                        const theme = controls.Controls.getTheme();
                        if (obj instanceof PhaserEventItem) {
                            return [
                                {
                                    color: theme.viewerForeground + "90",
                                    text: obj.phaserNamespace
                                },
                                {
                                    color: theme.viewerForeground,
                                    text: obj.constantName
                                }
                            ];
                        }
                        if (obj instanceof SkeletonEventItem) {
                            return [
                                {
                                    color: theme.viewerForeground,
                                    text: obj.eventName
                                },
                                {
                                    color: theme.viewerForeground + "90",
                                    text: " - " + obj.spineEvent.spineAsset.getKey() + " (Spine)"
                                }
                            ];
                        }
                        return [{
                                color: theme.viewerForeground,
                                text: obj.eventName
                            }];
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./UserPropertyType.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class ExpressionPropertyType extends sceneobjects.UserPropertyType {
                    constructor() {
                        super("expression", "");
                        this.setExpressionType("any");
                    }
                    hasCustomPropertyType() {
                        return true;
                    }
                    getName() {
                        return "Expression";
                    }
                    createEditorElement(getValue, setValue) {
                        const element = document.createElement("input");
                        element.type = "text";
                        element.classList.add("formText");
                        element.addEventListener("change", e => {
                            setValue(element.value);
                        });
                        const update = () => {
                            element.value = getValue();
                        };
                        return {
                            element,
                            update
                        };
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        return this.buildExpressionFieldCode(prop, this.getExpressionType(), value);
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_StringVerbatimProperty(args, userProp.getComponentProperty());
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon) {
                        section.createPropertyStringRow(parent, userProp.getComponentProperty(), lockIcon);
                    }
                }
                sceneobjects.ExpressionPropertyType = ExpressionPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./UserPropertyType.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                var code = scene.core.code;
                class KeyCodePropertyType extends sceneobjects.UserPropertyType {
                    constructor(typeId = "keycode") {
                        super(typeId, "SPACE");
                    }
                    getName() {
                        return "Key Code";
                    }
                    createEditorElement(getValue, setValue) {
                        const formBuilder = new controls.properties.FormBuilder();
                        const btn = formBuilder.createButton(undefined, "Key Code", e => {
                            const viewer = new sceneobjects.KeyboardKeysViewer();
                            const keyCode = getValue();
                            viewer.revealAndSelect(keyCode);
                            const dlg = new controls.dialogs.ViewerDialog(viewer, false);
                            dlg.create();
                            dlg.setTitle("Select Key Code");
                            dlg.addOpenButton("Select", (sel) => {
                                const value = sel[0];
                                setValue(value);
                            }, false);
                            dlg.addCancelButton();
                        });
                        const update = () => {
                            btn.textContent = getValue();
                        };
                        return {
                            element: btn,
                            update
                        };
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon) {
                        section.createKeyCodeRow(parent, userProp.getComponentProperty(), lockIcon);
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        return this.buildExpressionFieldCode(prop, "number", `Phaser.Input.Keyboard.KeyCodes.${value}`);
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM([userProp.getComponentProperty()], args2 => {
                            const dom = new code.AssignPropertyCodeDOM(args2.fieldCodeName, args.objectVarName);
                            dom.value(`Phaser.Input.Keyboard.KeyCodes.${args2.value}`);
                            args.statements.push(dom);
                        });
                    }
                }
                sceneobjects.KeyCodePropertyType = KeyCodePropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="UserPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class NumberPropertyType extends sceneobjects.UserPropertyType {
                    constructor(typeId = "number") {
                        super(typeId, 0);
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon) {
                        section.createPropertyFloatRow(parent, userProp.getComponentProperty(), lockIcon);
                    }
                    getName() {
                        return "Number";
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_FloatProperty(args, userProp.getComponentProperty());
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        return this.buildNumberFieldCode(prop, value);
                    }
                    createEditorElement(getValue, setValue) {
                        const element = document.createElement("input");
                        element.type = "text";
                        element.classList.add("formText");
                        element.addEventListener("change", e => {
                            const value = Number.parseFloat(element.value);
                            setValue(value);
                        });
                        const update = () => {
                            element.value = getValue().toString();
                        };
                        return {
                            element,
                            update
                        };
                    }
                }
                sceneobjects.NumberPropertyType = NumberPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./StringPropertyType.ts" />
/// <reference path="./AbstractDialogPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                var io = colibri.core.io;
                class ObjectConstructorPropertyType extends sceneobjects.AbstractDialogPropertyType {
                    constructor() {
                        super({
                            id: "constructor",
                            dialogTitle: "Select a Type",
                            name: "Object Constructor",
                            hasCustomIcon: true
                        });
                        this.setExpressionType("any");
                    }
                    hasCustomPropertyType() {
                        return true;
                    }
                    getName() {
                        return "Object Constructor";
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        return this.buildExpressionFieldCode(prop, this.getExpressionType(), value);
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_StringVerbatimProperty(args, userProp.getComponentProperty());
                    }
                    async updateIcon(iconControl, value) {
                        let icon = colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER);
                        if (value.startsWith("Phaser.GameObjects.")) {
                            icon = this.findIcon(value) || icon;
                        }
                        else {
                            const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                            const file = finder.getSceneFiles()
                                .find(f => this.valueToString(null, f) === value);
                            if (file) {
                                const cache = ui.SceneThumbnailCache.getInstance();
                                await cache.preload(file);
                                const img = cache.getContent(file);
                                if (img) {
                                    await img.preloadSize();
                                    await img.preload();
                                    icon = img;
                                }
                            }
                        }
                        iconControl.setIcon(icon);
                    }
                    findIcon(type) {
                        const ext = scene.ScenePlugin.getInstance().getGameObjectExtensions().find(ext => ext.getPhaserTypeName() === type);
                        if (ext) {
                            return ext.getIcon();
                        }
                        return undefined;
                    }
                    async createViewer() {
                        const viewer = new controls.viewers.TreeViewer(this.getId());
                        viewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider((element) => {
                            if (element instanceof io.FilePath) {
                                return new ui.viewers.SceneFileCellRenderer();
                            }
                            const icon = this.findIcon(element);
                            if (icon) {
                                return new controls.viewers.IconImageCellRenderer(icon);
                            }
                            return new controls.viewers.EmptyCellRenderer();
                        }));
                        viewer.setLabelProvider(new controls.viewers.LabelProvider((element) => {
                            const label = this.valueToString(viewer, element);
                            return label;
                        }));
                        // viewer.setTreeRenderer(new controls.viewers.GridTreeViewerRenderer(viewer));
                        viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        viewer.setCellSize(32);
                        return viewer;
                    }
                    async loadViewerInput(viewer) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const types = scene.ScenePlugin.getInstance().getGameObjectExtensions().map(ext => ext.getPhaserTypeName());
                        viewer.setInput([...finder.getPrefabFiles(), ...types]);
                    }
                    valueToString(viewer, selected) {
                        if (selected instanceof io.FilePath) {
                            return selected.getNameWithoutExtension();
                        }
                        return selected;
                    }
                }
                sceneobjects.ObjectConstructorPropertyType = ObjectConstructorPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./UserPropertyType.ts"/>
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene_116) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class ObjectVarPropertyType extends sceneobjects.AbstractDialogPropertyType {
                    constructor() {
                        super({
                            id: "object-var",
                            dialogTitle: "Select Object",
                            name: "Object Dialog",
                            hasCustomIcon: true
                        });
                        this.setExpressionType("Phaser.GameObjects.GameObject");
                    }
                    hasCustomPropertyType() {
                        return true;
                    }
                    getName() {
                        return "Object Variable";
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        return this.buildExpressionFieldCode(prop, this.getExpressionType(), value);
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_StringVerbatimProperty(args, userProp.getComponentProperty());
                    }
                    async createViewer() {
                        const viewer = new controls.viewers.TreeViewer("phasereditor2d.scene.editor.ObjectVarExpressionType.Dialog");
                        viewer.setCellRendererProvider(new ui.editor.outline.SceneEditorOutlineRendererProvider());
                        viewer.setLabelProvider(new ui.editor.outline.SceneEditorOutlineLabelProvider());
                        viewer.setStyledLabelProvider(new ui.editor.outline.SceneEditorOutlineStyledLabelProvider());
                        viewer.setContentProvider(new ObjectVarContentProvider(this.getEditor()));
                        return viewer;
                    }
                    valueToString(viewer, value) {
                        const objES = sceneobjects.EditorSupport.getEditorSupport(value);
                        if (objES) {
                            if (objES instanceof sceneobjects.GameObjectEditorSupport && objES.isNestedPrefabInstance()) {
                                return scene_116.core.code.SceneCodeDOMBuilder.getPrefabInstanceVarName(value);
                            }
                            return scene_116.core.code.formatToValidVarName(objES.getLabel());
                        }
                        return scene_116.core.code.formatToValidVarName(viewer.getLabelProvider().getLabel(value));
                    }
                    async loadViewerInput(viewer) {
                        const scene = this.getEditor().getScene();
                        const input = [
                            ...scene.getGameObjects(),
                            ...scene.getPlainObjects(),
                            ...scene.getObjectLists().getLists()
                        ];
                        viewer.setInput(input);
                    }
                    async updateIcon(iconControl, value) {
                        const scene = this.getEditor().getScene();
                        const foundElement = [undefined];
                        scene.visitAllAskChildren(obj => {
                            if (!foundElement[0]) {
                                const objES = obj.getEditorSupport();
                                if (objES.isNestedPrefabInstance()) {
                                    const objVarName = scene_116.core.code.SceneCodeDOMBuilder.getPrefabInstanceVarName(obj);
                                    if (objVarName === value) {
                                        foundElement[0] = obj;
                                        return false;
                                    }
                                }
                                else if (scene_116.core.code.formatToValidVarName(objES.getLabel()) === value) {
                                    foundElement[0] = obj;
                                    return false;
                                }
                                return true;
                            }
                        });
                        let found = foundElement[0];
                        if (!found) {
                            found = scene.getPlainObjects().find(obj => scene_116.core.code.formatToValidVarName(obj.getEditorSupport().getLabel()) === value);
                        }
                        if (!found) {
                            found = scene.getObjectLists().getLists()
                                .find(l => scene_116.core.code.formatToValidVarName(l.getLabel()) === value);
                        }
                        if (found) {
                            const renderer = new ui.editor.outline.SceneEditorOutlineRendererProvider()
                                .getCellRenderer(found);
                            const icon = new controls.viewers.ImageFromCellRenderer(found, renderer, controls.RENDER_ICON_SIZE, controls.RENDER_ICON_SIZE);
                            iconControl.setIcon(icon);
                        }
                        else {
                            iconControl.setIcon(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                        }
                    }
                }
                sceneobjects.ObjectVarPropertyType = ObjectVarPropertyType;
                class ObjectVarContentProvider extends ui.editor.outline.SceneEditorOutlineContentProvider {
                    getRoots(input) {
                        return input;
                    }
                }
                sceneobjects.ObjectVarContentProvider = ObjectVarContentProvider;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene_116.ui || (scene_116.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                var code = scene.core.code;
                class OptionPropertyType extends sceneobjects.UserPropertyType {
                    _options;
                    constructor() {
                        super("option", "");
                        this._options = [];
                    }
                    createInspectorPropertyEditor(section, parent, userProp, lockIcon) {
                        const prop = userProp.getComponentProperty();
                        section.createPropertyEnumRow(parent, prop, lockIcon);
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_StringProperty(args, userProp.getComponentProperty());
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        const decl = this.buildStringFieldCode(prop, value);
                        const typeName = this._options.map(opt => code.CodeDOM.quote(opt)).join("|");
                        decl.setType(typeName);
                        return decl;
                    }
                    getOptions() {
                        return this._options;
                    }
                    setOptions(options) {
                        this._options = options;
                    }
                    writeJSON(data) {
                        super.writeJSON(data);
                        data.options = this._options;
                    }
                    readJSON(data) {
                        super.readJSON(data);
                        this._options = data.options;
                    }
                    getName() {
                        return "Option";
                    }
                    createEditorElement(getValue, setValue) {
                        const items = this._options.map(option => ({
                            name: option,
                            value: option
                        }));
                        const element = document.createElement("button");
                        element.addEventListener("click", e => {
                            const menu = new controls.Menu();
                            for (const item of items) {
                                menu.add(new controls.Action({
                                    text: item.name,
                                    callback: () => {
                                        setValue(item.value);
                                    }
                                }));
                            }
                            menu.createWithEvent(e);
                        });
                        const update = () => {
                            element.innerHTML = getValue();
                        };
                        return { element, update };
                    }
                }
                sceneobjects.OptionPropertyType = OptionPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./PrefabUserPropertyWrapper.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class PrefabOptionUserPropertyWrapper extends sceneobjects.PrefabUserPropertyWrapper {
                    constructor(userProp) {
                        super(userProp);
                    }
                    get values() {
                        return this.getUserProperty().getType().getOptions();
                    }
                    getValueLabel(value) {
                        return value;
                    }
                }
                sceneobjects.PrefabOptionUserPropertyWrapper = PrefabOptionUserPropertyWrapper;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="UserPropertiesManager.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                function PrefabUserPropertyBuilder(prop) {
                    if (prop.getType() instanceof sceneobjects.OptionPropertyType) {
                        return new sceneobjects.PrefabOptionUserPropertyWrapper(prop);
                    }
                    return new sceneobjects.PrefabUserPropertyWrapper(prop);
                }
                sceneobjects.PrefabUserPropertyBuilder = PrefabUserPropertyBuilder;
                class PrefabUserProperties extends sceneobjects.UserPropertiesManager {
                    constructor() {
                        super(PrefabUserPropertyBuilder);
                    }
                }
                sceneobjects.PrefabUserProperties = PrefabUserProperties;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
/// <reference path="./StringPropertyType.ts" />
/// <reference path="./AbstractDialogPropertyType.ts" />
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                var controls = colibri.ui.controls;
                class SceneKeyPropertyType extends sceneobjects.AbstractDialogPropertyType {
                    constructor() {
                        super({
                            id: "scene-key",
                            dialogTitle: "Select Scene Key",
                            name: "Scene Key",
                            hasCustomIcon: true
                        });
                    }
                    async updateIcon(iconControl, value) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const file = finder.getSceneFiles()
                            .find(f => this.valueToString(null, f) === value);
                        if (file) {
                            const cache = ui.SceneThumbnailCache.getInstance();
                            await cache.preload(file);
                            const img = cache.getContent(file);
                            if (img) {
                                await img.preloadSize();
                                await img.preload();
                                iconControl.setIcon(img);
                            }
                            else {
                                iconControl.setIcon(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                            }
                        }
                    }
                    getDialogSize() {
                        return {
                            width: window.innerWidth / 2,
                            height: window.innerHeight / 2
                        };
                    }
                    async createViewer() {
                        const viewer = new controls.viewers.TreeViewer(this.getId());
                        viewer.setCellRendererProvider(new controls.viewers.EmptyCellRendererProvider(() => new ui.viewers.SceneFileCellRenderer()));
                        viewer.setLabelProvider(new controls.viewers.LabelProvider((file) => {
                            const label = this.valueToString(viewer, file);
                            return label;
                        }));
                        viewer.setTreeRenderer(new controls.viewers.GridTreeViewerRenderer(viewer));
                        viewer.setContentProvider(new controls.viewers.ArrayTreeContentProvider());
                        return viewer;
                    }
                    async loadViewerInput(viewer) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const prefabs = new Set(finder.getPrefabFiles());
                        viewer.setInput(finder.getSceneFiles().filter(f => !prefabs.has(f)));
                    }
                    valueToString(viewer, selected) {
                        const data = scene.ScenePlugin.getInstance().getSceneFinder().getSceneData(selected);
                        return data?.settings?.sceneKey || selected.getNameWithoutExtension();
                    }
                }
                sceneobjects.SceneKeyPropertyType = SceneKeyPropertyType;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class TextureConfigPropertyType extends sceneobjects.AbstractAssetKeyPropertyType {
                    constructor() {
                        super({
                            id: "texture-config",
                            name: "Texture Config",
                            dialogTitle: "Select Texture",
                            hasCustomIcon: true
                        });
                    }
                    getDialogSize() {
                        return {
                            width: window.innerWidth * 2 / 3,
                            height: window.innerHeight * 2 / 3
                        };
                    }
                    getIcon(finder, value) {
                        try {
                            const config = JSON.parse(value);
                            if (config) {
                                const result = finder.getAssetPackItemImage(config.key, config.frame);
                                return result;
                            }
                        }
                        catch (e) {
                            // nothing
                        }
                        return null;
                    }
                    revealValue(viewer, value) {
                        try {
                            const obj = JSON.parse(value);
                            const finder = new phasereditor2d.pack.core.PackFinder(...viewer.getInput());
                            const found = finder.getAssetPackItemOrFrame(obj.key, obj.frame);
                            if (found) {
                                viewer.setSelection([found]);
                                viewer.reveal(found);
                            }
                        }
                        catch (e) {
                            // nothing
                        }
                    }
                    buildSetObjectPropertyCodeDOM(comp, args, userProp) {
                        comp.buildSetObjectPropertyCodeDOM_StringVerbatimProperty(args, userProp.getComponentProperty());
                    }
                    buildDeclarePropertyCodeDOM(prop, value) {
                        return this.buildExpressionFieldCode(prop, "{key:string,frame?:string|number}", value);
                    }
                    formatKeyFrame(key, frame) {
                        let data;
                        if (frame !== undefined) {
                            data = { key, frame };
                        }
                        else {
                            data = { key };
                        }
                        return JSON.stringify(data);
                    }
                    async createViewer() {
                        const finder = new phasereditor2d.pack.core.PackFinder();
                        await finder.preload();
                        const viewer = await super.createViewer();
                        viewer.setContentProvider(new TextureContentProvider(finder));
                        viewer.setTreeRenderer(new phasereditor2d.pack.ui.viewers.AssetPackTreeViewerRenderer(viewer, false));
                        viewer.setCellSize(72, true);
                        return viewer;
                    }
                }
                sceneobjects.TextureConfigPropertyType = TextureConfigPropertyType;
                class TextureContentProvider {
                    finder;
                    constructor(finder) {
                        this.finder = finder;
                    }
                    getRoots(input) {
                        return [
                            phasereditor2d.pack.core.IMAGE_TYPE,
                            phasereditor2d.pack.core.SVG_TYPE,
                            phasereditor2d.pack.core.ATLAS_TYPE,
                            phasereditor2d.pack.core.ASEPRITE_TYPE,
                            phasereditor2d.pack.core.SPRITESHEET_TYPE
                        ];
                    }
                    getItems(type) {
                        return this.finder.getPacks()
                            .flatMap(p => p.getItems())
                            .filter(item => item.getType() === type || type === phasereditor2d.pack.core.ATLAS_TYPE &&
                            phasereditor2d.pack.core.AssetPackUtils.isAtlasType(item.getType()));
                    }
                    getChildren(parent) {
                        if (typeof parent === "string") {
                            return this.getItems(parent);
                        }
                        if (parent instanceof phasereditor2d.pack.core.ImageFrameContainerAssetPackItem
                            || parent instanceof phasereditor2d.pack.core.AsepriteAssetPackItem) {
                            if (!(parent instanceof phasereditor2d.pack.core.ImageAssetPackItem)) {
                                return parent.getFrames();
                            }
                        }
                        return [];
                    }
                }
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var sceneobjects;
            (function (sceneobjects) {
                class UserProperty {
                    _info;
                    _componentProperty;
                    _componentPropertyBuilder;
                    _manager;
                    constructor(allProperties, componentPropertyBuilder, info) {
                        this._manager = allProperties;
                        this._componentPropertyBuilder = componentPropertyBuilder;
                        this._info = info;
                    }
                    getManager() {
                        return this._manager;
                    }
                    getComponentProperty() {
                        if (!this._componentProperty) {
                            this._componentProperty = this._componentPropertyBuilder(this);
                        }
                        return this._componentProperty;
                    }
                    getType() {
                        return this._info.type;
                    }
                    getInfo() {
                        return this._info;
                    }
                    getName() {
                        return this._info.name;
                    }
                    getLabel() {
                        return this._info.label;
                    }
                    getTooltip() {
                        return this._info.tooltip;
                    }
                    getDefaultValue() {
                        return this._info.defValue;
                    }
                    isCustomDefinition() {
                        return this._info.customDefinition;
                    }
                    writeJSON(data) {
                        data.name = this._info.name;
                        data.label = this._info.label;
                        data.tooltip = this._info.tooltip;
                        data.defValue = this._info.defValue;
                        data.customDefinition = this._info.customDefinition;
                        data.type = {};
                        this._info.type.writeJSON(data.type);
                    }
                    readJSON(data) {
                        const typeData = data.type;
                        const typeId = typeData.id;
                        const propType = scene.ScenePlugin.getInstance().getUserPropertyType(typeId);
                        propType.readJSON(typeData);
                        this._info = {
                            name: data.name,
                            label: data.label,
                            tooltip: data.tooltip,
                            defValue: data.defValue,
                            customDefinition: data.customDefinition === undefined ? false : data.customDefinition,
                            type: propType
                        };
                        if (this._info.defValue === null || this._info.defValue === undefined) {
                            this._info.defValue = propType.getDefaultValue();
                        }
                    }
                    buildFieldDeclarationCode() {
                        return this.getType().buildDeclarePropertyCodeDOM(this, this._info.defValue);
                    }
                }
                sceneobjects.UserProperty = UserProperty;
            })(sceneobjects = ui.sceneobjects || (ui.sceneobjects = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var viewers;
            (function (viewers) {
                var controls = colibri.ui.controls;
                class ObjectExtensionAndPrefabViewer extends controls.viewers.TreeViewer {
                    static PREFAB_SECTION = "User Prefab";
                    static SECTIONS = [
                        ...scene.SCENE_OBJECT_CATEGORIES,
                        ObjectExtensionAndPrefabViewer.PREFAB_SECTION,
                    ];
                    constructor() {
                        super("phasereditor2d.scene.ui.viewers.ObjectExtensionAndPrefabViewer");
                        const treeRenderer = new controls.viewers.GridTreeViewerRenderer(this);
                        treeRenderer.setPaintItemShadow(true);
                        treeRenderer.setSectionCriteria(obj => ObjectExtensionAndPrefabViewer.SECTIONS.indexOf(obj) >= 0);
                        this.setLabelProvider(new ui.blocks.SceneEditorBlocksLabelProvider());
                        this.setCellRendererProvider(new CellRendererProvider());
                        this.setContentProvider(new ObjectExtensionAndPrefabContentProvider());
                        this.setTreeRenderer(treeRenderer);
                        this.setInput(ObjectExtensionAndPrefabViewer.SECTIONS);
                        this.setCellSize(78, true);
                    }
                }
                viewers.ObjectExtensionAndPrefabViewer = ObjectExtensionAndPrefabViewer;
                class CellRendererProvider extends ui.blocks.SceneEditorBlocksCellRendererProvider {
                    getCellRenderer(element) {
                        if (element === ObjectExtensionAndPrefabViewer.PREFAB_SECTION) {
                            return new controls.viewers.IconImageCellRenderer(colibri.ColibriPlugin.getInstance().getIcon(colibri.ICON_FOLDER));
                        }
                        return super.getCellRenderer(element);
                    }
                }
                class ObjectExtensionAndPrefabContentProvider {
                    getRoots(input) {
                        return ObjectExtensionAndPrefabViewer.SECTIONS;
                    }
                    getChildren(parent) {
                        const plugin = scene.ScenePlugin.getInstance();
                        if (scene.SCENE_OBJECT_CATEGORY_SET.has(parent)) {
                            return plugin.getGameObjectExtensions().filter(ext => ext.getCategory() === parent);
                        }
                        else if (parent === ObjectExtensionAndPrefabViewer.PREFAB_SECTION) {
                            return plugin.getSceneFinder().getPrefabFiles();
                        }
                        return [];
                    }
                }
                viewers.ObjectExtensionAndPrefabContentProvider = ObjectExtensionAndPrefabContentProvider;
            })(viewers = ui.viewers || (ui.viewers = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var viewers;
            (function (viewers) {
                var controls = colibri.ui.controls;
                class ObjectExtensionCellRendererProvider extends controls.viewers.EmptyCellRendererProvider {
                    constructor() {
                        super();
                    }
                    getCellRenderer(element) {
                        const ext = element;
                        return ext.getBlockCellRenderer();
                    }
                }
                viewers.ObjectExtensionCellRendererProvider = ObjectExtensionCellRendererProvider;
            })(viewers = ui.viewers || (ui.viewers = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var viewers;
            (function (viewers) {
                var controls = colibri.ui.controls;
                class ObjectExtensionLabelProvider extends controls.viewers.LabelProvider {
                    getLabel(ext) {
                        return ext.getTypeName();
                    }
                }
                viewers.ObjectExtensionLabelProvider = ObjectExtensionLabelProvider;
            })(viewers = ui.viewers || (ui.viewers = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var viewers;
            (function (viewers) {
                class PhaserTypeSymbol {
                    typeName;
                    static _symbols;
                    static getSymbols() {
                        if (!this._symbols) {
                            this._symbols = scene.ScenePlugin.getInstance().getGameObjectExtensions()
                                .map(e => new PhaserTypeSymbol(e.getPhaserTypeName()));
                            this._symbols = [new PhaserTypeSymbol("Phaser.Scene"), ...this._symbols];
                        }
                        return this._symbols;
                    }
                    _displayName;
                    constructor(typeName) {
                        this.typeName = typeName;
                        this._displayName = typeName.split(".").pop();
                    }
                    getPhaserType() {
                        return this.typeName;
                    }
                    getDisplayName() {
                        return this._displayName;
                    }
                }
                viewers.PhaserTypeSymbol = PhaserTypeSymbol;
            })(viewers = ui.viewers || (ui.viewers = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
var phasereditor2d;
(function (phasereditor2d) {
    var scene;
    (function (scene) {
        var ui;
        (function (ui) {
            var viewers;
            (function (viewers) {
                class SceneFileCellRenderer {
                    renderCell(args) {
                        const finder = scene.ScenePlugin.getInstance().getSceneFinder();
                        const file = args.obj;
                        let image;
                        if (finder.isScriptPrefabFile(file)) {
                            image = phasereditor2d.resources.getIcon(phasereditor2d.resources.ICON_BUILD);
                        }
                        else {
                            image = ui.SceneThumbnailCache.getInstance().getContent(file);
                        }
                        if (image) {
                            image.paint(args.canvasContext, args.x, args.y, args.w, args.h, args.center);
                        }
                    }
                    cellHeight(args) {
                        return args.viewer.getCellSize();
                    }
                    async preload(args) {
                        const file = args.obj;
                        return ui.SceneThumbnailCache.getInstance().preload(file);
                    }
                }
                viewers.SceneFileCellRenderer = SceneFileCellRenderer;
            })(viewers = ui.viewers || (ui.viewers = {}));
        })(ui = scene.ui || (scene.ui = {}));
    })(scene = phasereditor2d.scene || (phasereditor2d.scene = {}));
})(phasereditor2d || (phasereditor2d = {}));
