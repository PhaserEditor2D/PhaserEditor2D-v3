{
  "Phaser.GameObjects.Image": "An Image Game Object.\n\nAn Image is a light-weight Game Object useful for the display of static images in your game,\nsuch as logos, backgrounds, scenery or other non-animated elements. Images can have input\nevents and physics bodies, or be tweened, tinted or scrolled. The main difference between an\nImage and a Sprite is that you cannot animate an Image as they do not have the Animation component.",
  "Phaser.GameObjects.Sprite": "A Sprite Game Object.\n\nA Sprite Game Object is used for the display of both static and animated images in your game.\nSprites can have input events and physics bodies. They can also be tweened, tinted, scrolled\nand animated.\n\nThe main difference between a Sprite and an Image Game Object is that you cannot animate Images.\nAs such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation\nComponent. If you do not require animation then you can safely use Images to replace Sprites in all cases.",
  "Phaser.GameObjects.Container": "A Container Game Object.\n\nA Container, as the name implies, can 'contain' other types of Game Object.\nWhen a Game Object is added to a Container, the Container becomes responsible for the rendering of it.\nBy default it will be removed from the Display List and instead added to the Containers own internal list.\n\nThe position of the Game Object automatically becomes relative to the position of the Container.\n\nThe transform point of a Container is 0x0 (in local space) and that cannot be changed. The children you add to the\nContainer should be positioned with this value in mind. I.e. you should treat 0x0 as being the center of\nthe Container, and position children positively and negative around it as required.\n\nWhen the Container is rendered, all of its children are rendered as well, in the order in which they exist\nwithin the Container. Container children can be repositioned using methods such as `MoveUp`, `MoveDown` and `SendToBack`.\n\nIf you modify a transform property of the Container, such as `Container.x` or `Container.rotation` then it will\nautomatically influence all children as well.\n\nContainers can include other Containers for deeply nested transforms.\n\nContainers can have masks set on them and can be used as a mask too. However, Container children cannot be masked.\nThe masks do not 'stack up'. Only a Container on the root of the display list will use its mask.\n\nContainers can be enabled for input. Because they do not have a texture you need to provide a shape for them\nto use as their hit area. Container children can also be enabled for input, independent of the Container.\n\nIf input enabling a _child_ you should not set both the `origin` and a **negative** scale factor on the child,\nor the input area will become misaligned.\n\nContainers can be given a physics body for either Arcade Physics, Impact Physics or Matter Physics. However,\nif Container _children_ are enabled for physics you may get unexpected results, such as offset bodies,\nif the Container itself, or any of its ancestors, is positioned anywhere other than at 0 x 0. Container children\nwith physics do not factor in the Container due to the excessive extra calculations needed. Please structure\nyour game to work around this.\n\nIt's important to understand the impact of using Containers. They add additional processing overhead into\nevery one of their children. The deeper you nest them, the more the cost escalates. This is especially true\nfor input events. You also loose the ability to set the display depth of Container children in the same\nflexible manner as those not within them. In short, don't use them for the sake of it. You pay a small cost\nevery time you create one, try to structure your game around avoiding that where possible.",
  "Phaser.GameObjects.Components.Transform.x": "The x position of this Game Object.",
  "Phaser.GameObjects.Components.Transform.y": "The y position of this Game Object.",
  "Phaser.GameObjects.Components.Transform.setPosition": "Sets the position of this Game Object.",
  "Phaser.GameObjects.Components.Transform.scaleX": "The horizontal scale of this Game Object.",
  "Phaser.GameObjects.Components.Transform.scaleY": "The vertical scale of this Game Object.",
  "Phaser.GameObjects.Components.Transform.angle": "The angle of this Game Object as expressed in degrees.\n\nPhaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left\nand -90 is up.\n\nIf you prefer to work in radians, see the `rotation` property instead.",
  "Phaser.GameObjects.Components.Origin.originX": "The horizontal origin of this Game Object.\nThe origin maps the relationship between the size and position of the Game Object.\nThe default value is 0.5, meaning all Game Objects are positioned based on their center.\nSetting the value to 0 means the position now relates to the left of the Game Object.\nSet this value with `setOrigin()`.",
  "Phaser.GameObjects.Components.Origin.originY": "The vertical origin of this Game Object.\nThe origin maps the relationship between the size and position of the Game Object.\nThe default value is 0.5, meaning all Game Objects are positioned based on their center.\nSetting the value to 0 means the position now relates to the top of the Game Object.\nSet this value with `setOrigin()`.",
  "Phaser.GameObjects.Components.Origin.setOrigin": "Sets the origin of this Game Object.\n\nThe values are given in the range 0 to 1.",
  "Phaser.GameObjects.Components.Alpha.alpha": "The alpha value of the Game Object.\n\nThis is a global value, impacting the entire Game Object, not just a region of it.",
  "Phaser.GameObjects.Components.Alpha.alphaTopLeft": "The alpha value starting from the top-left of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Alpha.alphaTopRight": "The alpha value starting from the top-right of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Alpha.alphaBottomLeft": "The alpha value starting from the bottom-left of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Alpha.alphaBottomRight": "The alpha value starting from the bottom-right of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Flip.flipX": "The horizontally flipped state of the Game Object.\n\nA Game Object that is flipped horizontally will render inversed on the horizontal axis.\nFlipping always takes place from the middle of the texture and does not impact the scale value.\nIf this Game Object has a physics body, it will not change the body. This is a rendering toggle only.",
  "Phaser.GameObjects.Components.Flip.flipY": "The vertically flipped state of the Game Object.\n\nA Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\nFlipping always takes place from the middle of the texture and does not impact the scale value.\nIf this Game Object has a physics body, it will not change the body. This is a rendering toggle only.",
  "Phaser.GameObjects.Components.Visible.visible": "The visible state of the Game Object.\n\nAn invisible Game Object will skip rendering, but will still process update logic.",
  "Phaser.GameObjects.Components.Tint.tint": "The tint value being applied to the whole of the Game Object.\nThis property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.",
  "Phaser.GameObjects.Components.Tint.tintFill": "The tint fill mode.\n\n`false` = An additive tint (the default), where vertices colors are blended with the texture.\n`true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.",
  "Phaser.GameObjects.Components.Tint.tintTopLeft": "The tint value being applied to the top-left vertice of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.\nThe value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.",
  "Phaser.GameObjects.Components.Tint.tintTopRight": "The tint value being applied to the top-right vertice of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.\nThe value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.",
  "Phaser.GameObjects.Components.Tint.tintBottomLeft": "The tint value being applied to the bottom-left vertice of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.\nThe value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.",
  "Phaser.GameObjects.Components.Tint.tintBottomRight": "The tint value being applied to the bottom-right vertice of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.\nThe value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.",
  "Phaser.GameObjects.TileSprite": "A TileSprite is a Sprite that has a repeating texture.\n\nThe texture can be scrolled and scaled independently of the TileSprite itself. Textures will automatically wrap and\nare designed so that you can create game backdrops using seamless textures as a source.\n\nYou shouldn't ever create a TileSprite any larger than your actual canvas size. If you want to create a large repeating background\nthat scrolls across the whole map of your game, then you create a TileSprite that fits the canvas size and then use the `tilePosition`\nproperty to scroll the texture as the player moves. If you create a TileSprite that is thousands of pixels in size then it will\nconsume huge amounts of memory and cause performance issues. Remember: use `tilePosition` to scroll your texture and `tileScale` to\nadjust the scale of the texture - don't resize the sprite itself or make it larger than it needs.\n\nAn important note about Tile Sprites and NPOT textures: Internally, TileSprite textures use GL_REPEAT to provide\nseamless repeating of the textures. This, combined with the way in which the textures are handled in WebGL, means\nthey need to be POT (power-of-two) sizes in order to wrap. If you provide a NPOT (non power-of-two) texture to a\nTileSprite it will generate a POT sized canvas and draw your texture to it, scaled up to the POT size. It's then\nscaled back down again during rendering to the original dimensions. While this works, in that it allows you to use\nany size texture for a Tile Sprite, it does mean that NPOT textures are going to appear anti-aliased when rendered,\ndue to the interpolation that took place when it was resized into a POT texture. This is especially visible in\npixel art graphics. If you notice it and it becomes an issue, the only way to avoid it is to ensure that you\nprovide POT textures for Tile Sprites.",
  "Phaser.GameObjects.Components.ComputedSize.width": "The native (un-scaled) width of this Game Object.\n\nChanging this value will not change the size that the Game Object is rendered in-game.\nFor that you need to either set the scale of the Game Object (`setScale`) or use\nthe `displayWidth` property.",
  "Phaser.GameObjects.Components.ComputedSize.height": "The native (un-scaled) height of this Game Object.\n\nChanging this value will not change the size that the Game Object is rendered in-game.\nFor that you need to either set the scale of the Game Object (`setScale`) or use\nthe `displayHeight` property.",
  "Phaser.GameObjects.Components.ComputedSize.setSize": "Sets the internal size of this Game Object, as used for frame or physics body creation.\n\nThis will not change the size that the Game Object is rendered in-game.\nFor that you need to either set the scale of the Game Object (`setScale`) or call the\n`setDisplaySize` method, which is the same thing as changing the scale but allows you\nto do so by giving pixel values.\n\nIf you have enabled this Game Object for input, changing the size will _not_ change the\nsize of the hit area. To do this you should adjust the `input.hitArea` object directly.",
  "Phaser.GameObjects.TileSprite.tilePositionX": "The horizontal scroll position of the Tile Sprite.",
  "Phaser.GameObjects.TileSprite.tilePositionY": "The vertical scroll position of the Tile Sprite.",
  "Phaser.GameObjects.TileSprite.setTilePosition": "Sets {@link Phaser.GameObjects.TileSprite#tilePositionX} and {@link Phaser.GameObjects.TileSprite#tilePositionY}.",
  "Phaser.GameObjects.TileSprite.tileScaleX": "The horizontal scale of the Tile Sprite texture.",
  "Phaser.GameObjects.TileSprite.tileScaleY": "The vertical scale of the Tile Sprite texture.",
  "Phaser.GameObjects.TileSprite.setTileScale": "Sets {@link Phaser.GameObjects.TileSprite#tileScaleX} and {@link Phaser.GameObjects.TileSprite#tileScaleY}.",
  "Phaser.GameObjects.NineSlice": "A Nine Slice Game Object allows you to display a texture-based object that\ncan be stretched both horizontally and vertically, but that retains\nfixed-sized corners. The dimensions of the corners are set via the\nparameters to this class.\n\nThis is extremely useful for UI and button like elements, where you need\nthem to expand to accommodate the content without distorting the texture.\n\nThe texture you provide for this Game Object should be based on the\nfollowing layout structure:\n\n```\n     A                          B\n   +---+----------------------+---+\n C | 1 |          2           | 3 |\n   +---+----------------------+---+\n   |   |                      |   |\n   | 4 |          5           | 6 |\n   |   |                      |   |\n   +---+----------------------+---+\n D | 7 |          8           | 9 |\n   +---+----------------------+---+\n```\n\nWhen changing this objects width and / or height:\n\n    areas 1, 3, 7 and 9 (the corners) will remain unscaled\n    areas 2 and 8 will be stretched horizontally only\n    areas 4 and 6 will be stretched vertically only\n    area 5 will be stretched both horizontally and vertically\n\nYou can also create a 3 slice Game Object:\n\nThis works in a similar way, except you can only stretch it horizontally.\nTherefore, it requires less configuration:\n\n```\n     A                          B\n   +---+----------------------+---+\n   |   |                      |   |\n C | 1 |          2           | 3 |\n   |   |                      |   |\n   +---+----------------------+---+\n```\n\nWhen changing this objects width (you cannot change its height)\n\n    areas 1 and 3 will remain unscaled\n    area 2 will be stretched horizontally\n\nThe above configuration concept is adapted from the Pixi NineSlicePlane.\n\nTo specify a 3 slice object instead of a 9 slice you should only\nprovide the `leftWidth` and `rightWidth` parameters. To create a 9 slice\nyou must supply all parameters.\n\nThe _minimum_ width this Game Object can be is the total of\n`leftWidth` + `rightWidth`.  The _minimum_ height this Game Object\ncan be is the total of `topHeight` + `bottomHeight`.\nIf you need to display this object at a smaller size, you can scale it.\n\nIn terms of performance, using a 3 slice Game Object is the equivalent of\nhaving 3 Sprites in a row. Using a 9 slice Game Object is the equivalent\nof having 9 Sprites in a row. The vertices of this object are all batched\ntogether and can co-exist with other Sprites and graphics on the display\nlist, without incurring any additional overhead.\n\nAs of Phaser 3.60 this Game Object is WebGL only.",
  "Phaser.GameObjects.NineSlice.leftWidth": "The size of the left vertical bar (A).",
  "Phaser.GameObjects.NineSlice.rightWidth": "The size of the right vertical bar (B).",
  "Phaser.GameObjects.NineSlice.topHeight": "The size of the top horizontal bar (C).\n\nIf this is a 3 slice object this property will be set to the\nheight of the texture being used.",
  "Phaser.GameObjects.NineSlice.bottomHeight": "The size of the bottom horizontal bar (D).\n\nIf this is a 3 slice object this property will be set to zero.",
  "Phaser.GameObjects.GameObject.parentContainer": "The parent Container of this Game Object, if it has one.",
  "Phaser.GameObjects.Text": "A Text Game Object.\n\nText objects work by creating their own internal hidden Canvas and then renders text to it using\nthe standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered\nto your game during the render pass.\n\nBecause it uses the Canvas API you can take advantage of all the features this offers, such as\napplying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts\nloaded externally, such as Google or TypeKit Web fonts.\n\n**Important:** The font name must be quoted if it contains certain combinations of digits or\nspecial characters, either when creating the Text object, or when setting the font via `setFont`\nor `setFontFamily`, e.g.:\n\n```javascript\nthis.add.text(0, 0, 'Hello World', { fontFamily: 'Georgia, \"Goudy Bookletter 1911\", Times, serif' });\n```\n\n```javascript\nthis.add.text(0, 0, 'Hello World', { font: '\"Press Start 2P\"' });\n```\n\nYou can only display fonts that are currently loaded and available to the browser: therefore fonts must\nbe pre-loaded. Phaser does not do this for you, so you will require the use of a 3rd party font loader,\nor have the fonts ready available in the CSS on the page in which your Phaser game resides.\n\nSee {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts\nacross mobile browsers.\n\nA note on performance: Every time the contents of a Text object changes, i.e. changing the text being\ndisplayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the\nnew texture to the GPU. This can be an expensive operation if used often, or with large quantities of\nText objects in your game. If you run into performance issues you would be better off using Bitmap Text\ninstead, as it benefits from batching and avoids expensive Canvas API calls.",
  "Phaser.Types.GameObjects.Text.TextStyle.fixedWidth": "Force the Text object to have the exact width specified in this property. Leave as zero for it to change accordingly to content.",
  "Phaser.Types.GameObjects.Text.TextStyle.fixedHeight": "Force the Text object to have the exact height specified in this property. Leave as zero for it to change accordingly to content.",
  "Phaser.GameObjects.TextStyle.setFixedSize": "Set a fixed width and height for the text.\n\nPass in `0` for either of these parameters to disable fixed width or height respectively.",
  "Phaser.GameObjects.Text.setPadding": "Set the text padding.\n\n'left' can be an object.\n\nIf only 'left' and 'top' are given they are treated as 'x' and 'y'.",
  "Phaser.Types.GameObjects.Text.TextPadding.left": "The amount of padding added to the left of the Text object.",
  "Phaser.Types.GameObjects.Text.TextPadding.top": "The amount of padding added to the top of the Text object.",
  "Phaser.Types.GameObjects.Text.TextPadding.right": "The amount of padding added to the right of the Text object.",
  "Phaser.Types.GameObjects.Text.TextPadding.bottom": "The amount of padding added to the bottom of the Text object.",
  "Phaser.GameObjects.Text.lineSpacing": "The line spacing value.\nThis value is added to the font height to calculate the overall line height.\nOnly has an effect if this Text object contains multiple lines of text.\n\nIf you update this property directly, instead of using the `setLineSpacing` method, then\nbe sure to call `updateText` after, or you won't see the change reflected in the Text object.",
  "Phaser.GameObjects.Text.setAlign": "Set the alignment of the text in this Text object.\n\nThe argument can be one of: `left`, `right`, `center` or `justify`.\n\nAlignment only works if the Text object has more than one line of text.",
  "Phaser.GameObjects.Text.setFontFamily": "Set the font family.\n\n**Important:** The font name must be quoted if it contains certain combinations of digits or\nspecial characters:\n\n```javascript\nText.setFont('\"Press Start 2P\"');\n```\n\nEqually, if you wish to provide a list of fallback fonts, then you should ensure they are all\nquoted properly, too:\n\n```javascript\nText.setFont('Georgia, \"Goudy Bookletter 1911\", Times, serif');\n```",
  "Phaser.GameObjects.Text.setFontSize": "Set the font size. Can be a string with a valid CSS unit, i.e. `16px`, or a number.",
  "Phaser.GameObjects.Text.setFontStyle": "Set the font style.",
  "Phaser.GameObjects.Text.setColor": "Set the text fill color.",
  "Phaser.GameObjects.Text.setStroke(color)": "The stroke color.",
  "Phaser.GameObjects.Text.setStroke(thickness)": "The stroke thickness.",
  "Phaser.GameObjects.Text.setBackgroundColor": "Set the background color.",
  "Phaser.GameObjects.Text.setShadowOffset": "Set the shadow offset.",
  "Phaser.GameObjects.Text.setShadowOffset(x)": "The horizontal shadow offset.",
  "Phaser.GameObjects.Text.setShadowOffset(y)": "The vertical shadow offset.",
  "Phaser.GameObjects.Text.setShadowStroke": "Enable or disable shadow stroke.",
  "Phaser.GameObjects.Text.setShadowFill": "Enable or disable shadow fill.",
  "Phaser.GameObjects.Text.setShadowColor": "Set the shadow color.",
  "Phaser.GameObjects.Text.setShadowBlur": "Set the shadow blur radius.",
  "Phaser.GameObjects.TextStyle.baselineX": "The amount of horizontal padding added to the width of the text when calculating the font metrics.",
  "Phaser.GameObjects.TextStyle.baselineY": "The amount of vertical padding added to the height of the text when calculating the font metrics.",
  "Phaser.GameObjects.Text.setMaxLines": "Set the maximum number of lines to draw.",
  "Phaser.GameObjects.Text.setWordWrapWidth(useAdvancedWrap)": "Whether or not to use the advanced wrapping\nalgorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,\nspaces and whitespace are left as is.",
  "Phaser.GameObjects.Text.setWordWrapWidth(width)": "The maximum width of a line in pixels. Set to null to remove wrapping.",
  "Phaser.GameObjects.BitmapText": "BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.\n\nDuring rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to\nmatch the font structure.\n\nBitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability\nto use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by\nprocessing the font texture in an image editor, applying fills and any other effects required.\n\nTo create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\n\nTo create a BitmapText data files you need a 3rd party app such as:\n\nBMFont (Windows, free): {@link http://www.angelcode.com/products/bmfont/|http://www.angelcode.com/products/bmfont/}\nGlyph Designer (OS X, commercial): {@link http://www.71squared.com/en/glyphdesigner|http://www.71squared.com/en/glyphdesigner}\nSnow BMF (Web-based, free): {@link https://snowb.org//|https://snowb.org/}\nLittera (Flash-based, free): {@link http://kvazars.com/littera/|http://kvazars.com/littera/}\n\nFor most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of\nconverting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: {@link http://codebeautify.org/xmltojson|http://codebeautify.org/xmltojson}",
  "Phaser.GameObjects.BitmapText.setFont": "Changes the font this BitmapText is using to render.\n\nThe new texture is loaded and applied to the BitmapText. The existing test, size and alignment are preserved,\nunless overridden via the arguments.",
  "Phaser.GameObjects.BitmapText.align": "Controls the alignment of each line of text in this BitmapText object.\n\nOnly has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.\nHas no effect with single-lines of text.\n\nSee the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.\n\n0 = Left aligned (default)\n1 = Middle aligned\n2 = Right aligned\n\nThe alignment position is based on the longest line of text.",
  "Phaser.GameObjects.BitmapText.setFontSize": "Set the font size of this Bitmap Text.",
  "Phaser.GameObjects.BitmapText.setLetterSpacing": "Sets the letter spacing between each character of this Bitmap Text.\nCan be a positive value to increase the space, or negative to reduce it.\nSpacing is applied after the kerning values have been set.",
  "Phaser.GameObjects.BitmapText.dropShadowX": "The horizontal offset of the drop shadow.\n\nYou can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.",
  "Phaser.GameObjects.BitmapText.dropShadowY": "The vertical offset of the drop shadow.\n\nYou can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.",
  "Phaser.GameObjects.BitmapText.dropShadowColor": "The color of the drop shadow.\n\nYou can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.",
  "Phaser.GameObjects.BitmapText.dropShadowAlpha": "The alpha value of the drop shadow.\n\nYou can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.",
  "Phaser.Tilemaps.Tilemap": "A Tilemap is a container for Tilemap data. This isn't a display object, rather, it holds data\nabout the map and allows you to add tilesets and tilemap layers to it. A map can have one or\nmore tilemap layers, which are the display objects that actually render the tiles.\n\nThe Tilemap data can be parsed from a Tiled JSON file, a CSV file or a 2D array. Tiled is a free\nsoftware package specifically for creating tile maps, and is available from:\nhttp://www.mapeditor.org\n\nAs of Phaser 3.50.0 the Tilemap API now supports the following types of map:\n\n1) Orthogonal\n2) Isometric\n3) Hexagonal\n4) Staggered\n\nPrior to this release, only orthogonal maps were supported.\n\nAnother large change in 3.50 was the consolidation of Tilemap Layers. Previously, you created\neither a Static or Dynamic Tilemap Layer. However, as of 3.50 the features of both have been\nmerged and the API simplified, so now there is just the single `TilemapLayer` class.\n\nA Tilemap has handy methods for getting and manipulating the tiles within a layer, allowing\nyou to build or modify the tilemap data at runtime.\n\nNote that all Tilemaps use a base tile size to calculate dimensions from, but that a\nTilemapLayer may have its own unique tile size that overrides this.\n\nAs of Phaser 3.21.0, if your tilemap includes layer groups (a feature of Tiled 1.2.0+) these\nwill be traversed and the following properties will impact children:\n\n- Opacity (blended with parent) and visibility (parent overrides child)\n- Vertical and horizontal offset\n\nThe grouping hierarchy is not preserved and all layers will be flattened into a single array.\n\nGroup layers are parsed during Tilemap construction but are discarded after parsing so dynamic\nlayers will NOT continue to be affected by a parent.\n\nTo avoid duplicate layer names, a layer that is a child of a group layer will have its parent\ngroup name prepended with a '/'.  For example, consider a group called 'ParentGroup' with a\nchild called 'Layer 1'. In the Tilemap object, 'Layer 1' will have the name\n'ParentGroup/Layer 1'.\n\nThe Phaser Tiled Parser does **not** support the 'Collection of Images' feature for a Tileset.\nYou must ensure all of your tiles are contained in a single tileset image file (per layer)\nand have this 'embedded' in the exported Tiled JSON map data.",
  "Phaser.Tilemaps.Tilemap.tileWidth": "The base width of a tile in pixels. Note that individual layers may have a different tile\nwidth.",
  "Phaser.Tilemaps.Tilemap.tileHeight": "The base height of a tile in pixels. Note that individual layers may have a different\ntile height.",
  "Phaser.GameObjects.GameObjectFactory.tilemap(key)": "The key in the Phaser cache that corresponds to the loaded tilemap data.",
  "Phaser.Tilemaps.Tileset": "A Tileset is a combination of a single image containing the tiles and a container for data about\neach tile.",
  "Phaser.Tilemaps.Tileset.name": "The name of the Tileset.",
  "Phaser.Tilemaps.Tileset.image": "The cached image that contains the individual tiles. Use setImage to set.",
  "Phaser.Tilemaps.Tileset.tileWidth": "The width of each tile (in pixels). Use setTileSize to change.",
  "Phaser.Tilemaps.Tileset.tileHeight": "The height of each tile (in pixels). Use setTileSize to change.",
  "Phaser.Tilemaps.Tileset.tileMargin": "The margin around the tiles in the sheet (in pixels). Use `setSpacing` to change.",
  "Phaser.Tilemaps.Tileset.tileSpacing": "The spacing between each the tile in the sheet (in pixels). Use `setSpacing` to change.",
  "Phaser.Tilemaps.TilemapLayer": "A Tilemap Layer is a Game Object that renders LayerData from a Tilemap when used in combination\nwith one, or more, Tilesets.",
  "Phaser.Tilemaps.LayerData": "A class for representing data about about a layer in a map. Maps are parsed from CSV, Tiled,\netc. into this format. Tilemap and TilemapLayer objects have a reference\nto this data and use it to look up and perform operations on tiles.",
  "Phaser.Tilemaps.LayerData.name": "The name of the layer, if specified in Tiled.",
  "Phaser.Tilemaps.LayerData.width": "The width of the layer in tiles.",
  "Phaser.Tilemaps.LayerData.height": "The height of the layer in tiles.",
  "Phaser.Tilemaps.LayerData.tileWidth": "The pixel width of the tiles.",
  "Phaser.Tilemaps.LayerData.tileHeight": "The pixel height of the tiles.",
  "Phaser.Tilemaps.LayerData.widthInPixels": "The width in pixels of the entire layer.",
  "Phaser.Tilemaps.LayerData.heightInPixels": "The height in pixels of the entire layer.",
  "Phaser.GameObjects.Shape": "The Shape Game Object is a base class for the various different shapes, such as the Arc, Star or Polygon.\nYou cannot add a Shape directly to your Scene, it is meant as a base for your own custom Shape classes.",
  "Phaser.GameObjects.Shape.isFilled": "Controls if this Shape is filled or not.\nNote that some Shapes do not support being filled (such as Line shapes)",
  "Phaser.GameObjects.Shape.fillColor": "The fill color used by this Shape.",
  "Phaser.GameObjects.Shape.fillAlpha": "The fill alpha value used by this Shape.",
  "Phaser.GameObjects.Shape.isStroked": "Controls if this Shape is stroked or not.\nNote that some Shapes do not support being stroked (such as Iso Box shapes)",
  "Phaser.GameObjects.Shape.strokeColor": "The stroke color used by this Shape.",
  "Phaser.GameObjects.Shape.strokeAlpha": "The stroke alpha value used by this Shape.",
  "Phaser.GameObjects.Shape.lineWidth": "The stroke line width used by this Shape.",
  "Phaser.GameObjects.Rectangle": "The Rectangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\ntreat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\nit for input or physics. It provides a quick and easy way for you to render this shape in your\ngame without using a texture, while still taking advantage of being fully batched in WebGL.\n\nThis shape supports both fill and stroke colors.\n\nYou can change the size of the rectangle by changing the `width` and `height` properties.",
  "Phaser.GameObjects.Ellipse": "The Ellipse Shape is a Game Object that can be added to a Scene, Group or Container. You can\ntreat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\nit for input or physics. It provides a quick and easy way for you to render this shape in your\ngame without using a texture, while still taking advantage of being fully batched in WebGL.\n\nThis shape supports both fill and stroke colors.\n\nWhen it renders it displays an ellipse shape. You can control the width and height of the ellipse.\nIf the width and height match it will render as a circle. If the width is less than the height,\nit will look more like an egg shape.\n\nThe Ellipse shape also has a `smoothness` property and corresponding `setSmoothness` method.\nThis allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations\nthat take place during construction. Increase and decrease the default value for smoother, or more\njagged, shapes.",
  "Phaser.GameObjects.Ellipse.smoothness": "The smoothness of the ellipse. The number of points used when rendering it.\nIncrease this value for a smoother ellipse, at the cost of more polygons being rendered.",
  "Phaser.GameObjects.Polygon": "The Polygon Shape is a Game Object that can be added to a Scene, Group or Container. You can\ntreat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\nit for input or physics. It provides a quick and easy way for you to render this shape in your\ngame without using a texture, while still taking advantage of being fully batched in WebGL.\n\nThis shape supports both fill and stroke colors.\n\nThe Polygon Shape is created by providing a list of points, which are then used to create an\ninternal Polygon geometry object. The points can be set from a variety of formats:\n\n- A string containing paired values separated by a single space: `'40 0 40 20 100 20 100 80 40 80 40 100 0 50'`\n- An array of Point or Vector2 objects: `[new Phaser.Math.Vector2(x1, y1), ...]`\n- An array of objects with public x/y properties: `[obj1, obj2, ...]`\n- An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`\n- An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`\n\nBy default the `x` and `y` coordinates of this Shape refer to the center of it. However, depending\non the coordinates of the points provided, the final shape may be rendered offset from its origin.",
  "Phaser.GameObjects.Triangle": "The Triangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\ntreat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\nit for input or physics. It provides a quick and easy way for you to render this shape in your\ngame without using a texture, while still taking advantage of being fully batched in WebGL.\n\nThis shape supports both fill and stroke colors.\n\nThe Triangle consists of 3 lines, joining up to form a triangular shape. You can control the\nposition of each point of these lines. The triangle is always closed and cannot have an open\nface. If you require that, consider using a Polygon instead.",
  "Phaser.Geom.Triangle.x1": "`x` coordinate of the first point.",
  "Phaser.Geom.Triangle.y1": "`y` coordinate of the first point.",
  "Phaser.Geom.Triangle.x2": "`x` coordinate of the second point.",
  "Phaser.Geom.Triangle.y2": "`y` coordinate of the second point.",
  "Phaser.Geom.Triangle.x3": "`x` coordinate of the third point.",
  "Phaser.Geom.Triangle.y3": "`y` coordinate of the third point.",
  "Phaser.Geom.Rectangle.x": "The X coordinate of the top left corner of the Rectangle.",
  "Phaser.Geom.Rectangle.y": "The Y coordinate of the top left corner of the Rectangle.",
  "Phaser.Geom.Rectangle.width": "The width of the Rectangle, i.e. the distance between its left side (defined by `x`) and its right side.",
  "Phaser.Geom.Rectangle.height": "The height of the Rectangle, i.e. the distance between its top side (defined by `y`) and its bottom side.",
  "Phaser.Geom.Ellipse.x": "The x position of the center of the ellipse.",
  "Phaser.Geom.Ellipse.y": "The y position of the center of the ellipse.",
  "Phaser.Geom.Ellipse.width": "The width of the ellipse.",
  "Phaser.Geom.Ellipse.height": "The height of the ellipse.",
  "Phaser.GameObjects.Layer": "A Layer Game Object.\n\nA Layer is a special type of Game Object that acts as a Display List. You can add any type of Game Object\nto a Layer, just as you would to a Scene. Layers can be used to visually group together 'layers' of Game\nObjects:\n\n```javascript\nconst spaceman = this.add.sprite(150, 300, 'spaceman');\nconst bunny = this.add.sprite(400, 300, 'bunny');\nconst elephant = this.add.sprite(650, 300, 'elephant');\n\nconst layer = this.add.layer();\n\nlayer.add([ spaceman, bunny, elephant ]);\n```\n\nThe 3 sprites in the example above will now be managed by the Layer they were added to. Therefore,\nif you then set `layer.setVisible(false)` they would all vanish from the display.\n\nYou can also control the depth of the Game Objects within the Layer. For example, calling the\n`setDepth` method of a child of a Layer will allow you to adjust the depth of that child _within the\nLayer itself_, rather than the whole Scene. The Layer, too, can have its depth set as well.\n\nThe Layer class also offers many different methods for manipulating the list, such as the\nmethods `moveUp`, `moveDown`, `sendToBack`, `bringToTop` and so on. These allow you to change the\ndisplay list position of the Layers children, causing it to adjust the order in which they are\nrendered. Using `setDepth` on a child allows you to override this.\n\nLayers can have Post FX Pipelines set, which allows you to easily enable a post pipeline across\na whole range of children, which, depending on the effect, can often be far more efficient that doing so\non a per-child basis.\n\nLayers have no position or size within the Scene. This means you cannot enable a Layer for\nphysics or input, or change the position, rotation or scale of a Layer. They also have no scroll\nfactor, texture, tint, origin, crop or bounds.\n\nIf you need those kind of features then you should use a Container instead. Containers can be added\nto Layers, but Layers cannot be added to Containers.\n\nHowever, you can set the Alpha, Blend Mode, Depth, Mask and Visible state of a Layer. These settings\nwill impact all children being rendered by the Layer.",
  "Phaser.Physics.Arcade.Collider": "An Arcade Physics Collider will automatically check for collision, or overlaps, between two objects\nevery step. If a collision, or overlap, occurs it will invoke the given callbacks.",
  "Phaser.Physics.Arcade.Image": "An Arcade Physics Image is an Image with an Arcade Physics body and related components.\nThe body can be dynamic or static.\n\nThe main difference between an Arcade Image and an Arcade Sprite is that you cannot animate an Arcade Image.",
  "Phaser.Physics.Arcade.Sprite": "An Arcade Physics Sprite is a Sprite with an Arcade Physics body and related components.\nThe body can be dynamic or static.\n\nThe main difference between an Arcade Sprite and an Arcade Image is that you cannot animate an Arcade Image.\nIf you do not require animation then you can safely use Arcade Images instead of Arcade Sprites.",
  "Phaser.Physics.Arcade.Body": "A Dynamic Arcade Body.\n\nIts static counterpart is {@link Phaser.Physics.Arcade.StaticBody}.",
  "Phaser.Physics.Arcade.Body.enable": "Whether this Body is updated by the physics simulation.",
  "Phaser.Physics.Arcade.Body.offset": "The offset of this Body's position from its Game Object's position, in source pixels.",
  "Phaser.Physics.Arcade.Body.radius": "If this Body is circular, this is the unscaled radius of the Body, as set by setCircle(), in source pixels.\nThe true radius is equal to `halfWidth`.",
  "Phaser.Physics.Arcade.Body.moves": "Whether the Body's position and rotation are affected by its velocity, acceleration, drag, and gravity.",
  "Phaser.Physics.Arcade.Body.velocity": "The Body's velocity, in pixels per second.",
  "Phaser.Physics.Arcade.Body.maxVelocity": "The absolute maximum velocity of this body, in pixels per second.\nThe horizontal and vertical components are applied separately.",
  "Phaser.Physics.Arcade.Body.maxSpeed": "The maximum speed this Body is allowed to reach, in pixels per second.\n\nIf not negative it limits the scalar value of speed.\n\nAny negative value means no maximum is being applied (the default).",
  "Phaser.Physics.Arcade.Body.allowGravity": "Whether this Body's position is affected by gravity (local or world).",
  "Phaser.Physics.Arcade.Body.gravity": "Acceleration due to gravity (specific to this Body), in pixels per second squared.\nTotal gravity is the sum of this vector and the simulation's `gravity`.",
  "Phaser.Physics.Arcade.Body.acceleration": "The Body's change in velocity, in pixels per second squared.",
  "Phaser.Physics.Arcade.Body.useDamping": "If this Body is using `drag` for deceleration this property controls how the drag is applied.\nIf set to `true` drag will use a damping effect rather than a linear approach. If you are\ncreating a game where the Body moves freely at any angle (i.e. like the way the ship moves in\nthe game Asteroids) then you will get a far smoother and more visually correct deceleration\nby using damping, avoiding the axis-drift that is prone with linear deceleration.\n\nIf you enable this property then you should use far smaller `drag` values than with linear, as\nthey are used as a multiplier on the velocity. Values such as 0.05 will give a nice slow\ndeceleration.",
  "Phaser.Physics.Arcade.Body.allowDrag": "Whether this Body's velocity is affected by its `drag`.",
  "Phaser.Physics.Arcade.Body.drag": "When `useDamping` is false (the default), this is absolute loss of velocity due to movement, in pixels per second squared.\n\nWhen `useDamping` is true, this is a damping multiplier between 0 and 1.\nA value of 0 means the Body stops instantly.\nA value of 0.01 mean the Body keeps 1% of its velocity per second, losing 99%.\nA value of 0.1 means the Body keeps 10% of its velocity per second, losing 90%.\nA value of 1 means the Body loses no velocity.\nYou can use very small values (e.g., 0.001) to stop the Body quickly.\n\nThe x and y components are applied separately.\n\nDrag is applied only when `acceleration` is zero.",
  "Phaser.Physics.Arcade.Body.allowRotation": "Whether this Body's `rotation` is affected by its angular acceleration and angular velocity.",
  "Phaser.Physics.Arcade.Body.rotation": "This body's rotation, in degrees, based on its angular acceleration and angular velocity.\nThe Body's rotation controls the `angle` of its Game Object.\nIt doesn't rotate the Body's own geometry, which is always an axis-aligned rectangle or a circle.",
  "Phaser.Physics.Arcade.Body.angularVelocity": "The rate of change of this Body's `rotation`, in degrees per second.",
  "Phaser.Physics.Arcade.Body.angularAcceleration": "The Body's angular acceleration (change in angular velocity), in degrees per second squared.",
  "Phaser.Physics.Arcade.Body.angularDrag": "Loss of angular velocity due to angular movement, in degrees per second.\n\nAngular drag is applied only when angular acceleration is zero.",
  "Phaser.Physics.Arcade.Body.maxAngular": "The Body's maximum angular velocity, in degrees per second.",
  "Phaser.Physics.Arcade.Body.pushable": "Sets if this Body can be pushed by another Body.\n\nA body that cannot be pushed will reflect back all of the velocity it is given to the\ncolliding body. If that body is also not pushable, then the separation will be split\nbetween them evenly.\n\nIf you want your body to never move or seperate at all, see the `setImmovable` method.\n\nBy default, Dynamic Bodies are always pushable.",
  "Phaser.Physics.Arcade.Body.immovable": "Whether this Body can be moved by collisions with another Body.",
  "Phaser.Physics.Arcade.Body.collideWorldBounds": "Whether this Body interacts with the world boundary.",
  "Phaser.Physics.Arcade.Body.mass": "The Body's inertia, relative to a default unit (1).\nWith `bounce`, this affects the exchange of momentum (velocities) during collisions.",
  "Phaser.Physics.Arcade.Body.bounce": "Rebound following a collision, relative to 1.",
  "Phaser.Physics.Arcade.Body.friction": "If this Body is `immovable` and in motion, `friction` is the proportion of this Body's motion received by the riding Body on each axis, relative to 1.\nThe horizontal component (x) is applied only when two colliding Bodies are separated vertically.\nThe vertical component (y) is applied only when two colliding Bodies are separated horizontally.\nThe default value (1, 0) moves the riding Body horizontally in equal proportion to this Body and vertically not at all.",
  "Phaser.Physics.Arcade.Body.overlapX": "The amount of horizontal overlap (before separation), if this Body is colliding with another.",
  "Phaser.Physics.Arcade.Body.overlapY": "The amount of vertical overlap (before separation), if this Body is colliding with another.",
  "Phaser.Physics.Arcade.Body.overlapR": "The amount of overlap (before separation), if this Body is circular and colliding with another circular body.",
  "Phaser.Physics.Arcade.Collider(overlapOnly)": "Whether to check for collisions or overlap.",
  "Phaser.Physics.Arcade.Collider(object1)": "The first object to check for collision.",
  "Phaser.Physics.Arcade.Collider(object2)": "The second object to check for collision.",
  "Phaser.Physics.Arcade.Collider(collideCallback)": "The callback to invoke when the two objects collide.",
  "Phaser.Physics.Arcade.Collider(processCallback)": "The callback to invoke when the two objects collide. Must return a boolean.",
  "Phaser.Physics.Arcade.Collider(callbackContext)": "The scope in which to call the callbacks.",
  "Phaser.Input.Keyboard.Key": "A generic Key object which can be passed to the Process functions (and so on)\nkeycode must be an integer"
}