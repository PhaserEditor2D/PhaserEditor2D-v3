{
  "Phaser.Animations.Events.ADD_ANIMATION": "The Add Animation Event.\n\nThis event is dispatched when a new animation is added to the global Animation Manager.\n\nThis can happen either as a result of an animation instance being added to the Animation Manager,\nor the Animation Manager creating a new animation directly.",
  "Phaser.Animations.Events.ANIMATION_COMPLETE": "The Animation Complete Event.\n\nThis event is dispatched by a Sprite when an animation playing on it completes playback.\nThis happens when the animation gets to the end of its sequence, factoring in any delays\nor repeats it may have to process.\n\nAn animation that is set to loop, or repeat forever, will never fire this event, because\nit never actually completes. If you need to handle this, listen for the `ANIMATION_STOP`\nevent instead, as this is emitted when the animation is stopped directly.\n\nListen for it on the Sprite using `sprite.on('animationcomplete', listener)`\n\nThe animation event flow is as follows:\n\n1. `ANIMATION_START`\n2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n\nIf the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n\nIf the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.",
  "Phaser.Animations.Events.ANIMATION_COMPLETE_KEY": "The Animation Complete Dynamic Key Event.\n\nThis event is dispatched by a Sprite when an animation playing on it completes playback.\nThis happens when the animation gets to the end of its sequence, factoring in any delays\nor repeats it may have to process.\n\nAn animation that is set to loop, or repeat forever, will never fire this event, because\nit never actually completes. If you need to handle this, listen for the `ANIMATION_STOP`\nevent instead, as this is emitted when the animation is stopped directly.\n\nThe difference between this and the `ANIMATION_COMPLETE` event is that this one has a\ndynamic event name that contains the name of the animation within it. For example,\nif you had an animation called `explode` you could listen for the completion of that\nspecific animation by using: `sprite.on('animationcomplete-explode', listener)`. Or, if you\nwish to use types: `sprite.on(Phaser.Animations.Events.ANIMATION_COMPLETE_KEY + 'explode', listener)`.\n\nThe animation event flow is as follows:\n\n1. `ANIMATION_START`\n2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n\nIf the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n\nIf the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.",
  "Phaser.Animations.Events.ANIMATION_REPEAT": "The Animation Repeat Event.\n\nThis event is dispatched by a Sprite when an animation repeats playing on it.\nThis happens if the animation was created, or played, with a `repeat` value specified.\n\nAn animation will repeat when it reaches the end of its sequence.\n\nListen for it on the Sprite using `sprite.on('animationrepeat', listener)`\n\nThe animation event flow is as follows:\n\n1. `ANIMATION_START`\n2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n\nIf the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n\nIf the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.",
  "Phaser.Animations.Events.ANIMATION_RESTART": "The Animation Restart Event.\n\nThis event is dispatched by a Sprite when an animation restarts playing on it.\nThis only happens when the `Sprite.anims.restart` method is called.\n\nListen for it on the Sprite using `sprite.on('animationrestart', listener)`\n\nThe animation event flow is as follows:\n\n1. `ANIMATION_START`\n2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n\nIf the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n\nIf the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.",
  "Phaser.Animations.Events.ANIMATION_START": "The Animation Start Event.\n\nThis event is dispatched by a Sprite when an animation starts playing on it.\nThis happens when the animation is played, factoring in any delay that may have been specified.\nThis event happens after the delay has expired and prior to the first update event.\n\nListen for it on the Sprite using `sprite.on('animationstart', listener)`\n\nThe animation event flow is as follows:\n\n1. `ANIMATION_START`\n2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n\nIf the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n\nIf the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.",
  "Phaser.Animations.Events.ANIMATION_STOP": "The Animation Stop Event.\n\nThis event is dispatched by a Sprite when an animation is stopped on it. An animation\nwill only be stopeed if a method such as `Sprite.stop` or `Sprite.anims.stopAfterDelay`\nis called. It can also be emitted if a new animation is started before the current one completes.\n\nListen for it on the Sprite using `sprite.on('animationstop', listener)`\n\nThe animation event flow is as follows:\n\n1. `ANIMATION_START`\n2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n\nIf the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n\nIf the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.",
  "Phaser.Animations.Events.ANIMATION_UPDATE": "The Animation Update Event.\n\nThis event is dispatched by a Sprite when an animation playing on it updates. This happens when the animation changes frame.\nAn animation will change frame based on the frame rate and other factors like `timeScale` and `delay`. It can also change\nframe when stopped or restarted.\n\nListen for it on the Sprite using `sprite.on('animationupdate', listener)`\n\nIf an animation is playing faster than the game frame-rate can handle, it's entirely possible for it to emit several\nupdate events in a single game frame, so please be aware of this in your code. The **final** event received that frame\nis the one that is rendered to the game.\n\nThe animation event flow is as follows:\n\n1. `ANIMATION_START`\n2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n\nIf the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n\nIf the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.",
  "Phaser.Animations.Events.PAUSE_ALL": "The Pause All Animations Event.\n\nThis event is dispatched when the global Animation Manager is told to pause.\n\nWhen this happens all current animations will stop updating, although it doesn't necessarily mean\nthat the game has paused as well.",
  "Phaser.Animations.Events.REMOVE_ANIMATION": "The Remove Animation Event.\n\nThis event is dispatched when an animation is removed from the global Animation Manager.",
  "Phaser.Animations.Events.RESUME_ALL": "The Resume All Animations Event.\n\nThis event is dispatched when the global Animation Manager resumes, having been previously paused.\n\nWhen this happens all current animations will continue updating again.",
  "Phaser.Cache.Events.ADD": "The Cache Add Event.\n\nThis event is dispatched by any Cache that extends the BaseCache each time a new object is added to it.",
  "Phaser.Cache.Events.REMOVE": "The Cache Remove Event.\n\nThis event is dispatched by any Cache that extends the BaseCache each time an object is removed from it.",
  "Phaser.Cameras.Scene2D.Events.DESTROY": "The Destroy Camera Event.\n\nThis event is dispatched by a Camera instance when it is destroyed by the Camera Manager.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('cameradestroy', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.DESTROY, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.FADE_IN_COMPLETE": "The Camera Fade In Complete Event.\n\nThis event is dispatched by a Camera instance when the Fade In Effect completes.\n\nListen to it from a Camera instance using `Camera.on('camerafadeincomplete', listener)`.",
  "Phaser.Cameras.Scene2D.Events.FADE_IN_START": "The Camera Fade In Start Event.\n\nThis event is dispatched by a Camera instance when the Fade In Effect starts.\n\nListen to it from a Camera instance using `Camera.on('camerafadeinstart', listener)`.",
  "Phaser.Cameras.Scene2D.Events.FADE_OUT_COMPLETE": "The Camera Fade Out Complete Event.\n\nThis event is dispatched by a Camera instance when the Fade Out Effect completes.\n\nListen to it from a Camera instance using `Camera.on('camerafadeoutcomplete', listener)`.",
  "Phaser.Cameras.Scene2D.Events.FADE_OUT_START": "The Camera Fade Out Start Event.\n\nThis event is dispatched by a Camera instance when the Fade Out Effect starts.\n\nListen to it from a Camera instance using `Camera.on('camerafadeoutstart', listener)`.",
  "Phaser.Cameras.Scene2D.Events.FLASH_COMPLETE": "The Camera Flash Complete Event.\n\nThis event is dispatched by a Camera instance when the Flash Effect completes.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('cameraflashcomplete', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.FLASH_COMPLETE, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.FLASH_START": "The Camera Flash Start Event.\n\nThis event is dispatched by a Camera instance when the Flash Effect starts.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('cameraflashstart', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.FLASH_START, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.FOLLOW_UPDATE": "The Camera Follower Update Event.\n\nThis event is dispatched by a Camera instance when it is following a\nGame Object and the Camera position has been updated as a result of\nthat following.\n\nListen to it from a Camera instance using: `camera.on('followupdate', listener)`.",
  "Phaser.Cameras.Scene2D.Events.PAN_COMPLETE": "The Camera Pan Complete Event.\n\nThis event is dispatched by a Camera instance when the Pan Effect completes.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerapancomplete', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.PAN_COMPLETE, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.PAN_START": "The Camera Pan Start Event.\n\nThis event is dispatched by a Camera instance when the Pan Effect starts.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerapanstart', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.PAN_START, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.POST_RENDER": "The Camera Post-Render Event.\n\nThis event is dispatched by a Camera instance after is has finished rendering.\nIt is only dispatched if the Camera is rendering to a texture.\n\nListen to it from a Camera instance using: `camera.on('postrender', listener)`.",
  "Phaser.Cameras.Scene2D.Events.PRE_RENDER": "The Camera Pre-Render Event.\n\nThis event is dispatched by a Camera instance when it is about to render.\nIt is only dispatched if the Camera is rendering to a texture.\n\nListen to it from a Camera instance using: `camera.on('prerender', listener)`.",
  "Phaser.Cameras.Scene2D.Events.ROTATE_COMPLETE": "The Camera Rotate Complete Event.\n\nThis event is dispatched by a Camera instance when the Rotate Effect completes.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerarotatecomplete', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.ROTATE_COMPLETE, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.ROTATE_START": "The Camera Rotate Start Event.\n\nThis event is dispatched by a Camera instance when the Rotate Effect starts.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerarotatestart', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.ROTATE_START, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.SHAKE_COMPLETE": "The Camera Shake Complete Event.\n\nThis event is dispatched by a Camera instance when the Shake Effect completes.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerashakecomplete', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.SHAKE_COMPLETE, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.SHAKE_START": "The Camera Shake Start Event.\n\nThis event is dispatched by a Camera instance when the Shake Effect starts.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerashakestart', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.SHAKE_START, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.ZOOM_COMPLETE": "The Camera Zoom Complete Event.\n\nThis event is dispatched by a Camera instance when the Zoom Effect completes.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerazoomcomplete', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.ZOOM_COMPLETE, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.ZOOM_START": "The Camera Zoom Start Event.\n\nThis event is dispatched by a Camera instance when the Zoom Effect starts.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerazoomstart', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.ZOOM_START, () => {});\n```",
  "Phaser.Core.Events.BLUR": "The Game Blur Event.\n\nThis event is dispatched by the Game Visibility Handler when the window in which the Game instance is embedded\nenters a blurred state. The blur event is raised when the window loses focus. This can happen if a user swaps\ntab, or if they simply remove focus from the browser to another app.",
  "Phaser.Core.Events.BOOT": "The Game Boot Event.\n\nThis event is dispatched when the Phaser Game instance has finished booting, but before it is ready to start running.\nThe global systems use this event to know when to set themselves up, dispatching their own `ready` events as required.",
  "Phaser.Core.Events.CONTEXT_LOST": "The Game Context Lost Event.\n\nThis event is dispatched by the Game if the WebGL Renderer it is using encounters a WebGL Context Lost event from the browser.\n\nThe renderer halts all rendering and cannot resume after this happens.",
  "Phaser.Core.Events.DESTROY": "The Game Destroy Event.\n\nThis event is dispatched when the game instance has been told to destroy itself.\nLots of internal systems listen to this event in order to clear themselves out.\nCustom plugins and game code should also do the same.",
  "Phaser.Core.Events.FOCUS": "The Game Focus Event.\n\nThis event is dispatched by the Game Visibility Handler when the window in which the Game instance is embedded\nenters a focused state. The focus event is raised when the window re-gains focus, having previously lost it.",
  "Phaser.Core.Events.HIDDEN": "The Game Hidden Event.\n\nThis event is dispatched by the Game Visibility Handler when the document in which the Game instance is embedded\nenters a hidden state. Only browsers that support the Visibility API will cause this event to be emitted.\n\nIn most modern browsers, when the document enters a hidden state, the Request Animation Frame and setTimeout, which\ncontrol the main game loop, will automatically pause. There is no way to stop this from happening. It is something\nyour game should account for in its own code, should the pause be an issue (i.e. for multiplayer games)",
  "Phaser.Core.Events.PAUSE": "The Game Pause Event.\n\nThis event is dispatched when the Game loop enters a paused state, usually as a result of the Visibility Handler.",
  "Phaser.Core.Events.POST_RENDER": "The Game Post-Render Event.\n\nThis event is dispatched right at the end of the render process.\n\nEvery Scene will have rendered and been drawn to the canvas by the time this event is fired.\nUse it for any last minute post-processing before the next game step begins.",
  "Phaser.Core.Events.POST_STEP": "The Game Post-Step Event.\n\nThis event is dispatched after the Scene Manager has updated.\nHook into it from plugins or systems that need to do things before the render starts.",
  "Phaser.Core.Events.PRE_RENDER": "The Game Pre-Render Event.\n\nThis event is dispatched immediately before any of the Scenes have started to render.\n\nThe renderer will already have been initialized this frame, clearing itself and preparing to receive the Scenes for rendering, but it won't have actually drawn anything yet.",
  "Phaser.Core.Events.PRE_STEP": "The Game Pre-Step Event.\n\nThis event is dispatched before the main Game Step starts. By this point in the game cycle none of the Scene updates have yet happened.\nHook into it from plugins or systems that need to update before the Scene Manager does.",
  "Phaser.Core.Events.READY": "The Game Ready Event.\n\nThis event is dispatched when the Phaser Game instance has finished booting, the Texture Manager is fully ready,\nand all local systems are now able to start.",
  "Phaser.Core.Events.RESUME": "The Game Resume Event.\n\nThis event is dispatched when the game loop leaves a paused state and resumes running.",
  "Phaser.Core.Events.STEP": "The Game Step Event.\n\nThis event is dispatched after the Game Pre-Step and before the Scene Manager steps.\nHook into it from plugins or systems that need to update before the Scene Manager does, but after the core Systems have.",
  "Phaser.Core.Events.VISIBLE": "The Game Visible Event.\n\nThis event is dispatched by the Game Visibility Handler when the document in which the Game instance is embedded\nenters a visible state, previously having been hidden.\n\nOnly browsers that support the Visibility API will cause this event to be emitted.",
  "Phaser.Data.Events.CHANGE_DATA": "The Change Data Event.\n\nThis event is dispatched by a Data Manager when an item in the data store is changed.\n\nGame Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\na change data event from a Game Object you would use: `sprite.on('changedata', listener)`.\n\nThis event is dispatched for all items that change in the Data Manager.\nTo listen for the change of a specific item, use the `CHANGE_DATA_KEY_EVENT` event.",
  "Phaser.Data.Events.CHANGE_DATA_KEY": "The Change Data Key Event.\n\nThis event is dispatched by a Data Manager when an item in the data store is changed.\n\nGame Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\nthe change of a specific data item from a Game Object you would use: `sprite.on('changedata-key', listener)`,\nwhere `key` is the unique string key of the data item. For example, if you have a data item stored called `gold`\nthen you can listen for `sprite.on('changedata-gold')`.",
  "Phaser.Data.Events.DESTROY": "The Data Manager Destroy Event.\n\nThe Data Manager will listen for the destroy event from its parent, and then close itself down.",
  "Phaser.Data.Events.REMOVE_DATA": "The Remove Data Event.\n\nThis event is dispatched by a Data Manager when an item is removed from it.\n\nGame Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\nthe removal of a data item on a Game Object you would use: `sprite.on('removedata', listener)`.",
  "Phaser.Data.Events.SET_DATA": "The Set Data Event.\n\nThis event is dispatched by a Data Manager when a new item is added to the data store.\n\nGame Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\nthe addition of a new data item on a Game Object you would use: `sprite.on('setdata', listener)`.",
  "Phaser.GameObjects.Events.ADDED_TO_SCENE": "The Game Object Added to Scene Event.\n\nThis event is dispatched when a Game Object is added to a Scene.\n\nListen for it on a Game Object instance using `GameObject.on('addedtoscene', listener)`.",
  "Phaser.GameObjects.Events.DESTROY": "The Game Object Destroy Event.\n\nThis event is dispatched when a Game Object instance is being destroyed.\n\nListen for it on a Game Object instance using `GameObject.on('destroy', listener)`.",
  "Phaser.GameObjects.Events.REMOVED_FROM_SCENE": "The Game Object Removed from Scene Event.\n\nThis event is dispatched when a Game Object is removed from a Scene.\n\nListen for it on a Game Object instance using `GameObject.on('removedfromscene', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_COMPLETE": "The Video Game Object Complete Event.\n\nThis event is dispatched when a Video finishes playback by reaching the end of its duration. It\nis also dispatched if a video marker sequence is being played and reaches the end.\n\nNote that not all videos can fire this event. Live streams, for example, have no fixed duration,\nso never technically 'complete'.\n\nIf a video is stopped from playback, via the `Video.stop` method, it will emit the\n`VIDEO_STOP` event instead of this one.\n\nListen for it from a Video Game Object instance using `Video.on('complete', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_CREATED": "The Video Game Object Created Event.\n\nThis event is dispatched when the texture for a Video has been created. This happens\nwhen enough of the video source has been loaded that the browser is able to render a\nframe from it.\n\nListen for it from a Video Game Object instance using `Video.on('created', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_ERROR": "The Video Game Object Error Event.\n\nThis event is dispatched when a Video tries to play a source that does not exist, or is the wrong file type.\n\nListen for it from a Video Game Object instance using `Video.on('error', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_LOCKED": "The Video Game Object Locked Event.\n\nThis event is dispatched when a Video was attempted to be played, but the browser prevented it\nfrom doing so due to the Media Engagement Interaction policy.\n\nIf you get this event you will need to wait for the user to interact with the browser before\nthe video will play. This is a browser security measure to prevent autoplaying videos with\naudio. An interaction includes a mouse click, a touch, or a key press.\n\nListen for it from a Video Game Object instance using `Video.on('locked', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_LOOP": "The Video Game Object Loop Event.\n\nThis event is dispatched when a Video that is currently playing has looped. This only\nhappens if the `loop` parameter was specified, or the `setLoop` method was called,\nand if the video has a fixed duration. Video streams, for example, cannot loop, as\nthey have no duration.\n\nLooping is based on the result of the Video `timeupdate` event. This event is not\nframe-accurate, due to the way browsers work, so please do not rely on this loop\nevent to be time or frame precise.\n\nListen for it from a Video Game Object instance using `Video.on('loop', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_PLAYING": "The Video Game Object Playing Event.\n\nThe playing event is fired after playback is first started,\nand whenever it is restarted. For example it is fired when playback\nresumes after having been paused or delayed due to lack of data.\n\nListen for it from a Video Game Object instance using `Video.on('playing', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_PLAY": "The Video Game Object Play Event.\n\nThis event is dispatched when a Video begins playback. For videos that do not require\ninteraction unlocking, this is usually as soon as the `Video.play` method is called.\nHowever, for videos that require unlocking, it is fired once playback begins after\nthey've been unlocked.\n\nListen for it from a Video Game Object instance using `Video.on('play', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_SEEKED": "The Video Game Object Seeked Event.\n\nThis event is dispatched when a Video completes seeking to a new point in its timeline.\n\nListen for it from a Video Game Object instance using `Video.on('seeked', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_SEEKING": "The Video Game Object Seeking Event.\n\nThis event is dispatched when a Video _begins_ seeking to a new point in its timeline.\nWhen the seek is complete, it will dispatch the `VIDEO_SEEKED` event to conclude.\n\nListen for it from a Video Game Object instance using `Video.on('seeking', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_STALLED": "The Video Game Object Stalled Event.\n\nThis event is dispatched by a Video Game Object when the video playback stalls.\n\nThis can happen if the video is buffering.\n\nIf will fire for any of the following native DOM events:\n\n`stalled`\n`suspend`\n`waiting`\n\nListen for it from a Video Game Object instance using `Video.on('stalled', listener)`.\n\nNote that being stalled isn't always a negative thing. A video can be stalled if it\nhas downloaded enough data in to its buffer to not need to download any more until\nthe current batch of frames have rendered.",
  "Phaser.GameObjects.Events.VIDEO_STOP": "The Video Game Object Stopped Event.\n\nThis event is dispatched when a Video is stopped from playback via a call to the `Video.stop` method,\neither directly via game code, or indirectly as the result of changing a video source or destroying it.\n\nListen for it from a Video Game Object instance using `Video.on('stop', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_TEXTURE": "The Video Game Object Texture Ready Event.\n\nThis event is dispatched by a Video Game Object when it has finished creating its texture.\n\nThis happens when the video has finished loading enough data for its first frame.\n\nIf you wish to use the Video texture elsewhere in your game, such as as a Sprite texture,\nthen you should listen for this event first, before creating the Sprites that use it.\n\nListen for it from a Video Game Object instance using `Video.on('textureready', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_UNLOCKED": "The Video Game Object Unlocked Event.\n\nThis event is dispatched when a Video that was prevented from playback due to the browsers\nMedia Engagement Interaction policy, is unlocked by a user gesture.\n\nListen for it from a Video Game Object instance using `Video.on('unlocked', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_UNSUPPORTED": "The Video Game Object Unsupported Event.\n\nThis event is dispatched by a Video Game Object if the media source\n(which may be specified as a MediaStream, MediaSource, Blob, or File,\nfor example) doesn't represent a supported media format.\n\nListen for it from a Video Game Object instance using `Video.on('unsupported', listener)`.",
  "Phaser.GameObjects.Particles.Events.COMPLETE": "The Particle Emitter Complete Event.\n\nThis event is dispatched when the final particle, emitted from a Particle Emitter that\nhas been stopped, dies. Upon receipt of this event you know that no particles are\nstill rendering at this point in time.\n\nListen for it on a Particle Emitter instance using `ParticleEmitter.on('complete', listener)`.",
  "Phaser.GameObjects.Particles.Events.DEATH_ZONE": "The Particle Emitter Death Zone Event.\n\nThis event is dispatched when a Death Zone kills a Particle instance.\n\nListen for it on a Particle Emitter instance using `ParticleEmitter.on('deathzone', listener)`.\n\nIf you wish to know when the final particle is killed, see the `COMPLETE` event.",
  "Phaser.GameObjects.Particles.Events.EXPLODE": "The Particle Emitter Explode Event.\n\nThis event is dispatched when a Particle Emitter explodes a set of particles.\n\nListen for it on a Particle Emitter instance using `ParticleEmitter.on('explode', listener)`.",
  "Phaser.GameObjects.Particles.Events.START": "The Particle Emitter Start Event.\n\nThis event is dispatched when a Particle Emitter starts emission of particles.\n\nListen for it on a Particle Emitter instance using `ParticleEmitter.on('start', listener)`.",
  "Phaser.GameObjects.Particles.Events.STOP": "The Particle Emitter Stop Event.\n\nThis event is dispatched when a Particle Emitter is stopped. This can happen either\nwhen you directly call the `ParticleEmitter.stop` method, or if the emitter has\nbeen configured to stop after a set time via the `duration` property, or after a\nset number of particles via the `stopAfter` property.\n\nListen for it on a Particle Emitter instance using `ParticleEmitter.on('stop', listener)`.\n\nNote that just because the emitter has stopped, that doesn't mean there aren't still\nparticles alive and rendering. It just means the emitter has stopped emitting particles.\n\nIf you wish to know when the final particle is killed, see the `COMPLETE` event.",
  "Phaser.Input.Events.BOOT": "The Input Plugin Boot Event.\n\nThis internal event is dispatched by the Input Plugin when it boots, signalling to all of its systems to create themselves.",
  "Phaser.Input.Events.DESTROY": "The Input Plugin Destroy Event.\n\nThis internal event is dispatched by the Input Plugin when it is destroyed, signalling to all of its systems to destroy themselves.",
  "Phaser.Input.Events.DRAG_END": "The Pointer Drag End Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer stops dragging a Game Object.\n\nListen to this event from within a Scene using: `this.input.on('dragend', listener)`.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_END]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_END} event instead.",
  "Phaser.Input.Events.DRAG_ENTER": "The Pointer Drag Enter Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer drags a Game Object into a Drag Target.\n\nListen to this event from within a Scene using: `this.input.on('dragenter', listener)`.\n\nA Pointer can only drag a single Game Object at once.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_ENTER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_ENTER} event instead.",
  "Phaser.Input.Events.DRAG": "The Pointer Drag Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer moves while dragging a Game Object.\n\nListen to this event from within a Scene using: `this.input.on('drag', listener)`.\n\nA Pointer can only drag a single Game Object at once.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG} event instead.",
  "Phaser.Input.Events.DRAG_LEAVE": "The Pointer Drag Leave Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer drags a Game Object out of a Drag Target.\n\nListen to this event from within a Scene using: `this.input.on('dragleave', listener)`.\n\nA Pointer can only drag a single Game Object at once.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_LEAVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_LEAVE} event instead.",
  "Phaser.Input.Events.DRAG_OVER": "The Pointer Drag Over Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer drags a Game Object over a Drag Target.\n\nWhen the Game Object first enters the drag target it will emit a `dragenter` event. If it then moves while within\nthe drag target, it will emit this event instead.\n\nListen to this event from within a Scene using: `this.input.on('dragover', listener)`.\n\nA Pointer can only drag a single Game Object at once.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_OVER} event instead.",
  "Phaser.Input.Events.DRAG_START": "The Pointer Drag Start Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer starts to drag any Game Object.\n\nListen to this event from within a Scene using: `this.input.on('dragstart', listener)`.\n\nA Pointer can only drag a single Game Object at once.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_START]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_START} event instead.",
  "Phaser.Input.Events.DROP": "The Pointer Drop Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer drops a Game Object on a Drag Target.\n\nListen to this event from within a Scene using: `this.input.on('drop', listener)`.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DROP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DROP} event instead.",
  "Phaser.Input.Events.GAMEOBJECT_DOWN": "The Game Object Down Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is pressed down on _any_ interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('gameobjectdown', listener)`.\n\nTo receive this event, the Game Objects must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN} event instead.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}\n2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}\n3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_DRAG_END": "The Game Object Drag End Event.\n\nThis event is dispatched by an interactive Game Object if a pointer stops dragging it.\n\nListen to this event from a Game Object using: `gameObject.on('dragend', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive and enabled for drag.\nSee [GameObject.setInteractive](Phaser.GameObjects.GameObject#setInteractive) for more details.",
  "Phaser.Input.Events.GAMEOBJECT_DRAG_ENTER": "The Game Object Drag Enter Event.\n\nThis event is dispatched by an interactive Game Object if a pointer drags it into a drag target.\n\nListen to this event from a Game Object using: `gameObject.on('dragenter', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive and enabled for drag.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.",
  "Phaser.Input.Events.GAMEOBJECT_DRAG": "The Game Object Drag Event.\n\nThis event is dispatched by an interactive Game Object if a pointer moves while dragging it.\n\nListen to this event from a Game Object using: `gameObject.on('drag', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive and enabled for drag.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.",
  "Phaser.Input.Events.GAMEOBJECT_DRAG_LEAVE": "The Game Object Drag Leave Event.\n\nThis event is dispatched by an interactive Game Object if a pointer drags it out of a drag target.\n\nListen to this event from a Game Object using: `gameObject.on('dragleave', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive and enabled for drag.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.",
  "Phaser.Input.Events.GAMEOBJECT_DRAG_OVER": "The Game Object Drag Over Event.\n\nThis event is dispatched by an interactive Game Object if a pointer drags it over a drag target.\n\nWhen the Game Object first enters the drag target it will emit a `dragenter` event. If it then moves while within\nthe drag target, it will emit this event instead.\n\nListen to this event from a Game Object using: `gameObject.on('dragover', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive and enabled for drag.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.",
  "Phaser.Input.Events.GAMEOBJECT_DRAG_START": "The Game Object Drag Start Event.\n\nThis event is dispatched by an interactive Game Object if a pointer starts to drag it.\n\nListen to this event from a Game Object using: `gameObject.on('dragstart', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive and enabled for drag.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nThere are lots of useful drag related properties that are set within the Game Object when dragging occurs.\nFor example, `gameObject.input.dragStartX`, `dragStartY` and so on.",
  "Phaser.Input.Events.GAMEOBJECT_DROP": "The Game Object Drop Event.\n\nThis event is dispatched by an interactive Game Object if a pointer drops it on a Drag Target.\n\nListen to this event from a Game Object using: `gameObject.on('drop', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive and enabled for drag.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.",
  "Phaser.Input.Events.GAMEOBJECT_MOVE": "The Game Object Move Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is moved across _any_ interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('gameobjectmove', listener)`.\n\nTo receive this event, the Game Objects must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE} event instead.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE}\n2. [GAMEOBJECT_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_MOVE}\n3. [POINTER_MOVE]{@linkcode Phaser.Input.Events#event:POINTER_MOVE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_OUT": "The Game Object Out Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer moves out of _any_ interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('gameobjectout', listener)`.\n\nTo receive this event, the Game Objects must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT} event instead.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT}\n2. [GAMEOBJECT_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OUT}\n3. [POINTER_OUT]{@linkcode Phaser.Input.Events#event:POINTER_OUT}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.\n\nIf the pointer leaves the game canvas itself, it will not trigger an this event. To handle those cases,\nplease listen for the [GAME_OUT]{@linkcode Phaser.Input.Events#event:GAME_OUT} event.",
  "Phaser.Input.Events.GAMEOBJECT_OVER": "The Game Object Over Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer moves over _any_ interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('gameobjectover', listener)`.\n\nTo receive this event, the Game Objects must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER} event instead.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER}\n2. [GAMEOBJECT_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OVER}\n3. [POINTER_OVER]{@linkcode Phaser.Input.Events#event:POINTER_OVER}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN": "The Game Object Pointer Down Event.\n\nThis event is dispatched by an interactive Game Object if a pointer is pressed down on it.\n\nListen to this event from a Game Object using: `gameObject.on('pointerdown', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}\n2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}\n3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_POINTER_MOVE": "The Game Object Pointer Move Event.\n\nThis event is dispatched by an interactive Game Object if a pointer is moved while over it.\n\nListen to this event from a Game Object using: `gameObject.on('pointermove', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE}\n2. [GAMEOBJECT_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_MOVE}\n3. [POINTER_MOVE]{@linkcode Phaser.Input.Events#event:POINTER_MOVE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_POINTER_OUT": "The Game Object Pointer Out Event.\n\nThis event is dispatched by an interactive Game Object if a pointer moves out of it.\n\nListen to this event from a Game Object using: `gameObject.on('pointerout', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT}\n2. [GAMEOBJECT_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OUT}\n3. [POINTER_OUT]{@linkcode Phaser.Input.Events#event:POINTER_OUT}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.\n\nIf the pointer leaves the game canvas itself, it will not trigger an this event. To handle those cases,\nplease listen for the [GAME_OUT]{@linkcode Phaser.Input.Events#event:GAME_OUT} event.",
  "Phaser.Input.Events.GAMEOBJECT_POINTER_OVER": "The Game Object Pointer Over Event.\n\nThis event is dispatched by an interactive Game Object if a pointer moves over it.\n\nListen to this event from a Game Object using: `gameObject.on('pointerover', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER}\n2. [GAMEOBJECT_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OVER}\n3. [POINTER_OVER]{@linkcode Phaser.Input.Events#event:POINTER_OVER}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_POINTER_UP": "The Game Object Pointer Up Event.\n\nThis event is dispatched by an interactive Game Object if a pointer is released while over it.\n\nListen to this event from a Game Object using: `gameObject.on('pointerup', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}\n2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}\n3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_POINTER_WHEEL": "The Game Object Pointer Wheel Event.\n\nThis event is dispatched by an interactive Game Object if a pointer has its wheel moved while over it.\n\nListen to this event from a Game Object using: `gameObject.on('wheel', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_WHEEL}\n2. [GAMEOBJECT_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_WHEEL}\n3. [POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:POINTER_WHEEL}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_UP": "The Game Object Up Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is released while over _any_ interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('gameobjectup', listener)`.\n\nTo receive this event, the Game Objects must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP} event instead.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}\n2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}\n3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_WHEEL": "The Game Object Wheel Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer has its wheel moved while over _any_ interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('gameobjectwheel', listener)`.\n\nTo receive this event, the Game Objects must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_WHEEL} event instead.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_WHEEL}\n2. [GAMEOBJECT_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_WHEEL}\n3. [POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:POINTER_WHEEL}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAME_OUT": "The Input Plugin Game Out Event.\n\nThis event is dispatched by the Input Plugin if the active pointer leaves the game canvas and is now\noutside of it, elsewhere on the web page.\n\nListen to this event from within a Scene using: `this.input.on('gameout', listener)`.",
  "Phaser.Input.Events.GAME_OVER": "The Input Plugin Game Over Event.\n\nThis event is dispatched by the Input Plugin if the active pointer enters the game canvas and is now\nover of it, having previously been elsewhere on the web page.\n\nListen to this event from within a Scene using: `this.input.on('gameover', listener)`.",
  "Phaser.Input.Events.MANAGER_BOOT": "The Input Manager Boot Event.\n\nThis internal event is dispatched by the Input Manager when it boots.",
  "Phaser.Input.Events.MANAGER_PROCESS": "The Input Manager Process Event.\n\nThis internal event is dispatched by the Input Manager when not using the legacy queue system,\nand it wants the Input Plugins to update themselves.",
  "Phaser.Input.Events.MANAGER_UPDATE": "The Input Manager Update Event.\n\nThis internal event is dispatched by the Input Manager as part of its update step.",
  "Phaser.Input.Events.POINTERLOCK_CHANGE": "The Input Manager Pointer Lock Change Event.\n\nThis event is dispatched by the Input Manager when it is processing a native Pointer Lock Change DOM Event.",
  "Phaser.Input.Events.POINTER_DOWN": "The Pointer Down Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is pressed down anywhere.\n\nListen to this event from within a Scene using: `this.input.on('pointerdown', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}\n2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}\n3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.POINTER_DOWN_OUTSIDE": "The Pointer Down Outside Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is pressed down anywhere outside of the game canvas.\n\nListen to this event from within a Scene using: `this.input.on('pointerdownoutside', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}\n2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}\n3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.POINTER_MOVE": "The Pointer Move Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is moved anywhere.\n\nListen to this event from within a Scene using: `this.input.on('pointermove', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE}\n2. [GAMEOBJECT_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_MOVE}\n3. [POINTER_MOVE]{@linkcode Phaser.Input.Events#event:POINTER_MOVE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.POINTER_OUT": "The Pointer Out Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer moves out of any interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('pointerout', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT}\n2. [GAMEOBJECT_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OUT}\n3. [POINTER_OUT]{@linkcode Phaser.Input.Events#event:POINTER_OUT}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.\n\nIf the pointer leaves the game canvas itself, it will not trigger an this event. To handle those cases,\nplease listen for the [GAME_OUT]{@linkcode Phaser.Input.Events#event:GAME_OUT} event.",
  "Phaser.Input.Events.POINTER_OVER": "The Pointer Over Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer moves over any interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('pointerover', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER}\n2. [GAMEOBJECT_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OVER}\n3. [POINTER_OVER]{@linkcode Phaser.Input.Events#event:POINTER_OVER}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.POINTER_UP": "The Pointer Up Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is released anywhere.\n\nListen to this event from within a Scene using: `this.input.on('pointerup', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}\n2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}\n3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.POINTER_UP_OUTSIDE": "The Pointer Up Outside Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is released anywhere outside of the game canvas.\n\nListen to this event from within a Scene using: `this.input.on('pointerupoutside', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}\n2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}\n3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.POINTER_WHEEL": "The Pointer Wheel Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer has its wheel updated.\n\nListen to this event from within a Scene using: `this.input.on('wheel', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_WHEEL}\n2. [GAMEOBJECT_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_WHEEL}\n3. [POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:POINTER_WHEEL}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.PRE_UPDATE": "The Input Plugin Pre-Update Event.\n\nThis internal event is dispatched by the Input Plugin at the start of its `preUpdate` method.\nThis hook is designed specifically for input plugins, but can also be listened to from user-land code.",
  "Phaser.Input.Events.SHUTDOWN": "The Input Plugin Shutdown Event.\n\nThis internal event is dispatched by the Input Plugin when it shuts down, signalling to all of its systems to shut themselves down.",
  "Phaser.Input.Events.START": "The Input Plugin Start Event.\n\nThis internal event is dispatched by the Input Plugin when it has finished setting-up,\nsignalling to all of its internal systems to start.",
  "Phaser.Input.Events.UPDATE": "The Input Plugin Update Event.\n\nThis internal event is dispatched by the Input Plugin at the start of its `update` method.\nThis hook is designed specifically for input plugins, but can also be listened to from user-land code.",
  "Phaser.Input.Gamepad.Events.BUTTON_DOWN": "The Gamepad Button Down Event.\n\nThis event is dispatched by the Gamepad Plugin when a button has been pressed on any active Gamepad.\n\nListen to this event from within a Scene using: `this.input.gamepad.on('down', listener)`.\n\nYou can also listen for a DOWN event from a Gamepad instance. See the [GAMEPAD_BUTTON_DOWN]{@linkcode Phaser.Input.Gamepad.Events#event:GAMEPAD_BUTTON_DOWN} event for details.",
  "Phaser.Input.Gamepad.Events.BUTTON_UP": "The Gamepad Button Up Event.\n\nThis event is dispatched by the Gamepad Plugin when a button has been released on any active Gamepad.\n\nListen to this event from within a Scene using: `this.input.gamepad.on('up', listener)`.\n\nYou can also listen for an UP event from a Gamepad instance. See the [GAMEPAD_BUTTON_UP]{@linkcode Phaser.Input.Gamepad.Events#event:GAMEPAD_BUTTON_UP} event for details.",
  "Phaser.Input.Gamepad.Events.CONNECTED": "The Gamepad Connected Event.\n\nThis event is dispatched by the Gamepad Plugin when a Gamepad has been connected.\n\nListen to this event from within a Scene using: `this.input.gamepad.once('connected', listener)`.\n\nNote that the browser may require you to press a button on a gamepad before it will allow you to access it,\nthis is for security reasons. However, it may also trust the page already, in which case you won't get the\n'connected' event and instead should check `GamepadPlugin.total` to see if it thinks there are any gamepads\nalready connected.",
  "Phaser.Input.Gamepad.Events.DISCONNECTED": "The Gamepad Disconnected Event.\n\nThis event is dispatched by the Gamepad Plugin when a Gamepad has been disconnected.\n\nListen to this event from within a Scene using: `this.input.gamepad.once('disconnected', listener)`.",
  "Phaser.Input.Gamepad.Events.GAMEPAD_BUTTON_DOWN": "The Gamepad Button Down Event.\n\nThis event is dispatched by a Gamepad instance when a button has been pressed on it.\n\nListen to this event from a Gamepad instance. Once way to get this is from the `pad1`, `pad2`, etc properties on the Gamepad Plugin:\n`this.input.gamepad.pad1.on('down', listener)`.\n\nNote that you will not receive any Gamepad button events until the browser considers the Gamepad as being 'connected'.\n\nYou can also listen for a DOWN event from the Gamepad Plugin. See the [BUTTON_DOWN]{@linkcode Phaser.Input.Gamepad.Events#event:BUTTON_DOWN} event for details.",
  "Phaser.Input.Gamepad.Events.GAMEPAD_BUTTON_UP": "The Gamepad Button Up Event.\n\nThis event is dispatched by a Gamepad instance when a button has been released on it.\n\nListen to this event from a Gamepad instance. Once way to get this is from the `pad1`, `pad2`, etc properties on the Gamepad Plugin:\n`this.input.gamepad.pad1.on('up', listener)`.\n\nNote that you will not receive any Gamepad button events until the browser considers the Gamepad as being 'connected'.\n\nYou can also listen for an UP event from the Gamepad Plugin. See the [BUTTON_UP]{@linkcode Phaser.Input.Gamepad.Events#event:BUTTON_UP} event for details.",
  "Phaser.Input.Keyboard.Events.ANY_KEY_DOWN": "The Global Key Down Event.\n\nThis event is dispatched by the Keyboard Plugin when any key on the keyboard is pressed down.\n\nListen to this event from within a Scene using: `this.input.keyboard.on('keydown', listener)`.\n\nYou can also listen for a specific key being pressed. See [Keyboard.Events.KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:KEY_DOWN} for details.\n\nFinally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:DOWN} for details.\n\n_Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\nRead [this article on ghosting]{@link http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/} for details.\n\nAlso, please be aware that some browser extensions can disable or override Phaser keyboard handling.\nFor example, the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.\nThere are others. So, please check your extensions if you find you have specific keys that don't work.",
  "Phaser.Input.Keyboard.Events.ANY_KEY_UP": "The Global Key Up Event.\n\nThis event is dispatched by the Keyboard Plugin when any key on the keyboard is released.\n\nListen to this event from within a Scene using: `this.input.keyboard.on('keyup', listener)`.\n\nYou can also listen for a specific key being released. See [Keyboard.Events.KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:KEY_UP} for details.\n\nFinally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.UP]{@linkcode Phaser.Input.Keyboard.Events#event:UP} for details.",
  "Phaser.Input.Keyboard.Events.COMBO_MATCH": "The Key Combo Match Event.\n\nThis event is dispatched by the Keyboard Plugin when a [Key Combo]{@link Phaser.Input.Keyboard.KeyCombo} is matched.\n\nListen for this event from the Key Plugin after a combo has been created:\n\n```javascript\nthis.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });\n\nthis.input.keyboard.on('keycombomatch', function (event) {\n    console.log('Konami Code entered!');\n});\n```",
  "Phaser.Input.Keyboard.Events.DOWN": "The Key Down Event.\n\nThis event is dispatched by a [Key]{@link Phaser.Input.Keyboard.Key} object when it is pressed.\n\nListen for this event from the Key object instance directly:\n\n```javascript\nvar spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\nspaceBar.on('down', listener)\n```\n\nYou can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_DOWN} for details.",
  "Phaser.Input.Keyboard.Events.KEY_DOWN": "The Key Down Event.\n\nThis event is dispatched by the Keyboard Plugin when any key on the keyboard is pressed down.\n\nUnlike the `ANY_KEY_DOWN` event, this one has a special dynamic event name. For example, to listen for the `A` key being pressed\nuse the following from within a Scene: `this.input.keyboard.on('keydown-A', listener)`. You can replace the `-A` part of the event\nname with any valid [Key Code string]{@link Phaser.Input.Keyboard.KeyCodes}. For example, this will listen for the space bar:\n`this.input.keyboard.on('keydown-SPACE', listener)`.\n\nYou can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_DOWN} for details.\n\nFinally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:DOWN} for details.\n\n_Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\nRead [this article on ghosting]{@link http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/} for details.\n\nAlso, please be aware that some browser extensions can disable or override Phaser keyboard handling.\nFor example, the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.\nThere are others. So, please check your extensions if you find you have specific keys that don't work.",
  "Phaser.Input.Keyboard.Events.KEY_UP": "The Key Up Event.\n\nThis event is dispatched by the Keyboard Plugin when any key on the keyboard is released.\n\nUnlike the `ANY_KEY_UP` event, this one has a special dynamic event name. For example, to listen for the `A` key being released\nuse the following from within a Scene: `this.input.keyboard.on('keyup-A', listener)`. You can replace the `-A` part of the event\nname with any valid [Key Code string]{@link Phaser.Input.Keyboard.KeyCodes}. For example, this will listen for the space bar:\n`this.input.keyboard.on('keyup-SPACE', listener)`.\n\nYou can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_UP} for details.\n\nFinally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.UP]{@linkcode Phaser.Input.Keyboard.Events#event:UP} for details.",
  "Phaser.Input.Keyboard.Events.UP": "The Key Up Event.\n\nThis event is dispatched by a [Key]{@link Phaser.Input.Keyboard.Key} object when it is released.\n\nListen for this event from the Key object instance directly:\n\n```javascript\nvar spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\nspaceBar.on('up', listener)\n```\n\nYou can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_UP} for details.",
  "Phaser.Loader.Events.ADD": "The Loader Plugin Add File Event.\n\nThis event is dispatched when a new file is successfully added to the Loader and placed into the load queue.\n\nListen to it from a Scene using: `this.load.on('addfile', listener)`.\n\nIf you add lots of files to a Loader from a `preload` method, it will dispatch this event for each one of them.",
  "Phaser.Loader.Events.COMPLETE": "The Loader Plugin Complete Event.\n\nThis event is dispatched when the Loader has fully processed everything in the load queue.\nBy this point every loaded file will now be in its associated cache and ready for use.\n\nListen to it from a Scene using: `this.load.on('complete', listener)`.",
  "Phaser.Loader.Events.FILE_COMPLETE": "The File Load Complete Event.\n\nThis event is dispatched by the Loader Plugin when _any_ file in the queue finishes loading.\n\nListen to it from a Scene using: `this.load.on('filecomplete', listener)`.\n\nMake sure you remove this listener when you have finished, or it will continue to fire if the Scene reloads.\n\nYou can also listen for the completion of a specific file. See the [FILE_KEY_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_KEY_COMPLETE} event.",
  "Phaser.Loader.Events.FILE_KEY_COMPLETE": "The File Load Complete Event.\n\nThis event is dispatched by the Loader Plugin when any file in the queue finishes loading.\n\nIt uses a special dynamic event name constructed from the key and type of the file.\n\nFor example, if you have loaded an `image` with a key of `monster`, you can listen for it\nusing the following:\n\n```javascript\nthis.load.on('filecomplete-image-monster', function (key, type, data) {\n    // Your handler code\n});\n```\n\nOr, if you have loaded a texture `atlas` with a key of `Level1`:\n\n```javascript\nthis.load.on('filecomplete-atlasjson-Level1', function (key, type, data) {\n    // Your handler code\n});\n```\n\nOr, if you have loaded a sprite sheet with a key of `Explosion` and a prefix of `GAMEOVER`:\n\n```javascript\nthis.load.on('filecomplete-spritesheet-GAMEOVERExplosion', function (key, type, data) {\n    // Your handler code\n});\n```\n\nMake sure you remove your listeners when you have finished, or they will continue to fire if the Scene reloads.\n\nYou can also listen for the generic completion of files. See the [FILE_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_COMPLETE} event.",
  "Phaser.Loader.Events.FILE_LOAD_ERROR": "The File Load Error Event.\n\nThis event is dispatched by the Loader Plugin when a file fails to load.\n\nListen to it from a Scene using: `this.load.on('loaderror', listener)`.",
  "Phaser.Loader.Events.FILE_LOAD": "The File Load Event.\n\nThis event is dispatched by the Loader Plugin when a file finishes loading,\nbut _before_ it is processed and added to the internal Phaser caches.\n\nListen to it from a Scene using: `this.load.on('load', listener)`.",
  "Phaser.Loader.Events.FILE_PROGRESS": "The File Load Progress Event.\n\nThis event is dispatched by the Loader Plugin during the load of a file, if the browser receives a DOM ProgressEvent and\nthe `lengthComputable` event property is true. Depending on the size of the file and browser in use, this may, or may not happen.\n\nListen to it from a Scene using: `this.load.on('fileprogress', listener)`.",
  "Phaser.Loader.Events.POST_PROCESS": "The Loader Plugin Post Process Event.\n\nThis event is dispatched by the Loader Plugin when the Loader has finished loading everything in the load queue.\nIt is dispatched before the internal lists are cleared and each File is destroyed.\n\nUse this hook to perform any last minute processing of files that can only happen once the\nLoader has completed, but prior to it emitting the `complete` event.\n\nListen to it from a Scene using: `this.load.on('postprocess', listener)`.",
  "Phaser.Loader.Events.PROGRESS": "The Loader Plugin Progress Event.\n\nThis event is dispatched when the Loader updates its load progress, typically as a result of a file having completed loading.\n\nListen to it from a Scene using: `this.load.on('progress', listener)`.",
  "Phaser.Loader.Events.START": "The Loader Plugin Start Event.\n\nThis event is dispatched when the Loader starts running. At this point load progress is zero.\n\nThis event is dispatched even if there aren't any files in the load queue.\n\nListen to it from a Scene using: `this.load.on('start', listener)`.",
  "Phaser.Physics.Arcade.Events.COLLIDE": "The Arcade Physics World Collide Event.\n\nThis event is dispatched by an Arcade Physics World instance if two bodies collide _and_ at least\none of them has their [onCollide]{@link Phaser.Physics.Arcade.Body#onCollide} property set to `true`.\n\nIt provides an alternative means to handling collide events rather than using the callback approach.\n\nListen to it from a Scene using: `this.physics.world.on('collide', listener)`.\n\nPlease note that 'collide' and 'overlap' are two different things in Arcade Physics.",
  "Phaser.Physics.Arcade.Events.OVERLAP": "The Arcade Physics World Overlap Event.\n\nThis event is dispatched by an Arcade Physics World instance if two bodies overlap _and_ at least\none of them has their [onOverlap]{@link Phaser.Physics.Arcade.Body#onOverlap} property set to `true`.\n\nIt provides an alternative means to handling overlap events rather than using the callback approach.\n\nListen to it from a Scene using: `this.physics.world.on('overlap', listener)`.\n\nPlease note that 'collide' and 'overlap' are two different things in Arcade Physics.",
  "Phaser.Physics.Arcade.Events.PAUSE": "The Arcade Physics World Pause Event.\n\nThis event is dispatched by an Arcade Physics World instance when it is paused.\n\nListen to it from a Scene using: `this.physics.world.on('pause', listener)`.",
  "Phaser.Physics.Arcade.Events.RESUME": "The Arcade Physics World Resume Event.\n\nThis event is dispatched by an Arcade Physics World instance when it resumes from a paused state.\n\nListen to it from a Scene using: `this.physics.world.on('resume', listener)`.",
  "Phaser.Physics.Arcade.Events.TILE_COLLIDE": "The Arcade Physics Tile Collide Event.\n\nThis event is dispatched by an Arcade Physics World instance if a body collides with a Tile _and_\nhas its [onCollide]{@link Phaser.Physics.Arcade.Body#onCollide} property set to `true`.\n\nIt provides an alternative means to handling collide events rather than using the callback approach.\n\nListen to it from a Scene using: `this.physics.world.on('tilecollide', listener)`.\n\nPlease note that 'collide' and 'overlap' are two different things in Arcade Physics.",
  "Phaser.Physics.Arcade.Events.TILE_OVERLAP": "The Arcade Physics Tile Overlap Event.\n\nThis event is dispatched by an Arcade Physics World instance if a body overlaps with a Tile _and_\nhas its [onOverlap]{@link Phaser.Physics.Arcade.Body#onOverlap} property set to `true`.\n\nIt provides an alternative means to handling overlap events rather than using the callback approach.\n\nListen to it from a Scene using: `this.physics.world.on('tileoverlap', listener)`.\n\nPlease note that 'collide' and 'overlap' are two different things in Arcade Physics.",
  "Phaser.Physics.Arcade.Events.WORLD_BOUNDS": "The Arcade Physics World Bounds Event.\n\nThis event is dispatched by an Arcade Physics World instance if a body makes contact with the world bounds _and_\nit has its [onWorldBounds]{@link Phaser.Physics.Arcade.Body#onWorldBounds} property set to `true`.\n\nIt provides an alternative means to handling collide events rather than using the callback approach.\n\nListen to it from a Scene using: `this.physics.world.on('worldbounds', listener)`.",
  "Phaser.Physics.Arcade.Events.WORLD_STEP": "The Arcade Physics World Step Event.\n\nThis event is dispatched by an Arcade Physics World instance whenever a physics step is run.\nIt is emitted _after_ the bodies and colliders have been updated.\n\nIn high framerate settings this can be multiple times per game frame.\n\nListen to it from a Scene using: `this.physics.world.on('worldstep', listener)`.",
  "Phaser.Physics.Matter.Events.AFTER_ADD": "The Matter Physics After Add Event.\n\nThis event is dispatched by a Matter Physics World instance at the end of the process when a new Body\nor Constraint has just been added to the world.\n\nListen to it from a Scene using: `this.matter.world.on('afteradd', listener)`.",
  "Phaser.Physics.Matter.Events.AFTER_REMOVE": "The Matter Physics After Remove Event.\n\nThis event is dispatched by a Matter Physics World instance at the end of the process when a\nBody or Constraint was removed from the world.\n\nListen to it from a Scene using: `this.matter.world.on('afterremove', listener)`.",
  "Phaser.Physics.Matter.Events.AFTER_UPDATE": "The Matter Physics After Update Event.\n\nThis event is dispatched by a Matter Physics World instance after the engine has updated and all collision events have resolved.\n\nListen to it from a Scene using: `this.matter.world.on('afterupdate', listener)`.",
  "Phaser.Physics.Matter.Events.BEFORE_ADD": "The Matter Physics Before Add Event.\n\nThis event is dispatched by a Matter Physics World instance at the start of the process when a new Body\nor Constraint is being added to the world.\n\nListen to it from a Scene using: `this.matter.world.on('beforeadd', listener)`.",
  "Phaser.Physics.Matter.Events.BEFORE_REMOVE": "The Matter Physics Before Remove Event.\n\nThis event is dispatched by a Matter Physics World instance at the start of the process when a\nBody or Constraint is being removed from the world.\n\nListen to it from a Scene using: `this.matter.world.on('beforeremove', listener)`.",
  "Phaser.Physics.Matter.Events.BEFORE_UPDATE": "The Matter Physics Before Update Event.\n\nThis event is dispatched by a Matter Physics World instance right before all the collision processing takes place.\n\nListen to it from a Scene using: `this.matter.world.on('beforeupdate', listener)`.",
  "Phaser.Physics.Matter.Events.COLLISION_ACTIVE": "The Matter Physics Collision Active Event.\n\nThis event is dispatched by a Matter Physics World instance after the engine has updated.\nIt provides a list of all pairs that are colliding in the current tick (if any).\n\nListen to it from a Scene using: `this.matter.world.on('collisionactive', listener)`.",
  "Phaser.Physics.Matter.Events.COLLISION_END": "The Matter Physics Collision End Event.\n\nThis event is dispatched by a Matter Physics World instance after the engine has updated.\nIt provides a list of all pairs that have finished colliding in the current tick (if any).\n\nListen to it from a Scene using: `this.matter.world.on('collisionend', listener)`.",
  "Phaser.Physics.Matter.Events.COLLISION_START": "The Matter Physics Collision Start Event.\n\nThis event is dispatched by a Matter Physics World instance after the engine has updated.\nIt provides a list of all pairs that have started to collide in the current tick (if any).\n\nListen to it from a Scene using: `this.matter.world.on('collisionstart', listener)`.",
  "Phaser.Physics.Matter.Events.DRAG_END": "The Matter Physics Drag End Event.\n\nThis event is dispatched by a Matter Physics World instance when a Pointer Constraint\nstops dragging a body.\n\nListen to it from a Scene using: `this.matter.world.on('dragend', listener)`.",
  "Phaser.Physics.Matter.Events.DRAG": "The Matter Physics Drag Event.\n\nThis event is dispatched by a Matter Physics World instance when a Pointer Constraint\nis actively dragging a body. It is emitted each time the pointer moves.\n\nListen to it from a Scene using: `this.matter.world.on('drag', listener)`.",
  "Phaser.Physics.Matter.Events.DRAG_START": "The Matter Physics Drag Start Event.\n\nThis event is dispatched by a Matter Physics World instance when a Pointer Constraint\nstarts dragging a body.\n\nListen to it from a Scene using: `this.matter.world.on('dragstart', listener)`.",
  "Phaser.Physics.Matter.Events.PAUSE": "The Matter Physics World Pause Event.\n\nThis event is dispatched by an Matter Physics World instance when it is paused.\n\nListen to it from a Scene using: `this.matter.world.on('pause', listener)`.",
  "Phaser.Physics.Matter.Events.RESUME": "The Matter Physics World Resume Event.\n\nThis event is dispatched by an Matter Physics World instance when it resumes from a paused state.\n\nListen to it from a Scene using: `this.matter.world.on('resume', listener)`.",
  "Phaser.Physics.Matter.Events.SLEEP_END": "The Matter Physics Sleep End Event.\n\nThis event is dispatched by a Matter Physics World instance when a Body stop sleeping.\n\nListen to it from a Scene using: `this.matter.world.on('sleepend', listener)`.",
  "Phaser.Physics.Matter.Events.SLEEP_START": "The Matter Physics Sleep Start Event.\n\nThis event is dispatched by a Matter Physics World instance when a Body goes to sleep.\n\nListen to it from a Scene using: `this.matter.world.on('sleepstart', listener)`.",
  "Phaser.Renderer.Events.POST_RENDER": "The Post-Render Event.\n\nThis event is dispatched by the Renderer when all rendering, for all cameras in all Scenes,\nhas completed, but before any pending snap shots have been taken.",
  "Phaser.Renderer.Events.PRE_RENDER": "The Pre-Render Event.\n\nThis event is dispatched by the Phaser Renderer. This happens right at the start of the render\nprocess, after the context has been cleared, the scissors enabled (WebGL only) and everything has been\nreset ready for the render.",
  "Phaser.Renderer.Events.RENDER": "The Render Event.\n\nThis event is dispatched by the Phaser Renderer for every camera in every Scene.\n\nIt is dispatched before any of the children in the Scene have been rendered.",
  "Phaser.Renderer.Events.RESIZE": "The Renderer Resize Event.\n\nThis event is dispatched by the Phaser Renderer when it is resized, usually as a result\nof the Scale Manager resizing.",
  "Phaser.Renderer.WebGL.Pipelines.Events.AFTER_FLUSH": "The WebGLPipeline After Flush Event.\n\nThis event is dispatched by a WebGLPipeline right after it has issued a drawArrays command\nand cleared its vertex count.",
  "Phaser.Renderer.WebGL.Pipelines.Events.BEFORE_FLUSH": "The WebGLPipeline Before Flush Event.\n\nThis event is dispatched by a WebGLPipeline right before it is about to\nflush and issue a bufferData and drawArrays command.",
  "Phaser.Renderer.WebGL.Pipelines.Events.BIND": "The WebGLPipeline Bind Event.\n\nThis event is dispatched by a WebGLPipeline when it is bound by the Pipeline Manager.",
  "Phaser.Renderer.WebGL.Pipelines.Events.BOOT": "The WebGLPipeline Boot Event.\n\nThis event is dispatched by a WebGLPipeline when it has completed its `boot` phase.",
  "Phaser.Renderer.WebGL.Pipelines.Events.DESTROY": "The WebGLPipeline Destroy Event.\n\nThis event is dispatched by a WebGLPipeline when it is starting its destroy process.",
  "Phaser.Renderer.WebGL.Pipelines.Events.REBIND": "The WebGLPipeline ReBind Event.\n\nThis event is dispatched by a WebGLPipeline when it is re-bound by the Pipeline Manager.",
  "Phaser.Renderer.WebGL.Pipelines.Events.RESIZE": "The WebGLPipeline Resize Event.\n\nThis event is dispatched by a WebGLPipeline when it is resized, usually as a result\nof the Renderer resizing.",
  "Phaser.Scale.Events.ENTER_FULLSCREEN": "The Scale Manager has successfully entered fullscreen mode.",
  "Phaser.Scale.Events.FULLSCREEN_FAILED": "The Scale Manager tried to enter fullscreen mode but failed.",
  "Phaser.Scale.Events.FULLSCREEN_UNSUPPORTED": "The Scale Manager tried to enter fullscreen mode, but it is unsupported by the browser.",
  "Phaser.Scale.Events.LEAVE_FULLSCREEN": "The Scale Manager was in fullscreen mode, but has since left, either directly via game code,\nor via a user gestured, such as pressing the ESC key.",
  "Phaser.Scale.Events.ORIENTATION_CHANGE": "The Scale Manager Orientation Change Event.\n\nThis event is dispatched whenever the Scale Manager detects an orientation change event from the browser.",
  "Phaser.Scale.Events.RESIZE": "The Scale Manager Resize Event.\n\nThis event is dispatched whenever the Scale Manager detects a resize event from the browser.\nIt sends three parameters to the callback, each of them being Size components. You can read\nthe `width`, `height`, `aspectRatio` and other properties of these components to help with\nscaling your own game content.",
  "Phaser.Scenes.Events.ADDED_TO_SCENE": "The Game Object Added to Scene Event.\n\nThis event is dispatched when a Game Object is added to a Scene.\n\nListen for it from a Scene using `this.events.on('addedtoscene', listener)`.",
  "Phaser.Scenes.Events.BOOT": "The Scene Systems Boot Event.\n\nThis event is dispatched by a Scene during the Scene Systems boot process. Primarily used by Scene Plugins.\n\nListen to it from a Scene using `this.events.on('boot', listener)`.",
  "Phaser.Scenes.Events.CREATE": "The Scene Create Event.\n\nThis event is dispatched by a Scene after it has been created by the Scene Manager.\n\nIf a Scene has a `create` method then this event is emitted _after_ that has run.\n\nIf there is a transition, this event will be fired after the `TRANSITION_START` event.\n\nListen to it from a Scene using `this.events.on('create', listener)`.",
  "Phaser.Scenes.Events.DESTROY": "The Scene Systems Destroy Event.\n\nThis event is dispatched by a Scene during the Scene Systems destroy process.\n\nListen to it from a Scene using `this.events.on('destroy', listener)`.\n\nYou should destroy any resources that may be in use by your Scene in this event handler.",
  "Phaser.Scenes.Events.PAUSE": "The Scene Systems Pause Event.\n\nThis event is dispatched by a Scene when it is paused, either directly via the `pause` method, or as an\naction from another Scene.\n\nListen to it from a Scene using `this.events.on('pause', listener)`.",
  "Phaser.Scenes.Events.POST_UPDATE": "The Scene Systems Post Update Event.\n\nThis event is dispatched by a Scene during the main game loop step.\n\nThe event flow for a single step of a Scene is as follows:\n\n1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\n2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\n3. The `Scene.update` method is called, if it exists\n4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\n5. [PRE_RENDER]{@linkcode Phaser.Scenes.Events#event:PRE_RENDER}\n6. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\n\nListen to it from a Scene using `this.events.on('postupdate', listener)`.\n\nA Scene will only run its step if it is active.",
  "Phaser.Scenes.Events.PRE_RENDER": "The Scene Systems Pre-Render Event.\n\nThis event is dispatched by a Scene during the main game loop step.\n\nThe event flow for a single step of a Scene is as follows:\n\n1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\n2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\n3. The `Scene.update` method is called, if it exists\n4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\n5. [PRE_RENDER]{@linkcode Phaser.Scenes.Events#event:PRE_RENDER}\n6. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\n\nListen to this event from a Scene using `this.events.on('prerender', listener)`.\n\nA Scene will only render if it is visible.\n\nThis event is dispatched after the Scene Display List is sorted and before the Scene is rendered.",
  "Phaser.Scenes.Events.PRE_UPDATE": "The Scene Systems Pre Update Event.\n\nThis event is dispatched by a Scene during the main game loop step.\n\nThe event flow for a single step of a Scene is as follows:\n\n1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\n2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\n3. The `Scene.update` method is called, if it exists\n4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\n5. [PRE_RENDER]{@linkcode Phaser.Scenes.Events#event:PRE_RENDER}\n6. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\n\nListen to it from a Scene using `this.events.on('preupdate', listener)`.\n\nA Scene will only run its step if it is active.",
  "Phaser.Scenes.Events.READY": "The Scene Systems Ready Event.\n\nThis event is dispatched by a Scene during the Scene Systems start process.\nBy this point in the process the Scene is now fully active and rendering.\nThis event is meant for your game code to use, as all plugins have responded to the earlier 'start' event.\n\nListen to it from a Scene using `this.events.on('ready', listener)`.",
  "Phaser.Scenes.Events.REMOVED_FROM_SCENE": "The Game Object Removed from Scene Event.\n\nThis event is dispatched when a Game Object is removed from a Scene.\n\nListen for it from a Scene using `this.events.on('removedfromscene', listener)`.",
  "Phaser.Scenes.Events.RENDER": "The Scene Systems Render Event.\n\nThis event is dispatched by a Scene during the main game loop step.\n\nThe event flow for a single step of a Scene is as follows:\n\n1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\n2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\n3. The `Scene.update` method is called, if it exists\n4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\n5. [PRE_RENDER]{@linkcode Phaser.Scenes.Events#event:PRE_RENDER}\n6. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\n\nListen to it from a Scene using `this.events.on('render', listener)`.\n\nA Scene will only render if it is visible.\n\nBy the time this event is dispatched, the Scene will have already been rendered.",
  "Phaser.Scenes.Events.RESUME": "The Scene Systems Resume Event.\n\nThis event is dispatched by a Scene when it is resumed from a paused state, either directly via the `resume` method,\nor as an action from another Scene.\n\nListen to it from a Scene using `this.events.on('resume', listener)`.",
  "Phaser.Scenes.Events.SHUTDOWN": "The Scene Systems Shutdown Event.\n\nThis event is dispatched by a Scene during the Scene Systems shutdown process.\n\nListen to it from a Scene using `this.events.on('shutdown', listener)`.\n\nYou should free-up any resources that may be in use by your Scene in this event handler, on the understanding\nthat the Scene may, at any time, become active again. A shutdown Scene is not 'destroyed', it's simply not\ncurrently active. Use the [DESTROY]{@linkcode Phaser.Scenes.Events#event:DESTROY} event to completely clear resources.",
  "Phaser.Scenes.Events.SLEEP": "The Scene Systems Sleep Event.\n\nThis event is dispatched by a Scene when it is sent to sleep, either directly via the `sleep` method,\nor as an action from another Scene.\n\nListen to it from a Scene using `this.events.on('sleep', listener)`.",
  "Phaser.Scenes.Events.START": "The Scene Systems Start Event.\n\nThis event is dispatched by a Scene during the Scene Systems start process. Primarily used by Scene Plugins.\n\nListen to it from a Scene using `this.events.on('start', listener)`.",
  "Phaser.Scenes.Events.TRANSITION_COMPLETE": "The Scene Transition Complete Event.\n\nThis event is dispatched by the Target Scene of a transition.\n\nIt happens when the transition process has completed. This occurs when the duration timer equals or exceeds the duration\nof the transition.\n\nListen to it from a Scene using `this.events.on('transitioncomplete', listener)`.\n\nThe Scene Transition event flow is as follows:\n\n1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\n2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\n3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\n4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\n5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.",
  "Phaser.Scenes.Events.TRANSITION_INIT": "The Scene Transition Init Event.\n\nThis event is dispatched by the Target Scene of a transition.\n\nIt happens immediately after the `Scene.init` method is called. If the Scene does not have an `init` method,\nthis event is not dispatched.\n\nListen to it from a Scene using `this.events.on('transitioninit', listener)`.\n\nThe Scene Transition event flow is as follows:\n\n1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\n2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\n3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\n4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\n5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.",
  "Phaser.Scenes.Events.TRANSITION_OUT": "The Scene Transition Out Event.\n\nThis event is dispatched by a Scene when it initiates a transition to another Scene.\n\nListen to it from a Scene using `this.events.on('transitionout', listener)`.\n\nThe Scene Transition event flow is as follows:\n\n1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\n2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\n3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\n4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\n5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.",
  "Phaser.Scenes.Events.TRANSITION_START": "The Scene Transition Start Event.\n\nThis event is dispatched by the Target Scene of a transition, only if that Scene was not asleep.\n\nIt happens immediately after the `Scene.create` method is called. If the Scene does not have a `create` method,\nthis event is dispatched anyway.\n\nIf the Target Scene was sleeping then the [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} event is\ndispatched instead of this event.\n\nListen to it from a Scene using `this.events.on('transitionstart', listener)`.\n\nThe Scene Transition event flow is as follows:\n\n1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\n2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\n3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\n4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\n5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.",
  "Phaser.Scenes.Events.TRANSITION_WAKE": "The Scene Transition Wake Event.\n\nThis event is dispatched by the Target Scene of a transition, only if that Scene was asleep before\nthe transition began. If the Scene was not asleep the [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} event is dispatched instead.\n\nListen to it from a Scene using `this.events.on('transitionwake', listener)`.\n\nThe Scene Transition event flow is as follows:\n\n1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\n2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\n3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\n4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\n5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.",
  "Phaser.Scenes.Events.UPDATE": "The Scene Systems Update Event.\n\nThis event is dispatched by a Scene during the main game loop step.\n\nThe event flow for a single step of a Scene is as follows:\n\n1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\n2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\n3. The `Scene.update` method is called, if it exists and the Scene is in a Running state, otherwise this is skipped.\n4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\n5. [PRE_RENDER]{@linkcode Phaser.Scenes.Events#event:PRE_RENDER}\n6. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\n\nListen to it from a Scene using `this.events.on('update', listener)`.\n\nA Scene will only run its step if it is active.",
  "Phaser.Scenes.Events.WAKE": "The Scene Systems Wake Event.\n\nThis event is dispatched by a Scene when it is woken from sleep, either directly via the `wake` method,\nor as an action from another Scene.\n\nListen to it from a Scene using `this.events.on('wake', listener)`.",
  "Phaser.Sound.Events.COMPLETE": "The Sound Complete Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they complete playback.\n\nListen to it from a Sound instance using `Sound.on('complete', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('complete', listener);\nmusic.play();\n```",
  "Phaser.Sound.Events.DECODED_ALL": "The Audio Data Decoded All Event.\n\nThis event is dispatched by the Web Audio Sound Manager as a result of calling the `decodeAudio` method,\nonce all files passed to the method have been decoded (or errored).\n\nUse `Phaser.Sound.Events#DECODED` to listen for single sounds being decoded, and `DECODED_ALL` to\nlisten for them all completing.\n\nListen to it from the Sound Manager in a Scene using `this.sound.on('decodedall', listener)`, i.e.:\n\n```javascript\nthis.sound.once('decodedall', handler);\nthis.sound.decodeAudio([ audioFiles ]);\n```",
  "Phaser.Sound.Events.DECODED": "The Audio Data Decoded Event.\n\nThis event is dispatched by the Web Audio Sound Manager as a result of calling the `decodeAudio` method.\n\nListen to it from the Sound Manager in a Scene using `this.sound.on('decoded', listener)`, i.e.:\n\n```javascript\nthis.sound.on('decoded', handler);\nthis.sound.decodeAudio(key, audioData);\n```",
  "Phaser.Sound.Events.DESTROY": "The Sound Destroy Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are destroyed, either\ndirectly or via a Sound Manager.\n\nListen to it from a Sound instance using `Sound.on('destroy', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('destroy', listener);\nmusic.destroy();\n```",
  "Phaser.Sound.Events.DETUNE": "The Sound Detune Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when their detune value changes.\n\nListen to it from a Sound instance using `Sound.on('detune', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('detune', listener);\nmusic.play();\nmusic.setDetune(200);\n```",
  "Phaser.Sound.Events.GLOBAL_DETUNE": "The Sound Manager Global Detune Event.\n\nThis event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,\nor the HTML5 Audio Manager. It is dispatched when the `detune` property of the Sound Manager is changed, which globally\nadjusts the detuning of all active sounds.\n\nListen to it from a Scene using: `this.sound.on('rate', listener)`.",
  "Phaser.Sound.Events.GLOBAL_MUTE": "The Sound Manager Global Mute Event.\n\nThis event is dispatched by the Sound Manager when its `mute` property is changed, either directly\nor via the `setMute` method. This changes the mute state of all active sounds.\n\nListen to it from a Scene using: `this.sound.on('mute', listener)`.",
  "Phaser.Sound.Events.GLOBAL_RATE": "The Sound Manager Global Rate Event.\n\nThis event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,\nor the HTML5 Audio Manager. It is dispatched when the `rate` property of the Sound Manager is changed, which globally\nadjusts the playback rate of all active sounds.\n\nListen to it from a Scene using: `this.sound.on('rate', listener)`.",
  "Phaser.Sound.Events.GLOBAL_VOLUME": "The Sound Manager Global Volume Event.\n\nThis event is dispatched by the Sound Manager when its `volume` property is changed, either directly\nor via the `setVolume` method. This changes the volume of all active sounds.\n\nListen to it from a Scene using: `this.sound.on('volume', listener)`.",
  "Phaser.Sound.Events.LOOPED": "The Sound Looped Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they loop during playback.\n\nListen to it from a Sound instance using `Sound.on('looped', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('looped', listener);\nmusic.setLoop(true);\nmusic.play();\n```\n\nThis is not to be confused with the [LOOP]{@linkcode Phaser.Sound.Events#event:LOOP} event, which only emits when the loop state of a Sound is changed.",
  "Phaser.Sound.Events.LOOP": "The Sound Loop Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when their loop state is changed.\n\nListen to it from a Sound instance using `Sound.on('loop', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('loop', listener);\nmusic.setLoop(true);\n```\n\nThis is not to be confused with the [LOOPED]{@linkcode Phaser.Sound.Events#event:LOOPED} event, which emits each time a Sound loops during playback.",
  "Phaser.Sound.Events.MUTE": "The Sound Mute Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when their mute state changes.\n\nListen to it from a Sound instance using `Sound.on('mute', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('mute', listener);\nmusic.play();\nmusic.setMute(true);\n```",
  "Phaser.Sound.Events.PAN": "The Sound Pan Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when their pan changes.\n\nListen to it from a Sound instance using `Sound.on('pan', listener)`, i.e.:\n\n```javascript\nvar sound = this.sound.add('key');\nsound.on('pan', listener);\nsound.play();\nsound.setPan(0.5);\n```",
  "Phaser.Sound.Events.PAUSE_ALL": "The Pause All Sounds Event.\n\nThis event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,\nor the HTML5 Audio Manager. It is dispatched when the `pauseAll` method is invoked and after all current Sounds\nhave been paused.\n\nListen to it from a Scene using: `this.sound.on('pauseall', listener)`.",
  "Phaser.Sound.Events.PAUSE": "The Sound Pause Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are paused.\n\nListen to it from a Sound instance using `Sound.on('pause', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('pause', listener);\nmusic.play();\nmusic.pause();\n```",
  "Phaser.Sound.Events.PLAY": "The Sound Play Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are played.\n\nListen to it from a Sound instance using `Sound.on('play', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('play', listener);\nmusic.play();\n```",
  "Phaser.Sound.Events.RATE": "The Sound Rate Change Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when their rate changes.\n\nListen to it from a Sound instance using `Sound.on('rate', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('rate', listener);\nmusic.play();\nmusic.setRate(0.5);\n```",
  "Phaser.Sound.Events.RESUME_ALL": "The Resume All Sounds Event.\n\nThis event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,\nor the HTML5 Audio Manager. It is dispatched when the `resumeAll` method is invoked and after all current Sounds\nhave been resumed.\n\nListen to it from a Scene using: `this.sound.on('resumeall', listener)`.",
  "Phaser.Sound.Events.RESUME": "The Sound Resume Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are resumed from a paused state.\n\nListen to it from a Sound instance using `Sound.on('resume', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('resume', listener);\nmusic.play();\nmusic.pause();\nmusic.resume();\n```",
  "Phaser.Sound.Events.SEEK": "The Sound Seek Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are seeked to a new position.\n\nListen to it from a Sound instance using `Sound.on('seek', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('seek', listener);\nmusic.play();\nmusic.setSeek(5000);\n```",
  "Phaser.Sound.Events.STOP_ALL": "The Stop All Sounds Event.\n\nThis event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,\nor the HTML5 Audio Manager. It is dispatched when the `stopAll` method is invoked and after all current Sounds\nhave been stopped.\n\nListen to it from a Scene using: `this.sound.on('stopall', listener)`.",
  "Phaser.Sound.Events.STOP": "The Sound Stop Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are stopped.\n\nListen to it from a Sound instance using `Sound.on('stop', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('stop', listener);\nmusic.play();\nmusic.stop();\n```",
  "Phaser.Sound.Events.UNLOCKED": "The Sound Manager Unlocked Event.\n\nThis event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,\nor the HTML5 Audio Manager. It is dispatched during the update loop when the Sound Manager becomes unlocked. For\nWeb Audio this is on the first user gesture on the page.\n\nListen to it from a Scene using: `this.sound.on('unlocked', listener)`.",
  "Phaser.Sound.Events.VOLUME": "The Sound Volume Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when their volume changes.\n\nListen to it from a Sound instance using `Sound.on('volume', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('volume', listener);\nmusic.play();\nmusic.setVolume(0.5);\n```",
  "Phaser.Structs.Events.PROCESS_QUEUE_ADD": "The Process Queue Add Event.\n\nThis event is dispatched by a Process Queue when a new item is successfully moved to its active list.\n\nYou will most commonly see this used by a Scene's Update List when a new Game Object has been added.\n\nIn that instance, listen to this event from within a Scene using: `this.sys.updateList.on('add', listener)`.",
  "Phaser.Structs.Events.PROCESS_QUEUE_REMOVE": "The Process Queue Remove Event.\n\nThis event is dispatched by a Process Queue when a new item is successfully removed from its active list.\n\nYou will most commonly see this used by a Scene's Update List when a Game Object has been removed.\n\nIn that instance, listen to this event from within a Scene using: `this.sys.updateList.on('remove', listener)`.",
  "Phaser.Textures.Events.ADD": "The Texture Add Event.\n\nThis event is dispatched by the Texture Manager when a texture is added to it.\n\nListen to this event from within a Scene using: `this.textures.on('addtexture', listener)`.",
  "Phaser.Textures.Events.ADD_KEY": "The Texture Add Key Event.\n\nThis event is dispatched by the Texture Manager when a texture with the given key is added to it.\n\nListen to this event from within a Scene using: `this.textures.on('addtexture-key', listener)`.",
  "Phaser.Textures.Events.ERROR": "The Texture Load Error Event.\n\nThis event is dispatched by the Texture Manager when a texture it requested to load failed.\nThis only happens when base64 encoded textures fail. All other texture types are loaded via the Loader Plugin.\n\nListen to this event from within a Scene using: `this.textures.on('onerror', listener)`.",
  "Phaser.Textures.Events.LOAD": "The Texture Load Event.\n\nThis event is dispatched by the Texture Manager when a texture has finished loading on it.\nThis only happens for base64 encoded textures. All other texture types are loaded via the Loader Plugin.\n\nListen to this event from within a Scene using: `this.textures.on('onload', listener)`.\n\nThis event is dispatched after the [ADD]{@linkcode Phaser.Textures.Events#event:ADD} event.",
  "Phaser.Textures.Events.READY": "This internal event signifies that the Texture Manager is now ready and the Game can continue booting.\n\nWhen a Phaser Game instance is booting for the first time, the Texture Manager has to wait on a couple of non-blocking\nasync events before it's fully ready to carry on. When those complete the Texture Manager emits this event via the Game\ninstance, which tells the Game to carry on booting.",
  "Phaser.Textures.Events.REMOVE": "The Texture Remove Event.\n\nThis event is dispatched by the Texture Manager when a texture is removed from it.\n\nListen to this event from within a Scene using: `this.textures.on('removetexture', listener)`.\n\nIf you have any Game Objects still using the removed texture, they will start throwing\nerrors the next time they try to render. Be sure to clear all use of the texture in this event handler.",
  "Phaser.Textures.Events.REMOVE_KEY": "The Texture Remove Key Event.\n\nThis event is dispatched by the Texture Manager when a texture with the given key is removed from it.\n\nListen to this event from within a Scene using: `this.textures.on('removetexture-key', listener)`.\n\nIf you have any Game Objects still using the removed texture, they will start throwing\nerrors the next time they try to render. Be sure to clear all use of the texture in this event handler.",
  "Phaser.Tweens.Events.TWEEN_ACTIVE": "The Tween Active Event.\n\nThis event is dispatched by a Tween when it becomes active within the Tween Manager.\n\nAn 'active' Tween is one that is now progressing, although it may not yet be updating\nany target properties, due to settings such as `delay`. If you need an event for when\nthe Tween starts actually updating its first property, see `TWEEN_START`.\n\nListen to it from a Tween instance using `Tween.on('active', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.create({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000\n});\ntween.on('active', listener);\nthis.tweens.existing(tween);\n```\n\nNote that this event is usually dispatched already by the time you call `this.tweens.add()`, and is\nmeant for use with `tweens.create()` and/or `tweens.existing()`.",
  "Phaser.Tweens.Events.TWEEN_COMPLETE": "The Tween Complete Event.\n\nThis event is dispatched by a Tween when it completes playback entirely, factoring in repeats and loops.\n\nIf the Tween has been set to loop or repeat infinitely, this event will not be dispatched\nunless the `Tween.stop` method is called.\n\nIf a Tween has a `completeDelay` set, this event will fire after that delay expires.\n\nListen to it from a Tween instance using `Tween.on('complete', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000\n});\ntween.on('complete', listener);\n```",
  "Phaser.Tweens.Events.TWEEN_LOOP": "The Tween Loop Event.\n\nThis event is dispatched by a Tween when it loops.\n\nThis event will only be dispatched if the Tween has a loop count set.\n\nIf a Tween has a `loopDelay` set, this event will fire after that delay expires.\n\nThe difference between `loop` and `repeat` is that `repeat` is a property setting,\nwhere-as `loop` applies to the entire Tween.\n\nListen to it from a Tween instance using `Tween.on('loop', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000,\n    loop: 6\n});\ntween.on('loop', listener);\n```",
  "Phaser.Tweens.Events.TWEEN_PAUSE": "The Tween Pause Event.\n\nThis event is dispatched by a Tween when it is paused.\n\nListen to it from a Tween instance using `Tween.on('pause', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    ease: 'Power1',\n    duration: 3000,\n    x: 600\n});\ntween.on('pause', listener);\n// At some point later ...\ntween.pause();\n```",
  "Phaser.Tweens.Events.TWEEN_REPEAT": "The Tween Repeat Event.\n\nThis event is dispatched by a Tween when one of the properties it is tweening repeats.\n\nThis event will only be dispatched if the Tween has a property with a repeat count set.\n\nIf a Tween has a `repeatDelay` set, this event will fire after that delay expires.\n\nThe difference between `loop` and `repeat` is that `repeat` is a property setting,\nwhere-as `loop` applies to the entire Tween.\n\nListen to it from a Tween instance using `Tween.on('repeat', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000,\n    repeat: 4\n});\ntween.on('repeat', listener);\n```",
  "Phaser.Tweens.Events.TWEEN_RESUME": "The Tween Resume Event.\n\nThis event is dispatched by a Tween when it is resumed from a paused state.\n\nListen to it from a Tween instance using `Tween.on('resume', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    ease: 'Power1',\n    duration: 3000,\n    x: 600\n});\ntween.on('resume', listener);\n// At some point later ...\ntween.resume();\n```",
  "Phaser.Tweens.Events.TWEEN_START": "The Tween Start Event.\n\nThis event is dispatched by a Tween when it starts tweening its first property.\n\nA Tween will only emit this event once, as it can only start once.\n\nIf a Tween has a `delay` set, this event will fire after that delay expires.\n\nListen to it from a Tween instance using `Tween.on('start', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000\n});\ntween.on('start', listener);\n```",
  "Phaser.Tweens.Events.TWEEN_STOP": "The Tween Stop Event.\n\nThis event is dispatched by a Tween when it is stopped.\n\nListen to it from a Tween instance using `Tween.on('stop', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000\n});\ntween.on('stop', listener);\n```",
  "Phaser.Tweens.Events.TWEEN_UPDATE": "The Tween Update Event.\n\nThis event is dispatched by a Tween every time it updates _any_ of the properties it is tweening.\n\nA Tween that is changing 3 properties of a target will emit this event 3 times per change, once per property.\n\n**Note:** This is a very high frequency event and may be dispatched multiple times, every single frame.\n\nListen to it from a Tween instance using `Tween.on('update', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000,\n});\ntween.on('update', listener);\n```",
  "Phaser.Tweens.Events.TWEEN_YOYO": "The Tween Yoyo Event.\n\nThis event is dispatched by a Tween whenever a property it is tweening yoyos.\n\nThis event will only be dispatched if the Tween has a property with `yoyo` set.\n\nIf the Tween has a `hold` value, this event is dispatched when the hold expires.\n\nThis event is dispatched for every property, and for every target, that yoyos.\nFor example, if a Tween was updating 2 properties and had 10 targets, this event\nwould be dispatched 20 times (twice per target). So be careful how you use it!\n\nListen to it from a Tween instance using `Tween.on('yoyo', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000,\n    yoyo: true\n});\ntween.on('yoyo', listener);\n```"
}