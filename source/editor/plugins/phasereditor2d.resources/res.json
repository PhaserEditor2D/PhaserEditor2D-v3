{
 "phasereditor2d.animations/docs/phaser-docs.json": {
  "Phaser.Types.Animations.Animation.key": "The key that the animation will be associated with. i.e. sprite.animations.play(key)",
  "Phaser.Types.Animations.Animation.frameRate": "The frame rate of playback in frames per second (default 24 if duration is null)",
  "Phaser.Types.Animations.Animation.delay": "Delay before starting playback. Value given in milliseconds.",
  "Phaser.Types.Animations.Animation.repeat": "Number of times to repeat the animation (-1 for infinity)",
  "Phaser.Types.Animations.Animation.repeatDelay": "Delay before the animation repeats. Value given in milliseconds.",
  "Phaser.Types.Animations.Animation.yoyo": "Should the animation yoyo? (reverse back down to the start) before repeating?",
  "Phaser.Types.Animations.Animation.showOnStart": "Should sprite.visible = true when the animation starts to play? This happens _after_ any delay, if set.",
  "Phaser.Types.Animations.Animation.hideOnComplete": "Should sprite.visible = false when the animation finishes?",
  "Phaser.Types.Animations.Animation.showBeforeDelay": "If this animation has a delay, should it show the first frame immediately (true), or only after the delay (false)",
  "Phaser.Types.Animations.Animation.skipMissedFrames": "Skip frames if the time lags, or always advanced anyway?",
  "Phaser.Types.Animations.PlayAnimationConfig.startFrame": "The frame of the animation to start playback from."
 },
 "phasereditor2d.pack/docs/phaser-docs.json": {
  "Phaser.Loader.LoaderPlugin.atlas(atlasURL)": "The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.",
  "Phaser.Loader.LoaderPlugin.atlas(textureURL)": "The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".",
  "Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig.normalMap": "The filename of an associated normal map. It uses the same path and url to load as the texture image.",
  "Phaser.Loader.LoaderPlugin.aseprite(atlasURL)": "The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.",
  "Phaser.Loader.LoaderPlugin.aseprite(textureURL)": "The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".",
  "Phaser.Loader.LoaderPlugin.atlasXML(atlasURL)": "The absolute or relative URL to load the texture atlas xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".",
  "Phaser.Loader.LoaderPlugin.atlasXML(textureURL)": "The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".",
  "Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig.normalMap": "The filename of an associated normal map. It uses the same path and url to load as the texture image.",
  "Phaser.Loader.LoaderPlugin.audio(urls)": "The absolute or relative URL to load the audio files from.",
  "Phaser.Loader.LoaderPlugin.audioSprite(jsonURL)": "The absolute or relative URL to load the json file from. Or a well formed JSON object to use instead.",
  "Phaser.Loader.LoaderPlugin.audioSprite(audioURL)": "The absolute or relative URL to load the audio file from. If empty it will be obtained by parsing the JSON file.",
  "Phaser.Loader.LoaderPlugin.bitmapFont(fontDataURL)": "The absolute or relative URL to load the font xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".",
  "Phaser.Loader.LoaderPlugin.bitmapFont(textureURL)": "The absolute or relative URL to load the font image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".",
  "Phaser.Types.Loader.FileTypes.BitmapFontFileConfig.normalMap": "The filename of an associated normal map. It uses the same path and url to load as the texture image.",
  "Phaser.Loader.LoaderPlugin.htmlTexture(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.html`, i.e. if `key` was \"alien\" then the URL will be \"alien.html\".",
  "Phaser.Loader.LoaderPlugin.htmlTexture(width)": "The width of the texture the HTML will be rendered to.",
  "Phaser.Loader.LoaderPlugin.htmlTexture(height)": "The height of the texture the HTML will be rendered to.",
  "Phaser.Loader.LoaderPlugin.image(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".",
  "Phaser.Types.Loader.FileTypes.ImageFileConfig.normalMap": "The filename of an associated normal map. It uses the same path and url to load as the image.",
  "Phaser.Loader.LoaderPlugin.multiatlas(atlasURL)": "The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".",
  "Phaser.Loader.LoaderPlugin.multiatlas(path)": "Optional path to use when loading the textures defined in the atlas data.",
  "Phaser.Loader.LoaderPlugin.plugin(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\". Or, a plugin function.",
  "Phaser.Loader.LoaderPlugin.plugin(start)": "Automatically start the plugin after loading?",
  "Phaser.Loader.LoaderPlugin.plugin(mapping)": "If this plugin is to be injected into the Scene, this is the property key used.",
  "Phaser.Loader.LoaderPlugin.scenePlugin(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\". Or, set to a plugin function.",
  "Phaser.Loader.LoaderPlugin.scenePlugin(systemKey)": "If this plugin is to be added to Scene.Systems, this is the property key for it.",
  "Phaser.Loader.LoaderPlugin.scenePlugin(sceneKey)": "If this plugin is to be added to the Scene, this is the property key for it.",
  "Phaser.Loader.LoaderPlugin.animation(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".",
  "Phaser.Loader.LoaderPlugin.sceneFile(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".",
  "Phaser.Loader.LoaderPlugin.script(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".",
  "Phaser.Loader.LoaderPlugin.text(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".",
  "Phaser.Loader.LoaderPlugin.glsl(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.glsl`, i.e. if `key` was \"alien\" then the URL will be \"alien.glsl\".",
  "Phaser.Loader.LoaderPlugin.html(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.html`, i.e. if `key` was \"alien\" then the URL will be \"alien.html\".",
  "Phaser.Loader.LoaderPlugin.json(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, can be a fully formed JSON Object.",
  "Phaser.Loader.LoaderPlugin.xml(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".",
  "Phaser.Types.Textures.SpriteSheetConfig.frameWidth": "The fixed width of each frame.",
  "Phaser.Types.Textures.SpriteSheetConfig.frameHeight": "The fixed height of each frame. If not set it will use the frameWidth as the height.",
  "Phaser.Types.Textures.SpriteSheetConfig.startFrame": "Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.",
  "Phaser.Types.Textures.SpriteSheetConfig.endFrame": "The total number of frames to extract from the Sprite Sheet. The default value of -1 means \"extract all frames\".",
  "Phaser.Types.Textures.SpriteSheetConfig.margin": "If the frames have been drawn with a margin, specify the amount here.",
  "Phaser.Types.Textures.SpriteSheetConfig.spacing": "If the frames have been drawn with spacing between them, specify the amount here.",
  "Phaser.Loader.LoaderPlugin.spritesheet(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".",
  "Phaser.Loader.LoaderPlugin.svg(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.svg`, i.e. if `key` was \"alien\" then the URL will be \"alien.svg\".",
  "Phaser.Types.Loader.FileTypes.SVGSizeConfig.width": "An optional width. The SVG will be resized to this size before being rendered to a texture.",
  "Phaser.Types.Loader.FileTypes.SVGSizeConfig.height": "An optional height. The SVG will be resized to this size before being rendered to a texture.",
  "Phaser.Types.Loader.FileTypes.SVGSizeConfig.scale": "An optional scale. If given it overrides the width / height properties. The SVG is scaled by the scale factor before being rendered to a texture.",
  "Phaser.Loader.LoaderPlugin.tilemapCSV(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.csv`, i.e. if `key` was \"alien\" then the URL will be \"alien.csv\".",
  "Phaser.Loader.LoaderPlugin.tilemapImpact(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".",
  "Phaser.Loader.LoaderPlugin.tilemapTiledJSON(url)": "The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.",
  "Phaser.Loader.LoaderPlugin.unityAtlas(atlasURL)": "The absolute or relative URL to load the texture atlas data file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".",
  "Phaser.Loader.LoaderPlugin.unityAtlas(textureURL)": "The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".",
  "Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig.normalMap": "The filename of an associated normal map. It uses the same path and url to load as the texture image.",
  "Phaser.Loader.LoaderPlugin.video(urls)": "The absolute or relative URL to load the video files from."
 },
 "phasereditor2d.scene/code/scriptnode/js/ScriptNode.js": "class ScriptNode {\n\n    /** \n     * @private\n     * @type {Phaser.Scene} \n     **/\n    _scene;\n\n    /**\n     * @private \n     * @type {Phaser.GameObjects.GameObject | undefined}\n     */\n    _gameObject;\n\n    /**\n     * @private\n     * @type {ScriptNode | Phaser.GameObjects.GameObject | Phaser.Scene}\n     */\n    _parent;\n\n    /**\n     * @private\n     * @type {ScriptNode[] | undefined}\n     */\n    _children;\n\n    /**\n     * @param {ScriptNode | Phaser.GameObjects.GameObject | Phaser.Scene} parent \n     */\n    constructor(parent) {\n\n        this._parent = parent;\n\n        if (parent instanceof ScriptNode) {\n\n            this._scene = parent.scene;\n            this._gameObject = parent.gameObject;\n\n            parent.add(this);\n\n        } else if (parent instanceof Phaser.GameObjects.GameObject) {\n\n            this._scene = parent.scene;\n            this._gameObject = parent;\n\n        } else {\n\n            this._scene = parent;\n        }\n\n        const listenAwake = this.awake !== ScriptNode.prototype.awake;\n        const listenStart = this.start !== ScriptNode.prototype.start;\n        const listenUpdate = this.update !== ScriptNode.prototype.update;\n        const listenDestroy = this.destroy !== ScriptNode.prototype.destroy;\n\n        if (listenAwake) {\n\n            this.scene.events.once(\"scene-awake\", this.awake, this);\n        }\n\n        if (listenStart) {\n\n            this.scene.events.once(Phaser.Scenes.Events.UPDATE, this.start, this);\n        }\n\n        if (listenUpdate) {\n\n            this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.update, this);\n        }\n\n        if (listenAwake || listenStart || listenUpdate || listenDestroy) {\n\n            const destroyCallback = () => {\n\n                this.scene.events.off(\"scene-awake\", this.awake, this);\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.start, this);\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.update, this);\n\n                if (listenDestroy) {\n\n                    this.destroy();\n                }\n            };\n\n            if (this.gameObject) {\n\n                this.gameObject.on(Phaser.GameObjects.Events.DESTROY, destroyCallback);\n\n            } else {\n\n                this.scene.events.on(Phaser.Scenes.Events.SHUTDOWN, destroyCallback);\n            }\n        }\n    }\n\n    get scene() {\n\n        return this._scene;\n    }\n\n    get gameObject() {\n\n        return this._gameObject;\n    }\n\n    get parent() {\n\n        return this._parent;\n    }\n\n    get children() {\n\n        if (!this._children) {\n\n            this._children = [];\n        }\n\n        return this._children;\n    }\n\n    /**\n     * @param {ScriptNode} child \n     */\n    add(child) {\n\n        this.children.push(child);\n    }\n\n    /**\n     * @param  {...any} args \n     */\n    executeChildren(...args) {\n\n        if (this._children) {\n\n            for (const child of this._children) {\n\n                child.execute(...args);\n            }\n        }\n    }\n\n    /**\n     * @param  {...any} args \n     */\n    execute(...args) {\n        // override this on executable nodes\n    }\n\n    /**\n     * @protected\n     */\n    awake() {\n        // override this\n    }\n\n    /**\n     * @protected\n     */\n    start() {\n        // override this\n    }\n\n    /**\n     * @protected\n     */\n    update() {\n        // override this\n    }\n\n    /**\n     * @protected\n     */\n    destroy() {\n        // override this\n    }\n}",
 "phasereditor2d.scene/code/scriptnode/js-module/ScriptNode.js": "import Phaser from \"phaser\";\n\nexport default class ScriptNode {\n\n    /** \n     * @private\n     * @type {Phaser.Scene} \n     **/\n    _scene;\n\n    /**\n     * @private \n     * @type {Phaser.GameObjects.GameObject | undefined}\n     */\n    _gameObject;\n\n    /**\n     * @private\n     * @type {ScriptNode | Phaser.GameObjects.GameObject | Phaser.Scene}\n     */\n    _parent;\n\n    /**\n     * @private\n     * @type {ScriptNode[] | undefined}\n     */\n    _children;\n\n    /**\n     * @param {ScriptNode | Phaser.GameObjects.GameObject | Phaser.Scene} parent \n     */\n    constructor(parent) {\n\n        this._parent = parent;\n\n        if (parent instanceof ScriptNode) {\n\n            this._scene = parent.scene;\n            this._gameObject = parent.gameObject;\n\n            parent.add(this);\n\n        } else if (parent instanceof Phaser.GameObjects.GameObject) {\n\n            this._scene = parent.scene;\n            this._gameObject = parent;\n\n        } else {\n\n            this._scene = parent;\n        }\n\n        const listenAwake = this.awake !== ScriptNode.prototype.awake;\n        const listenStart = this.start !== ScriptNode.prototype.start;\n        const listenUpdate = this.update !== ScriptNode.prototype.update;\n        const listenDestroy = this.destroy !== ScriptNode.prototype.destroy;\n\n        if (listenAwake) {\n\n            this.scene.events.once(\"scene-awake\", this.awake, this);\n        }\n\n        if (listenStart) {\n\n            this.scene.events.once(Phaser.Scenes.Events.UPDATE, this.start, this);\n        }\n\n        if (listenUpdate) {\n\n            this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.update, this);\n        }\n\n        if (listenAwake || listenStart || listenUpdate || listenDestroy) {\n\n            const destroyCallback = () => {\n\n                this.scene.events.off(\"scene-awake\", this.awake, this);\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.start, this);\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.update, this);\n\n                if (listenDestroy) {\n\n                    this.destroy();\n                }\n            };\n\n            if (this.gameObject) {\n\n                this.gameObject.on(Phaser.GameObjects.Events.DESTROY, destroyCallback);\n\n            } else {\n\n                this.scene.events.on(Phaser.Scenes.Events.SHUTDOWN, destroyCallback);\n            }\n        }\n    }\n\n    get scene() {\n\n        return this._scene;\n    }\n\n    get gameObject() {\n\n        return this._gameObject;\n    }\n\n    get parent() {\n\n        return this._parent;\n    }\n\n    get children() {\n\n        if (!this._children) {\n\n            this._children = [];\n        }\n\n        return this._children;\n    }\n\n    /**\n     * @param {ScriptNode} child \n     */\n    add(child) {\n\n        this.children.push(child);\n    }\n\n    /**\n     * @param  {...any} args \n     */\n    executeChildren(...args) {\n\n        if (this._children) {\n\n            for (const child of this._children) {\n\n                child.execute(...args);\n            }\n        }\n    }\n\n    /**\n     * @param  {...any} args \n     */\n    execute(...args) {\n        // override this on executable nodes\n    }\n\n    /**\n     * @protected\n     */\n    awake() {\n        // override this\n    }\n\n    /**\n     * @protected\n     */\n    start() {\n        // override this\n    }\n\n    /**\n     * @protected\n     */\n    update() {\n        // override this\n    }\n\n    /**\n     * @protected\n     */\n    destroy() {\n        // override this\n    }\n}",
 "phasereditor2d.scene/code/scriptnode/ts/ScriptNode.ts": "class ScriptNode {\n\n    private _scene: Phaser.Scene;\n    private _gameObject?: Phaser.GameObjects.GameObject;\n    private _parent: ScriptNode | Phaser.GameObjects.GameObject | Phaser.Scene;\n    private _children?: ScriptNode[];\n\n    constructor(parent: ScriptNode | Phaser.GameObjects.GameObject | Phaser.Scene) {\n\n        this._parent = parent;\n\n        if (parent instanceof ScriptNode) {\n\n            this._scene = parent.scene;\n            this._gameObject = parent.gameObject;\n\n            parent.add(this);\n\n        } else if (parent instanceof Phaser.GameObjects.GameObject) {\n\n            this._scene = parent.scene;\n            this._gameObject = parent;\n\n        } else {\n\n            this._scene = parent;\n        }\n\n        const listenAwake = this.awake !== ScriptNode.prototype.awake;\n        const listenStart = this.start !== ScriptNode.prototype.start;\n        const listenUpdate = this.update !== ScriptNode.prototype.update;\n        const listenDestroy = this.destroy !== ScriptNode.prototype.destroy;\n\n        if (listenAwake) {\n\n            this.scene.events.once(\"scene-awake\", this.awake, this);\n        }\n\n        if (listenStart) {\n\n            this.scene.events.once(Phaser.Scenes.Events.UPDATE, this.start, this);\n        }\n\n        if (listenUpdate) {\n\n            this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.update, this);\n        }\n\n        if (listenAwake || listenStart || listenUpdate || listenDestroy) {\n\n            const destroyCallback = () => {\n\n                this.scene.events.off(\"scene-awake\", this.awake, this);\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.start, this);\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.update, this);\n\n                if (listenDestroy) {\n\n                    this.destroy();\n                }\n            };\n\n            if (this.gameObject) {\n\n                this.gameObject.on(Phaser.GameObjects.Events.DESTROY, destroyCallback);\n\n            } else {\n\n                this.scene.events.on(Phaser.Scenes.Events.SHUTDOWN, destroyCallback);\n            }\n        }\n    }\n\n    get scene() {\n\n        return this._scene;\n    }\n\n    get gameObject() {\n\n        return this._gameObject;\n    }\n\n    get parent() {\n\n        return this._parent;\n    }\n\n    get children(): ScriptNode[] {\n\n        if (!this._children) {\n\n            this._children = [];\n        }\n\n        return this._children;\n    }\n\n    add(child: ScriptNode) {\n\n        this.children.push(child);\n    }\n\n    executeChildren(...args: any[]) {\n\n        if (this._children) {\n\n            for(const child of this._children) {\n\n                child.execute(...args);\n            }\n        }\n    }\n\n    execute(...args: any[]): void {\n        // override this on executable nodes\n    }\n\n    protected awake() {\n        // override this\n    }\n\n    protected start() {\n        // override this\n    }\n\n    protected update() {\n        // override this\n    }\n\n    protected destroy() {\n        // override this\n    }\n}",
 "phasereditor2d.scene/code/scriptnode/ts-module/ScriptNode.ts": "import Phaser from \"phaser\";\n\nexport default class ScriptNode {\n\n    private _scene: Phaser.Scene;\n    private _gameObject?: Phaser.GameObjects.GameObject;\n    private _parent: ScriptNode | Phaser.GameObjects.GameObject | Phaser.Scene;\n    private _children?: ScriptNode[];\n\n    constructor(parent: ScriptNode | Phaser.GameObjects.GameObject | Phaser.Scene) {\n\n        this._parent = parent;\n\n        if (parent instanceof ScriptNode) {\n\n            this._scene = parent.scene;\n            this._gameObject = parent.gameObject;\n\n            parent.add(this);\n\n        } else if (parent instanceof Phaser.GameObjects.GameObject) {\n\n            this._scene = parent.scene;\n            this._gameObject = parent;\n\n        } else {\n\n            this._scene = parent;\n        }\n\n        const listenAwake = this.awake !== ScriptNode.prototype.awake;\n        const listenStart = this.start !== ScriptNode.prototype.start;\n        const listenUpdate = this.update !== ScriptNode.prototype.update;\n        const listenDestroy = this.destroy !== ScriptNode.prototype.destroy;\n\n        if (listenAwake) {\n\n            this.scene.events.once(\"scene-awake\", this.awake, this);\n        }\n\n        if (listenStart) {\n\n            this.scene.events.once(Phaser.Scenes.Events.UPDATE, this.start, this);\n        }\n\n        if (listenUpdate) {\n\n            this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.update, this);\n        }\n\n        if (listenAwake || listenStart || listenUpdate || listenDestroy) {\n\n            const destroyCallback = () => {\n\n                this.scene.events.off(\"scene-awake\", this.awake, this);\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.start, this);\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.update, this);\n\n                if (listenDestroy) {\n\n                    this.destroy();\n                }\n            };\n\n            if (this.gameObject) {\n\n                this.gameObject.on(Phaser.GameObjects.Events.DESTROY, destroyCallback);\n\n            } else {\n\n                this.scene.events.on(Phaser.Scenes.Events.SHUTDOWN, destroyCallback);\n            }\n        }\n    }\n\n    get scene() {\n\n        return this._scene;\n    }\n\n    get gameObject() {\n\n        return this._gameObject;\n    }\n\n    get parent() {\n\n        return this._parent;\n    }\n\n    get children(): ScriptNode[] {\n\n        if (!this._children) {\n\n            this._children = [];\n        }\n\n        return this._children;\n    }\n\n    add(child: ScriptNode) {\n\n        this.children.push(child);\n    }\n\n    executeChildren(...args: any[]) {\n\n        if (this._children) {\n\n            for(const child of this._children) {\n\n                child.execute(...args);\n            }\n        }\n    }\n\n    execute(...args: any[]): void {\n        // override this on executable nodes\n    }\n\n    protected awake() {\n        // override this\n    }\n\n    protected start() {\n        // override this\n    }\n\n    protected update() {\n        // override this\n    }\n\n    protected destroy() {\n        // override this\n    }\n}",
 "phasereditor2d.scene/code/usercomponent/js/UserComponent.js": "class UserComponent {\n\n    /**\n     * @param {Phaser.GameObjects.GameObject} gameObject The entity.\n     */\n    constructor(gameObject) {\n\n        this.scene = gameObject.scene;\n\n        const listenAwake = this.awake !== UserComponent.prototype.awake;\n        const listenStart = this.start !== UserComponent.prototype.start;\n        const listenUpdate = this.update !== UserComponent.prototype.update;\n        const listenDestroy = this.destroy !== UserComponent.prototype.destroy;\n        \n        if (listenAwake) {\n\n            this.scene.events.once(\"scene-awake\", this.awake, this);\n        }\n\n        if (listenStart) {\n\n            this.scene.events.once(Phaser.Scenes.Events.UPDATE, this.start, this);\n        }\n\n        if (listenUpdate) {\n\n            this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.update, this);\n        }\n\n        if (listenStart || listenUpdate || listenDestroy) {\n\n            gameObject.on(Phaser.GameObjects.Events.DESTROY, () => {\n\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.start, this);\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.update, this);\n\n                if (listenDestroy) {\n\n                    this.destroy();\n                }\n            });\n        }\n    }\n\n    /** @type {Phaser.Scene} */\n    scene;\n\n    awake() {\n        // override this\n    }\n\n    start() {\n        // override this\n    }\n\n    update() {\n        // override this\n    }\n\n    destroy() {\n        // override this\n    }\n}",
 "phasereditor2d.scene/code/usercomponent/js-module/UserComponent.js": "import Phaser from \"phaser\";\n\nexport default class UserComponent {\n\n    /**\n     * @param {Phaser.GameObjects.GameObject} gameObject The entity.     \n     */\n    constructor(gameObject) {\n\n        this.scene = gameObject.scene;\n\n        const listenAwake = this.awake !== UserComponent.prototype.awake;\n        const listenStart = this.start !== UserComponent.prototype.start;\n        const listenUpdate = this.update !== UserComponent.prototype.update;\n        const listenDestroy = this.destroy !== UserComponent.prototype.destroy;\n        \n        if (listenAwake) {\n\n            this.scene.events.once(\"scene-awake\", this.awake, this);\n        }\n\n        if (listenStart) {\n\n            this.scene.events.once(Phaser.Scenes.Events.UPDATE, this.start, this);\n        }\n\n        if (listenUpdate) {\n\n            this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.update, this);\n        }\n\n        if (listenStart || listenUpdate || listenDestroy) {\n\n            gameObject.on(Phaser.GameObjects.Events.DESTROY, () => {\n\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.start, this);\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.update, this);\n\n                if (listenDestroy) {\n\n                    this.destroy();\n                }\n            });\n        }\n    }\n\n    /** @type {Phaser.Scene} */\n    scene;\n\n    awake() {\n        // override this\n    }\n\n    start() {\n        // override this\n    }\n\n    update() {\n        // override this\n    }\n\n    destroy() {\n        // override this\n    }\n}",
 "phasereditor2d.scene/code/usercomponent/ts/UserComponent.ts": "class UserComponent {\n\n    /**\n     * @param gameObject The entity.\n     */\n    constructor(gameObject: Phaser.GameObjects.GameObject) {\n\n        this.scene = gameObject.scene;\n\n        const listenAwake = this.awake !== UserComponent.prototype.awake;\n        const listenStart = this.start !== UserComponent.prototype.start;\n        const listenUpdate = this.update !== UserComponent.prototype.update;\n        const listenDestroy = this.destroy !== UserComponent.prototype.destroy;\n        \n        if (listenAwake) {\n\n            this.scene.events.once(\"scene-awake\", this.awake, this);\n        }\n\n        if (listenStart) {\n\n            this.scene.events.once(Phaser.Scenes.Events.UPDATE, this.start, this);\n        }\n\n        if (listenUpdate) {\n\n            this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.update, this);\n        }\n\n        if (listenStart || listenUpdate || listenDestroy) {\n\n            gameObject.on(Phaser.GameObjects.Events.DESTROY, () => {\n\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.start, this);\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.update, this);\n\n                if (listenDestroy) {\n\n                    this.destroy();\n                }\n            });\n        }\n    }\n\n    scene: Phaser.Scene;\n\n    protected awake(): void {\n        // override this\n    }\n\n    protected start(): void {\n        // override this\n    }\n\n    protected update(): void {\n        // override this\n    }\n\n    protected destroy(): void {\n        // override this\n    }\n}",
 "phasereditor2d.scene/code/usercomponent/ts-module/UserComponent.ts": "import Phaser from \"phaser\";\n\nexport default class UserComponent {\n\n    /**\n     * @param gameObject The entity.\n     */\n    constructor(gameObject: Phaser.GameObjects.GameObject) {\n\n        this.scene = gameObject.scene;\n\n        const listenAwake = this.awake !== UserComponent.prototype.awake;\n        const listenStart = this.start !== UserComponent.prototype.start;\n        const listenUpdate = this.update !== UserComponent.prototype.update;\n        const listenDestroy = this.destroy !== UserComponent.prototype.destroy;\n        \n        if (listenAwake) {\n\n            this.scene.events.once(\"scene-awake\", this.awake, this);\n        }\n\n        if (listenStart) {\n\n            this.scene.events.once(Phaser.Scenes.Events.UPDATE, this.start, this);\n        }\n\n        if (listenUpdate) {\n\n            this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.update, this);\n        }\n\n        if (listenStart || listenUpdate || listenDestroy) {\n\n            gameObject.on(Phaser.GameObjects.Events.DESTROY, () => {\n\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.start, this);\n                this.scene.events.off(Phaser.Scenes.Events.UPDATE, this.update, this);\n\n                if (listenDestroy) {\n\n                    this.destroy();\n                }\n            });\n        }\n    }\n\n    scene: Phaser.Scene;\n\n    protected awake(): void {\n        // override this\n    }\n\n    protected start(): void {\n        // override this\n    }\n\n    protected update(): void {\n        // override this\n    }\n\n    protected destroy(): void {\n        // override this\n    }\n}",
 "phasereditor2d.scene/docs/events.json": {
  "Phaser.Animations.Events.ADD_ANIMATION": "The Add Animation Event.\n\nThis event is dispatched when a new animation is added to the global Animation Manager.\n\nThis can happen either as a result of an animation instance being added to the Animation Manager,\nor the Animation Manager creating a new animation directly.",
  "Phaser.Animations.Events.ANIMATION_COMPLETE": "The Animation Complete Event.\n\nThis event is dispatched by a Sprite when an animation playing on it completes playback.\nThis happens when the animation gets to the end of its sequence, factoring in any delays\nor repeats it may have to process.\n\nAn animation that is set to loop, or repeat forever, will never fire this event, because\nit never actually completes. If you need to handle this, listen for the `ANIMATION_STOP`\nevent instead, as this is emitted when the animation is stopped directly.\n\nListen for it on the Sprite using `sprite.on('animationcomplete', listener)`\n\nThe animation event flow is as follows:\n\n1. `ANIMATION_START`\n2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n\nIf the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n\nIf the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.",
  "Phaser.Animations.Events.ANIMATION_COMPLETE_KEY": "The Animation Complete Dynamic Key Event.\n\nThis event is dispatched by a Sprite when an animation playing on it completes playback.\nThis happens when the animation gets to the end of its sequence, factoring in any delays\nor repeats it may have to process.\n\nAn animation that is set to loop, or repeat forever, will never fire this event, because\nit never actually completes. If you need to handle this, listen for the `ANIMATION_STOP`\nevent instead, as this is emitted when the animation is stopped directly.\n\nThe difference between this and the `ANIMATION_COMPLETE` event is that this one has a\ndynamic event name that contains the name of the animation within it. For example,\nif you had an animation called `explode` you could listen for the completion of that\nspecific animation by using: `sprite.on('animationcomplete-explode', listener)`. Or, if you\nwish to use types: `sprite.on(Phaser.Animations.Events.ANIMATION_COMPLETE_KEY + 'explode', listener)`.\n\nThe animation event flow is as follows:\n\n1. `ANIMATION_START`\n2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n\nIf the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n\nIf the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.",
  "Phaser.Animations.Events.ANIMATION_REPEAT": "The Animation Repeat Event.\n\nThis event is dispatched by a Sprite when an animation repeats playing on it.\nThis happens if the animation was created, or played, with a `repeat` value specified.\n\nAn animation will repeat when it reaches the end of its sequence.\n\nListen for it on the Sprite using `sprite.on('animationrepeat', listener)`\n\nThe animation event flow is as follows:\n\n1. `ANIMATION_START`\n2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n\nIf the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n\nIf the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.",
  "Phaser.Animations.Events.ANIMATION_RESTART": "The Animation Restart Event.\n\nThis event is dispatched by a Sprite when an animation restarts playing on it.\nThis only happens when the `Sprite.anims.restart` method is called.\n\nListen for it on the Sprite using `sprite.on('animationrestart', listener)`\n\nThe animation event flow is as follows:\n\n1. `ANIMATION_START`\n2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n\nIf the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n\nIf the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.",
  "Phaser.Animations.Events.ANIMATION_START": "The Animation Start Event.\n\nThis event is dispatched by a Sprite when an animation starts playing on it.\nThis happens when the animation is played, factoring in any delay that may have been specified.\nThis event happens after the delay has expired and prior to the first update event.\n\nListen for it on the Sprite using `sprite.on('animationstart', listener)`\n\nThe animation event flow is as follows:\n\n1. `ANIMATION_START`\n2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n\nIf the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n\nIf the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.",
  "Phaser.Animations.Events.ANIMATION_STOP": "The Animation Stop Event.\n\nThis event is dispatched by a Sprite when an animation is stopped on it. An animation\nwill only be stopeed if a method such as `Sprite.stop` or `Sprite.anims.stopAfterDelay`\nis called. It can also be emitted if a new animation is started before the current one completes.\n\nListen for it on the Sprite using `sprite.on('animationstop', listener)`\n\nThe animation event flow is as follows:\n\n1. `ANIMATION_START`\n2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n\nIf the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n\nIf the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.",
  "Phaser.Animations.Events.ANIMATION_UPDATE": "The Animation Update Event.\n\nThis event is dispatched by a Sprite when an animation playing on it updates. This happens when the animation changes frame.\nAn animation will change frame based on the frame rate and other factors like `timeScale` and `delay`. It can also change\nframe when stopped or restarted.\n\nListen for it on the Sprite using `sprite.on('animationupdate', listener)`\n\nIf an animation is playing faster than the game frame-rate can handle, it's entirely possible for it to emit several\nupdate events in a single game frame, so please be aware of this in your code. The **final** event received that frame\nis the one that is rendered to the game.\n\nThe animation event flow is as follows:\n\n1. `ANIMATION_START`\n2. `ANIMATION_UPDATE` (repeated for however many frames the animation has)\n3. `ANIMATION_REPEAT` (only if the animation is set to repeat, it then emits more update events after this)\n4. `ANIMATION_COMPLETE` (only if there is a finite, or zero, repeat count)\n5. `ANIMATION_COMPLETE_KEY` (only if there is a finite, or zero, repeat count)\n\nIf the animation is stopped directly, the `ANIMATION_STOP` event is dispatched instead of `ANIMATION_COMPLETE`.\n\nIf the animation is restarted while it is already playing, `ANIMATION_RESTART` is emitted.",
  "Phaser.Animations.Events.PAUSE_ALL": "The Pause All Animations Event.\n\nThis event is dispatched when the global Animation Manager is told to pause.\n\nWhen this happens all current animations will stop updating, although it doesn't necessarily mean\nthat the game has paused as well.",
  "Phaser.Animations.Events.REMOVE_ANIMATION": "The Remove Animation Event.\n\nThis event is dispatched when an animation is removed from the global Animation Manager.",
  "Phaser.Animations.Events.RESUME_ALL": "The Resume All Animations Event.\n\nThis event is dispatched when the global Animation Manager resumes, having been previously paused.\n\nWhen this happens all current animations will continue updating again.",
  "Phaser.Cache.Events.ADD": "The Cache Add Event.\n\nThis event is dispatched by any Cache that extends the BaseCache each time a new object is added to it.",
  "Phaser.Cache.Events.REMOVE": "The Cache Remove Event.\n\nThis event is dispatched by any Cache that extends the BaseCache each time an object is removed from it.",
  "Phaser.Cameras.Scene2D.Events.DESTROY": "The Destroy Camera Event.\n\nThis event is dispatched by a Camera instance when it is destroyed by the Camera Manager.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('cameradestroy', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.DESTROY, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.FADE_IN_COMPLETE": "The Camera Fade In Complete Event.\n\nThis event is dispatched by a Camera instance when the Fade In Effect completes.\n\nListen to it from a Camera instance using `Camera.on('camerafadeincomplete', listener)`.",
  "Phaser.Cameras.Scene2D.Events.FADE_IN_START": "The Camera Fade In Start Event.\n\nThis event is dispatched by a Camera instance when the Fade In Effect starts.\n\nListen to it from a Camera instance using `Camera.on('camerafadeinstart', listener)`.",
  "Phaser.Cameras.Scene2D.Events.FADE_OUT_COMPLETE": "The Camera Fade Out Complete Event.\n\nThis event is dispatched by a Camera instance when the Fade Out Effect completes.\n\nListen to it from a Camera instance using `Camera.on('camerafadeoutcomplete', listener)`.",
  "Phaser.Cameras.Scene2D.Events.FADE_OUT_START": "The Camera Fade Out Start Event.\n\nThis event is dispatched by a Camera instance when the Fade Out Effect starts.\n\nListen to it from a Camera instance using `Camera.on('camerafadeoutstart', listener)`.",
  "Phaser.Cameras.Scene2D.Events.FLASH_COMPLETE": "The Camera Flash Complete Event.\n\nThis event is dispatched by a Camera instance when the Flash Effect completes.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('cameraflashcomplete', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.FLASH_COMPLETE, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.FLASH_START": "The Camera Flash Start Event.\n\nThis event is dispatched by a Camera instance when the Flash Effect starts.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('cameraflashstart', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.FLASH_START, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.FOLLOW_UPDATE": "The Camera Follower Update Event.\n\nThis event is dispatched by a Camera instance when it is following a\nGame Object and the Camera position has been updated as a result of\nthat following.\n\nListen to it from a Camera instance using: `camera.on('followupdate', listener)`.",
  "Phaser.Cameras.Scene2D.Events.PAN_COMPLETE": "The Camera Pan Complete Event.\n\nThis event is dispatched by a Camera instance when the Pan Effect completes.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerapancomplete', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.PAN_COMPLETE, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.PAN_START": "The Camera Pan Start Event.\n\nThis event is dispatched by a Camera instance when the Pan Effect starts.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerapanstart', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.PAN_START, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.POST_RENDER": "The Camera Post-Render Event.\n\nThis event is dispatched by a Camera instance after is has finished rendering.\nIt is only dispatched if the Camera is rendering to a texture.\n\nListen to it from a Camera instance using: `camera.on('postrender', listener)`.",
  "Phaser.Cameras.Scene2D.Events.PRE_RENDER": "The Camera Pre-Render Event.\n\nThis event is dispatched by a Camera instance when it is about to render.\nIt is only dispatched if the Camera is rendering to a texture.\n\nListen to it from a Camera instance using: `camera.on('prerender', listener)`.",
  "Phaser.Cameras.Scene2D.Events.ROTATE_COMPLETE": "The Camera Rotate Complete Event.\n\nThis event is dispatched by a Camera instance when the Rotate Effect completes.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerarotatecomplete', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.ROTATE_COMPLETE, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.ROTATE_START": "The Camera Rotate Start Event.\n\nThis event is dispatched by a Camera instance when the Rotate Effect starts.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerarotatestart', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.ROTATE_START, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.SHAKE_COMPLETE": "The Camera Shake Complete Event.\n\nThis event is dispatched by a Camera instance when the Shake Effect completes.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerashakecomplete', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.SHAKE_COMPLETE, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.SHAKE_START": "The Camera Shake Start Event.\n\nThis event is dispatched by a Camera instance when the Shake Effect starts.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerashakestart', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.SHAKE_START, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.ZOOM_COMPLETE": "The Camera Zoom Complete Event.\n\nThis event is dispatched by a Camera instance when the Zoom Effect completes.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerazoomcomplete', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.ZOOM_COMPLETE, () => {});\n```",
  "Phaser.Cameras.Scene2D.Events.ZOOM_START": "The Camera Zoom Start Event.\n\nThis event is dispatched by a Camera instance when the Zoom Effect starts.\n\nListen for it via either of the following:\n\n```js\nthis.cameras.main.on('camerazoomstart', () => {});\n```\n\nor use the constant, to avoid having to remember the correct event string:\n\n```js\nthis.cameras.main.on(Phaser.Cameras.Scene2D.Events.ZOOM_START, () => {});\n```",
  "Phaser.Core.Events.BLUR": "The Game Blur Event.\n\nThis event is dispatched by the Game Visibility Handler when the window in which the Game instance is embedded\nenters a blurred state. The blur event is raised when the window loses focus. This can happen if a user swaps\ntab, or if they simply remove focus from the browser to another app.",
  "Phaser.Core.Events.BOOT": "The Game Boot Event.\n\nThis event is dispatched when the Phaser Game instance has finished booting, but before it is ready to start running.\nThe global systems use this event to know when to set themselves up, dispatching their own `ready` events as required.",
  "Phaser.Core.Events.CONTEXT_LOST": "The Game Context Lost Event.\n\nThis event is dispatched by the Game if the WebGL Renderer it is using encounters a WebGL Context Lost event from the browser.\n\nThe renderer halts all rendering and cannot resume after this happens.",
  "Phaser.Core.Events.DESTROY": "The Game Destroy Event.\n\nThis event is dispatched when the game instance has been told to destroy itself.\nLots of internal systems listen to this event in order to clear themselves out.\nCustom plugins and game code should also do the same.",
  "Phaser.Core.Events.FOCUS": "The Game Focus Event.\n\nThis event is dispatched by the Game Visibility Handler when the window in which the Game instance is embedded\nenters a focused state. The focus event is raised when the window re-gains focus, having previously lost it.",
  "Phaser.Core.Events.HIDDEN": "The Game Hidden Event.\n\nThis event is dispatched by the Game Visibility Handler when the document in which the Game instance is embedded\nenters a hidden state. Only browsers that support the Visibility API will cause this event to be emitted.\n\nIn most modern browsers, when the document enters a hidden state, the Request Animation Frame and setTimeout, which\ncontrol the main game loop, will automatically pause. There is no way to stop this from happening. It is something\nyour game should account for in its own code, should the pause be an issue (i.e. for multiplayer games)",
  "Phaser.Core.Events.PAUSE": "The Game Pause Event.\n\nThis event is dispatched when the Game loop enters a paused state, usually as a result of the Visibility Handler.",
  "Phaser.Core.Events.POST_RENDER": "The Game Post-Render Event.\n\nThis event is dispatched right at the end of the render process.\n\nEvery Scene will have rendered and been drawn to the canvas by the time this event is fired.\nUse it for any last minute post-processing before the next game step begins.",
  "Phaser.Core.Events.POST_STEP": "The Game Post-Step Event.\n\nThis event is dispatched after the Scene Manager has updated.\nHook into it from plugins or systems that need to do things before the render starts.",
  "Phaser.Core.Events.PRE_RENDER": "The Game Pre-Render Event.\n\nThis event is dispatched immediately before any of the Scenes have started to render.\n\nThe renderer will already have been initialized this frame, clearing itself and preparing to receive the Scenes for rendering, but it won't have actually drawn anything yet.",
  "Phaser.Core.Events.PRE_STEP": "The Game Pre-Step Event.\n\nThis event is dispatched before the main Game Step starts. By this point in the game cycle none of the Scene updates have yet happened.\nHook into it from plugins or systems that need to update before the Scene Manager does.",
  "Phaser.Core.Events.READY": "The Game Ready Event.\n\nThis event is dispatched when the Phaser Game instance has finished booting, the Texture Manager is fully ready,\nand all local systems are now able to start.",
  "Phaser.Core.Events.RESUME": "The Game Resume Event.\n\nThis event is dispatched when the game loop leaves a paused state and resumes running.",
  "Phaser.Core.Events.STEP": "The Game Step Event.\n\nThis event is dispatched after the Game Pre-Step and before the Scene Manager steps.\nHook into it from plugins or systems that need to update before the Scene Manager does, but after the core Systems have.",
  "Phaser.Core.Events.VISIBLE": "The Game Visible Event.\n\nThis event is dispatched by the Game Visibility Handler when the document in which the Game instance is embedded\nenters a visible state, previously having been hidden.\n\nOnly browsers that support the Visibility API will cause this event to be emitted.",
  "Phaser.Data.Events.CHANGE_DATA": "The Change Data Event.\n\nThis event is dispatched by a Data Manager when an item in the data store is changed.\n\nGame Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\na change data event from a Game Object you would use: `sprite.on('changedata', listener)`.\n\nThis event is dispatched for all items that change in the Data Manager.\nTo listen for the change of a specific item, use the `CHANGE_DATA_KEY_EVENT` event.",
  "Phaser.Data.Events.CHANGE_DATA_KEY": "The Change Data Key Event.\n\nThis event is dispatched by a Data Manager when an item in the data store is changed.\n\nGame Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\nthe change of a specific data item from a Game Object you would use: `sprite.on('changedata-key', listener)`,\nwhere `key` is the unique string key of the data item. For example, if you have a data item stored called `gold`\nthen you can listen for `sprite.on('changedata-gold')`.",
  "Phaser.Data.Events.DESTROY": "The Data Manager Destroy Event.\n\nThe Data Manager will listen for the destroy event from its parent, and then close itself down.",
  "Phaser.Data.Events.REMOVE_DATA": "The Remove Data Event.\n\nThis event is dispatched by a Data Manager when an item is removed from it.\n\nGame Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\nthe removal of a data item on a Game Object you would use: `sprite.on('removedata', listener)`.",
  "Phaser.Data.Events.SET_DATA": "The Set Data Event.\n\nThis event is dispatched by a Data Manager when a new item is added to the data store.\n\nGame Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\nthe addition of a new data item on a Game Object you would use: `sprite.on('setdata', listener)`.",
  "Phaser.GameObjects.Events.ADDED_TO_SCENE": "The Game Object Added to Scene Event.\n\nThis event is dispatched when a Game Object is added to a Scene.\n\nListen for it on a Game Object instance using `GameObject.on('addedtoscene', listener)`.",
  "Phaser.GameObjects.Events.DESTROY": "The Game Object Destroy Event.\n\nThis event is dispatched when a Game Object instance is being destroyed.\n\nListen for it on a Game Object instance using `GameObject.on('destroy', listener)`.",
  "Phaser.GameObjects.Events.REMOVED_FROM_SCENE": "The Game Object Removed from Scene Event.\n\nThis event is dispatched when a Game Object is removed from a Scene.\n\nListen for it on a Game Object instance using `GameObject.on('removedfromscene', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_COMPLETE": "The Video Game Object Complete Event.\n\nThis event is dispatched when a Video finishes playback by reaching the end of its duration. It\nis also dispatched if a video marker sequence is being played and reaches the end.\n\nNote that not all videos can fire this event. Live streams, for example, have no fixed duration,\nso never technically 'complete'.\n\nIf a video is stopped from playback, via the `Video.stop` method, it will emit the\n`VIDEO_STOP` event instead of this one.\n\nListen for it from a Video Game Object instance using `Video.on('complete', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_CREATED": "The Video Game Object Created Event.\n\nThis event is dispatched when the texture for a Video has been created. This happens\nwhen enough of the video source has been loaded that the browser is able to render a\nframe from it.\n\nListen for it from a Video Game Object instance using `Video.on('created', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_ERROR": "The Video Game Object Error Event.\n\nThis event is dispatched when a Video tries to play a source that does not exist, or is the wrong file type.\n\nListen for it from a Video Game Object instance using `Video.on('error', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_LOCKED": "The Video Game Object Locked Event.\n\nThis event is dispatched when a Video was attempted to be played, but the browser prevented it\nfrom doing so due to the Media Engagement Interaction policy.\n\nIf you get this event you will need to wait for the user to interact with the browser before\nthe video will play. This is a browser security measure to prevent autoplaying videos with\naudio. An interaction includes a mouse click, a touch, or a key press.\n\nListen for it from a Video Game Object instance using `Video.on('locked', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_LOOP": "The Video Game Object Loop Event.\n\nThis event is dispatched when a Video that is currently playing has looped. This only\nhappens if the `loop` parameter was specified, or the `setLoop` method was called,\nand if the video has a fixed duration. Video streams, for example, cannot loop, as\nthey have no duration.\n\nLooping is based on the result of the Video `timeupdate` event. This event is not\nframe-accurate, due to the way browsers work, so please do not rely on this loop\nevent to be time or frame precise.\n\nListen for it from a Video Game Object instance using `Video.on('loop', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_PLAYING": "The Video Game Object Playing Event.\n\nThe playing event is fired after playback is first started,\nand whenever it is restarted. For example it is fired when playback\nresumes after having been paused or delayed due to lack of data.\n\nListen for it from a Video Game Object instance using `Video.on('playing', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_PLAY": "The Video Game Object Play Event.\n\nThis event is dispatched when a Video begins playback. For videos that do not require\ninteraction unlocking, this is usually as soon as the `Video.play` method is called.\nHowever, for videos that require unlocking, it is fired once playback begins after\nthey've been unlocked.\n\nListen for it from a Video Game Object instance using `Video.on('play', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_SEEKED": "The Video Game Object Seeked Event.\n\nThis event is dispatched when a Video completes seeking to a new point in its timeline.\n\nListen for it from a Video Game Object instance using `Video.on('seeked', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_SEEKING": "The Video Game Object Seeking Event.\n\nThis event is dispatched when a Video _begins_ seeking to a new point in its timeline.\nWhen the seek is complete, it will dispatch the `VIDEO_SEEKED` event to conclude.\n\nListen for it from a Video Game Object instance using `Video.on('seeking', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_STALLED": "The Video Game Object Stalled Event.\n\nThis event is dispatched by a Video Game Object when the video playback stalls.\n\nThis can happen if the video is buffering.\n\nIf will fire for any of the following native DOM events:\n\n`stalled`\n`suspend`\n`waiting`\n\nListen for it from a Video Game Object instance using `Video.on('stalled', listener)`.\n\nNote that being stalled isn't always a negative thing. A video can be stalled if it\nhas downloaded enough data in to its buffer to not need to download any more until\nthe current batch of frames have rendered.",
  "Phaser.GameObjects.Events.VIDEO_STOP": "The Video Game Object Stopped Event.\n\nThis event is dispatched when a Video is stopped from playback via a call to the `Video.stop` method,\neither directly via game code, or indirectly as the result of changing a video source or destroying it.\n\nListen for it from a Video Game Object instance using `Video.on('stop', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_TEXTURE": "The Video Game Object Texture Ready Event.\n\nThis event is dispatched by a Video Game Object when it has finished creating its texture.\n\nThis happens when the video has finished loading enough data for its first frame.\n\nIf you wish to use the Video texture elsewhere in your game, such as as a Sprite texture,\nthen you should listen for this event first, before creating the Sprites that use it.\n\nListen for it from a Video Game Object instance using `Video.on('textureready', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_UNLOCKED": "The Video Game Object Unlocked Event.\n\nThis event is dispatched when a Video that was prevented from playback due to the browsers\nMedia Engagement Interaction policy, is unlocked by a user gesture.\n\nListen for it from a Video Game Object instance using `Video.on('unlocked', listener)`.",
  "Phaser.GameObjects.Events.VIDEO_UNSUPPORTED": "The Video Game Object Unsupported Event.\n\nThis event is dispatched by a Video Game Object if the media source\n(which may be specified as a MediaStream, MediaSource, Blob, or File,\nfor example) doesn't represent a supported media format.\n\nListen for it from a Video Game Object instance using `Video.on('unsupported', listener)`.",
  "Phaser.GameObjects.Particles.Events.COMPLETE": "The Particle Emitter Complete Event.\n\nThis event is dispatched when the final particle, emitted from a Particle Emitter that\nhas been stopped, dies. Upon receipt of this event you know that no particles are\nstill rendering at this point in time.\n\nListen for it on a Particle Emitter instance using `ParticleEmitter.on('complete', listener)`.",
  "Phaser.GameObjects.Particles.Events.DEATH_ZONE": "The Particle Emitter Death Zone Event.\n\nThis event is dispatched when a Death Zone kills a Particle instance.\n\nListen for it on a Particle Emitter instance using `ParticleEmitter.on('deathzone', listener)`.\n\nIf you wish to know when the final particle is killed, see the `COMPLETE` event.",
  "Phaser.GameObjects.Particles.Events.EXPLODE": "The Particle Emitter Explode Event.\n\nThis event is dispatched when a Particle Emitter explodes a set of particles.\n\nListen for it on a Particle Emitter instance using `ParticleEmitter.on('explode', listener)`.",
  "Phaser.GameObjects.Particles.Events.START": "The Particle Emitter Start Event.\n\nThis event is dispatched when a Particle Emitter starts emission of particles.\n\nListen for it on a Particle Emitter instance using `ParticleEmitter.on('start', listener)`.",
  "Phaser.GameObjects.Particles.Events.STOP": "The Particle Emitter Stop Event.\n\nThis event is dispatched when a Particle Emitter is stopped. This can happen either\nwhen you directly call the `ParticleEmitter.stop` method, or if the emitter has\nbeen configured to stop after a set time via the `duration` property, or after a\nset number of particles via the `stopAfter` property.\n\nListen for it on a Particle Emitter instance using `ParticleEmitter.on('stop', listener)`.\n\nNote that just because the emitter has stopped, that doesn't mean there aren't still\nparticles alive and rendering. It just means the emitter has stopped emitting particles.\n\nIf you wish to know when the final particle is killed, see the `COMPLETE` event.",
  "Phaser.Input.Events.BOOT": "The Input Plugin Boot Event.\n\nThis internal event is dispatched by the Input Plugin when it boots, signalling to all of its systems to create themselves.",
  "Phaser.Input.Events.DESTROY": "The Input Plugin Destroy Event.\n\nThis internal event is dispatched by the Input Plugin when it is destroyed, signalling to all of its systems to destroy themselves.",
  "Phaser.Input.Events.DRAG_END": "The Pointer Drag End Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer stops dragging a Game Object.\n\nListen to this event from within a Scene using: `this.input.on('dragend', listener)`.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_END]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_END} event instead.",
  "Phaser.Input.Events.DRAG_ENTER": "The Pointer Drag Enter Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer drags a Game Object into a Drag Target.\n\nListen to this event from within a Scene using: `this.input.on('dragenter', listener)`.\n\nA Pointer can only drag a single Game Object at once.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_ENTER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_ENTER} event instead.",
  "Phaser.Input.Events.DRAG": "The Pointer Drag Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer moves while dragging a Game Object.\n\nListen to this event from within a Scene using: `this.input.on('drag', listener)`.\n\nA Pointer can only drag a single Game Object at once.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG} event instead.",
  "Phaser.Input.Events.DRAG_LEAVE": "The Pointer Drag Leave Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer drags a Game Object out of a Drag Target.\n\nListen to this event from within a Scene using: `this.input.on('dragleave', listener)`.\n\nA Pointer can only drag a single Game Object at once.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_LEAVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_LEAVE} event instead.",
  "Phaser.Input.Events.DRAG_OVER": "The Pointer Drag Over Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer drags a Game Object over a Drag Target.\n\nWhen the Game Object first enters the drag target it will emit a `dragenter` event. If it then moves while within\nthe drag target, it will emit this event instead.\n\nListen to this event from within a Scene using: `this.input.on('dragover', listener)`.\n\nA Pointer can only drag a single Game Object at once.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_OVER} event instead.",
  "Phaser.Input.Events.DRAG_START": "The Pointer Drag Start Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer starts to drag any Game Object.\n\nListen to this event from within a Scene using: `this.input.on('dragstart', listener)`.\n\nA Pointer can only drag a single Game Object at once.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DRAG_START]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DRAG_START} event instead.",
  "Phaser.Input.Events.DROP": "The Pointer Drop Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer drops a Game Object on a Drag Target.\n\nListen to this event from within a Scene using: `this.input.on('drop', listener)`.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_DROP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DROP} event instead.",
  "Phaser.Input.Events.GAMEOBJECT_DOWN": "The Game Object Down Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is pressed down on _any_ interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('gameobjectdown', listener)`.\n\nTo receive this event, the Game Objects must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN} event instead.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}\n2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}\n3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_DRAG_END": "The Game Object Drag End Event.\n\nThis event is dispatched by an interactive Game Object if a pointer stops dragging it.\n\nListen to this event from a Game Object using: `gameObject.on('dragend', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive and enabled for drag.\nSee [GameObject.setInteractive](Phaser.GameObjects.GameObject#setInteractive) for more details.",
  "Phaser.Input.Events.GAMEOBJECT_DRAG_ENTER": "The Game Object Drag Enter Event.\n\nThis event is dispatched by an interactive Game Object if a pointer drags it into a drag target.\n\nListen to this event from a Game Object using: `gameObject.on('dragenter', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive and enabled for drag.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.",
  "Phaser.Input.Events.GAMEOBJECT_DRAG": "The Game Object Drag Event.\n\nThis event is dispatched by an interactive Game Object if a pointer moves while dragging it.\n\nListen to this event from a Game Object using: `gameObject.on('drag', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive and enabled for drag.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.",
  "Phaser.Input.Events.GAMEOBJECT_DRAG_LEAVE": "The Game Object Drag Leave Event.\n\nThis event is dispatched by an interactive Game Object if a pointer drags it out of a drag target.\n\nListen to this event from a Game Object using: `gameObject.on('dragleave', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive and enabled for drag.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.",
  "Phaser.Input.Events.GAMEOBJECT_DRAG_OVER": "The Game Object Drag Over Event.\n\nThis event is dispatched by an interactive Game Object if a pointer drags it over a drag target.\n\nWhen the Game Object first enters the drag target it will emit a `dragenter` event. If it then moves while within\nthe drag target, it will emit this event instead.\n\nListen to this event from a Game Object using: `gameObject.on('dragover', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive and enabled for drag.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.",
  "Phaser.Input.Events.GAMEOBJECT_DRAG_START": "The Game Object Drag Start Event.\n\nThis event is dispatched by an interactive Game Object if a pointer starts to drag it.\n\nListen to this event from a Game Object using: `gameObject.on('dragstart', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive and enabled for drag.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nThere are lots of useful drag related properties that are set within the Game Object when dragging occurs.\nFor example, `gameObject.input.dragStartX`, `dragStartY` and so on.",
  "Phaser.Input.Events.GAMEOBJECT_DROP": "The Game Object Drop Event.\n\nThis event is dispatched by an interactive Game Object if a pointer drops it on a Drag Target.\n\nListen to this event from a Game Object using: `gameObject.on('drop', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive and enabled for drag.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.",
  "Phaser.Input.Events.GAMEOBJECT_MOVE": "The Game Object Move Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is moved across _any_ interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('gameobjectmove', listener)`.\n\nTo receive this event, the Game Objects must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE} event instead.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE}\n2. [GAMEOBJECT_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_MOVE}\n3. [POINTER_MOVE]{@linkcode Phaser.Input.Events#event:POINTER_MOVE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_OUT": "The Game Object Out Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer moves out of _any_ interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('gameobjectout', listener)`.\n\nTo receive this event, the Game Objects must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT} event instead.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT}\n2. [GAMEOBJECT_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OUT}\n3. [POINTER_OUT]{@linkcode Phaser.Input.Events#event:POINTER_OUT}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.\n\nIf the pointer leaves the game canvas itself, it will not trigger an this event. To handle those cases,\nplease listen for the [GAME_OUT]{@linkcode Phaser.Input.Events#event:GAME_OUT} event.",
  "Phaser.Input.Events.GAMEOBJECT_OVER": "The Game Object Over Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer moves over _any_ interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('gameobjectover', listener)`.\n\nTo receive this event, the Game Objects must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER} event instead.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER}\n2. [GAMEOBJECT_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OVER}\n3. [POINTER_OVER]{@linkcode Phaser.Input.Events#event:POINTER_OVER}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_POINTER_DOWN": "The Game Object Pointer Down Event.\n\nThis event is dispatched by an interactive Game Object if a pointer is pressed down on it.\n\nListen to this event from a Game Object using: `gameObject.on('pointerdown', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}\n2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}\n3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_POINTER_MOVE": "The Game Object Pointer Move Event.\n\nThis event is dispatched by an interactive Game Object if a pointer is moved while over it.\n\nListen to this event from a Game Object using: `gameObject.on('pointermove', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE}\n2. [GAMEOBJECT_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_MOVE}\n3. [POINTER_MOVE]{@linkcode Phaser.Input.Events#event:POINTER_MOVE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_POINTER_OUT": "The Game Object Pointer Out Event.\n\nThis event is dispatched by an interactive Game Object if a pointer moves out of it.\n\nListen to this event from a Game Object using: `gameObject.on('pointerout', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT}\n2. [GAMEOBJECT_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OUT}\n3. [POINTER_OUT]{@linkcode Phaser.Input.Events#event:POINTER_OUT}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.\n\nIf the pointer leaves the game canvas itself, it will not trigger an this event. To handle those cases,\nplease listen for the [GAME_OUT]{@linkcode Phaser.Input.Events#event:GAME_OUT} event.",
  "Phaser.Input.Events.GAMEOBJECT_POINTER_OVER": "The Game Object Pointer Over Event.\n\nThis event is dispatched by an interactive Game Object if a pointer moves over it.\n\nListen to this event from a Game Object using: `gameObject.on('pointerover', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER}\n2. [GAMEOBJECT_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OVER}\n3. [POINTER_OVER]{@linkcode Phaser.Input.Events#event:POINTER_OVER}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_POINTER_UP": "The Game Object Pointer Up Event.\n\nThis event is dispatched by an interactive Game Object if a pointer is released while over it.\n\nListen to this event from a Game Object using: `gameObject.on('pointerup', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}\n2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}\n3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_POINTER_WHEEL": "The Game Object Pointer Wheel Event.\n\nThis event is dispatched by an interactive Game Object if a pointer has its wheel moved while over it.\n\nListen to this event from a Game Object using: `gameObject.on('wheel', listener)`.\nNote that the scope of the listener is automatically set to be the Game Object instance itself.\n\nTo receive this event, the Game Object must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_WHEEL}\n2. [GAMEOBJECT_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_WHEEL}\n3. [POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:POINTER_WHEEL}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_UP": "The Game Object Up Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is released while over _any_ interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('gameobjectup', listener)`.\n\nTo receive this event, the Game Objects must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP} event instead.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}\n2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}\n3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAMEOBJECT_WHEEL": "The Game Object Wheel Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer has its wheel moved while over _any_ interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('gameobjectwheel', listener)`.\n\nTo receive this event, the Game Objects must have been set as interactive.\nSee [GameObject.setInteractive]{@link Phaser.GameObjects.GameObject#setInteractive} for more details.\n\nTo listen for this event from a _specific_ Game Object, use the [GAMEOBJECT_POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_WHEEL} event instead.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_WHEEL}\n2. [GAMEOBJECT_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_WHEEL}\n3. [POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:POINTER_WHEEL}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.GAME_OUT": "The Input Plugin Game Out Event.\n\nThis event is dispatched by the Input Plugin if the active pointer leaves the game canvas and is now\noutside of it, elsewhere on the web page.\n\nListen to this event from within a Scene using: `this.input.on('gameout', listener)`.",
  "Phaser.Input.Events.GAME_OVER": "The Input Plugin Game Over Event.\n\nThis event is dispatched by the Input Plugin if the active pointer enters the game canvas and is now\nover of it, having previously been elsewhere on the web page.\n\nListen to this event from within a Scene using: `this.input.on('gameover', listener)`.",
  "Phaser.Input.Events.MANAGER_BOOT": "The Input Manager Boot Event.\n\nThis internal event is dispatched by the Input Manager when it boots.",
  "Phaser.Input.Events.MANAGER_PROCESS": "The Input Manager Process Event.\n\nThis internal event is dispatched by the Input Manager when not using the legacy queue system,\nand it wants the Input Plugins to update themselves.",
  "Phaser.Input.Events.MANAGER_UPDATE": "The Input Manager Update Event.\n\nThis internal event is dispatched by the Input Manager as part of its update step.",
  "Phaser.Input.Events.POINTERLOCK_CHANGE": "The Input Manager Pointer Lock Change Event.\n\nThis event is dispatched by the Input Manager when it is processing a native Pointer Lock Change DOM Event.",
  "Phaser.Input.Events.POINTER_DOWN": "The Pointer Down Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is pressed down anywhere.\n\nListen to this event from within a Scene using: `this.input.on('pointerdown', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}\n2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}\n3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.POINTER_DOWN_OUTSIDE": "The Pointer Down Outside Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is pressed down anywhere outside of the game canvas.\n\nListen to this event from within a Scene using: `this.input.on('pointerdownoutside', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_DOWN}\n2. [GAMEOBJECT_DOWN]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_DOWN}\n3. [POINTER_DOWN]{@linkcode Phaser.Input.Events#event:POINTER_DOWN} or [POINTER_DOWN_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_DOWN_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.POINTER_MOVE": "The Pointer Move Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is moved anywhere.\n\nListen to this event from within a Scene using: `this.input.on('pointermove', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_MOVE}\n2. [GAMEOBJECT_MOVE]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_MOVE}\n3. [POINTER_MOVE]{@linkcode Phaser.Input.Events#event:POINTER_MOVE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.POINTER_OUT": "The Pointer Out Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer moves out of any interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('pointerout', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OUT}\n2. [GAMEOBJECT_OUT]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OUT}\n3. [POINTER_OUT]{@linkcode Phaser.Input.Events#event:POINTER_OUT}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.\n\nIf the pointer leaves the game canvas itself, it will not trigger an this event. To handle those cases,\nplease listen for the [GAME_OUT]{@linkcode Phaser.Input.Events#event:GAME_OUT} event.",
  "Phaser.Input.Events.POINTER_OVER": "The Pointer Over Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer moves over any interactive Game Object.\n\nListen to this event from within a Scene using: `this.input.on('pointerover', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_OVER}\n2. [GAMEOBJECT_OVER]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_OVER}\n3. [POINTER_OVER]{@linkcode Phaser.Input.Events#event:POINTER_OVER}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.POINTER_UP": "The Pointer Up Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is released anywhere.\n\nListen to this event from within a Scene using: `this.input.on('pointerup', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}\n2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}\n3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.POINTER_UP_OUTSIDE": "The Pointer Up Outside Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer is released anywhere outside of the game canvas.\n\nListen to this event from within a Scene using: `this.input.on('pointerupoutside', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_UP}\n2. [GAMEOBJECT_UP]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_UP}\n3. [POINTER_UP]{@linkcode Phaser.Input.Events#event:POINTER_UP} or [POINTER_UP_OUTSIDE]{@linkcode Phaser.Input.Events#event:POINTER_UP_OUTSIDE}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.POINTER_WHEEL": "The Pointer Wheel Input Event.\n\nThis event is dispatched by the Input Plugin belonging to a Scene if a pointer has its wheel updated.\n\nListen to this event from within a Scene using: `this.input.on('wheel', listener)`.\n\nThe event hierarchy is as follows:\n\n1. [GAMEOBJECT_POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_POINTER_WHEEL}\n2. [GAMEOBJECT_WHEEL]{@linkcode Phaser.Input.Events#event:GAMEOBJECT_WHEEL}\n3. [POINTER_WHEEL]{@linkcode Phaser.Input.Events#event:POINTER_WHEEL}\n\nWith the top event being dispatched first and then flowing down the list. Note that higher-up event handlers can stop\nthe propagation of this event.",
  "Phaser.Input.Events.PRE_UPDATE": "The Input Plugin Pre-Update Event.\n\nThis internal event is dispatched by the Input Plugin at the start of its `preUpdate` method.\nThis hook is designed specifically for input plugins, but can also be listened to from user-land code.",
  "Phaser.Input.Events.SHUTDOWN": "The Input Plugin Shutdown Event.\n\nThis internal event is dispatched by the Input Plugin when it shuts down, signalling to all of its systems to shut themselves down.",
  "Phaser.Input.Events.START": "The Input Plugin Start Event.\n\nThis internal event is dispatched by the Input Plugin when it has finished setting-up,\nsignalling to all of its internal systems to start.",
  "Phaser.Input.Events.UPDATE": "The Input Plugin Update Event.\n\nThis internal event is dispatched by the Input Plugin at the start of its `update` method.\nThis hook is designed specifically for input plugins, but can also be listened to from user-land code.",
  "Phaser.Input.Gamepad.Events.BUTTON_DOWN": "The Gamepad Button Down Event.\n\nThis event is dispatched by the Gamepad Plugin when a button has been pressed on any active Gamepad.\n\nListen to this event from within a Scene using: `this.input.gamepad.on('down', listener)`.\n\nYou can also listen for a DOWN event from a Gamepad instance. See the [GAMEPAD_BUTTON_DOWN]{@linkcode Phaser.Input.Gamepad.Events#event:GAMEPAD_BUTTON_DOWN} event for details.",
  "Phaser.Input.Gamepad.Events.BUTTON_UP": "The Gamepad Button Up Event.\n\nThis event is dispatched by the Gamepad Plugin when a button has been released on any active Gamepad.\n\nListen to this event from within a Scene using: `this.input.gamepad.on('up', listener)`.\n\nYou can also listen for an UP event from a Gamepad instance. See the [GAMEPAD_BUTTON_UP]{@linkcode Phaser.Input.Gamepad.Events#event:GAMEPAD_BUTTON_UP} event for details.",
  "Phaser.Input.Gamepad.Events.CONNECTED": "The Gamepad Connected Event.\n\nThis event is dispatched by the Gamepad Plugin when a Gamepad has been connected.\n\nListen to this event from within a Scene using: `this.input.gamepad.once('connected', listener)`.\n\nNote that the browser may require you to press a button on a gamepad before it will allow you to access it,\nthis is for security reasons. However, it may also trust the page already, in which case you won't get the\n'connected' event and instead should check `GamepadPlugin.total` to see if it thinks there are any gamepads\nalready connected.",
  "Phaser.Input.Gamepad.Events.DISCONNECTED": "The Gamepad Disconnected Event.\n\nThis event is dispatched by the Gamepad Plugin when a Gamepad has been disconnected.\n\nListen to this event from within a Scene using: `this.input.gamepad.once('disconnected', listener)`.",
  "Phaser.Input.Gamepad.Events.GAMEPAD_BUTTON_DOWN": "The Gamepad Button Down Event.\n\nThis event is dispatched by a Gamepad instance when a button has been pressed on it.\n\nListen to this event from a Gamepad instance. Once way to get this is from the `pad1`, `pad2`, etc properties on the Gamepad Plugin:\n`this.input.gamepad.pad1.on('down', listener)`.\n\nNote that you will not receive any Gamepad button events until the browser considers the Gamepad as being 'connected'.\n\nYou can also listen for a DOWN event from the Gamepad Plugin. See the [BUTTON_DOWN]{@linkcode Phaser.Input.Gamepad.Events#event:BUTTON_DOWN} event for details.",
  "Phaser.Input.Gamepad.Events.GAMEPAD_BUTTON_UP": "The Gamepad Button Up Event.\n\nThis event is dispatched by a Gamepad instance when a button has been released on it.\n\nListen to this event from a Gamepad instance. Once way to get this is from the `pad1`, `pad2`, etc properties on the Gamepad Plugin:\n`this.input.gamepad.pad1.on('up', listener)`.\n\nNote that you will not receive any Gamepad button events until the browser considers the Gamepad as being 'connected'.\n\nYou can also listen for an UP event from the Gamepad Plugin. See the [BUTTON_UP]{@linkcode Phaser.Input.Gamepad.Events#event:BUTTON_UP} event for details.",
  "Phaser.Input.Keyboard.Events.ANY_KEY_DOWN": "The Global Key Down Event.\n\nThis event is dispatched by the Keyboard Plugin when any key on the keyboard is pressed down.\n\nListen to this event from within a Scene using: `this.input.keyboard.on('keydown', listener)`.\n\nYou can also listen for a specific key being pressed. See [Keyboard.Events.KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:KEY_DOWN} for details.\n\nFinally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:DOWN} for details.\n\n_Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\nRead [this article on ghosting]{@link http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/} for details.\n\nAlso, please be aware that some browser extensions can disable or override Phaser keyboard handling.\nFor example, the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.\nThere are others. So, please check your extensions if you find you have specific keys that don't work.",
  "Phaser.Input.Keyboard.Events.ANY_KEY_UP": "The Global Key Up Event.\n\nThis event is dispatched by the Keyboard Plugin when any key on the keyboard is released.\n\nListen to this event from within a Scene using: `this.input.keyboard.on('keyup', listener)`.\n\nYou can also listen for a specific key being released. See [Keyboard.Events.KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:KEY_UP} for details.\n\nFinally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.UP]{@linkcode Phaser.Input.Keyboard.Events#event:UP} for details.",
  "Phaser.Input.Keyboard.Events.COMBO_MATCH": "The Key Combo Match Event.\n\nThis event is dispatched by the Keyboard Plugin when a [Key Combo]{@link Phaser.Input.Keyboard.KeyCombo} is matched.\n\nListen for this event from the Key Plugin after a combo has been created:\n\n```javascript\nthis.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });\n\nthis.input.keyboard.on('keycombomatch', function (event) {\n    console.log('Konami Code entered!');\n});\n```",
  "Phaser.Input.Keyboard.Events.DOWN": "The Key Down Event.\n\nThis event is dispatched by a [Key]{@link Phaser.Input.Keyboard.Key} object when it is pressed.\n\nListen for this event from the Key object instance directly:\n\n```javascript\nvar spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\nspaceBar.on('down', listener)\n```\n\nYou can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_DOWN} for details.",
  "Phaser.Input.Keyboard.Events.KEY_DOWN": "The Key Down Event.\n\nThis event is dispatched by the Keyboard Plugin when any key on the keyboard is pressed down.\n\nUnlike the `ANY_KEY_DOWN` event, this one has a special dynamic event name. For example, to listen for the `A` key being pressed\nuse the following from within a Scene: `this.input.keyboard.on('keydown-A', listener)`. You can replace the `-A` part of the event\nname with any valid [Key Code string]{@link Phaser.Input.Keyboard.KeyCodes}. For example, this will listen for the space bar:\n`this.input.keyboard.on('keydown-SPACE', listener)`.\n\nYou can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_DOWN} for details.\n\nFinally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:DOWN} for details.\n\n_Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\nRead [this article on ghosting]{@link http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/} for details.\n\nAlso, please be aware that some browser extensions can disable or override Phaser keyboard handling.\nFor example, the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.\nThere are others. So, please check your extensions if you find you have specific keys that don't work.",
  "Phaser.Input.Keyboard.Events.KEY_UP": "The Key Up Event.\n\nThis event is dispatched by the Keyboard Plugin when any key on the keyboard is released.\n\nUnlike the `ANY_KEY_UP` event, this one has a special dynamic event name. For example, to listen for the `A` key being released\nuse the following from within a Scene: `this.input.keyboard.on('keyup-A', listener)`. You can replace the `-A` part of the event\nname with any valid [Key Code string]{@link Phaser.Input.Keyboard.KeyCodes}. For example, this will listen for the space bar:\n`this.input.keyboard.on('keyup-SPACE', listener)`.\n\nYou can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_UP} for details.\n\nFinally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.UP]{@linkcode Phaser.Input.Keyboard.Events#event:UP} for details.",
  "Phaser.Input.Keyboard.Events.UP": "The Key Up Event.\n\nThis event is dispatched by a [Key]{@link Phaser.Input.Keyboard.Key} object when it is released.\n\nListen for this event from the Key object instance directly:\n\n```javascript\nvar spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\n\nspaceBar.on('up', listener)\n```\n\nYou can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_UP} for details.",
  "Phaser.Loader.Events.ADD": "The Loader Plugin Add File Event.\n\nThis event is dispatched when a new file is successfully added to the Loader and placed into the load queue.\n\nListen to it from a Scene using: `this.load.on('addfile', listener)`.\n\nIf you add lots of files to a Loader from a `preload` method, it will dispatch this event for each one of them.",
  "Phaser.Loader.Events.COMPLETE": "The Loader Plugin Complete Event.\n\nThis event is dispatched when the Loader has fully processed everything in the load queue.\nBy this point every loaded file will now be in its associated cache and ready for use.\n\nListen to it from a Scene using: `this.load.on('complete', listener)`.",
  "Phaser.Loader.Events.FILE_COMPLETE": "The File Load Complete Event.\n\nThis event is dispatched by the Loader Plugin when _any_ file in the queue finishes loading.\n\nListen to it from a Scene using: `this.load.on('filecomplete', listener)`.\n\nMake sure you remove this listener when you have finished, or it will continue to fire if the Scene reloads.\n\nYou can also listen for the completion of a specific file. See the [FILE_KEY_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_KEY_COMPLETE} event.",
  "Phaser.Loader.Events.FILE_KEY_COMPLETE": "The File Load Complete Event.\n\nThis event is dispatched by the Loader Plugin when any file in the queue finishes loading.\n\nIt uses a special dynamic event name constructed from the key and type of the file.\n\nFor example, if you have loaded an `image` with a key of `monster`, you can listen for it\nusing the following:\n\n```javascript\nthis.load.on('filecomplete-image-monster', function (key, type, data) {\n    // Your handler code\n});\n```\n\nOr, if you have loaded a texture `atlas` with a key of `Level1`:\n\n```javascript\nthis.load.on('filecomplete-atlasjson-Level1', function (key, type, data) {\n    // Your handler code\n});\n```\n\nOr, if you have loaded a sprite sheet with a key of `Explosion` and a prefix of `GAMEOVER`:\n\n```javascript\nthis.load.on('filecomplete-spritesheet-GAMEOVERExplosion', function (key, type, data) {\n    // Your handler code\n});\n```\n\nMake sure you remove your listeners when you have finished, or they will continue to fire if the Scene reloads.\n\nYou can also listen for the generic completion of files. See the [FILE_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_COMPLETE} event.",
  "Phaser.Loader.Events.FILE_LOAD_ERROR": "The File Load Error Event.\n\nThis event is dispatched by the Loader Plugin when a file fails to load.\n\nListen to it from a Scene using: `this.load.on('loaderror', listener)`.",
  "Phaser.Loader.Events.FILE_LOAD": "The File Load Event.\n\nThis event is dispatched by the Loader Plugin when a file finishes loading,\nbut _before_ it is processed and added to the internal Phaser caches.\n\nListen to it from a Scene using: `this.load.on('load', listener)`.",
  "Phaser.Loader.Events.FILE_PROGRESS": "The File Load Progress Event.\n\nThis event is dispatched by the Loader Plugin during the load of a file, if the browser receives a DOM ProgressEvent and\nthe `lengthComputable` event property is true. Depending on the size of the file and browser in use, this may, or may not happen.\n\nListen to it from a Scene using: `this.load.on('fileprogress', listener)`.",
  "Phaser.Loader.Events.POST_PROCESS": "The Loader Plugin Post Process Event.\n\nThis event is dispatched by the Loader Plugin when the Loader has finished loading everything in the load queue.\nIt is dispatched before the internal lists are cleared and each File is destroyed.\n\nUse this hook to perform any last minute processing of files that can only happen once the\nLoader has completed, but prior to it emitting the `complete` event.\n\nListen to it from a Scene using: `this.load.on('postprocess', listener)`.",
  "Phaser.Loader.Events.PROGRESS": "The Loader Plugin Progress Event.\n\nThis event is dispatched when the Loader updates its load progress, typically as a result of a file having completed loading.\n\nListen to it from a Scene using: `this.load.on('progress', listener)`.",
  "Phaser.Loader.Events.START": "The Loader Plugin Start Event.\n\nThis event is dispatched when the Loader starts running. At this point load progress is zero.\n\nThis event is dispatched even if there aren't any files in the load queue.\n\nListen to it from a Scene using: `this.load.on('start', listener)`.",
  "Phaser.Physics.Arcade.Events.COLLIDE": "The Arcade Physics World Collide Event.\n\nThis event is dispatched by an Arcade Physics World instance if two bodies collide _and_ at least\none of them has their [onCollide]{@link Phaser.Physics.Arcade.Body#onCollide} property set to `true`.\n\nIt provides an alternative means to handling collide events rather than using the callback approach.\n\nListen to it from a Scene using: `this.physics.world.on('collide', listener)`.\n\nPlease note that 'collide' and 'overlap' are two different things in Arcade Physics.",
  "Phaser.Physics.Arcade.Events.OVERLAP": "The Arcade Physics World Overlap Event.\n\nThis event is dispatched by an Arcade Physics World instance if two bodies overlap _and_ at least\none of them has their [onOverlap]{@link Phaser.Physics.Arcade.Body#onOverlap} property set to `true`.\n\nIt provides an alternative means to handling overlap events rather than using the callback approach.\n\nListen to it from a Scene using: `this.physics.world.on('overlap', listener)`.\n\nPlease note that 'collide' and 'overlap' are two different things in Arcade Physics.",
  "Phaser.Physics.Arcade.Events.PAUSE": "The Arcade Physics World Pause Event.\n\nThis event is dispatched by an Arcade Physics World instance when it is paused.\n\nListen to it from a Scene using: `this.physics.world.on('pause', listener)`.",
  "Phaser.Physics.Arcade.Events.RESUME": "The Arcade Physics World Resume Event.\n\nThis event is dispatched by an Arcade Physics World instance when it resumes from a paused state.\n\nListen to it from a Scene using: `this.physics.world.on('resume', listener)`.",
  "Phaser.Physics.Arcade.Events.TILE_COLLIDE": "The Arcade Physics Tile Collide Event.\n\nThis event is dispatched by an Arcade Physics World instance if a body collides with a Tile _and_\nhas its [onCollide]{@link Phaser.Physics.Arcade.Body#onCollide} property set to `true`.\n\nIt provides an alternative means to handling collide events rather than using the callback approach.\n\nListen to it from a Scene using: `this.physics.world.on('tilecollide', listener)`.\n\nPlease note that 'collide' and 'overlap' are two different things in Arcade Physics.",
  "Phaser.Physics.Arcade.Events.TILE_OVERLAP": "The Arcade Physics Tile Overlap Event.\n\nThis event is dispatched by an Arcade Physics World instance if a body overlaps with a Tile _and_\nhas its [onOverlap]{@link Phaser.Physics.Arcade.Body#onOverlap} property set to `true`.\n\nIt provides an alternative means to handling overlap events rather than using the callback approach.\n\nListen to it from a Scene using: `this.physics.world.on('tileoverlap', listener)`.\n\nPlease note that 'collide' and 'overlap' are two different things in Arcade Physics.",
  "Phaser.Physics.Arcade.Events.WORLD_BOUNDS": "The Arcade Physics World Bounds Event.\n\nThis event is dispatched by an Arcade Physics World instance if a body makes contact with the world bounds _and_\nit has its [onWorldBounds]{@link Phaser.Physics.Arcade.Body#onWorldBounds} property set to `true`.\n\nIt provides an alternative means to handling collide events rather than using the callback approach.\n\nListen to it from a Scene using: `this.physics.world.on('worldbounds', listener)`.",
  "Phaser.Physics.Arcade.Events.WORLD_STEP": "The Arcade Physics World Step Event.\n\nThis event is dispatched by an Arcade Physics World instance whenever a physics step is run.\nIt is emitted _after_ the bodies and colliders have been updated.\n\nIn high framerate settings this can be multiple times per game frame.\n\nListen to it from a Scene using: `this.physics.world.on('worldstep', listener)`.",
  "Phaser.Physics.Matter.Events.AFTER_ADD": "The Matter Physics After Add Event.\n\nThis event is dispatched by a Matter Physics World instance at the end of the process when a new Body\nor Constraint has just been added to the world.\n\nListen to it from a Scene using: `this.matter.world.on('afteradd', listener)`.",
  "Phaser.Physics.Matter.Events.AFTER_REMOVE": "The Matter Physics After Remove Event.\n\nThis event is dispatched by a Matter Physics World instance at the end of the process when a\nBody or Constraint was removed from the world.\n\nListen to it from a Scene using: `this.matter.world.on('afterremove', listener)`.",
  "Phaser.Physics.Matter.Events.AFTER_UPDATE": "The Matter Physics After Update Event.\n\nThis event is dispatched by a Matter Physics World instance after the engine has updated and all collision events have resolved.\n\nListen to it from a Scene using: `this.matter.world.on('afterupdate', listener)`.",
  "Phaser.Physics.Matter.Events.BEFORE_ADD": "The Matter Physics Before Add Event.\n\nThis event is dispatched by a Matter Physics World instance at the start of the process when a new Body\nor Constraint is being added to the world.\n\nListen to it from a Scene using: `this.matter.world.on('beforeadd', listener)`.",
  "Phaser.Physics.Matter.Events.BEFORE_REMOVE": "The Matter Physics Before Remove Event.\n\nThis event is dispatched by a Matter Physics World instance at the start of the process when a\nBody or Constraint is being removed from the world.\n\nListen to it from a Scene using: `this.matter.world.on('beforeremove', listener)`.",
  "Phaser.Physics.Matter.Events.BEFORE_UPDATE": "The Matter Physics Before Update Event.\n\nThis event is dispatched by a Matter Physics World instance right before all the collision processing takes place.\n\nListen to it from a Scene using: `this.matter.world.on('beforeupdate', listener)`.",
  "Phaser.Physics.Matter.Events.COLLISION_ACTIVE": "The Matter Physics Collision Active Event.\n\nThis event is dispatched by a Matter Physics World instance after the engine has updated.\nIt provides a list of all pairs that are colliding in the current tick (if any).\n\nListen to it from a Scene using: `this.matter.world.on('collisionactive', listener)`.",
  "Phaser.Physics.Matter.Events.COLLISION_END": "The Matter Physics Collision End Event.\n\nThis event is dispatched by a Matter Physics World instance after the engine has updated.\nIt provides a list of all pairs that have finished colliding in the current tick (if any).\n\nListen to it from a Scene using: `this.matter.world.on('collisionend', listener)`.",
  "Phaser.Physics.Matter.Events.COLLISION_START": "The Matter Physics Collision Start Event.\n\nThis event is dispatched by a Matter Physics World instance after the engine has updated.\nIt provides a list of all pairs that have started to collide in the current tick (if any).\n\nListen to it from a Scene using: `this.matter.world.on('collisionstart', listener)`.",
  "Phaser.Physics.Matter.Events.DRAG_END": "The Matter Physics Drag End Event.\n\nThis event is dispatched by a Matter Physics World instance when a Pointer Constraint\nstops dragging a body.\n\nListen to it from a Scene using: `this.matter.world.on('dragend', listener)`.",
  "Phaser.Physics.Matter.Events.DRAG": "The Matter Physics Drag Event.\n\nThis event is dispatched by a Matter Physics World instance when a Pointer Constraint\nis actively dragging a body. It is emitted each time the pointer moves.\n\nListen to it from a Scene using: `this.matter.world.on('drag', listener)`.",
  "Phaser.Physics.Matter.Events.DRAG_START": "The Matter Physics Drag Start Event.\n\nThis event is dispatched by a Matter Physics World instance when a Pointer Constraint\nstarts dragging a body.\n\nListen to it from a Scene using: `this.matter.world.on('dragstart', listener)`.",
  "Phaser.Physics.Matter.Events.PAUSE": "The Matter Physics World Pause Event.\n\nThis event is dispatched by an Matter Physics World instance when it is paused.\n\nListen to it from a Scene using: `this.matter.world.on('pause', listener)`.",
  "Phaser.Physics.Matter.Events.RESUME": "The Matter Physics World Resume Event.\n\nThis event is dispatched by an Matter Physics World instance when it resumes from a paused state.\n\nListen to it from a Scene using: `this.matter.world.on('resume', listener)`.",
  "Phaser.Physics.Matter.Events.SLEEP_END": "The Matter Physics Sleep End Event.\n\nThis event is dispatched by a Matter Physics World instance when a Body stop sleeping.\n\nListen to it from a Scene using: `this.matter.world.on('sleepend', listener)`.",
  "Phaser.Physics.Matter.Events.SLEEP_START": "The Matter Physics Sleep Start Event.\n\nThis event is dispatched by a Matter Physics World instance when a Body goes to sleep.\n\nListen to it from a Scene using: `this.matter.world.on('sleepstart', listener)`.",
  "Phaser.Renderer.Events.POST_RENDER": "The Post-Render Event.\n\nThis event is dispatched by the Renderer when all rendering, for all cameras in all Scenes,\nhas completed, but before any pending snap shots have been taken.",
  "Phaser.Renderer.Events.PRE_RENDER": "The Pre-Render Event.\n\nThis event is dispatched by the Phaser Renderer. This happens right at the start of the render\nprocess, after the context has been cleared, the scissors enabled (WebGL only) and everything has been\nreset ready for the render.",
  "Phaser.Renderer.Events.RENDER": "The Render Event.\n\nThis event is dispatched by the Phaser Renderer for every camera in every Scene.\n\nIt is dispatched before any of the children in the Scene have been rendered.",
  "Phaser.Renderer.Events.RESIZE": "The Renderer Resize Event.\n\nThis event is dispatched by the Phaser Renderer when it is resized, usually as a result\nof the Scale Manager resizing.",
  "Phaser.Renderer.WebGL.Pipelines.Events.AFTER_FLUSH": "The WebGLPipeline After Flush Event.\n\nThis event is dispatched by a WebGLPipeline right after it has issued a drawArrays command\nand cleared its vertex count.",
  "Phaser.Renderer.WebGL.Pipelines.Events.BEFORE_FLUSH": "The WebGLPipeline Before Flush Event.\n\nThis event is dispatched by a WebGLPipeline right before it is about to\nflush and issue a bufferData and drawArrays command.",
  "Phaser.Renderer.WebGL.Pipelines.Events.BIND": "The WebGLPipeline Bind Event.\n\nThis event is dispatched by a WebGLPipeline when it is bound by the Pipeline Manager.",
  "Phaser.Renderer.WebGL.Pipelines.Events.BOOT": "The WebGLPipeline Boot Event.\n\nThis event is dispatched by a WebGLPipeline when it has completed its `boot` phase.",
  "Phaser.Renderer.WebGL.Pipelines.Events.DESTROY": "The WebGLPipeline Destroy Event.\n\nThis event is dispatched by a WebGLPipeline when it is starting its destroy process.",
  "Phaser.Renderer.WebGL.Pipelines.Events.REBIND": "The WebGLPipeline ReBind Event.\n\nThis event is dispatched by a WebGLPipeline when it is re-bound by the Pipeline Manager.",
  "Phaser.Renderer.WebGL.Pipelines.Events.RESIZE": "The WebGLPipeline Resize Event.\n\nThis event is dispatched by a WebGLPipeline when it is resized, usually as a result\nof the Renderer resizing.",
  "Phaser.Scale.Events.ENTER_FULLSCREEN": "The Scale Manager has successfully entered fullscreen mode.",
  "Phaser.Scale.Events.FULLSCREEN_FAILED": "The Scale Manager tried to enter fullscreen mode but failed.",
  "Phaser.Scale.Events.FULLSCREEN_UNSUPPORTED": "The Scale Manager tried to enter fullscreen mode, but it is unsupported by the browser.",
  "Phaser.Scale.Events.LEAVE_FULLSCREEN": "The Scale Manager was in fullscreen mode, but has since left, either directly via game code,\nor via a user gestured, such as pressing the ESC key.",
  "Phaser.Scale.Events.ORIENTATION_CHANGE": "The Scale Manager Orientation Change Event.\n\nThis event is dispatched whenever the Scale Manager detects an orientation change event from the browser.",
  "Phaser.Scale.Events.RESIZE": "The Scale Manager Resize Event.\n\nThis event is dispatched whenever the Scale Manager detects a resize event from the browser.\nIt sends three parameters to the callback, each of them being Size components. You can read\nthe `width`, `height`, `aspectRatio` and other properties of these components to help with\nscaling your own game content.",
  "Phaser.Scenes.Events.ADDED_TO_SCENE": "The Game Object Added to Scene Event.\n\nThis event is dispatched when a Game Object is added to a Scene.\n\nListen for it from a Scene using `this.events.on('addedtoscene', listener)`.",
  "Phaser.Scenes.Events.BOOT": "The Scene Systems Boot Event.\n\nThis event is dispatched by a Scene during the Scene Systems boot process. Primarily used by Scene Plugins.\n\nListen to it from a Scene using `this.events.on('boot', listener)`.",
  "Phaser.Scenes.Events.CREATE": "The Scene Create Event.\n\nThis event is dispatched by a Scene after it has been created by the Scene Manager.\n\nIf a Scene has a `create` method then this event is emitted _after_ that has run.\n\nIf there is a transition, this event will be fired after the `TRANSITION_START` event.\n\nListen to it from a Scene using `this.events.on('create', listener)`.",
  "Phaser.Scenes.Events.DESTROY": "The Scene Systems Destroy Event.\n\nThis event is dispatched by a Scene during the Scene Systems destroy process.\n\nListen to it from a Scene using `this.events.on('destroy', listener)`.\n\nYou should destroy any resources that may be in use by your Scene in this event handler.",
  "Phaser.Scenes.Events.PAUSE": "The Scene Systems Pause Event.\n\nThis event is dispatched by a Scene when it is paused, either directly via the `pause` method, or as an\naction from another Scene.\n\nListen to it from a Scene using `this.events.on('pause', listener)`.",
  "Phaser.Scenes.Events.POST_UPDATE": "The Scene Systems Post Update Event.\n\nThis event is dispatched by a Scene during the main game loop step.\n\nThe event flow for a single step of a Scene is as follows:\n\n1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\n2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\n3. The `Scene.update` method is called, if it exists\n4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\n5. [PRE_RENDER]{@linkcode Phaser.Scenes.Events#event:PRE_RENDER}\n6. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\n\nListen to it from a Scene using `this.events.on('postupdate', listener)`.\n\nA Scene will only run its step if it is active.",
  "Phaser.Scenes.Events.PRE_RENDER": "The Scene Systems Pre-Render Event.\n\nThis event is dispatched by a Scene during the main game loop step.\n\nThe event flow for a single step of a Scene is as follows:\n\n1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\n2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\n3. The `Scene.update` method is called, if it exists\n4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\n5. [PRE_RENDER]{@linkcode Phaser.Scenes.Events#event:PRE_RENDER}\n6. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\n\nListen to this event from a Scene using `this.events.on('prerender', listener)`.\n\nA Scene will only render if it is visible.\n\nThis event is dispatched after the Scene Display List is sorted and before the Scene is rendered.",
  "Phaser.Scenes.Events.PRE_UPDATE": "The Scene Systems Pre Update Event.\n\nThis event is dispatched by a Scene during the main game loop step.\n\nThe event flow for a single step of a Scene is as follows:\n\n1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\n2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\n3. The `Scene.update` method is called, if it exists\n4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\n5. [PRE_RENDER]{@linkcode Phaser.Scenes.Events#event:PRE_RENDER}\n6. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\n\nListen to it from a Scene using `this.events.on('preupdate', listener)`.\n\nA Scene will only run its step if it is active.",
  "Phaser.Scenes.Events.READY": "The Scene Systems Ready Event.\n\nThis event is dispatched by a Scene during the Scene Systems start process.\nBy this point in the process the Scene is now fully active and rendering.\nThis event is meant for your game code to use, as all plugins have responded to the earlier 'start' event.\n\nListen to it from a Scene using `this.events.on('ready', listener)`.",
  "Phaser.Scenes.Events.REMOVED_FROM_SCENE": "The Game Object Removed from Scene Event.\n\nThis event is dispatched when a Game Object is removed from a Scene.\n\nListen for it from a Scene using `this.events.on('removedfromscene', listener)`.",
  "Phaser.Scenes.Events.RENDER": "The Scene Systems Render Event.\n\nThis event is dispatched by a Scene during the main game loop step.\n\nThe event flow for a single step of a Scene is as follows:\n\n1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\n2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\n3. The `Scene.update` method is called, if it exists\n4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\n5. [PRE_RENDER]{@linkcode Phaser.Scenes.Events#event:PRE_RENDER}\n6. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\n\nListen to it from a Scene using `this.events.on('render', listener)`.\n\nA Scene will only render if it is visible.\n\nBy the time this event is dispatched, the Scene will have already been rendered.",
  "Phaser.Scenes.Events.RESUME": "The Scene Systems Resume Event.\n\nThis event is dispatched by a Scene when it is resumed from a paused state, either directly via the `resume` method,\nor as an action from another Scene.\n\nListen to it from a Scene using `this.events.on('resume', listener)`.",
  "Phaser.Scenes.Events.SHUTDOWN": "The Scene Systems Shutdown Event.\n\nThis event is dispatched by a Scene during the Scene Systems shutdown process.\n\nListen to it from a Scene using `this.events.on('shutdown', listener)`.\n\nYou should free-up any resources that may be in use by your Scene in this event handler, on the understanding\nthat the Scene may, at any time, become active again. A shutdown Scene is not 'destroyed', it's simply not\ncurrently active. Use the [DESTROY]{@linkcode Phaser.Scenes.Events#event:DESTROY} event to completely clear resources.",
  "Phaser.Scenes.Events.SLEEP": "The Scene Systems Sleep Event.\n\nThis event is dispatched by a Scene when it is sent to sleep, either directly via the `sleep` method,\nor as an action from another Scene.\n\nListen to it from a Scene using `this.events.on('sleep', listener)`.",
  "Phaser.Scenes.Events.START": "The Scene Systems Start Event.\n\nThis event is dispatched by a Scene during the Scene Systems start process. Primarily used by Scene Plugins.\n\nListen to it from a Scene using `this.events.on('start', listener)`.",
  "Phaser.Scenes.Events.TRANSITION_COMPLETE": "The Scene Transition Complete Event.\n\nThis event is dispatched by the Target Scene of a transition.\n\nIt happens when the transition process has completed. This occurs when the duration timer equals or exceeds the duration\nof the transition.\n\nListen to it from a Scene using `this.events.on('transitioncomplete', listener)`.\n\nThe Scene Transition event flow is as follows:\n\n1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\n2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\n3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\n4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\n5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.",
  "Phaser.Scenes.Events.TRANSITION_INIT": "The Scene Transition Init Event.\n\nThis event is dispatched by the Target Scene of a transition.\n\nIt happens immediately after the `Scene.init` method is called. If the Scene does not have an `init` method,\nthis event is not dispatched.\n\nListen to it from a Scene using `this.events.on('transitioninit', listener)`.\n\nThe Scene Transition event flow is as follows:\n\n1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\n2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\n3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\n4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\n5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.",
  "Phaser.Scenes.Events.TRANSITION_OUT": "The Scene Transition Out Event.\n\nThis event is dispatched by a Scene when it initiates a transition to another Scene.\n\nListen to it from a Scene using `this.events.on('transitionout', listener)`.\n\nThe Scene Transition event flow is as follows:\n\n1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\n2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\n3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\n4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\n5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.",
  "Phaser.Scenes.Events.TRANSITION_START": "The Scene Transition Start Event.\n\nThis event is dispatched by the Target Scene of a transition, only if that Scene was not asleep.\n\nIt happens immediately after the `Scene.create` method is called. If the Scene does not have a `create` method,\nthis event is dispatched anyway.\n\nIf the Target Scene was sleeping then the [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} event is\ndispatched instead of this event.\n\nListen to it from a Scene using `this.events.on('transitionstart', listener)`.\n\nThe Scene Transition event flow is as follows:\n\n1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\n2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\n3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\n4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\n5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.",
  "Phaser.Scenes.Events.TRANSITION_WAKE": "The Scene Transition Wake Event.\n\nThis event is dispatched by the Target Scene of a transition, only if that Scene was asleep before\nthe transition began. If the Scene was not asleep the [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} event is dispatched instead.\n\nListen to it from a Scene using `this.events.on('transitionwake', listener)`.\n\nThe Scene Transition event flow is as follows:\n\n1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\n2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\n3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\n4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\n5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.",
  "Phaser.Scenes.Events.UPDATE": "The Scene Systems Update Event.\n\nThis event is dispatched by a Scene during the main game loop step.\n\nThe event flow for a single step of a Scene is as follows:\n\n1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\n2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\n3. The `Scene.update` method is called, if it exists and the Scene is in a Running state, otherwise this is skipped.\n4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\n5. [PRE_RENDER]{@linkcode Phaser.Scenes.Events#event:PRE_RENDER}\n6. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\n\nListen to it from a Scene using `this.events.on('update', listener)`.\n\nA Scene will only run its step if it is active.",
  "Phaser.Scenes.Events.WAKE": "The Scene Systems Wake Event.\n\nThis event is dispatched by a Scene when it is woken from sleep, either directly via the `wake` method,\nor as an action from another Scene.\n\nListen to it from a Scene using `this.events.on('wake', listener)`.",
  "Phaser.Sound.Events.COMPLETE": "The Sound Complete Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they complete playback.\n\nListen to it from a Sound instance using `Sound.on('complete', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('complete', listener);\nmusic.play();\n```",
  "Phaser.Sound.Events.DECODED_ALL": "The Audio Data Decoded All Event.\n\nThis event is dispatched by the Web Audio Sound Manager as a result of calling the `decodeAudio` method,\nonce all files passed to the method have been decoded (or errored).\n\nUse `Phaser.Sound.Events#DECODED` to listen for single sounds being decoded, and `DECODED_ALL` to\nlisten for them all completing.\n\nListen to it from the Sound Manager in a Scene using `this.sound.on('decodedall', listener)`, i.e.:\n\n```javascript\nthis.sound.once('decodedall', handler);\nthis.sound.decodeAudio([ audioFiles ]);\n```",
  "Phaser.Sound.Events.DECODED": "The Audio Data Decoded Event.\n\nThis event is dispatched by the Web Audio Sound Manager as a result of calling the `decodeAudio` method.\n\nListen to it from the Sound Manager in a Scene using `this.sound.on('decoded', listener)`, i.e.:\n\n```javascript\nthis.sound.on('decoded', handler);\nthis.sound.decodeAudio(key, audioData);\n```",
  "Phaser.Sound.Events.DESTROY": "The Sound Destroy Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are destroyed, either\ndirectly or via a Sound Manager.\n\nListen to it from a Sound instance using `Sound.on('destroy', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('destroy', listener);\nmusic.destroy();\n```",
  "Phaser.Sound.Events.DETUNE": "The Sound Detune Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when their detune value changes.\n\nListen to it from a Sound instance using `Sound.on('detune', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('detune', listener);\nmusic.play();\nmusic.setDetune(200);\n```",
  "Phaser.Sound.Events.GLOBAL_DETUNE": "The Sound Manager Global Detune Event.\n\nThis event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,\nor the HTML5 Audio Manager. It is dispatched when the `detune` property of the Sound Manager is changed, which globally\nadjusts the detuning of all active sounds.\n\nListen to it from a Scene using: `this.sound.on('rate', listener)`.",
  "Phaser.Sound.Events.GLOBAL_MUTE": "The Sound Manager Global Mute Event.\n\nThis event is dispatched by the Sound Manager when its `mute` property is changed, either directly\nor via the `setMute` method. This changes the mute state of all active sounds.\n\nListen to it from a Scene using: `this.sound.on('mute', listener)`.",
  "Phaser.Sound.Events.GLOBAL_RATE": "The Sound Manager Global Rate Event.\n\nThis event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,\nor the HTML5 Audio Manager. It is dispatched when the `rate` property of the Sound Manager is changed, which globally\nadjusts the playback rate of all active sounds.\n\nListen to it from a Scene using: `this.sound.on('rate', listener)`.",
  "Phaser.Sound.Events.GLOBAL_VOLUME": "The Sound Manager Global Volume Event.\n\nThis event is dispatched by the Sound Manager when its `volume` property is changed, either directly\nor via the `setVolume` method. This changes the volume of all active sounds.\n\nListen to it from a Scene using: `this.sound.on('volume', listener)`.",
  "Phaser.Sound.Events.LOOPED": "The Sound Looped Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they loop during playback.\n\nListen to it from a Sound instance using `Sound.on('looped', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('looped', listener);\nmusic.setLoop(true);\nmusic.play();\n```\n\nThis is not to be confused with the [LOOP]{@linkcode Phaser.Sound.Events#event:LOOP} event, which only emits when the loop state of a Sound is changed.",
  "Phaser.Sound.Events.LOOP": "The Sound Loop Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when their loop state is changed.\n\nListen to it from a Sound instance using `Sound.on('loop', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('loop', listener);\nmusic.setLoop(true);\n```\n\nThis is not to be confused with the [LOOPED]{@linkcode Phaser.Sound.Events#event:LOOPED} event, which emits each time a Sound loops during playback.",
  "Phaser.Sound.Events.MUTE": "The Sound Mute Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when their mute state changes.\n\nListen to it from a Sound instance using `Sound.on('mute', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('mute', listener);\nmusic.play();\nmusic.setMute(true);\n```",
  "Phaser.Sound.Events.PAN": "The Sound Pan Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when their pan changes.\n\nListen to it from a Sound instance using `Sound.on('pan', listener)`, i.e.:\n\n```javascript\nvar sound = this.sound.add('key');\nsound.on('pan', listener);\nsound.play();\nsound.setPan(0.5);\n```",
  "Phaser.Sound.Events.PAUSE_ALL": "The Pause All Sounds Event.\n\nThis event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,\nor the HTML5 Audio Manager. It is dispatched when the `pauseAll` method is invoked and after all current Sounds\nhave been paused.\n\nListen to it from a Scene using: `this.sound.on('pauseall', listener)`.",
  "Phaser.Sound.Events.PAUSE": "The Sound Pause Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are paused.\n\nListen to it from a Sound instance using `Sound.on('pause', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('pause', listener);\nmusic.play();\nmusic.pause();\n```",
  "Phaser.Sound.Events.PLAY": "The Sound Play Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are played.\n\nListen to it from a Sound instance using `Sound.on('play', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('play', listener);\nmusic.play();\n```",
  "Phaser.Sound.Events.RATE": "The Sound Rate Change Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when their rate changes.\n\nListen to it from a Sound instance using `Sound.on('rate', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('rate', listener);\nmusic.play();\nmusic.setRate(0.5);\n```",
  "Phaser.Sound.Events.RESUME_ALL": "The Resume All Sounds Event.\n\nThis event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,\nor the HTML5 Audio Manager. It is dispatched when the `resumeAll` method is invoked and after all current Sounds\nhave been resumed.\n\nListen to it from a Scene using: `this.sound.on('resumeall', listener)`.",
  "Phaser.Sound.Events.RESUME": "The Sound Resume Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are resumed from a paused state.\n\nListen to it from a Sound instance using `Sound.on('resume', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('resume', listener);\nmusic.play();\nmusic.pause();\nmusic.resume();\n```",
  "Phaser.Sound.Events.SEEK": "The Sound Seek Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are seeked to a new position.\n\nListen to it from a Sound instance using `Sound.on('seek', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('seek', listener);\nmusic.play();\nmusic.setSeek(5000);\n```",
  "Phaser.Sound.Events.STOP_ALL": "The Stop All Sounds Event.\n\nThis event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,\nor the HTML5 Audio Manager. It is dispatched when the `stopAll` method is invoked and after all current Sounds\nhave been stopped.\n\nListen to it from a Scene using: `this.sound.on('stopall', listener)`.",
  "Phaser.Sound.Events.STOP": "The Sound Stop Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when they are stopped.\n\nListen to it from a Sound instance using `Sound.on('stop', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('stop', listener);\nmusic.play();\nmusic.stop();\n```",
  "Phaser.Sound.Events.UNLOCKED": "The Sound Manager Unlocked Event.\n\nThis event is dispatched by the Base Sound Manager, or more typically, an instance of the Web Audio Sound Manager,\nor the HTML5 Audio Manager. It is dispatched during the update loop when the Sound Manager becomes unlocked. For\nWeb Audio this is on the first user gesture on the page.\n\nListen to it from a Scene using: `this.sound.on('unlocked', listener)`.",
  "Phaser.Sound.Events.VOLUME": "The Sound Volume Event.\n\nThis event is dispatched by both Web Audio and HTML5 Audio Sound objects when their volume changes.\n\nListen to it from a Sound instance using `Sound.on('volume', listener)`, i.e.:\n\n```javascript\nvar music = this.sound.add('key');\nmusic.on('volume', listener);\nmusic.play();\nmusic.setVolume(0.5);\n```",
  "Phaser.Structs.Events.PROCESS_QUEUE_ADD": "The Process Queue Add Event.\n\nThis event is dispatched by a Process Queue when a new item is successfully moved to its active list.\n\nYou will most commonly see this used by a Scene's Update List when a new Game Object has been added.\n\nIn that instance, listen to this event from within a Scene using: `this.sys.updateList.on('add', listener)`.",
  "Phaser.Structs.Events.PROCESS_QUEUE_REMOVE": "The Process Queue Remove Event.\n\nThis event is dispatched by a Process Queue when a new item is successfully removed from its active list.\n\nYou will most commonly see this used by a Scene's Update List when a Game Object has been removed.\n\nIn that instance, listen to this event from within a Scene using: `this.sys.updateList.on('remove', listener)`.",
  "Phaser.Textures.Events.ADD": "The Texture Add Event.\n\nThis event is dispatched by the Texture Manager when a texture is added to it.\n\nListen to this event from within a Scene using: `this.textures.on('addtexture', listener)`.",
  "Phaser.Textures.Events.ADD_KEY": "The Texture Add Key Event.\n\nThis event is dispatched by the Texture Manager when a texture with the given key is added to it.\n\nListen to this event from within a Scene using: `this.textures.on('addtexture-key', listener)`.",
  "Phaser.Textures.Events.ERROR": "The Texture Load Error Event.\n\nThis event is dispatched by the Texture Manager when a texture it requested to load failed.\nThis only happens when base64 encoded textures fail. All other texture types are loaded via the Loader Plugin.\n\nListen to this event from within a Scene using: `this.textures.on('onerror', listener)`.",
  "Phaser.Textures.Events.LOAD": "The Texture Load Event.\n\nThis event is dispatched by the Texture Manager when a texture has finished loading on it.\nThis only happens for base64 encoded textures. All other texture types are loaded via the Loader Plugin.\n\nListen to this event from within a Scene using: `this.textures.on('onload', listener)`.\n\nThis event is dispatched after the [ADD]{@linkcode Phaser.Textures.Events#event:ADD} event.",
  "Phaser.Textures.Events.READY": "This internal event signifies that the Texture Manager is now ready and the Game can continue booting.\n\nWhen a Phaser Game instance is booting for the first time, the Texture Manager has to wait on a couple of non-blocking\nasync events before it's fully ready to carry on. When those complete the Texture Manager emits this event via the Game\ninstance, which tells the Game to carry on booting.",
  "Phaser.Textures.Events.REMOVE": "The Texture Remove Event.\n\nThis event is dispatched by the Texture Manager when a texture is removed from it.\n\nListen to this event from within a Scene using: `this.textures.on('removetexture', listener)`.\n\nIf you have any Game Objects still using the removed texture, they will start throwing\nerrors the next time they try to render. Be sure to clear all use of the texture in this event handler.",
  "Phaser.Textures.Events.REMOVE_KEY": "The Texture Remove Key Event.\n\nThis event is dispatched by the Texture Manager when a texture with the given key is removed from it.\n\nListen to this event from within a Scene using: `this.textures.on('removetexture-key', listener)`.\n\nIf you have any Game Objects still using the removed texture, they will start throwing\nerrors the next time they try to render. Be sure to clear all use of the texture in this event handler.",
  "Phaser.Tweens.Events.TWEEN_ACTIVE": "The Tween Active Event.\n\nThis event is dispatched by a Tween when it becomes active within the Tween Manager.\n\nAn 'active' Tween is one that is now progressing, although it may not yet be updating\nany target properties, due to settings such as `delay`. If you need an event for when\nthe Tween starts actually updating its first property, see `TWEEN_START`.\n\nListen to it from a Tween instance using `Tween.on('active', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.create({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000\n});\ntween.on('active', listener);\nthis.tweens.existing(tween);\n```\n\nNote that this event is usually dispatched already by the time you call `this.tweens.add()`, and is\nmeant for use with `tweens.create()` and/or `tweens.existing()`.",
  "Phaser.Tweens.Events.TWEEN_COMPLETE": "The Tween Complete Event.\n\nThis event is dispatched by a Tween when it completes playback entirely, factoring in repeats and loops.\n\nIf the Tween has been set to loop or repeat infinitely, this event will not be dispatched\nunless the `Tween.stop` method is called.\n\nIf a Tween has a `completeDelay` set, this event will fire after that delay expires.\n\nListen to it from a Tween instance using `Tween.on('complete', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000\n});\ntween.on('complete', listener);\n```",
  "Phaser.Tweens.Events.TWEEN_LOOP": "The Tween Loop Event.\n\nThis event is dispatched by a Tween when it loops.\n\nThis event will only be dispatched if the Tween has a loop count set.\n\nIf a Tween has a `loopDelay` set, this event will fire after that delay expires.\n\nThe difference between `loop` and `repeat` is that `repeat` is a property setting,\nwhere-as `loop` applies to the entire Tween.\n\nListen to it from a Tween instance using `Tween.on('loop', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000,\n    loop: 6\n});\ntween.on('loop', listener);\n```",
  "Phaser.Tweens.Events.TWEEN_PAUSE": "The Tween Pause Event.\n\nThis event is dispatched by a Tween when it is paused.\n\nListen to it from a Tween instance using `Tween.on('pause', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    ease: 'Power1',\n    duration: 3000,\n    x: 600\n});\ntween.on('pause', listener);\n// At some point later ...\ntween.pause();\n```",
  "Phaser.Tweens.Events.TWEEN_REPEAT": "The Tween Repeat Event.\n\nThis event is dispatched by a Tween when one of the properties it is tweening repeats.\n\nThis event will only be dispatched if the Tween has a property with a repeat count set.\n\nIf a Tween has a `repeatDelay` set, this event will fire after that delay expires.\n\nThe difference between `loop` and `repeat` is that `repeat` is a property setting,\nwhere-as `loop` applies to the entire Tween.\n\nListen to it from a Tween instance using `Tween.on('repeat', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000,\n    repeat: 4\n});\ntween.on('repeat', listener);\n```",
  "Phaser.Tweens.Events.TWEEN_RESUME": "The Tween Resume Event.\n\nThis event is dispatched by a Tween when it is resumed from a paused state.\n\nListen to it from a Tween instance using `Tween.on('resume', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    ease: 'Power1',\n    duration: 3000,\n    x: 600\n});\ntween.on('resume', listener);\n// At some point later ...\ntween.resume();\n```",
  "Phaser.Tweens.Events.TWEEN_START": "The Tween Start Event.\n\nThis event is dispatched by a Tween when it starts tweening its first property.\n\nA Tween will only emit this event once, as it can only start once.\n\nIf a Tween has a `delay` set, this event will fire after that delay expires.\n\nListen to it from a Tween instance using `Tween.on('start', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000\n});\ntween.on('start', listener);\n```",
  "Phaser.Tweens.Events.TWEEN_STOP": "The Tween Stop Event.\n\nThis event is dispatched by a Tween when it is stopped.\n\nListen to it from a Tween instance using `Tween.on('stop', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000\n});\ntween.on('stop', listener);\n```",
  "Phaser.Tweens.Events.TWEEN_UPDATE": "The Tween Update Event.\n\nThis event is dispatched by a Tween every time it updates _any_ of the properties it is tweening.\n\nA Tween that is changing 3 properties of a target will emit this event 3 times per change, once per property.\n\n**Note:** This is a very high frequency event and may be dispatched multiple times, every single frame.\n\nListen to it from a Tween instance using `Tween.on('update', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000,\n});\ntween.on('update', listener);\n```",
  "Phaser.Tweens.Events.TWEEN_YOYO": "The Tween Yoyo Event.\n\nThis event is dispatched by a Tween whenever a property it is tweening yoyos.\n\nThis event will only be dispatched if the Tween has a property with `yoyo` set.\n\nIf the Tween has a `hold` value, this event is dispatched when the hold expires.\n\nThis event is dispatched for every property, and for every target, that yoyos.\nFor example, if a Tween was updating 2 properties and had 10 targets, this event\nwould be dispatched 20 times (twice per target). So be careful how you use it!\n\nListen to it from a Tween instance using `Tween.on('yoyo', listener)`, i.e.:\n\n```javascript\nvar tween = this.tweens.add({\n    targets: image,\n    x: 500,\n    ease: 'Power1',\n    duration: 3000,\n    yoyo: true\n});\ntween.on('yoyo', listener);\n```"
 },
 "phasereditor2d.scene/docs/phaser.json": {
  "Phaser.GameObjects.Image": "An Image Game Object.\n\nAn Image is a light-weight Game Object useful for the display of static images in your game,\nsuch as logos, backgrounds, scenery or other non-animated elements. Images can have input\nevents and physics bodies, or be tweened, tinted or scrolled. The main difference between an\nImage and a Sprite is that you cannot animate an Image as they do not have the Animation component.",
  "Phaser.GameObjects.Sprite": "A Sprite Game Object.\n\nA Sprite Game Object is used for the display of both static and animated images in your game.\nSprites can have input events and physics bodies. They can also be tweened, tinted, scrolled\nand animated.\n\nThe main difference between a Sprite and an Image Game Object is that you cannot animate Images.\nAs such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation\nComponent. If you do not require animation then you can safely use Images to replace Sprites in all cases.",
  "Phaser.GameObjects.Container": "A Container Game Object.\n\nA Container, as the name implies, can 'contain' other types of Game Object.\nWhen a Game Object is added to a Container, the Container becomes responsible for the rendering of it.\nBy default it will be removed from the Display List and instead added to the Containers own internal list.\n\nThe position of the Game Object automatically becomes relative to the position of the Container.\n\nThe transform point of a Container is 0x0 (in local space) and that cannot be changed. The children you add to the\nContainer should be positioned with this value in mind. I.e. you should treat 0x0 as being the center of\nthe Container, and position children positively and negative around it as required.\n\nWhen the Container is rendered, all of its children are rendered as well, in the order in which they exist\nwithin the Container. Container children can be repositioned using methods such as `MoveUp`, `MoveDown` and `SendToBack`.\n\nIf you modify a transform property of the Container, such as `Container.x` or `Container.rotation` then it will\nautomatically influence all children as well.\n\nContainers can include other Containers for deeply nested transforms.\n\nContainers can have masks set on them and can be used as a mask too. However, Container children cannot be masked.\nThe masks do not 'stack up'. Only a Container on the root of the display list will use its mask.\n\nContainers can be enabled for input. Because they do not have a texture you need to provide a shape for them\nto use as their hit area. Container children can also be enabled for input, independent of the Container.\n\nIf input enabling a _child_ you should not set both the `origin` and a **negative** scale factor on the child,\nor the input area will become misaligned.\n\nContainers can be given a physics body for either Arcade Physics, Impact Physics or Matter Physics. However,\nif Container _children_ are enabled for physics you may get unexpected results, such as offset bodies,\nif the Container itself, or any of its ancestors, is positioned anywhere other than at 0 x 0. Container children\nwith physics do not factor in the Container due to the excessive extra calculations needed. Please structure\nyour game to work around this.\n\nIt's important to understand the impact of using Containers. They add additional processing overhead into\nevery one of their children. The deeper you nest them, the more the cost escalates. This is especially true\nfor input events. You also loose the ability to set the display depth of Container children in the same\nflexible manner as those not within them. In short, don't use them for the sake of it. You pay a small cost\nevery time you create one, try to structure your game around avoiding that where possible.",
  "Phaser.GameObjects.Components.Transform.x": "The x position of this Game Object.",
  "Phaser.GameObjects.Components.Transform.y": "The y position of this Game Object.",
  "Phaser.GameObjects.Components.Transform.setPosition": "Sets the position of this Game Object.",
  "Phaser.GameObjects.Components.Transform.scaleX": "The horizontal scale of this Game Object.",
  "Phaser.GameObjects.Components.Transform.scaleY": "The vertical scale of this Game Object.",
  "Phaser.GameObjects.Components.Transform.angle": "The angle of this Game Object as expressed in degrees.\n\nPhaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left\nand -90 is up.\n\nIf you prefer to work in radians, see the `rotation` property instead.",
  "Phaser.GameObjects.Components.Origin.originX": "The horizontal origin of this Game Object.\nThe origin maps the relationship between the size and position of the Game Object.\nThe default value is 0.5, meaning all Game Objects are positioned based on their center.\nSetting the value to 0 means the position now relates to the left of the Game Object.\nSet this value with `setOrigin()`.",
  "Phaser.GameObjects.Components.Origin.originY": "The vertical origin of this Game Object.\nThe origin maps the relationship between the size and position of the Game Object.\nThe default value is 0.5, meaning all Game Objects are positioned based on their center.\nSetting the value to 0 means the position now relates to the top of the Game Object.\nSet this value with `setOrigin()`.",
  "Phaser.GameObjects.Components.Origin.setOrigin": "Sets the origin of this Game Object.\n\nThe values are given in the range 0 to 1.",
  "Phaser.GameObjects.Components.Alpha.alpha": "The alpha value of the Game Object.\n\nThis is a global value, impacting the entire Game Object, not just a region of it.",
  "Phaser.GameObjects.Components.Alpha.alphaTopLeft": "The alpha value starting from the top-left of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Alpha.alphaTopRight": "The alpha value starting from the top-right of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Alpha.alphaBottomLeft": "The alpha value starting from the bottom-left of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Alpha.alphaBottomRight": "The alpha value starting from the bottom-right of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Flip.flipX": "The horizontally flipped state of the Game Object.\n\nA Game Object that is flipped horizontally will render inversed on the horizontal axis.\nFlipping always takes place from the middle of the texture and does not impact the scale value.\nIf this Game Object has a physics body, it will not change the body. This is a rendering toggle only.",
  "Phaser.GameObjects.Components.Flip.flipY": "The vertically flipped state of the Game Object.\n\nA Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\nFlipping always takes place from the middle of the texture and does not impact the scale value.\nIf this Game Object has a physics body, it will not change the body. This is a rendering toggle only.",
  "Phaser.GameObjects.Components.Visible.visible": "The visible state of the Game Object.\n\nAn invisible Game Object will skip rendering, but will still process update logic.",
  "Phaser.GameObjects.Components.Tint.tint": "The tint value being applied to the whole of the Game Object.\nReturn `tintTopLeft` when read this tint property.",
  "Phaser.GameObjects.Components.Tint.tintFill": "The tint fill mode.\n\n`false` = An additive tint (the default), where vertices colors are blended with the texture.\n`true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.",
  "Phaser.GameObjects.Components.Tint.tintTopLeft": "The tint value being applied to the top-left vertice of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.\nThe value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.",
  "Phaser.GameObjects.Components.Tint.tintTopRight": "The tint value being applied to the top-right vertice of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.\nThe value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.",
  "Phaser.GameObjects.Components.Tint.tintBottomLeft": "The tint value being applied to the bottom-left vertice of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.\nThe value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.",
  "Phaser.GameObjects.Components.Tint.tintBottomRight": "The tint value being applied to the bottom-right vertice of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.\nThe value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.",
  "Phaser.GameObjects.TileSprite": "A TileSprite is a Sprite that has a repeating texture.\n\nThe texture can be scrolled and scaled independently of the TileSprite itself. Textures will automatically wrap and\nare designed so that you can create game backdrops using seamless textures as a source.\n\nYou shouldn't ever create a TileSprite any larger than your actual canvas size. If you want to create a large repeating background\nthat scrolls across the whole map of your game, then you create a TileSprite that fits the canvas size and then use the `tilePosition`\nproperty to scroll the texture as the player moves. If you create a TileSprite that is thousands of pixels in size then it will\nconsume huge amounts of memory and cause performance issues. Remember: use `tilePosition` to scroll your texture and `tileScale` to\nadjust the scale of the texture - don't resize the sprite itself or make it larger than it needs.\n\nAn important note about Tile Sprites and NPOT textures: Internally, TileSprite textures use GL_REPEAT to provide\nseamless repeating of the textures. This, combined with the way in which the textures are handled in WebGL, means\nthey need to be POT (power-of-two) sizes in order to wrap. If you provide a NPOT (non power-of-two) texture to a\nTileSprite it will generate a POT sized canvas and draw your texture to it, scaled up to the POT size. It's then\nscaled back down again during rendering to the original dimensions. While this works, in that it allows you to use\nany size texture for a Tile Sprite, it does mean that NPOT textures are going to appear anti-aliased when rendered,\ndue to the interpolation that took place when it was resized into a POT texture. This is especially visible in\npixel art graphics. If you notice it and it becomes an issue, the only way to avoid it is to ensure that you\nprovide POT textures for Tile Sprites.",
  "Phaser.GameObjects.Components.ComputedSize.width": "The native (un-scaled) width of this Game Object.\n\nChanging this value will not change the size that the Game Object is rendered in-game.\nFor that you need to either set the scale of the Game Object (`setScale`) or use\nthe `displayWidth` property.",
  "Phaser.GameObjects.Components.ComputedSize.height": "The native (un-scaled) height of this Game Object.\n\nChanging this value will not change the size that the Game Object is rendered in-game.\nFor that you need to either set the scale of the Game Object (`setScale`) or use\nthe `displayHeight` property.",
  "Phaser.GameObjects.Components.ComputedSize.setSize": "Sets the internal size of this Game Object, as used for frame or physics body creation.\n\nThis will not change the size that the Game Object is rendered in-game.\nFor that you need to either set the scale of the Game Object (`setScale`) or call the\n`setDisplaySize` method, which is the same thing as changing the scale but allows you\nto do so by giving pixel values.\n\nIf you have enabled this Game Object for input, changing the size will _not_ change the\nsize of the hit area. To do this you should adjust the `input.hitArea` object directly.",
  "Phaser.GameObjects.TileSprite.tilePositionX": "The horizontal scroll position of the Tile Sprite.",
  "Phaser.GameObjects.TileSprite.tilePositionY": "The vertical scroll position of the Tile Sprite.",
  "Phaser.GameObjects.TileSprite.setTilePosition": "Sets {@link Phaser.GameObjects.TileSprite#tilePositionX} and {@link Phaser.GameObjects.TileSprite#tilePositionY}.",
  "Phaser.GameObjects.TileSprite.tileScaleX": "The horizontal scale of the Tile Sprite texture.",
  "Phaser.GameObjects.TileSprite.tileScaleY": "The vertical scale of the Tile Sprite texture.",
  "Phaser.GameObjects.TileSprite.setTileScale": "Sets {@link Phaser.GameObjects.TileSprite#tileScaleX} and {@link Phaser.GameObjects.TileSprite#tileScaleY}.",
  "Phaser.GameObjects.NineSlice": "A Nine Slice Game Object allows you to display a texture-based object that\ncan be stretched both horizontally and vertically, but that retains\nfixed-sized corners. The dimensions of the corners are set via the\nparameters to this class.\n\nThis is extremely useful for UI and button like elements, where you need\nthem to expand to accommodate the content without distorting the texture.\n\nThe texture you provide for this Game Object should be based on the\nfollowing layout structure:\n\n```\n     A                          B\n   +---+----------------------+---+\n C | 1 |          2           | 3 |\n   +---+----------------------+---+\n   |   |                      |   |\n   | 4 |          5           | 6 |\n   |   |                      |   |\n   +---+----------------------+---+\n D | 7 |          8           | 9 |\n   +---+----------------------+---+\n```\n\nWhen changing this objects width and / or height:\n\n    areas 1, 3, 7 and 9 (the corners) will remain unscaled\n    areas 2 and 8 will be stretched horizontally only\n    areas 4 and 6 will be stretched vertically only\n    area 5 will be stretched both horizontally and vertically\n\nYou can also create a 3 slice Game Object:\n\nThis works in a similar way, except you can only stretch it horizontally.\nTherefore, it requires less configuration:\n\n```\n     A                          B\n   +---+----------------------+---+\n   |   |                      |   |\n C | 1 |          2           | 3 |\n   |   |                      |   |\n   +---+----------------------+---+\n```\n\nWhen changing this objects width (you cannot change its height)\n\n    areas 1 and 3 will remain unscaled\n    area 2 will be stretched horizontally\n\nThe above configuration concept is adapted from the Pixi NineSlicePlane.\n\nTo specify a 3 slice object instead of a 9 slice you should only\nprovide the `leftWidth` and `rightWidth` parameters. To create a 9 slice\nyou must supply all parameters.\n\nThe _minimum_ width this Game Object can be is the total of\n`leftWidth` + `rightWidth`.  The _minimum_ height this Game Object\ncan be is the total of `topHeight` + `bottomHeight`.\nIf you need to display this object at a smaller size, you can scale it.\n\nIn terms of performance, using a 3 slice Game Object is the equivalent of\nhaving 3 Sprites in a row. Using a 9 slice Game Object is the equivalent\nof having 9 Sprites in a row. The vertices of this object are all batched\ntogether and can co-exist with other Sprites and graphics on the display\nlist, without incurring any additional overhead.\n\nAs of Phaser 3.60 this Game Object is WebGL only.\n\nAs of Phaser 3.70 this Game Object can now populate its values automatically\nif they have been set within Texture Packer 7.1.0 or above and exported with\nthe atlas json. If this is the case, you can just call this method without\nspecifying anything more than the texture key and frame and it will pull the\narea data from the atlas.",
  "Phaser.GameObjects.NineSlice.leftWidth": "The size of the left vertical bar (A).",
  "Phaser.GameObjects.NineSlice.rightWidth": "The size of the right vertical bar (B).",
  "Phaser.GameObjects.NineSlice.topHeight": "The size of the top horizontal bar (C).\n\nIf this is a 3 slice object this property will be set to the\nheight of the texture being used.",
  "Phaser.GameObjects.NineSlice.bottomHeight": "The size of the bottom horizontal bar (D).\n\nIf this is a 3 slice object this property will be set to zero.",
  "Phaser.GameObjects.GameObject.parentContainer": "The parent Container of this Game Object, if it has one.",
  "Phaser.GameObjects.Text": "A Text Game Object.\n\nText objects work by creating their own internal hidden Canvas and then renders text to it using\nthe standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered\nto your game during the render pass.\n\nBecause it uses the Canvas API you can take advantage of all the features this offers, such as\napplying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts\nloaded externally, such as Google or TypeKit Web fonts.\n\n**Important:** The font name must be quoted if it contains certain combinations of digits or\nspecial characters, either when creating the Text object, or when setting the font via `setFont`\nor `setFontFamily`, e.g.:\n\n```javascript\nthis.add.text(0, 0, 'Hello World', { fontFamily: 'Georgia, \"Goudy Bookletter 1911\", Times, serif' });\n```\n\n```javascript\nthis.add.text(0, 0, 'Hello World', { font: '\"Press Start 2P\"' });\n```\n\nYou can only display fonts that are currently loaded and available to the browser: therefore fonts must\nbe pre-loaded. Phaser does not do this for you, so you will require the use of a 3rd party font loader,\nor have the fonts ready available in the CSS on the page in which your Phaser game resides.\n\nSee {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts\nacross mobile browsers.\n\nA note on performance: Every time the contents of a Text object changes, i.e. changing the text being\ndisplayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the\nnew texture to the GPU. This can be an expensive operation if used often, or with large quantities of\nText objects in your game. If you run into performance issues you would be better off using Bitmap Text\ninstead, as it benefits from batching and avoids expensive Canvas API calls.",
  "Phaser.Types.GameObjects.Text.TextStyle.fixedWidth": "Force the Text object to have the exact width specified in this property. Leave as zero for it to change accordingly to content.",
  "Phaser.Types.GameObjects.Text.TextStyle.fixedHeight": "Force the Text object to have the exact height specified in this property. Leave as zero for it to change accordingly to content.",
  "Phaser.GameObjects.TextStyle.setFixedSize": "Set a fixed width and height for the text.\n\nPass in `0` for either of these parameters to disable fixed width or height respectively.",
  "Phaser.GameObjects.Text.setPadding": "Set the text padding.\n\n'left' can be an object.\n\nIf only 'left' and 'top' are given they are treated as 'x' and 'y'.",
  "Phaser.Types.GameObjects.Text.TextPadding.left": "The amount of padding added to the left of the Text object.",
  "Phaser.Types.GameObjects.Text.TextPadding.top": "The amount of padding added to the top of the Text object.",
  "Phaser.Types.GameObjects.Text.TextPadding.right": "The amount of padding added to the right of the Text object.",
  "Phaser.Types.GameObjects.Text.TextPadding.bottom": "The amount of padding added to the bottom of the Text object.",
  "Phaser.GameObjects.Text.lineSpacing": "The line spacing value.\nThis value is added to the font height to calculate the overall line height.\nOnly has an effect if this Text object contains multiple lines of text.\n\nIf you update this property directly, instead of using the `setLineSpacing` method, then\nbe sure to call `updateText` after, or you won't see the change reflected in the Text object.",
  "Phaser.GameObjects.Text.setAlign": "Set the alignment of the text in this Text object.\n\nThe argument can be one of: `left`, `right`, `center` or `justify`.\n\nAlignment only works if the Text object has more than one line of text.",
  "Phaser.GameObjects.Text.setFontFamily": "Set the font family.\n\n**Important:** The font name must be quoted if it contains certain combinations of digits or\nspecial characters:\n\n```javascript\nText.setFont('\"Press Start 2P\"');\n```\n\nEqually, if you wish to provide a list of fallback fonts, then you should ensure they are all\nquoted properly, too:\n\n```javascript\nText.setFont('Georgia, \"Goudy Bookletter 1911\", Times, serif');\n```",
  "Phaser.GameObjects.Text.setFontSize": "Set the font size. Can be a string with a valid CSS unit, i.e. `16px`, or a number.",
  "Phaser.GameObjects.Text.setFontStyle": "Set the font style.",
  "Phaser.GameObjects.Text.setColor": "Set the text fill color.",
  "Phaser.GameObjects.Text.setStroke(color)": "The stroke color.",
  "Phaser.GameObjects.Text.setStroke(thickness)": "The stroke thickness.",
  "Phaser.GameObjects.Text.setBackgroundColor": "Set the background color.",
  "Phaser.GameObjects.Text.setShadowOffset": "Set the shadow offset.",
  "Phaser.GameObjects.Text.setShadowOffset(x)": "The horizontal shadow offset.",
  "Phaser.GameObjects.Text.setShadowOffset(y)": "The vertical shadow offset.",
  "Phaser.GameObjects.Text.setShadowStroke": "Enable or disable shadow stroke.",
  "Phaser.GameObjects.Text.setShadowFill": "Enable or disable shadow fill.",
  "Phaser.GameObjects.Text.setShadowColor": "Set the shadow color.",
  "Phaser.GameObjects.Text.setShadowBlur": "Set the shadow blur radius.",
  "Phaser.GameObjects.TextStyle.baselineX": "The amount of horizontal padding added to the width of the text when calculating the font metrics.",
  "Phaser.GameObjects.TextStyle.baselineY": "The amount of vertical padding added to the height of the text when calculating the font metrics.",
  "Phaser.GameObjects.Text.setMaxLines": "Set the maximum number of lines to draw.",
  "Phaser.GameObjects.Text.setWordWrapWidth(useAdvancedWrap)": "Whether or not to use the advanced wrapping\nalgorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,\nspaces and whitespace are left as is.",
  "Phaser.GameObjects.Text.setWordWrapWidth(width)": "The maximum width of a line in pixels. Set to null to remove wrapping.",
  "Phaser.GameObjects.BitmapText": "BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.\n\nDuring rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to\nmatch the font structure.\n\nBitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability\nto use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by\nprocessing the font texture in an image editor, applying fills and any other effects required.\n\nTo create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\n\nTo create a BitmapText data files you need a 3rd party app such as:\n\nBMFont (Windows, free): {@link http://www.angelcode.com/products/bmfont/|http://www.angelcode.com/products/bmfont/}\nGlyph Designer (OS X, commercial): {@link http://www.71squared.com/en/glyphdesigner|http://www.71squared.com/en/glyphdesigner}\nSnow BMF (Web-based, free): {@link https://snowb.org//|https://snowb.org/}\nLittera (Flash-based, free): {@link http://kvazars.com/littera/|http://kvazars.com/littera/}\n\nFor most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of\nconverting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: {@link http://codebeautify.org/xmltojson|http://codebeautify.org/xmltojson}",
  "Phaser.GameObjects.BitmapText.setFont": "Changes the font this BitmapText is using to render.\n\nThe new texture is loaded and applied to the BitmapText. The existing test, size and alignment are preserved,\nunless overridden via the arguments.",
  "Phaser.GameObjects.BitmapText.align": "Controls the alignment of each line of text in this BitmapText object.\n\nOnly has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.\nHas no effect with single-lines of text.\n\nSee the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.\n\n0 = Left aligned (default)\n1 = Middle aligned\n2 = Right aligned\n\nThe alignment position is based on the longest line of text.",
  "Phaser.GameObjects.BitmapText.setFontSize": "Set the font size of this Bitmap Text.",
  "Phaser.GameObjects.BitmapText.setLetterSpacing": "Sets the letter spacing between each character of this Bitmap Text.\nCan be a positive value to increase the space, or negative to reduce it.\nSpacing is applied after the kerning values have been set.",
  "Phaser.GameObjects.BitmapText.dropShadowX": "The horizontal offset of the drop shadow.\n\nYou can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.",
  "Phaser.GameObjects.BitmapText.dropShadowY": "The vertical offset of the drop shadow.\n\nYou can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.",
  "Phaser.GameObjects.BitmapText.dropShadowColor": "The color of the drop shadow.\n\nYou can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.",
  "Phaser.GameObjects.BitmapText.dropShadowAlpha": "The alpha value of the drop shadow.\n\nYou can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.",
  "Phaser.Tilemaps.Tilemap": "A Tilemap is a container for Tilemap data. This isn't a display object, rather, it holds data\nabout the map and allows you to add tilesets and tilemap layers to it. A map can have one or\nmore tilemap layers, which are the display objects that actually render the tiles.\n\nThe Tilemap data can be parsed from a Tiled JSON file, a CSV file or a 2D array. Tiled is a free\nsoftware package specifically for creating tile maps, and is available from:\nhttp://www.mapeditor.org\n\nAs of Phaser 3.50.0 the Tilemap API now supports the following types of map:\n\n1) Orthogonal\n2) Isometric\n3) Hexagonal\n4) Staggered\n\nPrior to this release, only orthogonal maps were supported.\n\nAnother large change in 3.50 was the consolidation of Tilemap Layers. Previously, you created\neither a Static or Dynamic Tilemap Layer. However, as of 3.50 the features of both have been\nmerged and the API simplified, so now there is just the single `TilemapLayer` class.\n\nA Tilemap has handy methods for getting and manipulating the tiles within a layer, allowing\nyou to build or modify the tilemap data at runtime.\n\nNote that all Tilemaps use a base tile size to calculate dimensions from, but that a\nTilemapLayer may have its own unique tile size that overrides this.\n\nAs of Phaser 3.21.0, if your tilemap includes layer groups (a feature of Tiled 1.2.0+) these\nwill be traversed and the following properties will impact children:\n\n- Opacity (blended with parent) and visibility (parent overrides child)\n- Vertical and horizontal offset\n\nThe grouping hierarchy is not preserved and all layers will be flattened into a single array.\n\nGroup layers are parsed during Tilemap construction but are discarded after parsing so dynamic\nlayers will NOT continue to be affected by a parent.\n\nTo avoid duplicate layer names, a layer that is a child of a group layer will have its parent\ngroup name prepended with a '/'.  For example, consider a group called 'ParentGroup' with a\nchild called 'Layer 1'. In the Tilemap object, 'Layer 1' will have the name\n'ParentGroup/Layer 1'.\n\nThe Phaser Tiled Parser does **not** support the 'Collection of Images' feature for a Tileset.\nYou must ensure all of your tiles are contained in a single tileset image file (per layer)\nand have this 'embedded' in the exported Tiled JSON map data.",
  "Phaser.Tilemaps.Tilemap.tileWidth": "The base width of a tile in pixels. Note that individual layers may have a different tile\nwidth.",
  "Phaser.Tilemaps.Tilemap.tileHeight": "The base height of a tile in pixels. Note that individual layers may have a different\ntile height.",
  "Phaser.GameObjects.GameObjectFactory.tilemap(key)": "The key in the Phaser cache that corresponds to the loaded tilemap data.",
  "Phaser.Tilemaps.Tileset": "A Tileset is a combination of a single image containing the tiles and a container for data about\neach tile.",
  "Phaser.Tilemaps.Tileset.name": "The name of the Tileset.",
  "Phaser.Tilemaps.Tileset.image": "The cached image that contains the individual tiles. Use setImage to set.",
  "Phaser.Tilemaps.Tileset.tileWidth": "The width of each tile (in pixels). Use setTileSize to change.",
  "Phaser.Tilemaps.Tileset.tileHeight": "The height of each tile (in pixels). Use setTileSize to change.",
  "Phaser.Tilemaps.Tileset.tileMargin": "The margin around the tiles in the sheet (in pixels). Use `setSpacing` to change.",
  "Phaser.Tilemaps.Tileset.tileSpacing": "The spacing between each the tile in the sheet (in pixels). Use `setSpacing` to change.",
  "Phaser.Tilemaps.TilemapLayer": "A Tilemap Layer is a Game Object that renders LayerData from a Tilemap when used in combination\nwith one, or more, Tilesets.",
  "Phaser.Tilemaps.LayerData": "A class for representing data about about a layer in a map. Maps are parsed from CSV, Tiled,\netc. into this format. Tilemap and TilemapLayer objects have a reference\nto this data and use it to look up and perform operations on tiles.",
  "Phaser.Tilemaps.LayerData.name": "The name of the layer, if specified in Tiled.",
  "Phaser.Tilemaps.LayerData.width": "The width of the layer in tiles.",
  "Phaser.Tilemaps.LayerData.height": "The height of the layer in tiles.",
  "Phaser.Tilemaps.LayerData.tileWidth": "The pixel width of the tiles.",
  "Phaser.Tilemaps.LayerData.tileHeight": "The pixel height of the tiles.",
  "Phaser.Tilemaps.LayerData.widthInPixels": "The width in pixels of the entire layer.",
  "Phaser.Tilemaps.LayerData.heightInPixels": "The height in pixels of the entire layer.",
  "Phaser.GameObjects.Shape": "The Shape Game Object is a base class for the various different shapes, such as the Arc, Star or Polygon.\nYou cannot add a Shape directly to your Scene, it is meant as a base for your own custom Shape classes.",
  "Phaser.GameObjects.Shape.isFilled": "Controls if this Shape is filled or not.\nNote that some Shapes do not support being filled (such as Line shapes)",
  "Phaser.GameObjects.Shape.fillColor": "The fill color used by this Shape.",
  "Phaser.GameObjects.Shape.fillAlpha": "The fill alpha value used by this Shape.",
  "Phaser.GameObjects.Shape.isStroked": "Controls if this Shape is stroked or not.\nNote that some Shapes do not support being stroked (such as Iso Box shapes)",
  "Phaser.GameObjects.Shape.strokeColor": "The stroke color used by this Shape.",
  "Phaser.GameObjects.Shape.strokeAlpha": "The stroke alpha value used by this Shape.",
  "Phaser.GameObjects.Shape.lineWidth": "The stroke line width used by this Shape.",
  "Phaser.GameObjects.Rectangle": "The Rectangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\ntreat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\nit for input or physics. It provides a quick and easy way for you to render this shape in your\ngame without using a texture, while still taking advantage of being fully batched in WebGL.\n\nThis shape supports both fill and stroke colors.\n\nYou can change the size of the rectangle by changing the `width` and `height` properties.",
  "Phaser.GameObjects.Ellipse": "The Ellipse Shape is a Game Object that can be added to a Scene, Group or Container. You can\ntreat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\nit for input or physics. It provides a quick and easy way for you to render this shape in your\ngame without using a texture, while still taking advantage of being fully batched in WebGL.\n\nThis shape supports both fill and stroke colors.\n\nWhen it renders it displays an ellipse shape. You can control the width and height of the ellipse.\nIf the width and height match it will render as a circle. If the width is less than the height,\nit will look more like an egg shape.\n\nThe Ellipse shape also has a `smoothness` property and corresponding `setSmoothness` method.\nThis allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations\nthat take place during construction. Increase and decrease the default value for smoother, or more\njagged, shapes.",
  "Phaser.GameObjects.Ellipse.smoothness": "The smoothness of the ellipse. The number of points used when rendering it.\nIncrease this value for a smoother ellipse, at the cost of more polygons being rendered.",
  "Phaser.GameObjects.Polygon": "The Polygon Shape is a Game Object that can be added to a Scene, Group or Container. You can\ntreat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\nit for input or physics. It provides a quick and easy way for you to render this shape in your\ngame without using a texture, while still taking advantage of being fully batched in WebGL.\n\nThis shape supports both fill and stroke colors.\n\nThe Polygon Shape is created by providing a list of points, which are then used to create an\ninternal Polygon geometry object. The points can be set from a variety of formats:\n\n- A string containing paired values separated by a single space: `'40 0 40 20 100 20 100 80 40 80 40 100 0 50'`\n- An array of Point or Vector2 objects: `[new Phaser.Math.Vector2(x1, y1), ...]`\n- An array of objects with public x/y properties: `[obj1, obj2, ...]`\n- An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`\n- An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`\n\nBy default the `x` and `y` coordinates of this Shape refer to the center of it. However, depending\non the coordinates of the points provided, the final shape may be rendered offset from its origin.",
  "Phaser.GameObjects.Triangle": "The Triangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\ntreat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\nit for input or physics. It provides a quick and easy way for you to render this shape in your\ngame without using a texture, while still taking advantage of being fully batched in WebGL.\n\nThis shape supports both fill and stroke colors.\n\nThe Triangle consists of 3 lines, joining up to form a triangular shape. You can control the\nposition of each point of these lines. The triangle is always closed and cannot have an open\nface. If you require that, consider using a Polygon instead.",
  "Phaser.Geom.Triangle.x1": "`x` coordinate of the first point.",
  "Phaser.Geom.Triangle.y1": "`y` coordinate of the first point.",
  "Phaser.Geom.Triangle.x2": "`x` coordinate of the second point.",
  "Phaser.Geom.Triangle.y2": "`y` coordinate of the second point.",
  "Phaser.Geom.Triangle.x3": "`x` coordinate of the third point.",
  "Phaser.Geom.Triangle.y3": "`y` coordinate of the third point.",
  "Phaser.Geom.Rectangle.x": "The X coordinate of the top left corner of the Rectangle.",
  "Phaser.Geom.Rectangle.y": "The Y coordinate of the top left corner of the Rectangle.",
  "Phaser.Geom.Rectangle.width": "The width of the Rectangle, i.e. the distance between its left side (defined by `x`) and its right side.",
  "Phaser.Geom.Rectangle.height": "The height of the Rectangle, i.e. the distance between its top side (defined by `y`) and its bottom side.",
  "Phaser.Geom.Ellipse.x": "The x position of the center of the ellipse.",
  "Phaser.Geom.Ellipse.y": "The y position of the center of the ellipse.",
  "Phaser.Geom.Ellipse.width": "The width of the ellipse.",
  "Phaser.Geom.Ellipse.height": "The height of the ellipse.",
  "Phaser.Geom.Circle.x": "The x position of the center of the circle.",
  "Phaser.Geom.Circle.y": "The y position of the center of the circle.",
  "Phaser.Geom.Circle.radius": "The radius of the Circle.",
  "Phaser.Input.InputPlugin.makePixelPerfect(alphaTolerance)": "The alpha level that the pixel should be above to be included as a successful interaction.",
  "Phaser.GameObjects.Layer": "A Layer Game Object.\n\nA Layer is a special type of Game Object that acts as a Display List. You can add any type of Game Object\nto a Layer, just as you would to a Scene. Layers can be used to visually group together 'layers' of Game\nObjects:\n\n```javascript\nconst spaceman = this.add.sprite(150, 300, 'spaceman');\nconst bunny = this.add.sprite(400, 300, 'bunny');\nconst elephant = this.add.sprite(650, 300, 'elephant');\n\nconst layer = this.add.layer();\n\nlayer.add([ spaceman, bunny, elephant ]);\n```\n\nThe 3 sprites in the example above will now be managed by the Layer they were added to. Therefore,\nif you then set `layer.setVisible(false)` they would all vanish from the display.\n\nYou can also control the depth of the Game Objects within the Layer. For example, calling the\n`setDepth` method of a child of a Layer will allow you to adjust the depth of that child _within the\nLayer itself_, rather than the whole Scene. The Layer, too, can have its depth set as well.\n\nThe Layer class also offers many different methods for manipulating the list, such as the\nmethods `moveUp`, `moveDown`, `sendToBack`, `bringToTop` and so on. These allow you to change the\ndisplay list position of the Layers children, causing it to adjust the order in which they are\nrendered. Using `setDepth` on a child allows you to override this.\n\nLayers can have Post FX Pipelines set, which allows you to easily enable a post pipeline across\na whole range of children, which, depending on the effect, can often be far more efficient that doing so\non a per-child basis.\n\nLayers have no position or size within the Scene. This means you cannot enable a Layer for\nphysics or input, or change the position, rotation or scale of a Layer. They also have no scroll\nfactor, texture, tint, origin, crop or bounds.\n\nIf you need those kind of features then you should use a Container instead. Containers can be added\nto Layers, but Layers cannot be added to Containers.\n\nHowever, you can set the Alpha, Blend Mode, Depth, Mask and Visible state of a Layer. These settings\nwill impact all children being rendered by the Layer.",
  "Phaser.Physics.Arcade.Collider": "An Arcade Physics Collider will automatically check for collision, or overlaps, between two objects\nevery step. If a collision, or overlap, occurs it will invoke the given callbacks.",
  "Phaser.Physics.Arcade.Image": "An Arcade Physics Image is an Image with an Arcade Physics body and related components.\nThe body can be dynamic or static.\n\nThe main difference between an Arcade Image and an Arcade Sprite is that you cannot animate an Arcade Image.",
  "Phaser.Physics.Arcade.Sprite": "An Arcade Physics Sprite is a Sprite with an Arcade Physics body and related components.\nThe body can be dynamic or static.\n\nThe main difference between an Arcade Sprite and an Arcade Image is that you cannot animate an Arcade Image.\nIf you do not require animation then you can safely use Arcade Images instead of Arcade Sprites.",
  "Phaser.Physics.Arcade.Body": "A Dynamic Arcade Body.\n\nIts static counterpart is {@link Phaser.Physics.Arcade.StaticBody}.",
  "Phaser.Physics.Arcade.Body.enable": "Whether this Body is updated by the physics simulation.",
  "Phaser.Physics.Arcade.Body.offset": "The offset of this Body's position from its Game Object's position, in source pixels.",
  "Phaser.Physics.Arcade.Body.radius": "If this Body is circular, this is the unscaled radius of the Body, as set by setCircle(), in source pixels.\nThe true radius is equal to `halfWidth`.",
  "Phaser.Physics.Arcade.Body.moves": "Whether the Body's position and rotation are affected by its velocity, acceleration, drag, and gravity.",
  "Phaser.Physics.Arcade.Body.velocity": "The Body's velocity, in pixels per second.",
  "Phaser.Physics.Arcade.Body.maxVelocity": "The absolute maximum velocity of this body, in pixels per second.\nThe horizontal and vertical components are applied separately.",
  "Phaser.Physics.Arcade.Body.maxSpeed": "The maximum speed this Body is allowed to reach, in pixels per second.\n\nIf not negative it limits the scalar value of speed.\n\nAny negative value means no maximum is being applied (the default).",
  "Phaser.Physics.Arcade.Body.allowGravity": "Whether this Body's position is affected by gravity (local or world).",
  "Phaser.Physics.Arcade.Body.gravity": "Acceleration due to gravity (specific to this Body), in pixels per second squared.\nTotal gravity is the sum of this vector and the simulation's `gravity`.",
  "Phaser.Physics.Arcade.Body.acceleration": "The Body's change in velocity, in pixels per second squared.",
  "Phaser.Physics.Arcade.Body.useDamping": "If this Body is using `drag` for deceleration this property controls how the drag is applied.\nIf set to `true` drag will use a damping effect rather than a linear approach. If you are\ncreating a game where the Body moves freely at any angle (i.e. like the way the ship moves in\nthe game Asteroids) then you will get a far smoother and more visually correct deceleration\nby using damping, avoiding the axis-drift that is prone with linear deceleration.\n\nIf you enable this property then you should use far smaller `drag` values than with linear, as\nthey are used as a multiplier on the velocity. Values such as 0.05 will give a nice slow\ndeceleration.",
  "Phaser.Physics.Arcade.Body.allowDrag": "Whether this Body's velocity is affected by its `drag`.",
  "Phaser.Physics.Arcade.Body.drag": "When `useDamping` is false (the default), this is absolute loss of velocity due to movement, in pixels per second squared.\n\nWhen `useDamping` is true, this is a damping multiplier between 0 and 1.\nA value of 0 means the Body stops instantly.\nA value of 0.01 mean the Body keeps 1% of its velocity per second, losing 99%.\nA value of 0.1 means the Body keeps 10% of its velocity per second, losing 90%.\nA value of 1 means the Body loses no velocity.\nYou can use very small values (e.g., 0.001) to stop the Body quickly.\n\nThe x and y components are applied separately.\n\nDrag is applied only when `acceleration` is zero.",
  "Phaser.Physics.Arcade.Body.allowRotation": "Whether this Body's `rotation` is affected by its angular acceleration and angular velocity.",
  "Phaser.Physics.Arcade.Body.rotation": "This body's rotation, in degrees, based on its angular acceleration and angular velocity.\nThe Body's rotation controls the `angle` of its Game Object.\nIt doesn't rotate the Body's own geometry, which is always an axis-aligned rectangle or a circle.",
  "Phaser.Physics.Arcade.Body.angularVelocity": "The rate of change of this Body's `rotation`, in degrees per second.",
  "Phaser.Physics.Arcade.Body.angularAcceleration": "The Body's angular acceleration (change in angular velocity), in degrees per second squared.",
  "Phaser.Physics.Arcade.Body.angularDrag": "Loss of angular velocity due to angular movement, in degrees per second.\n\nAngular drag is applied only when angular acceleration is zero.",
  "Phaser.Physics.Arcade.Body.maxAngular": "The Body's maximum angular velocity, in degrees per second.",
  "Phaser.Physics.Arcade.Body.pushable": "Sets if this Body can be pushed by another Body.\n\nA body that cannot be pushed will reflect back all of the velocity it is given to the\ncolliding body. If that body is also not pushable, then the separation will be split\nbetween them evenly.\n\nIf you want your body to never move or seperate at all, see the `setImmovable` method.\n\nBy default, Dynamic Bodies are always pushable.",
  "Phaser.Physics.Arcade.Body.immovable": "Whether this Body can be moved by collisions with another Body.",
  "Phaser.Physics.Arcade.Body.collideWorldBounds": "Whether this Body interacts with the world boundary.",
  "Phaser.Physics.Arcade.Body.onWorldBounds": "Whether the simulation emits a `worldbounds` event when this Body collides with the world boundary\n(and `collideWorldBounds` is also true).",
  "Phaser.Physics.Arcade.Body.mass": "The Body's inertia, relative to a default unit (1).\nWith `bounce`, this affects the exchange of momentum (velocities) during collisions.",
  "Phaser.Physics.Arcade.Body.bounce": "Rebound following a collision, relative to 1.",
  "Phaser.Physics.Arcade.Body.friction": "If this Body is `immovable` and in motion, `friction` is the proportion of this Body's motion received by the riding Body on each axis, relative to 1.\nThe horizontal component (x) is applied only when two colliding Bodies are separated vertically.\nThe vertical component (y) is applied only when two colliding Bodies are separated horizontally.\nThe default value (1, 0) moves the riding Body horizontally in equal proportion to this Body and vertically not at all.",
  "Phaser.Physics.Arcade.Body.overlapX": "The amount of horizontal overlap (before separation), if this Body is colliding with another.",
  "Phaser.Physics.Arcade.Body.overlapY": "The amount of vertical overlap (before separation), if this Body is colliding with another.",
  "Phaser.Physics.Arcade.Body.overlapR": "The amount of overlap (before separation), if this Body is circular and colliding with another circular body.",
  "Phaser.Physics.Arcade.Collider(overlapOnly)": "Whether to check for collisions or overlap.",
  "Phaser.Physics.Arcade.Collider(object1)": "The first object to check for collision.",
  "Phaser.Physics.Arcade.Collider(object2)": "The second object to check for collision.",
  "Phaser.Physics.Arcade.Collider(collideCallback)": "The callback to invoke when the two objects collide.",
  "Phaser.Physics.Arcade.Collider(processCallback)": "The callback to invoke when the two objects collide. Must return a boolean.",
  "Phaser.Physics.Arcade.Collider(callbackContext)": "The scope in which to call the callbacks.",
  "Phaser.FX.Glow.color": "The color of the glow as a number value.",
  "Phaser.FX.Glow.outerStrength": "The strength of the glow outward from the edge of the Sprite.",
  "Phaser.FX.Glow.innerStrength": "The strength of the glow inward from the edge of the Sprite.",
  "Phaser.FX.Glow.knockout": "If `true` only the glow is drawn, not the texture itself.",
  "Phaser.FX.Shadow.x": "The horizontal offset of the shadow effect.",
  "Phaser.FX.Shadow.y": "The vertical offset of the shadow effect.",
  "Phaser.FX.Shadow.decay": "The amount of decay for the shadow effect.",
  "Phaser.FX.Shadow.power": "The power of the shadow effect.",
  "Phaser.FX.Shadow.color": "The color of the shadow.",
  "Phaser.FX.Shadow.samples": "The number of samples that the shadow effect will run for.\n\nThis should be an integer with a minimum value of 1 and a maximum of 12.",
  "Phaser.FX.Shadow.intensity": "The intensity of the shadow effect.",
  "Phaser.FX.Barrel.amount": "The amount of distortion applied to the barrel effect.\n\nTypically keep this within the range 1 (no distortion) to +- 1.",
  "Phaser.FX.Bloom.color": "The color of the bloom as a number value.",
  "Phaser.FX.Bloom.offsetX": "The horizontal offset of the bloom effect.",
  "Phaser.FX.Bloom.offsetY": "The vertical offset of the bloom effect.",
  "Phaser.FX.Bloom.blurStrength": "The strength of the blur process of the bloom effect.",
  "Phaser.FX.Bloom.strength": "The strength of the blend process of the bloom effect.",
  "Phaser.FX.Bloom.steps": "The number of steps to run the Bloom effect for.\n\nThis value should always be an integer.\n\nIt defaults to 4. The higher the value, the smoother the Bloom,\nbut at the cost of exponentially more gl operations.\n\nKeep this to the lowest possible number you can have it, while\nstill looking correct for your game.",
  "Phaser.FX.Bokeh.radius": "The radius of the bokeh effect.\n\nThis is a float value, where a radius of 0 will result in no effect being applied,\nand a radius of 1 will result in a strong bokeh. However, you can exceed this value\nfor even stronger effects.",
  "Phaser.FX.Bokeh.amount": "The amount, or strength, of the bokeh effect. Defaults to 1.",
  "Phaser.FX.Bokeh.contrast": "The color contrast, or brightness, of the bokeh effect. Defaults to 0.2.",
  "Phaser.FX.Bokeh.isTiltShift": "Is this a Tilt Shift effect or a standard bokeh effect?",
  "Phaser.FX.Bokeh.blurX": "If a Tilt Shift effect this controls the amount of horizontal blur.\n\nSetting this value on a non-Tilt Shift effect will have no effect.",
  "Phaser.FX.Bokeh.blurY": "If a Tilt Shift effect this controls the amount of vertical blur.\n\nSetting this value on a non-Tilt Shift effect will have no effect.",
  "Phaser.FX.Bokeh.strength": "If a Tilt Shift effect this controls the strength of the blur.\n\nSetting this value on a non-Tilt Shift effect will have no effect.",
  "Phaser.FX.Circle.thickness": "The width of the circle around the texture, in pixels. This value\ndoesn't factor in the feather, which can extend the thickness\ninternally depending on its value.",
  "Phaser.FX.Circle.color": "The color of the circular ring, given as a number value.",
  "Phaser.FX.Circle.backgroundColor": "The color of the background, behind the texture, given as a number value.",
  "Phaser.FX.Circle.scale": "The scale of the circle. The default scale is 1, which is a circle\nthe full size of the underlying texture. Reduce this value to create\na smaller circle, or increase it to create a circle that extends off\nthe edges of the texture.",
  "Phaser.FX.Circle.feather": "The amount of feathering to apply to the circle from the ring,\nextending into the middle of the circle. The default is 0.005,\nwhich is a very low amount of feathering just making sure the ring\nhas a smooth edge. Increase this amount to a value such as 0.5\nor 0.025 for larger amounts of feathering.",
  "Phaser.FX.ColorMatrix.alpha": "The value that determines how much of the original color is used\nwhen mixing the colors. A value between 0 (all original) and 1 (all final)",
  "Phaser.FX.ColorMatrix.brightness(value)": "The amount of brightness to apply to this ColorMatrix. Between 0 (black) and 1.",
  "Phaser.FX.ColorMatrix.hue(rotation)": "The amount of hue rotation to apply to this ColorMatrix, in degrees.",
  "Phaser.FX.ColorMatrix.grayscale(value)": "The grayscale scale (0 is black).",
  "Phaser.FX.ColorMatrix.contrast(value)": "The amount of contrast to apply to this ColorMatrix.",
  "Phaser.FX.ColorMatrix.night(intensity)": "The intensity of this effect.",
  "Phaser.FX.Displacement.x": "The amount of horizontal displacement to apply.",
  "Phaser.FX.Displacement.y": "The amount of vertical displacement to apply.",
  "Phaser.FX.Gradient.color1": "The first gradient color, given as a number value.",
  "Phaser.FX.Gradient.color2": "The second gradient color, given as a number value.",
  "Phaser.FX.Gradient.alpha": "The alpha value of the gradient effect.",
  "Phaser.FX.Gradient.fromX": "The horizontal position the gradient will start from. This value is normalized, between 0 and 1 and is not in pixels.",
  "Phaser.FX.Gradient.fromY": "The vertical position the gradient will start from. This value is normalized, between 0 and 1 and is not in pixels.",
  "Phaser.FX.Gradient.toX": "The horizontal position the gradient will end. This value is normalized, between 0 and 1 and is not in pixels.",
  "Phaser.FX.Gradient.toY": "The vertical position the gradient will end. This value is normalized, between 0 and 1 and is not in pixels.",
  "Phaser.FX.Gradient.size": "Sets how many 'chunks' the gradient is divided in to, as spread over the\nentire height of the texture. Leave this at zero for a smooth gradient,\nor set to a higher number to split the gradient into that many sections, giving\na more banded 'retro' effect.",
  "Phaser.FX.Pixelate.amount": "The amount of pixelation to apply.",
  "Phaser.FX.Shine.speed": "The speed of the Shine effect.",
  "Phaser.FX.Shine.lineWidth": "The line width of the Shine effect.",
  "Phaser.FX.Shine.gradient": "The gradient of the Shine effect.",
  "Phaser.FX.Shine.reveal": "Does this Shine effect reveal or get added to its target?",
  "Phaser.FX.Vignette.x": "The horizontal offset of the vignette effect. This value is normalized to the range 0 to 1.",
  "Phaser.FX.Vignette.y": "The vertical offset of the vignette effect. This value is normalized to the range 0 to 1.",
  "Phaser.FX.Vignette.radius": "The radius of the vignette effect. This value is normalized to the range 0 to 1.",
  "Phaser.FX.Vignette.strength": "The strength of the vignette effect.",
  "Phaser.FX.Wipe.wipeWidth": "The width of the wipe effect. This value is normalized in the range 0 to 1.",
  "Phaser.FX.Wipe.direction": "The direction of the wipe effect. Either 0 or 1. Set in conjunction with the axis property.",
  "Phaser.FX.Wipe.axis": "The axis of the wipe effect. Either 0 or 1. Set in conjunction with the direction property.",
  "Phaser.FX.Wipe.progress": "The progress of the Wipe effect. This value is normalized to the range 0 to 1.\n\nAdjust this value to make the wipe transition (i.e. via a Tween)",
  "Phaser.FX.Wipe.reveal": "Is this a reveal (true) or a fade (false) effect?",
  "Phaser.Input.Keyboard.Key": "A generic Key object which can be passed to the Process functions (and so on)\nkeycode must be an integer",
  "spine.SpineGameObject": "A SpineGameObject is a Phaser {@link GameObject} that can be added to a Phaser Scene and render a Spine skeleton.\n\nThe Spine GameObject is a thin wrapper around a Spine {@link Skeleton}, {@link AnimationState} and {@link AnimationStateData}. It is responsible for:\n- updating the animation state\n- applying the animation state to the skeleton's bones, slots, attachments, and draw order.\n- updating the skeleton's bone world transforms\n- rendering the skeleton\n\nSee the {@link SpinePlugin} class for more information on how to create a `SpineGameObject`.\n\nThe skeleton, animation state, and animation state data can be accessed via the repsective fields. They can be manually updated via {@link updatePose}.\n\nTo modify the bone hierarchy before the world transforms are computed, a callback can be set via the {@link beforeUpdateWorldTransforms} field.\n\nTo modify the bone hierarchy after the world transforms are computed, a callback can be set via the {@link afterUpdateWorldTransforms} field.\n\nThe class also features methods to convert between the skeleton coordinate system and the Phaser coordinate system.\n\nSee {@link skeletonToPhaserWorldCoordinates}, {@link phaserWorldCoordinatesToSkeleton}, and {@link phaserWorldCoordinatesToBoneLocal.}",
  "spine.SkinsAndAnimationBoundsProvider(animation)": "The animation to use for calculating the bounds. If null, the setup pose is used.",
  "spine.SkinsAndAnimationBoundsProvider(skins)": "The skins to use for calculating the bounds. If empty, the default skin is used.",
  "spine.SkinsAndAnimationBoundsProvider(timeStep)": "The time step to use for calculating the bounds. A smaller time step means more precision, but slower calculation.",
  "spine.AnimationState.timeScale": "Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\nor faster. Defaults to 1.\n\nSee TrackEntry {@link TrackEntry#timeScale} for affecting a single animation.",
  "spine.AnimationStateData.defaultMix": "The mix duration to use when no mix duration has been defined between two animations.",
  "spine.AnimationStateData.setMixWith": "Sets the mix duration when changing from the specified animation to the other.\n\nSee {@link TrackEntry#mixDuration}.",
  "Phaser.Types.Animations.PlayAnimationConfig.frameRate": "The frame rate of playback in frames per second (default 24 if duration is null)",
  "Phaser.Types.Animations.PlayAnimationConfig.delay": "Delay before starting playback. Value given in milliseconds.",
  "Phaser.Types.Animations.PlayAnimationConfig.repeat": "Number of times to repeat the animation (-1 for infinity)",
  "Phaser.Types.Animations.PlayAnimationConfig.repeatDelay": "Delay before the animation repeats. Value given in milliseconds.",
  "Phaser.Types.Animations.PlayAnimationConfig.yoyo": "Should the animation yoyo? (reverse back down to the start) before repeating?",
  "Phaser.Types.Animations.PlayAnimationConfig.showOnStart": "Should sprite.visible = true when the animation starts to play?",
  "Phaser.Types.Animations.PlayAnimationConfig.hideOnComplete": "Should sprite.visible = false when the animation finishes?",
  "Phaser.Types.Animations.PlayAnimationConfig.showBeforeDelay": "If this animation has a delay, should it show the first frame immediately (true), or only after the delay (false)",
  "Phaser.Types.Animations.PlayAnimationConfig.startFrame": "The frame of the animation to start playback from.",
  "Phaser.Types.Animations.PlayAnimationConfig.timeScale": "The time scale to be applied to playback of this animation."
 }
}